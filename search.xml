<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>runtime 接口说明</title>
      <link href="/2020/08/07/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/runtime-%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/08/07/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/runtime-%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="message"><a class="markdownIt-Anchor" href="#message"></a> Message</h2><h3 id="objc_msgsend-消息机制"><a class="markdownIt-Anchor" href="#objc_msgsend-消息机制"></a> <code>objc_msgSend</code> 消息机制</h3><ol><li>发送消息，继承结构查询消息</li><li>动态方法解析，让用户自己给实例对象 or 类对象添加方法</li><li>消息转发，当 1，2 都失败以后，会通过 NSInvocation 的方式将消息转发给其他对象</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> ObjectiveC.message;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MessageObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)message:(<span class="keyword">int</span>)number&#123;</span><br><span class="line">  printf(<span class="string">"%d\n"</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息机制，都会在编译后转换成 objc_msgSend 方法调用，内部执行runtime 消息机制</span></span><br><span class="line"><span class="comment">// 注意 objc_msgSend 类型转换</span></span><br><span class="line">MessageObject *receiver = [MessageObject new];</span><br><span class="line"><span class="comment">//objc_msgSend 使用的时候需要 强转下方法类型 (void(*)(id, SEL, int))</span></span><br><span class="line">((<span class="keyword">void</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>))objc_msgSend)(receiver, <span class="keyword">@selector</span>(message:), <span class="number">4</span>);</span><br></pre></td></tr></table></figure><h3 id="methodforselector-获取消息实现地址-imp直接调用方法"><a class="markdownIt-Anchor" href="#methodforselector-获取消息实现地址-imp直接调用方法"></a> <code>methodForSelector</code> 获取消息实现地址 IMP，直接调用方法</h3><p>在 for 循环中，如果反复对一个对象发送消息每次都会调用 <code>objc_msgSend</code><br>第一次会执行 <code>objc_msgSend</code> 全流程，知道找到方法<br>第二次以后都会从 对象 <code>cache_t</code> 中找到函数地址 <code>IMP</code><br>如果确定发送消息的具体实现可以通过消息选择器得到 函数地址 <code>IMP</code> 直接调用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IMP message = [receiver  methodForSelector:<span class="keyword">@selector</span>(message:)];</span><br><span class="line">((<span class="keyword">void</span>(*)(<span class="keyword">id</span>, SEL, <span class="keyword">int</span>))message)(receiver, <span class="keyword">@selector</span>(message:), <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h3 id="动态方法解析-class_addmethod-动态添加方法"><a class="markdownIt-Anchor" href="#动态方法解析-class_addmethod-动态添加方法"></a> 动态方法解析, <code>class_addMethod</code> 动态添加方法</h3><p>消息机制第一步对象继承图中没有找到对应消息，那么动态解析添加方法<br><code>class_addMethod</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> ObjectiveC.runtime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> dynamicInstanceMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">  printf(<span class="string">"instance resolved\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> dynamicClassMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">  printf(<span class="string">"class resolved\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DynamicResolve</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">  <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">  <span class="comment">// 给类添加方法</span></span><br><span class="line">  class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP) dynamicInstanceMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">  <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">  <span class="comment">// 给元类添加方法</span></span><br><span class="line">  class_addMethod(objc_getMetaClass(<span class="string">"DynamicResolve"</span>), sel, (IMP) dynamicClassMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="forwardinvocation-消息转发"><a class="markdownIt-Anchor" href="#forwardinvocation-消息转发"></a> <code>forwardInvocation</code> 消息转发</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MessageForwarding</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息转发过程中必须实现这个方法，找到消息的唯一身份签名！</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span>*)methodSignatureForSelector:(SEL)selector &#123;</span><br><span class="line">  printf(<span class="string">"origin:%s\n"</span>, <span class="string">"MessageForwarding"</span>);</span><br><span class="line">  <span class="built_in">NSMethodSignature</span>* signature = [<span class="keyword">super</span> methodSignatureForSelector:selector];</span><br><span class="line">  <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">  signature = [[ForwardObject new] methodSignatureForSelector:selector];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">  ForwardObject *obj = [ForwardObject new];</span><br><span class="line">  <span class="keyword">if</span> ([obj respondsToSelector:[anInvocation selector]])</span><br><span class="line">  [anInvocation invokeWithTarget:obj];</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  [<span class="keyword">super</span> forwardInvocation:anInvocation];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h2><p><code>class_addIvar</code> 这个方法只能在 <code>objc_allocateClassPair</code> 后，<code>objc_registerClassPair</code> 前被调用, 不可以给已加载的类添加变量<br>因为添加 ivar 会改变 class 的layout，通过关联对象给class 添加属性</p><h3 id="打印-propertyattribute"><a class="markdownIt-Anchor" href="#打印-propertyattribute"></a> 打印 property，attribute</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">float</span> alone;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> alone;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">"Lender"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pOutCount;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;pOutCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pOutCount; i++) &#123;</span><br><span class="line">  objc_property_t property = properties[i];</span><br><span class="line">  fprintf(stdout, <span class="string">"%s %s\n"</span>, property_getName(property), property_getAttributes(property));</span><br><span class="line">&#125;</span><br><span class="line">free(properties);</span><br><span class="line">printf(<span class="string">"-----------\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> iOutCount;</span><br><span class="line">Ivar *ivars = class_copyIvarList(LenderClass, &amp;iOutCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;iOutCount; ++i) &#123;</span><br><span class="line">  Ivar v = ivars[i];</span><br><span class="line">  fprintf(stdout, <span class="string">"%s %s\n"</span>, ivar_getName(v), ivar_getTypeEncoding(v));</span><br><span class="line">&#125;</span><br><span class="line">free(ivars);</span><br><span class="line">printf(<span class="string">"-----------\n"</span>);</span><br><span class="line">printf(<span class="string">"property:%u, ivar:%u\n"</span>, pOutCount, iOutCount);</span><br></pre></td></tr></table></figure><h3 id="实现字典转模型"><a class="markdownIt-Anchor" href="#实现字典转模型"></a> 实现字典转模型</h3><details><summary>demo</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> ObjectiveC.runtime;</span><br><span class="line"><span class="keyword">@import</span> ObjectiveC.message;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ModelMapping</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDic:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    [<span class="keyword">self</span> creatModelWithDic:dict];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)creatModelWithDic:(<span class="built_in">NSDictionary</span> *)dict &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">  objc_property_t *properties = class_copyPropertyList(<span class="keyword">self</span>.class, &amp;outCount);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:propertyName];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> value = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (![dict[key] isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      value = dict[key];</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    objc_property_attribute_t *atts = property_copyAttributeList(property, &amp;count);</span><br><span class="line">    objc_property_attribute_t att = atts[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *type = [<span class="built_in">NSString</span> stringWithUTF8String:att.value];</span><br><span class="line">    type = [type stringByReplacingOccurrencesOfString:<span class="string">@"“"</span> withString:<span class="string">@""</span>];</span><br><span class="line">    type = [type stringByReplacingOccurrencesOfString:<span class="string">@"@"</span> withString:<span class="string">@""</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"type%@"</span>,type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据为数组时</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">      Class <span class="keyword">class</span> = <span class="built_in">NSClassFromString</span>(key);</span><br><span class="line">      <span class="built_in">NSMutableArray</span> *temArr = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">      <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *tempDic <span class="keyword">in</span> value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">class</span>) &#123;</span><br><span class="line">          <span class="keyword">id</span> model = [[<span class="keyword">class</span> alloc] initWithDic:tempDic];</span><br><span class="line">          [temArr addObject:model];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      value = temArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据为字典时</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp; ![type hasPrefix:<span class="string">@"NS"</span>] ) &#123;</span><br><span class="line">      Class <span class="keyword">class</span> = <span class="built_in">NSClassFromString</span>(key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">class</span>) &#123;</span><br><span class="line">        value = [[<span class="keyword">class</span> alloc] initWithDic:value];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    SEL setterSel = [<span class="keyword">self</span> findSetterWithKey:key];</span><br><span class="line">    <span class="keyword">if</span> (setterSel != <span class="literal">nil</span>) &#123;</span><br><span class="line">      ((<span class="keyword">void</span> (*)(<span class="keyword">id</span>,SEL,<span class="keyword">id</span>))objc_msgSend)(<span class="keyword">self</span>,setterSel,value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="built_in">NSDictionary</span> *)modelToDic &#123;</span><br><span class="line">  <span class="built_in">NSMutableDictionary</span> *dic = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">  objc_property_t *properties = class_copyPropertyList(<span class="keyword">self</span>.class, &amp;outCount);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *pName = property_getName(property);</span><br><span class="line">    <span class="built_in">NSString</span> *key = [<span class="built_in">NSString</span> stringWithUTF8String:pName];</span><br><span class="line"></span><br><span class="line">    SEL <span class="keyword">getter</span> = [<span class="keyword">self</span> findGetterWithKey:key];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">getter</span>) &#123;</span><br><span class="line">      <span class="comment">//有几种方式获得value</span></span><br><span class="line">      <span class="comment">//id value = [self performSelector:getter];</span></span><br><span class="line">      <span class="comment">//id value = [self valueForKey:key];</span></span><br><span class="line">      <span class="comment">//NSMethodSignature *signature = [self methodSignatureForSelector:getter];</span></span><br><span class="line">      <span class="comment">//NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature];</span></span><br><span class="line">      <span class="comment">//[invocation setSelector:getter];</span></span><br><span class="line">      <span class="comment">//[invocation invokeWithTarget:self];</span></span><br><span class="line">      <span class="comment">//__unsafe_unretained NSObject *value = nil;</span></span><br><span class="line">      <span class="comment">//[invocation getReturnValue:&amp;value];</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">id</span> value = ((<span class="keyword">id</span> (*)(<span class="keyword">id</span>,SEL))objc_msgSend)(<span class="keyword">self</span>,<span class="keyword">getter</span>);</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">        objc_property_attribute_t *attributes = property_copyAttributeList(property, &amp;outCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;outCount; i++) &#123;</span><br><span class="line">          objc_property_attribute_t att = attributes[i];</span><br><span class="line">          <span class="built_in">NSString</span> *attValue = [<span class="built_in">NSString</span> stringWithUTF8String:att.value];</span><br><span class="line">          <span class="keyword">if</span> ([attValue isEqualToString:<span class="string">@"@\"NSDictionary\""</span>]) &#123;<span class="comment">//字典</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"key %@ is NSDictionary but nil"</span>,key);</span><br><span class="line">            value = [[<span class="built_in">NSDictionary</span> alloc] init];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ([attValue isEqualToString:<span class="string">@"@\"NSString\""</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"key %@ is NSString but nil"</span>,key);</span><br><span class="line">            value = <span class="string">@""</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ([attValue isEqualToString:<span class="string">@"@\"NSInteger\""</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"key %@ is NSInteger but nil"</span>,key);</span><br><span class="line">            value = <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> ([attValue isEqualToString:<span class="string">@"@\"NSArray\""</span>]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"key %@ is NSArray but nil"</span>,key);</span><br><span class="line">            value = @[];</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [dic setValue:value forKey:key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  free(properties);</span><br><span class="line">  <span class="keyword">return</span> dic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark Private Method</span></span><br><span class="line">- (SEL)findSetterWithKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">  <span class="built_in">NSString</span> *selStr = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@:"</span>,key.capitalizedString];</span><br><span class="line">  SEL setterSEL = <span class="built_in">NSSelectorFromString</span>(selStr);</span><br><span class="line">  <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:setterSEL]) &#123; <span class="comment">//必须使用respondsToSelector:判断是否有相应方法 这里与Message Forwarding相关,防止异常，</span></span><br><span class="line">    <span class="keyword">return</span> setterSEL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SEL)findGetterWithKey:(<span class="built_in">NSString</span> *)key&#123;</span><br><span class="line">  SEL <span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>(key);</span><br><span class="line">  <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>]) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">getter</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></pre></details><h2 id="创建类元类"><a class="markdownIt-Anchor" href="#创建类元类"></a> 创建类&amp;元类</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Adding Classes */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 使用 objc_allocateClassPair 创建出一个 class + metaclass</span></span><br><span class="line"><span class="comment">2. object_getClass(newClass) 得到新类的元类</span></span><br><span class="line"><span class="comment">3. 使用 class_addIvar，objc_registerClassPair 配置类的属性.</span></span><br><span class="line"><span class="comment">4. 注册 objc_registerClassPair</span></span><br><span class="line"><span class="comment">Instance methods and instance variables should be added to the class itself. Class methods should be added to the metaclass.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">superclass：新类的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">OBJC_EXPORT Class _Nullable</span><br><span class="line">objc_allocateClassPair(Class _Nullable superclass,</span><br><span class="line">                       <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name,</span><br><span class="line">                       <span class="keyword">size_t</span> extraBytes);</span><br><span class="line"></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_registerClassPair(Class _Nonnull cls);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 销毁 cls &amp; metaCls */</span></span><br><span class="line">OBJC_EXPORT <span class="keyword">void</span></span><br><span class="line">objc_disposeClassPair(Class _Nonnull cls)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 配置一个实例对象所属类 */</span></span><br><span class="line">OBJC_EXPORT Class _Nullable</span><br><span class="line">object_setClass(id _Nullable obj, Class _Nonnull cls);</span><br></pre></td></tr></table></figure><p><code>Aspects</code> 中生成子类的实例 demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;</span><br><span class="line">Class subclass = objc_getClass(subclassName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (subclass == nil) &#123;</span><br><span class="line">  subclass = objc_allocateClassPair(baseClass, subclassName, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (subclass == nil) &#123;</span><br><span class="line">    NSString *errrorDesc = [NSString stringWithFormat:@<span class="string">"objc_allocateClassPair failed to allocate class %s."</span>, subclassName];</span><br><span class="line">    AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc);</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  aspect_swizzleForwardInvocation(subclass);</span><br><span class="line">  aspect_hookedGetClass(subclass, statedClass);</span><br><span class="line">  aspect_hookedGetClass(object_getClass(subclass), statedClass);</span><br><span class="line">  objc_registerClassPair(subclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">object_setClass(self, subclass);</span><br></pre></td></tr></table></figure><h2 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h2><h3 id="method_exchangeimplementations-方法交换"><a class="markdownIt-Anchor" href="#method_exchangeimplementations-方法交换"></a> <code>method_exchangeImplementations</code> 方法交换</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> ObjectiveC.runtime;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MethodExchange</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;</span><br><span class="line">  printf(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)method2&#123;</span><br><span class="line">  printf(<span class="string">"%s\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)test &#123;</span><br><span class="line">  MethodExchange *normarlTest = [MethodExchange new];</span><br><span class="line">  [normarlTest method1];</span><br><span class="line">  printf(<span class="string">"changed \n"</span>);</span><br><span class="line">  SEL s1 = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"method1"</span>);</span><br><span class="line">  SEL s2 = <span class="built_in">NSSelectorFromString</span>(<span class="string">@"method2"</span>);</span><br><span class="line">  Method m1 = class_getInstanceMethod([MethodExchange <span class="keyword">class</span>], s1);</span><br><span class="line">  Method m2 = class_getInstanceMethod([MethodExchange <span class="keyword">class</span>], s2);</span><br><span class="line">  method_exchangeImplementations(m1, m2);</span><br><span class="line">  [normarlTest method1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="通过方法交换-class_replacemethod-hook-指定方法"><a class="markdownIt-Anchor" href="#通过方法交换-class_replacemethod-hook-指定方法"></a> 通过方法交换 <code>class_replaceMethod</code> Hook 指定方法</h3><p>具体步骤</p><ol><li>确定要 hook 的方法 m1</li><li>给这个类添加个方法 _m1，内部调用 m1，_m1 中添加要hook 的信息</li><li>swizzle method，交换 m1, _m1实现</li></ol><p>这样当发消息的 m1 的时候会调用 _m1, _m1 内部调用 m1</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> ObjectiveC.runtime;</span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">HookViewController</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    Method m1 = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewWillAppear:));</span><br><span class="line">    Method m2 = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(_viewWillAppear:));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> isSuccess = class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewWillAppear:), method_getImplementation(m2), method_getTypeEncoding(m2));</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">      <span class="comment">//添加失败：说明源方法已经有实现，直接将两个方法的实现交换即</span></span><br><span class="line">      method_exchangeImplementations(m1, m2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 添加成功：说明源方法m1现在的实现为交换方法m2的实现，现在将源方法m1的实现替换到交换方法m2中</span></span><br><span class="line">      class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(_viewWillAppear:), method_getImplementation(m1), method_getTypeEncoding(m1));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">  printf(<span class="string">"viewWillAppear\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">  printf(<span class="string">"hooked before: %s\n"</span>, __func__);</span><br><span class="line">  [<span class="keyword">self</span> _viewWillAppear:<span class="literal">YES</span>];</span><br><span class="line">  printf(<span class="string">"hooked after: %s\n"</span>, __func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
            <tag> obj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU 实现+实际应用</title>
      <link href="/2020/06/09/%E7%AE%97%E6%B3%95/LRU-%E5%AE%9E%E7%8E%B0-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/2020/06/09/%E7%AE%97%E6%B3%95/LRU-%E5%AE%9E%E7%8E%B0-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p>目前分析几种 <code>LRU</code> 实现</p><p><code>LRU</code>：Least Recently Used 最近最久未使用<br>常用于大量数据中只会频繁调用部分数据的优化算法<br>在 OS 中缓存算法（页面置换算法）-FIFO、LFU、LRU</p><p>实例分析，假如os分给进程的页面大小为3，序列为4、3、2、3、5，下面的缺页次数为4次</p><table><thead><tr><th style="text-align:left">4</th><th style="text-align:left">3</th><th style="text-align:left">2</th><th style="text-align:left">3</th><th style="text-align:left">5</th></tr></thead><tbody><tr><td style="text-align:left">4</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">3</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">null</td><td style="text-align:left">4</td><td style="text-align:left">3</td><td style="text-align:left">2</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">null</td><td style="text-align:left">null</td><td style="text-align:left">4</td><td style="text-align:left">4</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">缺页</td><td style="text-align:left">缺页</td><td style="text-align:left">缺页</td><td style="text-align:left">不缺</td><td style="text-align:left">缺页</td></tr></tbody></table><h3 id="使用单链表双链表"><a class="markdownIt-Anchor" href="#使用单链表双链表"></a> 使用单链表，双链表</h3><p>如果只是使用链表存储数据结构</p><ol><li>查询：每次都需要遍历 list 插到指定 node。 O(n)</li><li>插入：O(n)<ol><li>先遍历 list 找到 node，然后断链</li><li>把 node 放在 head 位置，原来断链地方复原</li><li>如果不存在那就需要读磁盘数据，放在 list head 位置，然后把 list.end 删除。</li></ol></li></ol><h3 id="使用数组"><a class="markdownIt-Anchor" href="#使用数组"></a> 使用数组</h3><ol><li>查询：每次遍历数组找到 idx。 O(n)</li><li>插入：O(n) 数组大量位置移动<ol><li>遍历 array 查找 idx</li><li>将 array[idx] 放在数组头位置。时间复杂度 O(n)</li><li>如果不在这个位置需要，读磁盘放在数组array 位置</li></ol></li><li>优化方案，可以把最近使用的数据放在 array 末尾位置减少数组移动的问题<ol><li>但是如果多次未命中，磁盘数据每次插到 array 首位，也会大量移动数据</li><li>如果多次未命中说明不该使用 LRU 了呀</li></ol></li></ol><h3 id="哈希链表"><a class="markdownIt-Anchor" href="#哈希链表"></a> 哈希链表</h3><p>根据前两种设计方式，耗时的地方是遍历<br>使用 hashmap 可以解决遍历问题，可是 hashmap 是无序的，那么 hashmap + list呢(+array<br>不存在的……)？<br>hashmap 不是连续的，那么就是用 list 来维护有序性<br>使用单向链表，移动节点的时候，找到 node 以后，断链问题需要找到 prev 节点，所以还需要重头遍历 O(n)<br>如果使用双向链表，就可以解决前置节点问题</p><p>所以最终使用 <code>hashmap + doublelist</code> 处理 LRU</p><ol><li>查询：使用 hashmap O(1)</li><li>插入：O(1)<ol><li>put hashmap，更新 list</li></ol></li></ol><p>算法实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Node</span>: <span class="title">Equatable</span>, <span class="title">CustomStringConvertible</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val: <span class="type">Int?</span></span><br><span class="line">    <span class="keyword">var</span> key: <span class="type">Int?</span></span><br><span class="line">    <span class="keyword">var</span> prev: <span class="type">Node?</span></span><br><span class="line">    <span class="keyword">var</span> next: <span class="type">Node?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Node, rhs: Node)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> lhs.val == rhs.val</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> <span class="number">_</span> = key,</span><br><span class="line">        <span class="keyword">let</span> v = val&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\(v) "</span></span><br><span class="line">      &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"head-tail"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">map</span>: [<span class="type">Int</span>: <span class="type">Node</span>]!</span><br><span class="line">  <span class="keyword">let</span> head = <span class="type">Node</span>()</span><br><span class="line">  <span class="keyword">let</span> tail = <span class="type">Node</span>()</span><br><span class="line">  <span class="keyword">let</span> capacity: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(<span class="number">_</span> capacity: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.capacity = capacity</span><br><span class="line">    <span class="built_in">map</span> = [<span class="type">Int</span>: <span class="type">Node</span>].<span class="keyword">init</span>(minimumCapacity: capacity)</span><br><span class="line">    head.next = tail</span><br><span class="line">    tail.prev = head</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">moveToHead</span><span class="params">(<span class="number">_</span> n: Node)</span></span> &#123;</span><br><span class="line">    n.prev?.next = n.next</span><br><span class="line">    n.next?.prev = n.prev</span><br><span class="line"></span><br><span class="line">    n.next = head.next</span><br><span class="line">    head.next = n</span><br><span class="line">    n.next?.prev = n</span><br><span class="line">    n.prev = head</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(<span class="number">_</span> n: Node)</span></span>&#123;</span><br><span class="line">    n.prev?.next = n.next</span><br><span class="line">    n.next?.prev = n.prev</span><br><span class="line">    n.prev = <span class="literal">nil</span>; n.next = <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">addNodeToCache</span><span class="params">(<span class="number">_</span> n: Node)</span></span> &#123;</span><br><span class="line">    <span class="built_in">map</span>[n.key!] = n</span><br><span class="line">    moveToHead(n)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">map</span>.<span class="built_in">count</span> &gt; capacity &#123;<span class="comment">// 超出缓存拿走</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> n = tail.prev,</span><br><span class="line">        <span class="keyword">let</span> k = n.key &#123;</span><br><span class="line">        <span class="built_in">map</span>.removeValue(forKey: k)</span><br><span class="line">        deleteNode(n)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="number">_</span> key: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> n = <span class="built_in">map</span>[key] &#123;</span><br><span class="line">      moveToHead(n)</span><br><span class="line">      <span class="keyword">return</span> n.val!</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">put</span><span class="params">(<span class="number">_</span> key: Int, <span class="number">_</span> value: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> n = <span class="built_in">map</span>[key] &#123; <span class="comment">// update value</span></span><br><span class="line">      n.val = value</span><br><span class="line">      moveToHead(n)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> n = <span class="type">Node</span>()</span><br><span class="line">      n.key = key</span><br><span class="line">      n.val = value</span><br><span class="line">      addNodeToCache(n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SnapKit 分析</title>
      <link href="/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/"/>
      <url>/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>请看 <a href="https://changzw.github.io/2017/06/01/source-code/Masonry-%E5%88%86%E6%9E%90/">Masonry 源码分析</a></p><p>这篇文章是写给自己看的，初稿</p><p>（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言）</p><p>分析源码前想想怎么看源码：</p><ol><li>目的：这个第三方库，他是为了解决什么问题的？</li><li>技术起源：效果实现的核心技术是什么？</li><li>设计模式：整体结构是什么样的？</li><li>该怎么入手：由外而内逐层分析层次结构？</li></ol><h2 id="snapkit-是什么"><a class="markdownIt-Anchor" href="#snapkit-是什么"></a> <code>SnapKit</code> 是什么</h2><p><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">SnapKit 源码地址</a></p><h2 id="为什么要设计-snapkit"><a class="markdownIt-Anchor" href="#为什么要设计-snapkit"></a> 为什么要设计 <code>SnapKit</code></h2><p>为了解决 Apple 布局框架 AutoLayout 繁琐的 API</p><p>首先和系统提供接口对比下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> constraint1 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">150</span>);</span><br><span class="line">constraint1.isActive = <span class="literal">true</span></span><br><span class="line">... top, width</span><br><span class="line"><span class="keyword">let</span> constraint4 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .height,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .notAnAttribute,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">20</span>);</span><br><span class="line">constraint4.isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Anchor: 只支持 ios &gt;= 9</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">  label.leftAnchor.constraint(equalTo: view.leftAnchor, constant: <span class="number">150</span>),</span><br><span class="line">  label.topAnchor.constraint(equalTo: view.topAnchor, constant: <span class="number">200</span>),</span><br><span class="line">  label.widthAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">  label.heightAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><span id="code1"></span></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.top.equalToSuperview().offset(<span class="number">200</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. SnapKit 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = true</p><p>可以看出 SnapKit 接口更加简洁</p><p>那么他是如何实现的呢？</p><ol><li>如何处理原生 AutoLayout 繁杂接口</li><li>如何实现链式</li><li>如何封装 <code>NSLayoutConstraint</code> 的</li><li>如何把多个 <code>NSLayoutConstraint</code> 封装成简单的一句搞定的</li></ol><hr><h2 id="snapkit-代码结构分析"><a class="markdownIt-Anchor" href="#snapkit-代码结构分析"></a> <code>SnapKit</code> 代码结构分析</h2><h3 id="从调用层次分析"><a class="markdownIt-Anchor" href="#从调用层次分析"></a> 从调用层次分析</h3><p>像洋葱一样一层一层的看源码</p><ol><li>最外层接口<br>根据这段代码分析</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstraintMaker.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; [<span class="type">Constraint</span>]</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">remakeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">updateConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>make: ConstraintMaker</li><li>left, top，bottom，right……: ConstraintMakerExtendable</li><li>布局方法：make， remake， update</li></ol><p>我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口<br>还要找到下图的这些信息，目前的源码卡不出来<br><img src="/img/view_formula.jpeg" alt="view formula"></p><ol start="2"><li>接着往里面看</li></ol><ul><li><code>ConstraintMakerExtendable</code> 继承自 <code>ConstraintMakerRelatable</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerExtendable</span> : <span class="title">ConstraintMakerRelatable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">left</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .top</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .bottom</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">right</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><ul><li><p>问题&amp;猜测：</p><ul><li><code>description</code> 是啥？不知道</li><li>不过他有 <code>attributes</code> 属性，看样子对应 <code>NSLayoutConstraint.Attribute</code></li><li>left, top …… 这些都返回 <code>ConstraintMakerExtendable</code> ，猜测他是链式编程中链的节点对象</li></ul></li><li><p>继续看 <code>ConstraintMakerRelatable</code></p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerRelatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> description: <span class="type">ConstraintDescription</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(<span class="number">_</span> description: <span class="type">ConstraintDescription</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">relatedTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> related: <span class="type">ConstraintItem</span></span><br><span class="line">    <span class="keyword">let</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintItem</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> other.attributes == <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span> ||</span><br><span class="line">          other.attributes.layoutAttributes.<span class="built_in">count</span> &lt;= <span class="number">1</span> ||</span><br><span class="line">          other.attributes.layoutAttributes == <span class="keyword">self</span>.description.attributes.layoutAttributes ||</span><br><span class="line">          other.attributes == .edges &amp;&amp; <span class="keyword">self</span>.description.attributes == .margins ||</span><br><span class="line">          other.attributes == .margins &amp;&amp; <span class="keyword">self</span>.description.attributes == .edges ||</span><br><span class="line">          other.attributes == .directionalEdges &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalMargins ||</span><br><span class="line">          other.attributes == .directionalMargins &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalEdges <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Cannot constraint to multiple non identical attributes. (\(file), \(line))"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      related = other</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintView</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintConstantTarget</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: <span class="literal">nil</span>, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = other</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *), <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintLayoutGuide</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fatalError</span>(<span class="string">"Invalid constraint. (\(file), \(line))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> editable = <span class="type">ConstraintMakerEditable</span>(<span class="keyword">self</span>.description)</span><br><span class="line">    editable.description.sourceLocation = (file, line)</span><br><span class="line">    editable.description.relation = relation</span><br><span class="line">    editable.description.related = related</span><br><span class="line">    editable.description.constant = constant</span><br><span class="line">    <span class="keyword">return</span> editable</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">equalTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, <span class="number">_</span> file: String = #file, <span class="number">_</span> line: UInt = #line)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.relatedTo(other, relation: .<span class="built_in">equal</span>, file: file, line: line)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到了</p><ul><li>ConstraintConstantTarget(struct)</li><li>ConstraintRelation(struct)</li><li>ConstraintAttributes(struct)</li><li>ConstraintDescription(class)</li><li>ConstraintItem(class)</li><li>ConstraintMakerEditable(class)</li></ul><h3 id="model-层数据分析"><a class="markdownIt-Anchor" href="#model-层数据分析"></a> model 层数据分析</h3><h4 id="constraintconstanttarget"><a class="markdownIt-Anchor" href="#constraintconstanttarget"></a> ConstraintConstantTarget</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">LayoutAttribute</span> = <span class="type">NSLayoutConstraint</span>.<span class="type">Attribute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintInsets</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDirectionalEdgeInsets</span> : <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">constraintConstantTargetValueFor</span><span class="params">(layoutAttribute: LayoutAttribute)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码知道 <code>ConstraintConstantTarget</code> 是 autolayout 方程式中的 constant，他是这个 constant 扩展封装</p><h4 id="constraintrelation"><a class="markdownIt-Anchor" href="#constraintrelation"></a> ConstraintRelation</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConstraintRelation</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">  <span class="keyword">case</span> <span class="built_in">equal</span> </span><br><span class="line">  <span class="keyword">case</span> lessThanOrEqual </span><br><span class="line">  <span class="keyword">case</span> greaterThanOrEqual </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutRelation: <span class="type">LayoutRelation</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintRelation</code> 是 方程式中的 关系符号</p><h4 id="constraintattributes"><a class="markdownIt-Anchor" href="#constraintattributes"></a> ConstraintAttributes</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConstraintAttributes</span> : <span class="title">OptionSet</span>, <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">none</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> top: <span class="type">ConstraintAttributes</span> &#123;  <span class="keyword">return</span> <span class="number">2</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">8</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leading: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">16</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailing: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">32</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> width: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">64</span> &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutAttributes:[<span class="type">LayoutAttribute</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs = [<span class="type">LayoutAttribute</span>]()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.<span class="keyword">left</span>)) &#123;</span><br><span class="line">      attrs.append(.<span class="keyword">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.top)) &#123;</span><br><span class="line">      attrs.append(.top)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> -&gt; <span class="type">ConstraintAttributes</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">left</span>.union(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> &#123;</span><br><span class="line">  <span class="keyword">left</span>.formUnion(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ConstraintAttributes 使用了swift 的选择集(可选枚举)</li><li>重载了运算符</li><li>依然猜测 它对应 <code>NSLayoutConstraint.Attribute</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">AnyObject?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(target: <span class="type">AnyObject?</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutConstraintItem: <span class="type">LayoutConstraintItem?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target <span class="keyword">as</span>? <span class="type">LayoutConstraintItem</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: ConstraintItem, rhs: ConstraintItem)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LayoutConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">LayoutConstraintItem</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintLayoutGuide</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintView</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintLayoutGuide</span> = <span class="type">UILayoutGuide</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintView</span> = <span class="type">UIView</span></span><br></pre></td></tr></table></figure><p>nice~<br>ConstraintItem 就是 view 和 他对应布局属性的元组 (view, attr)</p><h4 id="constraintdescription"><a class="markdownIt-Anchor" href="#constraintdescription"></a> ConstraintDescription</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintDescription</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> item: <span class="type">LayoutConstraintItem</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> relation: <span class="type">ConstraintRelation?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> sourceLocation: (<span class="type">String</span>, <span class="type">UInt</span>)?</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> label: <span class="type">String?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> related: <span class="type">ConstraintItem?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> multiplier: <span class="type">ConstraintMultiplierTarget</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> priority: <span class="type">ConstraintPriorityTarget</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="built_in">lazy</span> <span class="keyword">var</span> constraint: <span class="type">SnapKit</span>.<span class="type">Constraint?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// main</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintDescription</code> 包含了 autolayout 布局方程式中所有信息，可是不知道为啥不在这里调用 NSLayoutConstraint 添加属性，非要搞一个 SnapKit.Constraint来做这些事</p><ul><li>ConstraintMakerEditable 是链式编程技巧里面的往后看</li></ul><h3 id="分析-snapkit-链式封装"><a class="markdownIt-Anchor" href="#分析-snapkit-链式封装"></a> 分析 <code>SnapKit</code> 链式封装</h3><h4 id="主要组件结"><a class="markdownIt-Anchor" href="#主要组件结"></a> 主要组件结</h4><ul><li>文件分组<br><img src="/img/snapkit_files.jpeg" alt="snapkit_files"></li></ul><h4 id="使用函数调用栈分析"><a class="markdownIt-Anchor" href="#使用函数调用栈分析"></a> 使用函数调用栈分析</h4><details><summary>SnapKit 主流程</summary><pres><p><img src="/img/snapKit_main_flow.jpeg" alt="snapKit main flow"><br></p></pres><p></p></details><details><summary>SnapKit 链式流程</summary><pres><p><img src="/img/snapKit_chain.jpeg" alt="snapKit chain"><br></p></pres><p></p></details><p>maker 创建一个其实节点 ContraintExtentable，他维护自己的 description<br>maker 保存 descriptions[] 数组</p><p>传递 description 来延续链节点</p><p>to be continued</p><h3 id="代码组件分析"><a class="markdownIt-Anchor" href="#代码组件分析"></a> 代码组件分析</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="noopener">Auto Layout Guide</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> UI 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> swift </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 closures 代替 Gesture Recognizers 选择器</title>
      <link href="/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/"/>
      <url>/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/@sdrzn/adding-gesture-recognizers-with-closures-instead-of-selectors-9fb3e09a8f0b" target="_blank" rel="noopener">原文 Adding Gesture Recognizers with Closures Instead of Selectors<br></a></p><p>添加UITapGestureRecognizer或任何 recognizer/target action 的最糟糕的部分是仅针对选择器参数实现新功能。今天，我想分享一个巧妙的技巧，让你添加不带选择器的手势识别器。</p><p>假设我们在View Controller中有一个UIImageView，我们想向其中添加一个UITapGestureRecognizer，以便在点击它时打印出一条语句.</p><p>通常，我们会创建一个 UITapGestureRecognizer 的实例，并将其目标设置为视图控制器及其选择器，因为我们会快速将它们组合在一起(myImageViewTapped(sender：UITapGestureRecognizer))。</p><p>这可能会有点多余，并且可能导致要添加交互性的每个子视图的函数的代码混乱。</p><p>我以为我可以快速扩展一下，以便为我的图像视图添加敲击手势识别器，但是然后我必须为每个识别器创建一个新功能，对吗？错误！利用关联对象的功能，我们实际上可以将闭包存储为扩展中的计算属性！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In order to create computed properties for extensions, we need a key to </span></span><br><span class="line">  <span class="comment">// store and access the stored property</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociatedObjectKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tapGestureRecognizer = <span class="string">"MediaViewerAssociatedObjectKey_mediaViewer"</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">typealias</span> <span class="type">Action</span> = (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set our computed property type to a closure</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> tapGestureRecognizerAction: <span class="type">Action?</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newValue = newValue &#123;</span><br><span class="line">        <span class="comment">// Computed properties get stored as associated objects</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> tapGestureRecognizerActionInstance = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer) <span class="keyword">as</span>? <span class="type">Action</span></span><br><span class="line">      <span class="keyword">return</span> tapGestureRecognizerActionInstance</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// This is the meat of the sauce, here we create the tap gesture recognizer and</span></span><br><span class="line">  <span class="comment">// store the closure the user passed to us in the associated object we declared above</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addTapGestureRecognizer</span><span class="params">(action: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.tapGestureRecognizerAction = action</span><br><span class="line">    <span class="keyword">let</span> tapGestureRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleTapGesture))</span><br><span class="line">    <span class="keyword">self</span>.addGestureRecognizer(tapGestureRecognizer)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Every time the user taps on the UIImageView, this function gets called,</span></span><br><span class="line">  <span class="comment">// which triggers the closure we stored</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">handleTapGesture</span><span class="params">(sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.tapGestureRecognizerAction &#123;</span><br><span class="line">      action?()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"no action"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们要将UITapGestureRecognizer添加到UIView或UIView子类（如UIImageView）时，都可以这样做，而无需为选择器创建关联的功能！这是一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampleImageView.addTapGestureRecognizer &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"image tapped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有UITapGestureRecognizers实例，没有targets，没有selectors，没有不必要的functions！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 翻译 </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apple 系统界面渲染过程</title>
      <link href="/2020/02/20/UI%20%E7%9B%B8%E5%85%B3/iOS%20%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
      <url>/2020/02/20/UI%20%E7%9B%B8%E5%85%B3/iOS%20%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="苹果的渲染框架通俗的理解"><a class="markdownIt-Anchor" href="#苹果的渲染框架通俗的理解"></a> 苹果的渲染框架(通俗的理解)</h2><p><img src="/img/coreAnimation.jpeg" alt="coreAnimation"></p><p>根据日常开发和上图分析渲染流程</p><ol><li>UIKit: 开发中使用的用户交互组件都来自于 UIKit <strong><code>(理解为收集渲染信息+用户交互事件信息的框架)</code></strong><ol><li>提供各种 UI 组件</li><li>提供配置 UI 组件的样式接口(autoLayout, Frame, Color, Text ……)，交由 Core Animation 处理</li><li>封装用户事件接口</li></ol></li><li>Core Animation：字面翻译是核心动画，看下 CALayer，<code>CA</code> 表示的就是 Core Animation，<strong><code>Core Animation 理解为收集渲染信息，触底给底部然后得到一个渲染结果 contents</code></strong>（UIKit 上所有能看到的东西都是通过 <code>layer.contents</code> 呈现的）<ol><li>给 UIKit 提供 layer</li><li>管理动画</li><li>收集渲染数据交由渲染引擎处理</li><li>不负责用户事件相关处理！</li></ol></li><li>OpenGL ES &amp; Core Graphics 渲染引擎<ol><li>收集 Core Animation 提供的渲染数据</li><li>Core Graphics 是基于 Quartz(轻量级 2D 渲染) 高级绘图引擎</li></ol></li><li>Graphics Hardware 译为图形硬件，也就是我们经常提及的 GPU<ol><li>GPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效</li></ol></li></ol><p>用户操作的核心在 Core Animation，你要渲染的数据都要放在（<code>layer.contents</code>）上<br>当然用户也可以直接访问</p><ul><li>OpenGL ES(GLKView) 来处理渲染</li><li>Core Graphic (CG-- 相关接口) 来生成 bitmap 数据，然后将其放到 Core Animation 上<code>layer.contents</code></li></ul><ol><li>UIKit 中的组件都会关联到相应的 CALayer</li><li>渲染引擎 OpenGL ES &amp; Core Graphic 都会把渲染结果交给 layer.contents (CGImage)</li></ol><h3 id="用户使用渲染框架的数据流向"><a class="markdownIt-Anchor" href="#用户使用渲染框架的数据流向"></a> 用户使用渲染框架的数据流向</h3><p><img src="/img/user-render.jpg" alt="渲染的数据流向"></p><h2 id="官方渲染流程-core-animation-pipeline"><a class="markdownIt-Anchor" href="#官方渲染流程-core-animation-pipeline"></a> 官方渲染流程 Core Animation Pipeline</h2><p>在看完 wwdc2014 session419(Advanced Graphics and Animations for iOS Apps) 有了更深入的了解</p><p><img src="/img/core-animation-pipeline.jpg" alt="core animation pipeline"></p><p>上图需要注意：</p><ol><li>苹果的 UI 渲染频率是 60hz 16.67ms 一次（Vsync）</li><li>每个垂直的虚线表示一个 Vsync</li><li>水平虚线，表示一个硬件资源</li></ol><p>问题来了，根据上图一个渲染周期需要 3frame，那么真实的渲染频率只有 20hz<br>那么系统是怎么做到 60hz 的呢？答案： 流水线</p><p><img src="/img/core-animation-flow.jpeg" alt="core-animation-flow"></p><p>如果在每一帧上对应硬件操作都完成了，那么就会以 60hz 的速度渲染</p><p>接下来说一下渲染过程中的每个细节部分</p><p><span id="1"></span></p><h3 id="提交事务commit-transaction"><a class="markdownIt-Anchor" href="#提交事务commit-transaction"></a> 提交事务（commit transaction）</h3><p>主要是 4个阶段</p><ol><li>Layout：构建 Views<ol><li>调用 <code>layoutSubviews</code> 如果重载了</li><li>创建 view，addSubView:</li><li>填充内容，轻量级的数据查询（就是 string 赋值之类的）</li><li>通常是 CPU, I/O 负责</li></ol></li><li>Display：绘制 Views<ol><li><code>drawRect</code> 绘制内容，如果重载了（主要使用 Core Graphic，避免执行复杂操作）</li><li>String drawing</li><li>通常是 CPU / memory 负责</li></ol></li><li>Prepare：做些 Core Animation 相关操作<ol><li>image decoding（view hierachy 绘制的，jpeg，png）</li><li>image conversion（因为有些图片 GPU 不支持），通常是解码成 bitmap</li></ol></li><li>Commit：打包 layers，然后将他们发给 render server<ol><li>递归上述流程</li><li>如果 layer 树很复杂，那么会很耗性能。所以尽可能的让 layer tree 平一些（少几层）</li></ol></li></ol><h3 id="动画animation"><a class="markdownIt-Anchor" href="#动画animation"></a> 动画Animation</h3><p>主要是 3个阶段，有 2个阶段发生在 Application 进程中，1个在 Render Server 进程中</p><ol><li>创建动画接着更新视图层级 <code>animateWithDuration:animations:</code></li><li>准备动画，然后提交 <code>layoutSubviews</code>, <code>drawRect:</code> <a href="#1">就是<strong>提交事务</strong>这几步</a></li><li>使用进程间通信，render server 进程绘制出动画相关的每一帧，在交由 App 进程</li></ol><p><img src="/img/core-animation-animation.jpeg" alt="Animation 过程"></p><h3 id="渲染-render"><a class="markdownIt-Anchor" href="#渲染-render"></a> 渲染 render</h3><p>一个 view 的渲染过程</p><p><img src="/img/render-pass.jpeg" alt="render pass"></p><p>添加 masking 后的渲染过程</p><p><img src="/img/render-pass-mask.jpeg" alt="render-pass-mask"></p><p>GPU 的离屏渲染，就是对于一个 view 需要多次渲染组合，因为需要多个渲染层所以需要离屏渲染开辟缓存，绘制这些mask，radius，blend ……<br>如果需要组合的那些渲染过程在 CPU 中完成，然后CPU直接把一个绘制好的 image 交给 GPU 渲染就不会有这些问题了！不过 CPU 性能问题！drawRect 中如果绘制 image 太过复杂依然会出现掉帧问题</p><h2 id="runloop-core-animation"><a class="markdownIt-Anchor" href="#runloop-core-animation"></a> Runloop &amp; Core Animation</h2><p>RunLoop主要处理以下6类事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Observer</span><br><span class="line"><span class="number">2.</span> block</span><br><span class="line"><span class="number">3.</span> timer</span><br><span class="line"><span class="number">4.</span> main_dispatch_queue</span><br><span class="line"><span class="number">5.</span> source0</span><br><span class="line"><span class="number">6.</span> source1</span><br></pre></td></tr></table></figure><ol><li>Observer事件：runloop中状态变化时进行通知。Core Animation 监听 RunloopObserver 闲置的时候触发。</li><li>Block事件：</li><li>Main_Dispatch_Queue事件：GCD中dispatch到main queue的block 会在 main loop 中执行。</li><li>Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。</li><li>Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。(用户可以手动调用performSelector 方法触发 source0)</li><li>Source1事件：处理系统内核的mach_msg事件。（推测CADisplayLink也是这里触发）。</li></ol><p>App 进程的 Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件（就是不让 runloop 睡！）<br>。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。<br>当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p><h3 id="布局渲染"><a class="markdownIt-Anchor" href="#布局渲染"></a> 布局&amp;渲染</h3><p>渲染图片之前一定要先计算好尺寸位置，也就是 frame，AutoLayout 最终结果也是 frame，在 iOS12以后 AutoLayout 性能大幅提升</p><p><img src="/img/layout&amp;render.jpeg" alt="layout&amp;render"></p><p>更新布局限制的过程是：子–&gt;父(super.updateConstraints最后调用)<br>更新布局的过程是：父–&gt;子 (layoutSubview)</p><h3 id="布局渲染相关方法"><a class="markdownIt-Anchor" href="#布局渲染相关方法"></a> 布局渲染相关方法</h3><p><img src="/img/layout&amp;render-function.jpeg" alt="layout&amp;render-function"></p><ol><li>布局限制</li></ol><p>autulayout 的布局限制不要将布局 放到 <code>updateContraints</code> 方法中，这里是放大量布局更新的地方，通常布局代码放在 view 的 <code>init</code>, <code>awakeFromNib</code> or viewcontroller 的 <code>viewDidLoad，loadView</code> 方法中</p><p>setNeedXXXX 是标记脏布局，在下一次 RunLoop循环的时候就会调用 updateXXX 方法</p><ol start="2"><li>布局</li></ol><p><code>layoutSubViews</code> 被系统调用的时候，所有相关的子view的 frame 都已经被 AutoLayout 的布局引擎布局好了，都有了自己 frame，这个时候可以更改 他们的frame了</p><ol start="3"><li>显示（CPU）</li></ol><p>嗯以上的1~3都是 CPU的操作</p><ul><li>drawRect方法 通过 CoreGraphic库绘制 2D image，放在 layer.contents 编码交给 Render Server处理</li><li>同理 CALayer 的 drawLayer 方法</li><li>CALayer 的 delegate</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CALayerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If defined, called by the default implementation of the -display</span></span><br><span class="line"><span class="comment"> * method, in which case it should implement the entire display</span></span><br><span class="line"><span class="comment"> * process (typically by setting the `contents' property). */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If defined, called by the default implementation of -drawInContext: */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>默认情况 UIView 是 CALayer 的CALayerDelegate，drawRect 内部就是调用 CALayerDelegate的方法 给 Layer 绘制 contents</p><p>只要 layer.contents 的东西交由 Render Server，内部render 引擎渲染就是系统的事了<br>所以有了写异步渲染框架，只要程序员在子线程配置好了 contents然后在主线程交给 layer 就可以了</p><h2 id="离屏渲染"><a class="markdownIt-Anchor" href="#离屏渲染"></a> 离屏渲染</h2><p>离屏渲染是 GPU 为了缓存的已经渲染出来图形，等待跟其他图形组合<br>离屏渲染空间只有屏幕的 2.5倍</p><p>eg: 圆角图片<br>由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染。但如果仅仅是实现一个简单的效果，直接使用 CPU 渲染的效率又可能比离屏渲染好，毕竟普通的离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。对一些简单的绘制过程来说，这个过程有可能用CoreGraphics，全部用CPU来完成反而会比GPU做得更好。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> 系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义 keyboard</title>
      <link href="/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/"/>
      <url>/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>原文：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html" target="_blank" rel="noopener">CustomKeyboard</a></p><h3 id="自定义键盘api"><a class="markdownIt-Anchor" href="#自定义键盘api"></a> 自定义键盘API</h3><p>开发自定义键盘的快速入门,如下图，它展示了键盘运行过程中一些重要的对象，以及它们在开发流程中的的位置：</p><p><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/keyboard_architecture_2x.png" alt="keyboard"></p><p>自定义键盘模板（在iOS“Application Extension”目标模板组）包含一个UIInputViewController的子类，它是你开发的键盘的主视图控制器。该模板包含</p><p>键盘所必需的“下一个键盘”按钮的实现，它调用了UIInputViewController类的advanceToNextInputMode方法。如上图所示，可以在输入视图控制器的主视图（在其inputView属性）中添加子视图、控制器以及手势识别器等。对于其它类型的扩展应用，在目标上并不存在窗体，因此也就没有根视图控制器了。</p><p>在模板的Info.plist文件中有预先配置好的键盘所需要的最基本的值。参见其中的NSExtensionAttributes字典关键字，配置一个键盘的关键字在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW18" target="_blank" rel="noopener">《配置自定义键盘的Info.plist文件》</a>中有介绍。</p><p>默认，键盘不能访问网络，不能和它的app共享容器。如果要具备这种能力，必须要将Info.plist文件中RequestsOpenAccess的值置为YES。这需要扩展键盘的沙盒，在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《设计用户信任》</a>中有介绍相关内容。</p><p>一个输入视图控制器遵从各种与文本输入对象内容交互的协议：</p><ul><li>响应触摸消息时如果要插入或删除文本，可以使用<a href="https://developer.apple.com/reference/uikit/uikeyinput" target="_blank" rel="noopener">UIKeyInput</a>协议的insertText:和deleteBackward方法。可以在视图控制器的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618193-textdocumentproxy" target="_blank" rel="noopener">textDocumentProxy</a>属性中调用这些方法，该属性代表当前文本输入对象，它遵从<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="noopener">UITextDocumentProxy</a>协议。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"hello "</span>]; <span class="comment">// Inserts the string "hello " at the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy deleteBackward];       <span class="comment">// Deletes the character to the left of the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"\n"</span>];     <span class="comment">// In a text view, inserts a newline character at the insertion point</span></span><br></pre></td></tr></table></figure><ul><li>在调用deleteBackward之前要先决定删除的字符数。可以通过textDocumentProxy的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618190-documentcontextbeforeinput" target="_blank" rel="noopener">documentContextBeforeInput</a>属性，来获得光标附近的文本上下文信息。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *precedingContext = <span class="keyword">self</span>.textDocumentProxy.documentContextBeforeInput;</span><br></pre></td></tr></table></figure><ul><li>为了控制光标所在位置的操作，比如支持向前删除文字，需要调用UITextDocumentProxy协议中的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618194-adjusttextposition" target="_blank" rel="noopener">adjustTextPositionByCharacterOffset:</a>方法。比如向前删除一个字符，代码如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) deleteForward &#123;</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy adjustTextPositionByCharacterOffset: <span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy deleteBackward];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现<a href="https://developer.apple.com/reference/uikit/uitextinputdelegate" target="_blank" rel="noopener">UITextInputDelegate</a>协议中的方法，可以响应当前输入文本对象的一些变化，比如内容变化以及用户触发的光标位置的变化。</li></ul><p>为了展现与当前文本输入对象适配的键盘布局，需要参照该对象的<a href="https://developer.apple.com/reference/uikit/uikeyboardtype" target="_blank" rel="noopener">UIKeyboardType</a>属性，根据每种你的键盘所能支持的属性，变化布局内容。</p><p><strong>在自定义键盘中，有两种方式来支持多语言：</strong></p><ul><li>为每个语言创建一个键盘，每个键盘都作为向容器app添加的独立的Target</li><li>创建一个多语言键盘，动态切换当前语言。可以使用UIInputViewController类的primaryLanguage属性来动态切换语言。</li></ul><p>根据你要支持的语言数量以及你想提供的用户体验，你可以从上面选择最合适的方案。</p><p>每种自定义键盘（需要RequestsOpenAccess）都可以通过UILexicon类访问自动纠错的词典。通过使用该类，并结合你自己的词典设计，可以在用户输入过程中为他提供输入建议和自动纠错。UILexicon对象包含来自如下源的单词：</p><ul><li>来自用户通讯录的人名和姓</li><li>在 设置 &gt; 通用 &gt; 键盘 &gt; 快捷方式（文本替换） 列表</li><li>通用词典</li></ul><p>你可以使用自动布局来调整你的自定义键盘主视图的高度。默认情况下，自定义键盘会根据屏幕尺寸以及设备方向，和系统键盘的尺寸保持一致。自定义键盘的宽度通常与屏幕当前宽度一致。修改自定义键盘主视图的高度约束即可修改其高度。</p><p>下面的代码展示如何定义和添加约束：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> _expandedHeight = <span class="number">500</span>;</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *_heightConstraint = </span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem: <span class="keyword">self</span>.view </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeHeight</span> </span><br><span class="line">                                 relatedBy: <span class="built_in">NSLayoutRelationEqual</span> </span><br><span class="line">                                    toItem: <span class="literal">nil</span> </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeNotAnAttribute</span></span><br><span class="line">                                multiplier: <span class="number">0.0</span> </span><br><span class="line">                                  constant: _expandedHeight];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint: _heightConstraint];</span><br></pre></td></tr></table></figure><h2 id="自定义键盘的开发关键"><a class="markdownIt-Anchor" href="#自定义键盘的开发关键"></a> 自定义键盘的开发关键</h2><p>自定义键盘开发有两个关键点：</p><ul><li>信任。 自定义键盘能访问用户输入的内容 ，因此在键盘和用户间建立信任非常关键。</li><li>“下一个键盘”键。 通过键盘界面必须能让用户能切换到下一个键盘。</li></ul><h3 id="为用户信任所做的设计"><a class="markdownIt-Anchor" href="#为用户信任所做的设计"></a> 为用户信任所做的设计</h3><p>作为自定义键盘的开发者，你首先应当考虑的是如何建立和维护用户信任。你要理解隐私策略的最佳实践并知道如何实现它才能很好地践行。</p><blockquote><p>注意<br>本节为你创建自定义键盘提供相关的开发手册，该手册要求尊重用户隐私。了解iOS编程要求，请阅读应用商店审核手册，iOS人机交互手册，iOS开发许可协议，请参见苹果的<a href="https://developer.apple.com/support/appstore/app-review/" target="_blank" rel="noopener">《应用审核支持》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/ExpectedAppBehaviors/ExpectedAppBehaviors.html#//apple_ref/doc/uid/TP40007072-CH3-SW6" target="_blank" rel="noopener">《支持用户隐私》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="noopener">《iOS应用编程指南》</a>。</p></blockquote><p>对于键盘，如下三个方面对于建立和维护用户信任至关重要：</p><ul><li>按键数据的安全。 用户希望他们的敲键会落在文档以及输入区域内，而不是上传到服务器或者用于其他不明目的。</li><li>最小化合理利用其它用户数据。 如果你的键盘还需要使用其他用户数据，例如定位服务或者通讯录，你有义务解释这给用户带来的好处是什么。</li><li>准确。 把输入事件转换成文本要求精准，这本身虽然不是一个隐私话题，但他会影响到信任：每次文字转换需要体现出你的代码的精准。</li></ul><p>在信任的开发设计过程中，首先考虑的是是否要获取open access权限。尽管开启了open access权限能给自定义键盘开发带来极大便利，但这也增加了你作为开发者的责任。下面是标准的open access的能力和隐私考虑：</p><table><thead><tr><th>Open Access</th><th>能力和限制</th><th>隐私考虑</th></tr></thead><tbody><tr><td>Off(default)</td><td>·键盘可以执行所有基本键盘的职责<br>·可以访问通用词典以支持自动纠错和输入建议<br>·访问设置里的快捷短语<br>·不与containing应用共享容器<br>·不访问键盘容器以外的文件系统<br>·不访问键盘容器以外的文件系统<br>·不能直接或间接访问iCloud或游戏中心或应用内购买</td><td>用户了解按键仅仅被发送到当前使用键盘的应用里</td></tr><tr><td>On</td><td>·具备非联网自定义键盘的所有能力<br>·在用户许可情况下可以访问位置服务和通讯录<br>·键盘和containing app可以访问共享容器<br>·键盘可以为服务器侧处理过程发送按键或其他输入事件<br>·containing app自动纠错字典提供编辑界面<br>·通过containing app键盘可以使用iCloud来保证自动纠错词典和设置的更新<br>·通过containing app，键盘可以参与到游戏中心和应用内购买<br>·如果键盘支持移动设备管理(MDM)，它可与被管理的应用共同工作</td><td>·用户了解键盘开发者会利用按键数据<br>·你必须遵守有联网能力的键盘开发手册和iOS开发许可协议，可参见《应用审核支持》</td></tr></tbody></table><p>如果你的自定义键盘不需要open access权限，系统确保敲键信息不会被发送给你的键盘以及别的地方。如果只想提供一般的键盘功能，请不要给键盘配备联网能力。由于有沙盒限制，不联网的键盘一定是满足苹果的数据隐私手册并能获得用户信任的。</p><p>开启open access权限（如上所述，可以在Info.plist文件中配置），能给你的开发带来更多可能性，同时也带来更多的责任。</p><blockquote><p>注意<br>向应用商店提交一个open-access的键盘必须遵守苹果《应用审核支持》中的相关条款。</p></blockquote><p>每一个与open access相关的功能都需要你履行相应的责任，应当最大限度地尊重用户数据，不得用于与用户输入无关的其他任何目的。下表列出了open access带来的好处以及开发者需承担的责任：</p><table><thead><tr><th>能力</th><th>用户利益示例</th><th>开发者责任</th></tr></thead><tbody><tr><td>与containing app共享容器</td><td>为键盘的自动纠错词典管理UI界面</td><td>要考虑到自动纠错数据属于用户隐私。不要把他发到你的服务器，用作与输入无关的用途。</td></tr><tr><td>把按键数据发到你的服务器</td><td>通过开发者的计算资源可以提供更好的按键处理结果和输入预测</td><td>只有为用户提供更好的输入体验之用时，才能保存按键和语音数据</td></tr><tr><td>基于云的自动纠错词典</td><td>把人名、地名、热点新闻加入到自动纠错词典中</td><td>不要把用户身份与输入数据关联起来，不得将用户信息用作与输入体验无关的其他目的</td></tr><tr><td>通讯录</td><td>把人名、地名、电话号码添加到自动纠错词典中</td><td>不得讲通讯录用作与输入体验无关的其他目的</td></tr><tr><td>位置服务</td><td>将附近的地名添加到自动纠错词典中</td><td>不要在后台使用位置服务，不得将位置信息发送到你的服务器并用于与输入体验无关的其他目的</td></tr></tbody></table><p>一个具有open-access权限的键盘和其containing app能将按键数据发送到服务器端，通过这些数据可以为用户提供更好的输入体验。如果你使用了这些能力，当不需要这些数据的时候，请及时在服务器端删除。参见上面的表格来履行你使用open-access权限中的义务。</p><h3 id="提供切换到其他键盘的方法"><a class="markdownIt-Anchor" href="#提供切换到其他键盘的方法"></a> 提供切换到其他键盘的方法</h3><p>系统键盘的小地球按键用于切换到其他键盘：<br><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/globe_key_2x.png" alt="The system keyboard’s Globe key"></p><p>你的自定义键盘必须提供类似的机制能切换到其他键盘。</p><p>调用UIInputViewController类的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618191-advancetonextinputmode" target="_blank" rel="noopener">advanceToNextInputMode</a>方法可以切换到其他键盘。系统会选择下一个键盘，没有能获得键盘列表的API，也没有切换到指定键盘的API。</p><p>Xcode自定义键盘模板中就已经在下一个键盘按钮上具备了advanceToNextInputMode的功能。为了提供最好的用户体验，应当把你的下一个键盘按键放在靠近系统键盘的小地球键的位置。</p><blockquote><p>注意<br>要通过应用审核，必须在你的键盘上提供明显允许用户切换键盘的UI标识。</p></blockquote><h2 id="开始自定义键盘的开发"><a class="markdownIt-Anchor" href="#开始自定义键盘的开发"></a> 开始自定义键盘的开发</h2><h3 id="使用xcode自定义键盘模板"><a class="markdownIt-Anchor" href="#使用xcode自定义键盘模板"></a> 使用Xcode自定义键盘模板</h3><p>创建键盘及其containing app与其他扩展应用略有不同。本节将带你领略基本键盘的开发和运行。</p><p><strong>在一个容器app中创建键盘，步骤如下</strong></p><ol><li>在Xcode中选择File &gt; New &gt; Project &gt; iOS &gt; Application选择Single View Application模板。</li><li>点击Next。</li><li>填写Project Name（如CKIme），点击Next。</li><li>选择要保存的位置，点击Create。这样，你就有了一个空app，该app只能完成一个简单的操作，接下来它将承载键盘。在你提交到应用商店之前，你需要完成一些有用的功能。请到应用审核支持参考应用商店审核指南。</li><li>选择File &gt; New &gt; Target &gt; iOS &gt; Application Extension选择Custom Keyboard Extension，点击Next。</li><li>填写Product Name（如CKbd），点击Finish。</li><li>确认Project和Embed in Application中都显示的是容器app的名字（CKIme），点击Finish。如果弹出Activate “CKbd” scheme提示让激活键盘工程，点击Activate。</li></ol><p><strong>定义键盘group name，步骤如下：</strong></p><ol><li>在Xcode工程导航视图中，选择容器app的Info.plist文件，</li><li>在右侧plist编辑器中，鼠标hover到Bundle name上，点“+”按钮创建一行空属性。</li><li>在Key中填写Bundle display name，回车</li><li>双击该行的Value，填写你要自定义的键盘group name。</li><li>选择File &gt; Save保存设置。</li></ol><p>下表汇总了在容器app和键盘app的Info.plist文件中你可以配置的UI字符串：</p><table><thead><tr><th>iOS UI字符串</th><th>Info.plist关键字</th></tr></thead><tbody><tr><td>· 在系统设置的已购键盘列表中的键盘group name</td><td>在容器app的Info.plist文件中的Bundle display name</td></tr><tr><td>· 系统设置中的键盘名称<br>· 键盘换列表中的键盘名称</td><td>在键盘app的Info.plist文件中的Bundle display name</td></tr></tbody></table><p><strong>运行自定义键盘并将Xcode调试器attach到它上面</strong></p><ol><li>在Xcode，你的view controller实现中设置一个断点（比如可以断在viewDidLoad上）。</li><li>在Xcode工具栏确保当前活动的项目为键盘项目，并对应iOS模拟器或设备。</li><li>选择菜单Project &gt; Run，或点击Build and then run the current scheme按钮（即播放按钮）。Xcode会提示选择host app。选择一个带有输入框的，比如通讯录或Safari。</li><li>点击Run。Xcode将运行起你指定的host app。如果这是你第一次使用键盘扩展应用，需要现在设置中添加并启用键盘：<ol><li>Settings &gt; General &gt; Keyboard &gt; Keyboards</li><li>点击Add New Keyboard…</li><li>在OTHER IPHONE KEYBOARDS中点击你刚刚创建的键盘</li></ol></li><li>在iOS模拟器或真机上，调出你的自定义键盘。<br>点击任意可输入区域，将显示出系统键盘。按住小地球，选择你的自定义键盘。<br>此时你将看到自定义键盘，但是调试器尚未attach上来。一个从模板构建而来的极简键盘仅有一个Next Keyboard按钮，点击后切换回前一个键盘。</li><li>取消你的键盘（以便在第8步中你可以再次调出键盘以命中viewDidLoad断点）</li><li>在Xcode中，选择Debug &gt; Attach to Process &gt; By Process Identifier(PID) or Name 在弹出对话框中，输入你的键盘扩展应用的名字（包含空格）.默认就是该扩展应用在工程导航窗口里的group name。</li><li>点击Attach。Xcode将显示出等待attach的调试器。</li><li>在任意能输入文字的app中调出键盘。<br>当你的键盘主视图开始加载时，Xcode调试器将attache到你的键盘，并命中断点。</li></ol><h3 id="为自定义键盘配置infoplist文件"><a class="markdownIt-Anchor" href="#为自定义键盘配置infoplist文件"></a> 为自定义键盘配置Info.plist文件</h3><p>自定义键盘的Info.plist文件允许静态定义键盘的现式特征，包括主要语言，以及是否需要open access权限。</p><p>打开Xcode并切换到自定义键盘的 target。在工程导航栏选择Info.plist文件，按文本格式呈现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtension<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionAttributes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>IsASCIICapable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrefersRightToLeft<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrimaryLanguage<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>en-US<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>RequestsOpenAccess<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPointIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.keyboard-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPrincipalClass<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>KeyboardViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个关键字在App Extension Keys中都有解释。可以使用字典NSExtensionAttributes中的关键字来描述你的自定义键盘的特征和需求，如下：</p><p><code>IsASCIICapable</code> - 默认为NO的布尔值。用户键盘是否可以向文档中插入ASCII字串。如果要为<code>UIKeyboardTypeASCIICapable</code>属性的输入对象展现单独类型的键盘，需要将该值置为YES。</p><p><code>PrefersRightToLeft</code> - 默认为NO的布尔值。是否为从右到左的语种设计的的自定义键盘。</p><p><code>PrimaryLanguage</code> - 默认为en-US的字串。以&lt;语种&gt;-&lt;区域&gt;的形式描述键盘的主语言。可以到http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c找到对应的语种和区域。</p><p><code>RequestsOpenAccess</code> - 默认为NO的布尔值。是否需要比基础键盘更大的沙盒范围。把该值置为YES将需要完全访问权限，你的键盘将获得如下能力，每个能力都伴随有相应的权限：</p><ul><li>访问定位服务，通讯录数据库，相机，每个都需要用户允许</li><li>与键盘的容器app共享容器数据，以便完成比如在容器app中管理用户词库的界面的功能</li><li>通过网络发送按键、输入事件之类的数据供云端处理</li><li>使用UIPasteboard类</li><li>播放音频，包括使用playInputClick方法播放按键音</li><li>访问iCloud，可以用来根据用户身份同步比如键盘设置、自定义自动纠错词典</li><li>通过容器app访问游戏中心和应用内购买</li><li>如果你的键盘支持移动设备管理（MDM），可以与被管理的app无缝合作</li></ul><p>当考虑是否将这些关键字设置为YES之前，一定要先阅读<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《用户信任设计》</a>，这里描述了如何尊重和保护用户数据。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> AppExtensions </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>runloop 实践相关</title>
      <link href="/2019/12/29/runloop/runloop-%E5%AE%9E%E8%B7%B5%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/12/29/runloop/runloop-%E5%AE%9E%E8%B7%B5%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>RunLoop 是系统层级上的设计，用来给管理系统消息队列派发，那我们都可以用 runLoop 做什么呢？<br>简单来说，RunLoop 是用来监听输入源，进行调度处理的。</p><p>RunLoop 输入源可以是：</p><ul><li>输入设备</li><li>网络</li><li>周期性或者延迟时间</li><li>异步回调</li></ul><p><img src="/img/runloop_core.jpeg" alt="runloop activities"></p><p>runloop 的 observer 可以监听的 7中状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">  kCFRunLoopEntry ,         <span class="comment">// 进入 loop</span></span><br><span class="line">  kCFRunLoopBeforeTimers ,  <span class="comment">// 触发 Timer 之前</span></span><br><span class="line">  kCFRunLoopBeforeSources , <span class="comment">// 触发 Source0 之前</span></span><br><span class="line">  kCFRunLoopBeforeWaiting , <span class="comment">// 等待 mach_port 消息（等待源Source和计时器Timer之前，进入睡眠）</span></span><br><span class="line">  <span class="comment">// 在这两个状态中真正处理事件</span></span><br><span class="line">  kCFRunLoopAfterWaiting ), <span class="comment">// 接收 mach_port 消息（等待源Source和计时器Timer后，同时在被唤醒之前）</span></span><br><span class="line">  kCFRunLoopExit , <span class="comment">// 退出 loop</span></span><br><span class="line">  kCFRunLoopAllActivities  <span class="comment">// loop 所有状态改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测-ios-app-卡顿"><a class="markdownIt-Anchor" href="#检测-ios-app-卡顿"></a> 检测 iOS App 卡顿</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h3><h4 id="卡顿如何造成的"><a class="markdownIt-Anchor" href="#卡顿如何造成的"></a> 卡顿如何造成的</h4><p>iOS系统页面刷新频率：60 FPS，60次/s, <code>let refresh_time_per = 1s/60 &lt; 0.02</code><br>如果在 <code>refresh_time_per</code> 时间内没有完成图片绘制，那么就会出现卡顿现象！<br>而系统页面刷新事件处理…… 事件几乎都是由 runloop 调用执行的。<br>那么如果 runloop 一次循环时间 &gt; <code>refresh_time_per</code> 就说明图片没有渲染完成，导致卡顿。</p><p>问题来了，如何判断 runloop 一次循环时间 &gt; <code>refresh_time_per</code> 呢？</p><p>RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p><p>所以要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。<br>RunLoop 的两个 loop 状态<br>在进入睡眠之前: kCFRunLoopBeforeSources<br>在进入唤醒之后: kCFRunLoopAfterWaiting<br>也就是要触发 Source0 回调和接收 mach_port 消息两个状态。</p><details><summary>runloop 核心源码</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="comment">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line"><span class="comment">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line"><span class="comment">// 执行被加入的block</span></span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line"><span class="comment">// 执行被加入的block</span></span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line"><span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">  Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">  <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line"><span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line"><span class="comment">// • 一个基于 port 的Source 的事件。</span></span><br><span class="line"><span class="comment">// • 一个 Timer 到时间了</span></span><br><span class="line"><span class="comment">// • RunLoop 自身的超时时间到了</span></span><br><span class="line"><span class="comment">// • 被其他什么调用者手动唤醒</span></span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">  mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到消息，处理消息。</span></span><br><span class="line">handle_msg:</span><br><span class="line">      <span class="comment">// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line"><span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">  __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">  __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">  sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">  <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  退出 runloop 逻辑 retVal != 0 exit</span></span><br><span class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">  <span class="comment">// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">  retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">  <span class="comment">// 超出传入参数标记的超时时间了</span></span><br><span class="line">  retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">  <span class="comment">// 被外部调用者强制停止了</span></span><br><span class="line">  retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">  <span class="comment">// source/timer/observer一个都没有了</span></span><br><span class="line">  retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h3 id="卡顿监听实践"><a class="markdownIt-Anchor" href="#卡顿监听实践"></a> 卡顿监听实践</h3><ol><li>创建 runloop 的observer对象:</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakSelf = <span class="type">Unmanaged</span>&lt;<span class="type">Monitor</span>&gt;.passUnretained(<span class="keyword">self</span>).toOpaque()</span><br><span class="line"><span class="keyword">var</span> ctx: <span class="type">CFRunLoopObserverContext</span> = <span class="type">CFRunLoopObserverContext</span>(version: <span class="number">0</span>, weakSelf: info, retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.runLoopObserver = <span class="type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.allActivities.rawValue, <span class="literal">true</span>, <span class="number">0</span>, runLoopCallBack(), &amp;ctx)</span><br></pre></td></tr></table></figure><ol start="2"><li>将 observer 添加到 runloop 的 commonModes 中</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFRunLoopAddObserver</span>(<span class="type">CFRunLoopGetCurrent</span>(), <span class="keyword">self</span>.runLoopObserver, <span class="type">CFRunLoopMode</span>.commonModes)</span><br></pre></td></tr></table></figure><ol start="3"><li>创建子线程，监听runloop的状态<ul><li>beforeSources: 进入睡眠前</li><li>afterWaiting: 唤醒后的状态</li><li>设置卡顿阀值</li><li>打印堆栈信息</li></ul></li></ol><p>为什么要监听 beforeSources 和 afterWaiting 这两个状态呢？<br>因为只有这两个状态 runloop 触发事件回调，如果runloop 长时间处于这两个状态中说明卡顿！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> sem = <span class="keyword">self</span>.dispatchSemaphore?.wait(timeout: <span class="type">DispatchTime</span>.now() + <span class="number">1</span> / <span class="number">50</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="type">DispatchTimeoutResult</span>.timedOut = sem &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.runLoopObserver <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dispatchSemaphore = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.runLoopActivity = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.runLoopActivity == <span class="type">CFRunLoopActivity</span>.beforeSources || <span class="keyword">self</span>.runLoopActivity == <span class="type">CFRunLoopActivity</span>.afterWaiting) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"symbo: \(Thread.callStackSymbols)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"打印卡顿堆栈..."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何获取卡顿的方法堆栈信息"><a class="markdownIt-Anchor" href="#如何获取卡顿的方法堆栈信息"></a> 如何获取卡顿的方法堆栈信息？</h3><h4 id="直接调用系统函数获取"><a class="markdownIt-Anchor" href="#直接调用系统函数获取"></a> 直接调用系统函数获取</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signals[] = &#123;</span><br><span class="line">  SIGABRT,</span><br><span class="line">  SIGBUS,</span><br><span class="line">  SIGFPE,</span><br><span class="line">  SIGILL,</span><br><span class="line">  SIGSEGV,</span><br><span class="line">  SIGTRAP,</span><br><span class="line">  SIGTERM,</span><br><span class="line">  SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signal_num = <span class="keyword">sizeof</span>(s_fatal_signals) / <span class="keyword">sizeof</span>(s_fatal_signals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">  <span class="built_in">NSArray</span> *exceptionArray = [exception callStackSymbols]; <span class="comment">// 得到当前调用栈信息</span></span><br><span class="line">  <span class="built_in">NSString</span> *exceptionReason = [exception reason];     <span class="comment">// 非常重要，就是崩溃的原因</span></span><br><span class="line">  <span class="built_in">NSString</span> *exceptionName = [exception name];       <span class="comment">// 异常类型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> SignalHandler(<span class="keyword">int</span> code) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"signal handler = %d"</span>,code);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> InitCrashReport() &#123;</span><br><span class="line">  <span class="comment">// 系统错误信号捕获</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">    signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//oc 未捕获异常的捕获</span></span><br><span class="line">  <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    InitCrashReport();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><h4 id="第三方库来获取堆栈信息"><a class="markdownIt-Anchor" href="#第三方库来获取堆栈信息"></a> 第三方库来获取堆栈信息</h4><p><a href="https://opensource.plausible.coop/src/projects/PLCR/repos/plcrashreporter/browse" target="_blank" rel="noopener">PLCrashReporter</a></p><h2 id="利用runloop空闲时间"><a class="markdownIt-Anchor" href="#利用runloop空闲时间"></a> 利用RunLoop空闲时间</h2><p>卡顿是因为 runloop 一次时间 &gt; 1/60s<br>那么如果 runloop 一次运行时间 &lt; 1/60s 呢？<br>譬如你把手机放在那看着 app，runloop 在那睡觉(<code>kCFRunLoopBeforeWaiting</code>)</p><p>这个时候往 runloop 里面放个 source or timer，runloop 就会醒来 进入 <code>kCFRunLoopAfterWaiting</code> 状态</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">BeforeWaitingDo</span> = () -&gt; ()</span><br><span class="line"><span class="keyword">var</span> tasks: [<span class="type">BeforeWaitingDo</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">self</span>.tasks.remove(at: <span class="number">0</span>)</span><br><span class="line">  t()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> rl = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">  <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.beforeWaiting.rawValue, <span class="literal">true</span>, <span class="number">0</span>) &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] (observer, actives) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span>,</span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.tasks.first <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">    <span class="comment">// 创建一个 source0 把 runloop 被叫醒</span></span><br><span class="line">    <span class="keyword">self</span>.perform(#selector(<span class="type">ChatEmojiViewController</span>.exec), on: <span class="type">Thread</span>.current, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">CFRunLoopAddObserver</span>(rl, observer, <span class="type">CFRunLoopMode</span>.commonModes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F161%3Fcode%3DQjb1JtJcvAPISj9QjxdKrAmeXmURMroQbkOcLNm0jeY%253D%26from%3Dsinglemessage%26isappinstalled%3D0" target="_blank" rel="noopener">《iOS开发高手课》</a><br><a href="https://www.jianshu.com/p/632d7a1526e9" target="_blank" rel="noopener">iOS 性能监控（二）—— 主线程卡顿监控</a><br><a href="https://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> runloop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>调试内存不足问题：使用运行时魔法捕获布局反馈循环</title>
      <link href="/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/"/>
      <url>/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>目标：<br>使用代码替代 <code>UIViewLayoutFeedbackLoopDebuggingThreshold</code> 符号调试，来捕获 Autolayout反馈循环所导致的内存不足问题。</p><h2 id="导致内存不足的原因"><a class="markdownIt-Anchor" href="#导致内存不足的原因"></a> 导致内存不足的原因</h2><p>如果 App，开始有大量日活用户并且崩溃率很低，但是过段时间，总会出现崩溃问题，检查 Fabric 也没啥用。</p><p>出现这种情况很可能是因为，内存不足，导致应用被系统终止。</p><p>导致内存不足的原因：</p><ul><li>循环引用;</li><li>竞争条件;</li><li>废弃的线程;</li><li>死锁;</li><li>布局反馈循环。</li></ul><p>Apple 提供了很多方法来解决这类问题：</p><ul><li>Instruments 里的 Allocations 和 Leaks 工具用于解决循环引用和 <a href="https://developer.apple.com/videos/play/wwdc2015/230/" target="_blank" rel="noopener">其他类型的泄漏</a></li><li>在 Xcode 8 中引入的 <a href="https://developer.apple.com/videos/play/wwdc2016/410/" target="_blank" rel="noopener">Memory Debugger</a> 代替了 Allocations 和 Leaks 的一部分功能</li><li><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">Thread Sanitizer</a> 帮助你找到竞争条件、废弃的线程或者死锁</li></ul><h2 id="布局反馈循环"><a class="markdownIt-Anchor" href="#布局反馈循环"></a> 布局反馈循环</h2><blockquote><p>当视图正在运行它们的布局代码，但某种方法导致它们再一次开始布局传递，此时布局反馈循环就会出现。这可能是因为某个视图正在改变某个父视图的大小，或者因为你有一个模棱两可的布局。无论哪种原因，这个问题的表现是你的 CPU 使用被占满和 RAM 使用量稳步上升，因为你的视图正在一次又一次地运行它们的布局代码，却没有返回。<br>-来自<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">HackingWithSwift 的 Paul Hudson</a></p></blockquote><p>在 WWDC 16 中 Apple 介绍了“布局反馈循环调试器”。这个调试器有助于识别在调试过程中发生循环的时间点。这就是一个符号断点，它的工作方式非常简单：它会计算在单个 run loop 迭代中调用每个视图上的 <font color="red">layoutSubviews()</font> 方法的次数。一旦这个计数值超过某个临界值（比如，100），这个应用程序将会停在这个断点并打印出日志。<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">这篇文章</a> 快速地介绍如何使用这个调试器。</p><p>这个方法在可以重现问题的情况下十分有效。但是在线上出现就不用容易调试。但是你可以尝试把 <font color="red">UIViewLayoutFeedbackLoopDebuggingThreshold</font> 的代码复制到生产代码中。</p><h3 id="如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"><a class="markdownIt-Anchor" href="#如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"></a> 如何用代码实现 UIViewLayoutFeedbackLoopDebuggingThreshold 的功能呢</h3><p>符号断点是如何工作的：它会计算 layoutSubviews() 的调用次数并在单个 run loop 迭代中超过某个临界值时发送一个事件。听起来很简单，对吧？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackableView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="type">YourAnalyticsFramework</span>.event(name: <span class="string">"loop"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于一个视图，这段代码运行正常。</li><li>但是现在你想要在另一个视图上实现它。当然，你可以创建一个 UIView 的子类，在这里实现它并使你项目中的所有视图都继承这个子类。</li><li>然后为 UITableView，UIScrollView，UIStackView 等做同样的事情。</li></ol><p>如果将此逻辑注入你想要的任何类，而无需编写大量重复的代码。这时候就可以 <code>借助运行时编程</code> 了。</p><h3 id="使用-runtime-实现子类"><a class="markdownIt-Anchor" href="#使用-runtime-实现子类"></a> 使用 runtime 实现子类</h3><p>我们会做同样的事情——创建一个子类，重写 layoutSubviews() 方法并计算其调用次数。唯一的区别是所有这些都使用 runtime 完成，而不是在项目中创建重复的类。</p><p><strong>创建自定义子类</strong>，并将原始视图的类更改为新的子类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>objc_allocateClassPair() 方法的文档告诉我们这个方法何时失败：</li></ol><blockquote><p>新类，或者如果无法创建类，则为 Nil （例如，所需名称已被使用）。</p></blockquote><p>这就意味着不能拥有两个同名的类。我们的策略是为单个视图类创建一个单独的运行时类。这就是我们在原始类名前加上前缀来形成新类的名称的原因。</p><ol start="2"><li>现在添加一个计数器到子类中。理论上，有两种方法可以做到这一点。</li><li>添加一个保存计数器的属性。</li><li>为这个类创建一个关联对象（Associated object）。</li></ol><p>但是目前，只有一个方法奏效。你可以想象属性是存储在分配给类的内存里的东西，然而关联对象则储存在一个完全不同的地方。因为分配给已存在对象的内存是固定的，所以我们<font color="red">在自定义类上新添加的属性将会从其他资源里“窃取”内存</font>。它可能导致意料之外的行为和难以调试的程序崩溃（点击 <a href="https://stackoverflow.com/questions/3346427/object-setclass-to-bigger-class" target="_blank" rel="noopener">这里</a> 查看更多信息）。但是在使用关联对象的情况下，它们将会存储在运行时创建的一个哈希表里，这是完全安全的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = <span class="string">"_counter"</span></span><br><span class="line">...</span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>当新的子类被创建时，计数器初值设置为 0。</p><p><strong>实现这个新的layoutSubviews() 方法，并将它添加到我们的类中</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">      onLoop()</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>为了理解上面这段代码实际上在干什么，让我们看一下这个来自 &lt;objc/runtime.h&gt; 的结构体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> </span>&#123;</span><br><span class="line">  <span class="type">SEL</span> method_name;</span><br><span class="line">  char *method_types;</span><br><span class="line">  <span class="type">IMP</span> method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实际上是由什么组成的：</p><ul><li>方法的实现 method_imp，这是调用方法时要执行的实际函数。它的前两个形参总是方法接收者和消息选择器。</li><li>包含方法签名的方法类型字符串 method_types。你可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">这里</a> 详细了解其格式。但是在现在的情况下，需要明确说明的字符串是 “v@:”。作为返回类型，v 代表 void，而 @ 和 : 分别代表接收者和消息选择器。</li><li>选择器 method_name 作为键，用于在运行时查找方法的实现。</li></ul><p>你可以把 Witness Table（在其他编程语言中，它也被称作方法派发表）想象成一个简单的字典数据结构。那么选择器为键，且实现部分则为对应的值。<br>在下面这行代码中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(trackableClass,#selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>我们所做的是给 layoutSubviews() 方法对应的键分配新值。</p><p>这个方法直截了当。我们获得这个计数器，使它的计数值加一。如果计数值超过临界值，我们会发送分析事件，其中包含类名和想要的任何数据体。</p><p>让我们回顾一下如何对关联对象实现和使用键：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>为什么我们使用 var 来修饰计数器的键这个静态属性并在传递到其他地方时使用引用？答案隐藏在 Swift 语言基础——字符串之中。字符串像其他所有的值类型一样，是按值传递的。那么，当你把它传入这个闭包时，这个字符串将会被复制到一个不同的地址，这会导致在关联对象表中产生一个完全不同的键。&amp; 符号总是保证将相同的地址作为键参数的值。你可以尝试以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAddress</span><span class="params">(<span class="number">_</span> string: UnsafeRawPointer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(string)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">printAddress(str)</span><br><span class="line">printAddress(str)</span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  printAddress(str)</span><br><span class="line">  printAddress(str)</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 最后两个函数调用的地址将始终不同</span></span><br></pre></td></tr></table></figure><p>用引用的方式来传递键的主意总是好的，因为有时，即使你没有使用闭包，变量的地址仍可能因内存管理而更改。在我们例子中，如果你把上面的代码运行多次，即使是前两个 printAddress() 的调用也可能会输出不同的地址。</p><p>让我们回到运行时的魔法里来。在新 layoutSubviews() 的实现里，还有一件很重要的事情没有完成。这件事是每次重写父类的方法时通常都会做的事情——调用父类实现。layoutSubviews() 的文档里提到：</p><blockquote><p>在 iOS 5.1 及更早版本中，这个方法的默认实现不执行任何操作。而之后的默认实现会使用你设置的任何约束来确定任何子视图的大小和位置。</p></blockquote><p>为了避免发生一些难以预料的布局行为，我们得调用父类的实现，但这不像平常那样简单明了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line"><span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line"><span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line"><span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">originalLayoutSubviews(view, selector)</span><br></pre></td></tr></table></figure><p>这里实际发生的是：我们检索方法所需的实现部分，并直接从代码中调用它，而不是用常见的方式来调用方法（即执行一个会在 Witness Table 中寻找对应实现的选择器）。</p><p>目前为止，让我们看看实现部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">  <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称</span></span><br><span class="line">  <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">  <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在当前运行时会话期间尚未创建此类</span></span><br><span class="line">    <span class="comment">// 注册这个类并将其与原始视图的类交换</span></span><br><span class="line">    objc_registerClassPair(trackableClass)</span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">    objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">    <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">      <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">      <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">      <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">      <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">      <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">      originalLayoutSubviews(view, selector)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">          onLoop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">    class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">    <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类</span></span><br><span class="line">    <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换</span></span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为视图创建模拟布局循环，并为其设置计数器来进行测试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">    <span class="type">LayoutLoopHunter</span>.setUp(<span class="keyword">for</span>: view) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Hello, world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line">    view.setNeedsLayout() <span class="comment">// loop creation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是忘记了什么事情？让我们再次回顾一下 UIViewLayoutFeedbackLoopDebuggingThreshold 断点的工作原理：</p><blockquote><p>在确认为反馈循环之前，定义某个视图的子视图在单个 run loop 里必须布局的次数</p></blockquote><p>我们从未把“单个 run loop ”这一条件考虑进来。如果视图在屏幕上停留了相当长的时间，并经常被反复布局，计数器迟早会超过临界值。但这可不是因为内存的问题。</p><p>我们该怎么解决这个问题呢？只需在每次 run loop 迭代时重置计数器。为了做到这一点，我们可以创建一个 <a href="https://www.appcoda.com/grand-central-dispatch/" target="_blank" rel="noopener">DispatchWorkItem</a>，它重置计数器，并在主队列上异步传递它。通过这种方式，它会在 run loop 下一次进入主线程时被调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">  previousResetWorkItem.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> currentResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async(execute: currentResetWorkItem)</span><br><span class="line">objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, currentResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>最终的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Associated objects keys</span></span><br><span class="line">    <span class="comment">// 关联对象键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">      objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">      <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">        <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">        <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">        <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">        <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">        originalLayoutSubviews(view, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">            onLoop()</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 为重置计数器，在每个新的 run loop 遍历中分发 work item</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">          previousResetWorkItem.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> counterResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">          objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async(execute: counterResetWorkItem)</span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, counterResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">      class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>是的！现在你可以为所有可疑的视图设置分析事件了，发布应用程序，并找到这个问题的确切出处。你可以把这个问题的范围缩小到某个特定的视图，并在用户不知情的情况下借助于他们来解决这个问题。</p><p>最后要提到的一件事是：能力越大责任越大。运行时编程非常容易出错，因此很容易在不知情的情况下为应用程序引入另一个严重的问题。这就是为什么总是建议将应用程序中的所有危险代码包装在某种可停止开关中，因为你可以在发现代码导致问题时从后端触发开关禁用该功能。这有一篇介绍 Firebase 的 Feature Flags 的 <a href="https://medium.com/@rwbutler/feature-flags-a-b-testing-mvt-on-ios-718339ac7aa1" target="_blank" rel="noopener">(好文章</a></p><p>完整代码可以从这个 <a href="https://github.com/rsrbk/LayoutLoopHunter" target="_blank" rel="noopener">GitHub 仓库</a> 里获取，并且也将会发布到 CocoPods 上，以跟踪项目中的布局循环。</p><blockquote><p><a href="https://swift.gg/2019/11/11/layout-feedback-loop/" target="_blank" rel="noopener">大量引用</a><br>原文读起来费劲，只是想让自己读的容易写的这篇文章</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlamoFire 分析</title>
      <link href="/2019/08/23/source-code/AlamoFire-%E5%88%86%E6%9E%90/"/>
      <url>/2019/08/23/source-code/AlamoFire-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>分析源码：</p><ol><li>这个第三方库，他设计的目标是什么？</li><li>需要哪些基础知识</li><li>整体结构是什么样的</li><li>由外而内逐层分析层次结构</li><li>每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点</li><li>为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？</li></ol><p>为什么要分析 AlamoFire</p><ul><li>分析它的接口设计</li><li>分析他是如何封装 URL Loading System 的</li><li>分析网络层次思考数据传输过程</li></ul><p>AlamoFire 都做了什么？</p><ul><li>Chainable Request / Response Methods</li><li>URL / JSON Parameter Encoding</li><li>Upload File / Data / Stream / MultipartFormData</li><li>Download File using Request or Resume Data</li><li>Authentication with URLCredential</li><li>HTTP Response Validation</li><li>Upload and Download Progress Closures with Progress</li><li>cURL Command Output</li><li>Dynamically Adapt and Retry Requests</li><li>TLS Certificate and Public Key Pinning</li><li>Network Reachability</li></ul><h2 id="foundation-中提供的网络相关接口"><a class="markdownIt-Anchor" href="#foundation-中提供的网络相关接口"></a> Foundation 中提供的网络相关接口</h2><p><code>AlamoFire</code> 是一个网络请求库，底层封装的事 Apple 提供的 <code>URL Loading System</code></p><h3 id="后台-session下载流程注意事项"><a class="markdownIt-Anchor" href="#后台-session下载流程注意事项"></a> 后台 session下载流程&amp;注意事项</h3><p>后台 sessionConfiguration 下载文件保存 到本地沙盒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启后台 请求 task</span></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> session = <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.downloadTask(with: <span class="type">URL</span>(string: urlDownloadStr)!).resume()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">URLSessionDownloadDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">// 下载完成后代理回调方法，将文件移动到沙盒指定位置</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载完成 - \(location)"</span>)</span><br><span class="line">    <span class="keyword">let</span> locationPath = location.path</span><br><span class="line">    <span class="keyword">let</span> documnets = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/xxxx"</span> + <span class="string">".zip"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"移动地址:\(documnets)"</span>)</span><br><span class="line">    <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">try</span>! fileManager.moveItem(atPath: locationPath, toPath: documnets)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// http 分段传输，会不断调用这个方法直到，全部下载完成</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台请求，需要申请后台权限，这样 app 进入 background 的时候才可以继续下载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存后台下载的completionHandler</span></span><br><span class="line"><span class="keyword">var</span> backgroundSessionCompletionHandler: (() -&gt; <span class="type">Void</span>)? </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"background: \(identifier)"</span>)</span><br><span class="line">  <span class="keyword">self</span>.backgroundSessionCompletionHandler = completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-alamofire"><a class="markdownIt-Anchor" href="#使用-alamofire"></a> 使用 AlamoFire</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(urlString)</span><br><span class="line">  .responseJSON &#123; (data) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面对比[原生的方法(#code1), 思考 <code>AlamoFire</code> 都封装了什么，如何实现链式调用的，内部如何使用 oop，pop 的, 思考 <code>AlamoFire</code> 接口设计</p><p>下面这些都是怎么实现的？</p><ul><li>链式语法</li><li>直接传 string</li><li>封装调用 session，resume</li><li>Response 回调的返回的是 json 数据</li><li><code>Alamofire</code> 模块导入调用</li></ul><p>调用的第一层：<br>Alamofire.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Alamofire Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">  method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  headers: HTTPHeaders? = <span class="literal">nil</span>)</span></span></span><br><span class="line">  -&gt; <span class="type">DataRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>.<span class="keyword">default</span>.request(</span><br><span class="line">    url,</span><br><span class="line">    method: method,</span><br><span class="line">    parameters: parameters,</span><br><span class="line">    encoding: encoding,</span><br><span class="line">    headers: headers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionManager.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SessionManager</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A default instance of `SessionManager`, used by top-level Alamofire request methods, and suitable for use</span></span><br><span class="line"><span class="comment">/// directly for any ad hoc requests.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `<span class="keyword">default</span>`: <span class="type">SessionManager</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.httpAdditionalHeaders = <span class="type">SessionManager</span>.defaultHTTPHeaders </span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>(configuration: configuration)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">  configuration: <span class="type">URLSessionConfiguration</span> = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span> = <span class="type">SessionDelegate</span>(),</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = <span class="type">URLSession</span>(configuration: configuration, delegate: delegate, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>?(</span><br><span class="line">  session: <span class="type">URLSession</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span>,</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> delegate === session.delegate <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = session</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SessionDelegate()</code> 代理移交 <code>SessionDelegate</code> 是个 class, 处理 <code>URLSession</code> 的事件回调代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionTaskDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionStreamDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>为什么 Manager 不处理 <code>URLSession</code> 的代理回调方法，要搞一个 <code>SessionDelegate</code> 处理，因为 Manager 是一个中介者，用于管理各个 class 之间的联系，处理回调的那些方法应该归属于 xxxClass 来处理</p><p><img src="/img/AlamoFire-Manager.jpg" alt="AlamoFire 基本核心框架"></p><p>使用 Manager 主要作用是把代码模块之间的 频繁调用关系化简。划分业务层，管理层<br>Manager 统一管理调度<br>各个模块处理完成后，回调给 Manager</p><h3 id="处理后台下载"><a class="markdownIt-Anchor" href="#处理后台下载"></a> 处理后台下载</h3><h2 id="request"><a class="markdownIt-Anchor" href="#request"></a> request</h2><h3 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h3><p><img src="/img/requst_encode.jpeg" alt="提供的3种编码方式"></p><ul><li>url</li><li>json</li><li>propertyList</li></ul><p>url 是ASCII码编码的，他不是 Unicode，ASCII 码中的外文无法识别，所以要百分号编码——将 ACSII -&gt; Unicode 这样可以被识别</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> urlRequest: URLRequestConvertible, with parameters: Parameters?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> urlRequest = <span class="keyword">try</span> urlRequest.asURLRequest()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> parameters = parameters <span class="keyword">else</span> &#123; <span class="keyword">return</span> urlRequest &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// header</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> method = <span class="type">HTTPMethod</span>(rawValue: urlRequest.httpMethod ?? <span class="string">"GET"</span>), encodesParametersInURL(with: method) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = urlRequest.url <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">AFError</span>.parameterEncodingFailed(reason: .missingURL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">var</span> urlComponents = <span class="type">URLComponents</span>(url: url, resolvingAgainstBaseURL: <span class="literal">false</span>), !parameters.isEmpty &#123;</span><br><span class="line">      <span class="keyword">let</span> percentEncodedQuery = (urlComponents.percentEncodedQuery.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"&amp;"</span> &#125; ?? <span class="string">""</span>) + query(parameters)</span><br><span class="line">      urlComponents.percentEncodedQuery = percentEncodedQuery</span><br><span class="line">      urlRequest.url = urlComponents.url</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> urlRequest.value(forHTTPHeaderField: <span class="string">"Content-Type"</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">      urlRequest.setValue(<span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// body</span></span><br><span class="line">    urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> urlRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p.s. 传输组的时候一定要传 json 字符串！</p><p><a href="https://github.com/Alamofire/Alamofire/issues/1920" target="_blank" rel="noopener">iOS 10: Background Session won’t inform when downloads have failed #1920</a></p><blockquote><p><a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">URL Loading System</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL Loading System</title>
      <link href="/2019/08/19/%E7%BD%91%E7%BB%9C/URL-Loading-System/"/>
      <url>/2019/08/19/%E7%BD%91%E7%BB%9C/URL-Loading-System/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>在 Foundation 框架中</li><li>支持协议：<ul><li>FTP协议（ftp://）</li><li>超文本传输协议（http://）</li><li>加密超文本传输协议(https://)</li><li>本地资源(file://)</li><li>数据URLs(data://)</li></ul></li><li>关键类：URLSession，URL，URLRequest，Tasks，Data</li><li>支持：Authorization credentials，cache 和cookies， 配置管理</li><li>使用 closure 和 delegate 处理 Response</li></ul><p><img src="/img/url_loading_system.jpg" alt="url_loading_system 核心类 分 6 个部分"></p><h2 id="核心-urlsession-urlsessiontask"><a class="markdownIt-Anchor" href="#核心-urlsession-urlsessiontask"></a> 核心 URLSession &amp; URLSessionTask</h2><p>一个 session 请求网络数据需要的核心内容</p><p><img src="/img/urlsession.jpg" alt="urlsession"></p><h3 id="session-configuration"><a class="markdownIt-Anchor" href="#session-configuration"></a> Session Configuration</h3><p>每个配置属性都值得研究<br><img src="/img/urlsession_configuration.jpg" alt="configuration"><br><a href="https://juejin.im/post/5d5f5bcbe51d4561c02a2547" target="_blank" rel="noopener">这篇文章有各个参数翻译</a></p><p>总共有三种 configuration</p><ul><li><code>Default</code>: 使用本地沙盒缓存，用户credential保存在 keychain 中</li><li><code>Ephemeral</code>: 不使用沙盒，所有缓存credential 等数据存在 与 session 绑定的 RAM 中，session 失效后内存自动清理</li><li><code>Background</code>: 跟 default session 相似，但是使用的是另外一个 进程(process) 处理数据传输，因为是跨进程，所以 background session 有些限制操作。（嗯后台session 使用了进程间通信）</li></ul><p>为什么要有 configuration？<br>session 相当一个 manager，用来管理组织 task，网络事件处理的枢纽，configuration是这个枢纽的参数信息！相当于 一个 app 他都有 自己 preference</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration1 = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span><span class="comment">// 允许用户拥有沙盒缓存器，当session 释放的时候，数据依然存在</span></span><br><span class="line"><span class="keyword">let</span> configuration2 = <span class="type">URLSessionConfiguration</span>.ephemeral<span class="comment">// session 无效时，东西就会消失</span></span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration).dataTask(with: <span class="type">URL</span>(string: urlDownloadStr)!)</span><br><span class="line">  .resume()<span class="comment">// 后台 sessionConfiguration 不能设置 completeHandler，需要自己设置代理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"background-内存大小：\(String(describing: configuration.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"background-沙盒大小：\(String(describing: configuration.urlCache.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-内存大小：\(String(describing: configuration1.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-沙盒大小：\(String(describing: configuration1.urlCache.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-内存大小：\(String(describing: configuration2.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-沙盒大小：\(String(describing: configuration2.urlCache.diskCapacity))"</span>)</span><br></pre></td></tr></table></figure><p>打印结果：<br>background-内存大小：nil<br>background-沙盒大小：nil<br>default-内存大小：512000<br>default-沙盒大小：10000000<br>ephemeral-内存大小：512000<br>ephemeral-沙盒大小：0</p><p>就像文档说的，当session 失效以后 ephemeral 的 cache 会消失，因为他没有沙盒空间</p><h3 id="session-网络请求"><a class="markdownIt-Anchor" href="#session-网络请求"></a> session 网络请求</h3><p><img src="/img/urlsession_flow.jpg" alt="urlsession request flow"></p><p>我们要做的</p><ol><li>配置需要的 session configuration，</li><li>配置 session<ol><li>系统提供的 shared 单例，系统自己配置 configuration，sessionDelegate，delegateQueue</li><li>自定义 session，自己设置 configuration，sessionDelegate，delegateQueue(是 serial queue)</li></ol></li><li>提供 request &amp; url 给 session</li><li>生成 task<ol><li>URLSessionTask<ul><li>URLSessionDataTask</li><li>URLSessionUploadTask</li><li>URLSessionDownloadTask</li><li>URLSessionStreamTask</li><li>URLSessionWebSocketTask（iOS 13.0）</li></ul></li></ol></li><li>配置SessionDelegate, SessionTaskDelegate 对网络事件处理 (URLSessionTaskDelegate: URLSessionDelegate<ul><li>URLSessionDataDelegate</li><li>URLSessionDownloadDelegate</li><li>URLSessionStreamDelegate</li><li>URLSessionWebSocketDelegate（iOS 13.0）</li></ul></li></ol><p>SessionDelegate 只有3个接口</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, didBecomeInvalidWithError error: Error?)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping <span class="params">(URLSession.AuthChallengeDisposition, URLCredential?)</span></span></span> -&gt; <span class="type">Void</span>) </span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSessionDidFinishEvents</span><span class="params">(forBackgroundURLSession session: URLSession)</span></span></span><br></pre></td></tr></table></figure><p>至于各个 taskDelegate，对应不同的task 类型有个字不同协议接口<br>这里主要看 SessionTaskDelegate</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">URLSessionTaskDelegate</span> : <span class="title">URLSessionDelegate</span> </span>&#123; </span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest, completionHandler: @escaping <span class="params">(URLSession.DelayedRequestDisposition, URLRequest?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping <span class="params">(URLRequest?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping <span class="params">(URLSession.AuthChallengeDisposition, URLCredential?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping <span class="params">(InputStream?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的是 dataTask，downloadTask，uploadTask</p><h2 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h2><h3 id="从网站获取数据到内存"><a class="markdownIt-Anchor" href="#从网站获取数据到内存"></a> 从网站获取数据到内存</h3><h4 id="使用回调处理接受结果使用closure-回调得到-data"><a class="markdownIt-Anchor" href="#使用回调处理接受结果使用closure-回调得到-data"></a> 使用回调处理接受结果：使用closure 回调得到 data</h4><p><img src="https://docs-assets.developer.apple.com/published/c7124fb5d7/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task 的状态</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSessionTask</span> </span>&#123; </span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> running </span><br><span class="line">    <span class="keyword">case</span> suspended <span class="comment">// 初试状态</span></span><br><span class="line">    <span class="keyword">case</span> canceling </span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/"</span>)!</span><br><span class="line">  <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">      <span class="keyword">self</span>.handleClientError(error)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>,</span><br><span class="line">      (<span class="number">200</span>...<span class="number">299</span>).<span class="built_in">contains</span>(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.handleServerError(response)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mimeType = httpResponse.mimeType, mimeType == <span class="string">"text/html"</span>,</span><br><span class="line">      <span class="keyword">let</span> data = data,</span><br><span class="line">      <span class="keyword">let</span> string = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: url)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session create 出来的 task 是 suspend 的状态</span></span><br><span class="line">  task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>session create 出来的 task 初始状态是 suspend</li><li>回调处理是在 serial queue 任务放到子线程处理的，通知 UI 变化应切换主线程</li></ol><h4 id="接受请求详情结果使用-delegate"><a class="markdownIt-Anchor" href="#接受请求详情结果使用-delegate"></a> 接受请求详情&amp;结果：使用 Delegate</h4><p><img src="https://docs-assets.developer.apple.com/published/8b22355c7f/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png" alt=""></p><p>这个时候 session 不应该使用 <code>shared</code>，而是要自己配置</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> session: <span class="type">URLSession</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.waitsForConnectivity = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: configuration,</span><br><span class="line">                    delegate: <span class="keyword">self</span>,</span><br><span class="line">                    delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receivedData: <span class="type">Data?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  loadButton.isEnabled = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/"</span>)!</span><br><span class="line">  receivedData = <span class="type">Data</span>()</span><br><span class="line">  <span class="keyword">let</span> task = session.dataTask(with: url)</span><br><span class="line">  task.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate methods</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: @escaping <span class="params">(URLSession.ResponseDisposition)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>,</span><br><span class="line">    (<span class="number">200</span>...<span class="number">299</span>).<span class="built_in">contains</span>(response.statusCode),</span><br><span class="line">    <span class="keyword">let</span> mimeType = response.mimeType,</span><br><span class="line">    mimeType == <span class="string">"text/html"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.cancel)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  completionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.receivedData?.append(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span> &#123;</span><br><span class="line">  <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">self</span>.loadButton.isEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">      handleClientError(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> receivedData = <span class="keyword">self</span>.receivedData,</span><br><span class="line">      <span class="keyword">let</span> string = <span class="type">String</span>(data: receivedData, encoding: .utf8) &#123;</span><br><span class="line">      <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理的方式，可以处理很多特殊的情况：</p><ul><li>authentication challenges</li><li>following redirects</li></ul><blockquote><p><a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">URL Loading System</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好文章</title>
      <link href="/2019/06/03/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
      <url>/2019/06/03/%E5%A5%BD%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://juejin.im/post/5bd5a546f265da0af033cee6" target="_blank" rel="noopener">深入理解 Autolayout 与列表性能 – 背锅的 Cassowary 和偷懒的 CPU</a><br><a href="https://juejin.im/post/5c22eaf1f265da611b5863b2" target="_blank" rel="noopener">深入浅出iOS编译</a><br><a href="https://zhuanlan.zhihu.com/p/57907139" target="_blank" rel="noopener">不了解GIF的加载原理？看我就够了！</a><br><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a><br><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a><br><a href="https://blog.csdn.net/zhangao0086/article/details/45622875" target="_blank" rel="noopener">如何设计一个 iOS 控件?(iOS 控件完全解析)</a><br><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">RxSwift + MVVM: how to feed ViewModels</a><br><a href="https://swift.gg/2019/11/11/layout-feedback-loop/" target="_blank" rel="noopener">调试内存不足问题：使用运行时魔法捕获布局反馈循环</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> favorite </category>
          
      </categories>
      
      
        <tags>
            
            <tag> readings </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读代码 Me</title>
      <link href="/2019/05/17/source-code/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/"/>
      <url>/2019/05/17/source-code/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="为什么看"><a class="markdownIt-Anchor" href="#为什么看"></a> 为什么看</h2><p>抽空晚上睡不着看 <a href="https://github.com/vsouza/awesome-ios#gcd" target="_blank" rel="noopener">awesome-ios</a> 提供的优秀代码库<br>[Me](<a href="https://github.com/pascalbros/Me" target="_blank" rel="noopener">https://github.com/pascalbros/Me</a> 源码</p><h2 id="他是做什么的"><a class="markdownIt-Anchor" href="#他是做什么的"></a> 他是做什么的</h2><p>Me 是解决嵌套异步问题的一个轻量级库——就一个文件</p><h2 id="使用他以后的效果"><a class="markdownIt-Anchor" href="#使用他以后的效果"></a> 使用他以后的效果</h2><p>before</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyAPI</span>.login &#123;</span><br><span class="line">  <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">    <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">    <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">      <span class="comment">//We are done here</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Me</span>.start &#123; (me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.login &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">   <span class="comment">//We are done here</span></span><br><span class="line">   me.end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.run()</span><br></pre></td></tr></table></figure><p>看效果：</p><ol><li>Me 把异步嵌套代码–&gt; 链式代码（想想他是怎么做的？）</li><li>Me 是链条型的，start，next，next(name:)，jump(toName:)，end<ol><li>他是如何做异步通知的？</li><li>如何开始，如何结束？</li><li>支持实现多链条并发执行吗？</li></ol></li><li>从提供的接口上可以看出<ol><li>Me开启结束要由用户控制</li><li>节点驱动需要用户触发</li><li>支持指定节点跳转</li></ol></li></ol><p>ok 使用demo&amp;基本特性分析完了，接下来看源码</p><hr><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><h3 id="先看接口"><a class="markdownIt-Anchor" href="#先看接口"></a> 先看接口</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeInitClosure</span> = ((<span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeClosure</span> = ((<span class="number">_</span> previous: <span class="type">Me?</span>, <span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Me</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> index: <span class="type">UInt</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> parameters: [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式节点函数，static 是起点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(name: String = <span class="string">""</span>, this: @escaping MeInitClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(this: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">(name: String = <span class="string">""</span>, next: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNextOnMain</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toName jump: String)</span></span></span><br></pre></td></tr></table></figure><ol><li>提供 Me 节点 index，name，代码库内部维护</li><li>只提供其实节点 first</li><li>提供线程队列调度接口</li><li>parameters 是干什么的？像是 [name: MeClouse] 字典，每个 me 节点都有一个clouse</li></ol><h3 id="看代码实现"><a class="markdownIt-Anchor" href="#看代码实现"></a> 看代码实现</h3><ol><li>核心代码，这个地方封装了 GCD</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> next = <span class="keyword">self</span>.next &#123;</span><br><span class="line">    <span class="comment">//self.nextObj!.parameters = self.parameters //enable to pass parameters to the next object</span></span><br><span class="line">    queue.async &#123;</span><br><span class="line">      next(<span class="keyword">self</span>, <span class="keyword">self</span>.nextObj!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> to = me(at: jump) &#123;</span><br><span class="line">    to.this(<span class="keyword">self</span>, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个问题是：<code>jump</code> 的queue 没有用……（这个库的使用价值不大）只有 <code>runNext</code> 相关方法可以调度线程<br>parameters: 是 me 节点保存数据，用于用户自己传递数据使用</p><ol start="2"><li>内部数据结构使用的是链表</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> nextObj: <span class="type">Me?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _first: <span class="type">Me?</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 读源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift + MVVM:如何提供ViewModels</title>
      <link href="/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/"/>
      <url>/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">原文：RxSwift + MVVM: how to feed ViewModels</a></p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>自从我们开始在BlaBlaCar的Model-View-ViewModel（MVVM）架构中使用RxSwift以来，已经快一年了。我们对结果感到兴奋。我们使用这种方法编写的代码更容易理解，维护，测试和扩展。但是，最初的几周并不是小菜一碟。我们必须在MVVM + RxSwift架构的某些方面进行迭代，以使事情变得正确。其中一个方式——给 ViewModels 提供 Inputs。</p><p>让我们通过两种不同方式给ViewModels 提供 Inputs（Rx Event）</p><p>但是首先，让我们简单谈一下 ViewModels</p><h2 id="viewmodels"><a class="markdownIt-Anchor" href="#viewmodels"></a> ViewModels</h2><p>ViewModel的职责，你必须正确理解它（不止一个）：</p><ul><li>它应该是可以插入到任何View上的。比如，不是先造一个View再去定义一个ViewModel。注意，是View拥有ViewModel。View知道ViewModel，而不是反过来。</li><li>它是可测试的。最终，MVVM架构最大的好处就是让业务逻辑可测。</li><li>MVVM使用绑定机制更加牛逼，所以让使用 RxSwift 来更好地利用 ViewModel</li></ul><p>to be continued…</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 响应链</title>
      <link href="/2019/02/11/UI%20%E7%9B%B8%E5%85%B3/iOS-%E5%93%8D%E5%BA%94%E9%93%BE/"/>
      <url>/2019/02/11/UI%20%E7%9B%B8%E5%85%B3/iOS-%E5%93%8D%E5%BA%94%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>响应链就是 UIRespondser 对象的组成链</p><h2 id="什么可以作为响应对象"><a class="markdownIt-Anchor" href="#什么可以作为响应对象"></a> 什么可以作为响应对象</h2><ol><li>响应者链通常是由视图（UIView）构成的</li><li>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）</li><li>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图</li><li>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者</li><li>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环</li></ol><p>当事件触发，UIKit 会把事件分发给响应链来处理 event</p><h2 id="事件分发"><a class="markdownIt-Anchor" href="#事件分发"></a> 事件分发</h2><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。<br>整个响应者链和事件分发的使命都是找出第一响应者。</p><p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p><p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p><p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。<br>hitTest:withEvent:方法的处理流程如下:</p><p>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;</p><p>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</p><p>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪球速读法--迭代树--整体&amp;细节</title>
      <link href="/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/"/>
      <url>/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="雪球速读法浅析"><a class="markdownIt-Anchor" href="#雪球速读法浅析"></a> 雪球速读法–浅析</h2><p>《雪球速读法》中说：</p><blockquote><p>速读的方式是：<br>速度技巧 * 资料库(大小) = 速读</p><ul><li>反复读 n 变</li><li>每次快速阅读，要求1.不求甚解，2.脑子里不要有读的声音</li></ul><p>具体：</p><ul><li>先话读目录，前言，后记 用 15~30，思考书的整体结构，作者写作意图</li><li>从框架的外层一层层向知识细节挖，每次处理一层，理解一层，构建自己对这本书的资料库（滚雪球的过程）</li></ul></blockquote><p>这样做的好处是：</p><ol><li>强调先掌握知识的框架！从整体的角度一层层学习知识。</li><li>有了框架就知道森林大概的样子！</li><li>如果单纯的按照目录一点点学习书本上的知识，会陷在局部细节中出不来浪费大量时间，读书时间过长，前面的知识会忘，后面不一定会认真读完，最后整本书都很难理解。</li><li>作者是以什么样的方式写书的呢？类似于《雪球速读法》先有中心思想，目录，段落，然后落实到细节，《雪球速读法》就是按照作者的写作的方式理解知识的过程。</li><li>速读不发出声音，更有利于读者跟作者产生共鸣！这个也是读书的一个目的</li></ol><h2 id="目标-vs-任务"><a class="markdownIt-Anchor" href="#目标-vs-任务"></a> 目标 vs 任务</h2><p>目标：一个你想要看见的好结果<br>任务：为实现目标你要做的事</p><p>在缺少动力的时候多思考目标带来那些美好的愿景，用 Deadline 给自己施加压力，对比人的承诺。</p><p>在执行的时候多看细节，任务，因为总是关注目标，会无从下手，很多细节上的困难乐观对待！导致目标最终搁浅。</p><h2 id="树状结构知识"><a class="markdownIt-Anchor" href="#树状结构知识"></a> 树状结构知识</h2><p>有关树状结构，知识迭代过程都是一层层包裹的知识，有历史气息的知识都是树状结构<br>这样的知识可以像《雪球速读法》一样层层学习</p><h2 id="计算机知识"><a class="markdownIt-Anchor" href="#计算机知识"></a> 计算机知识</h2><p>计算机知识就是一个大大的树，找到一个大树枝，然后一层层分解这个知识点<br><img src="/img/knowledge_tree.jpg" alt="-"></p><p>程序开发的时候也是，现有结构，然后再是细节！</p><p>有时间补充</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 渲染过程性能优化</title>
      <link href="/2019/02/05/UI%20%E7%9B%B8%E5%85%B3/iOS-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/2019/02/05/UI%20%E7%9B%B8%E5%85%B3/iOS-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>此文整理<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p><h2 id="屏幕显示原理"><a class="markdownIt-Anchor" href="#屏幕显示原理"></a> 屏幕显示原理</h2><h3 id="crt-显示器原理"><a class="markdownIt-Anchor" href="#crt-显示器原理"></a> CRT 显示器原理</h3><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png" alt="CRT 显示器原理"></p><ul><li>一帧画面：CRT 的电子枪从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。</li><li>为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。<ul><li>HSync: 当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization）</li><li>VSync: 而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization）。</li></ul></li><li>显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变</li></ul><h3 id="cpu-gpu-将数据交给显示器"><a class="markdownIt-Anchor" href="#cpu-gpu-将数据交给显示器"></a> CPU, GPU 将数据交给显示器</h3><p><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png" target="_blank" rel="noopener">CPU, GPU 将数据交给显示器</a></p><ol><li>CPU 计算好显示内容提交到 GPU</li><li>GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</li></ol><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。<br>在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg" alt="资源竞争冲突"></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h2 id="卡顿产生的原因和解决方案"><a class="markdownIt-Anchor" href="#卡顿产生的原因和解决方案"></a> 卡顿产生的原因和解决方案</h2><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png" alt="卡顿产生的原因和解决方案"></p><ol><li>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App</li><li>App <code>主线程</code> 开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。</li><li>随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，</li><li>等待下一次 VSync 信号到来时显示到屏幕上。</li></ol><h3 id="卡顿原因"><a class="markdownIt-Anchor" href="#卡顿原因"></a> 卡顿原因</h3><ul><li>如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，</li><li>则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。</li></ul><p>这就是界面卡顿的原因。</p><p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><h3 id="cpu-资源消耗原因和解决方案"><a class="markdownIt-Anchor" href="#cpu-资源消耗原因和解决方案"></a> CPU 资源消耗原因和解决方案</h3><h4 id="对象创建"><a class="markdownIt-Anchor" href="#对象创建"></a> 对象创建</h4><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。<br>尽量用轻量的对象代替重量的对象，可以对性能有所优化。</p><p>eg:</p><ul><li>CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。</li><li>如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。</li><li>通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</li><li>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。</li><li>如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</li></ul><h4 id="对象调整"><a class="markdownIt-Anchor" href="#对象调整"></a> 对象调整</h4><p>对象的调整也经常是消耗 CPU 资源的地方。</p><ul><li>这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。</li><li>UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</li></ul><p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><h4 id="对象销毁"><a class="markdownIt-Anchor" href="#对象销毁"></a> 对象销毁</h4><p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。</p><ul><li>如果对象可以放到后台线程去释放，那就挪到后台线程去。</li><li>这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><details><summary>在异步线程中让引用计数变为 0，达到异步回收，swift版本，</summary><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncReleaseObjc</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"AsyncReleaseObjc:"</span> + #function + <span class="string">"\(Thread.current)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncReleaseObjcViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mainReleaseData: <span class="type">AsyncReleaseObjc?</span></span><br><span class="line">  <span class="keyword">var</span> threadReleaseData: <span class="type">AsyncReleaseObjc?</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    view.backgroundColor = .white</span><br><span class="line">    mainReleaseData = <span class="type">AsyncReleaseObjc</span>()</span><br><span class="line">    threadReleaseData = <span class="type">AsyncReleaseObjc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">    mainReleaseData = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tmp = threadReleaseData</span><br><span class="line">    threadReleaseData = <span class="literal">nil</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;<span class="comment">// 捕获 threadReleaseData，当async 结束时，释放</span></span><br><span class="line">      tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"AsyncReleaseObjcController:"</span> + #function)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="布局计算"><a class="markdownIt-Anchor" href="#布局计算"></a> 布局计算</h4><p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。</p><ul><li>如果能在后台线程提前计算好视图布局</li><li>并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</li></ul><p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。<br>上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p><p>Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。(iOS12 性能改善，几乎跟 frame 差不多)</p><p>具体数据可以看这个文章：<a href="http://pilky.me/36/%E3%80%82" target="_blank" rel="noopener">http://pilky.me/36/。</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p><h4 id="文本计算"><a class="markdownIt-Anchor" href="#文本计算"></a> 文本计算</h4><p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。<br>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：</p><ul><li>用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，</li><li>用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。</li></ul><p>尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p><h4 id="文本渲染"><a class="markdownIt-Anchor" href="#文本渲染"></a> 文本渲染</h4><p>屏幕上能看到的所有文本内容控件在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。</p><ul><li>UIWebView，UILabel、UITextView 等</li><li>其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。</li><li>对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。</li><li>尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）</li><li>CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</li></ul><h4 id="图片的解码"><a class="markdownIt-Anchor" href="#图片的解码"></a> 图片的解码</h4><ol><li>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。</li><li>图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。</li><li>这一步是发生在主线程的，并且不可避免。</li><li>如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</li></ol><h4 id="图像的绘制"><a class="markdownIt-Anchor" href="#图像的绘制"></a> 图像的绘制</h4><p>图像的绘制通常是指用那些以 CG(CoreGraphic) 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。<br>这个最常见的地方就是 [UIView drawRect:] 里面了。<br>由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gpu-资源消耗原因和解决方案"><a class="markdownIt-Anchor" href="#gpu-资源消耗原因和解决方案"></a> GPU 资源消耗原因和解决方案</h3><p>相对于 CPU 来说，GPU 能干的事情比较单一：</p><ul><li>接收提交的纹理（Texture）和顶点描述（三角形）</li><li>应用变换（transform）、混合并渲染，然后输出到屏幕上。</li><li>通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</li></ul><h4 id="纹理的渲染"><a class="markdownIt-Anchor" href="#纹理的渲染"></a> 纹理的渲染</h4><ul><li>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。</li><li>不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。</li><li>当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。</li><li>避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</li></ul><p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：<a href="http://iosres.com" target="_blank" rel="noopener">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p><h4 id="视图的混合-composing"><a class="markdownIt-Anchor" href="#视图的混合-composing"></a> 视图的混合 (Composing)</h4><p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。</p><p>为了减轻这种情况的 GPU 消耗</p><ul><li>应用应当尽量减少视图数量和层次</li><li>并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。</li><li>当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</li></ul><h4 id="图形的生成"><a class="markdownIt-Anchor" href="#图形的生成"></a> 图形的生成</h4><p>离屏渲染通常发生在 GPU 中:</p><ol><li>CALayer 的 border、圆角、阴影、遮罩（mask）</li><li>CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering）。</li><li>当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。</li><li>这时界面仍然能正常滑动，但平均帧数会降到很低。</li><li>为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。</li><li>最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> 系统原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 5.RxDataSources</title>
      <link href="/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/"/>
      <url>/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/RxSwiftCommunity/RxDataSources/issues?q=is%3Aissue+is%3Aclosed" target="_blank" rel="noopener">原文: RxDataSources</a></p><h2 id="table-和-collection-view-data-sources"><a class="markdownIt-Anchor" href="#table-和-collection-view-data-sources"></a> Table 和 Collection View data sources</h2><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li>[x] O(N)计算差异的算法<ul><li>该算法假设所有 sections 和 items 都是唯一的，因此没有二义性</li><li>如果有歧义，在非动画刷新时自动回退</li></ul></li><li>[x] 他使用其他启发式方法以将最少数量的命令发送到分段视图<ul><li>即使运行时间是线性的，发送命令的首选数量通常也比线性少</li><li>最好（并且有可能）将更改数量限制为较小的数量，并且如果更改数量朝线性方向增长，则只需进行正常的reload即可</li></ul></li><li>[x] 支持扩展你的 item 和 section 结构<ul><li>只需使用 <code>IdentifiableType</code> 和 <code>Equatable</code> 扩展你的 item，并使用 <code>AnimatableSectionModelType</code> 扩展 section</li></ul></li><li>[x] 支持 section 和 item 的两级分层动画的所有组合<ul><li>Section 动画: Insert, Delete, Mov</li><li>Item 动画: Insert, Delete, Move, Reload (如果旧值不等于新值)</li></ul></li><li>[x] 可配置动画类型对于 Insert, Reload and Delete (Automatic, Fade, …)</li><li>[x] 示例 app</li><li>[x] 随机压力测试（eg app）</li><li>[x] 支持开箱即用的编辑（eg app）</li><li>[x] 同 UITableView 和 UICollectionView 一起工作</li></ul><h2 id="为什么"><a class="markdownIt-Anchor" href="#为什么"></a> 为什么</h2><p>编写 table 和 collection View 数据源很繁琐。对于最简单的情况，需要实现大量的委托方法。</p><p>RxSwift 通过简单的数据绑定机制有助于减轻一些负担：</p><ol><li>把你的数据转化成可见听序列 Observable</li><li>使用下面方法把数据绑定到 tableView/collectionView 上<ul><li>rx.items(dataSource:protocol&lt;RxTableViewDataSourceType, UITableViewDataSource&gt;)</li><li>rx.items(cellIdentifier:String)</li><li>rx.items(cellIdentifier:String:Cell.Type:_: )</li><li>rx.items(<em>:</em>: )</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">Observable</span>&lt;[<span class="type">String</span>]&gt;.just([<span class="string">"first element"</span>, <span class="string">"second element"</span>, <span class="string">"third element"</span>])</span><br><span class="line"></span><br><span class="line">data.bind(to: tableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; index, model, cell <span class="keyword">in</span></span><br><span class="line">  cell.textLabel?.text = model</span><br><span class="line">&#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这适用于简单数据集，但不适用于需要将复杂数据集与多个section 绑定或在添加/修改/删除item 时需要执行动画的情况。</p><p>这些正是RxDataSources帮助解决的用例。</p><p>使用RxDataSources，写起来非常容易</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">SectionModel</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;&gt;(configureCell: configureCell)</span><br><span class="line"><span class="type">Observable</span>.just([<span class="type">SectionModel</span>(model: <span class="string">"title"</span>, items: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])])</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/rxdatasources/RxDataSources.gif" alt="-"></p><h2 id="怎么用"><a class="markdownIt-Anchor" href="#怎么用"></a> 怎么用</h2><p>给定以下自定义数据结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anInt: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> aString: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> aCGPoint: <span class="type">CGPoint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先使用遵循 SectionModelType 协议的结构定义你的section：<ul><li>定义 item 类型别名：等于该 section 将包含的 item 类型</li><li>声明一个 items 属性：Item 类型数组</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOfCustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> header: <span class="type">String</span>    </span><br><span class="line">  <span class="keyword">var</span> items: [<span class="type">Item</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SectionOfCustomData</span>: <span class="title">SectionModelType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Item</span> = <span class="type">CustomData</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(original: <span class="type">SectionOfCustomData</span>, items: [<span class="type">Item</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span> = original</span><br><span class="line">    <span class="keyword">self</span>.items = items</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个dataSource对象，并将其传递给 SectionOfCustomData 类型：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedAnimatedDataSource</span>&lt;<span class="type">MySection</span>&gt;(</span><br><span class="line">    configureCell: &#123; ds, tv, <span class="number">_</span>, item <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> cell = tv.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>) ?? <span class="type">UITableViewCell</span>(style: .<span class="keyword">default</span>, reuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"Item \(item)"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;,</span><br><span class="line">    titleForHeaderInSection: &#123; ds, index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> ds.sectionModels[index].header</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>根据需要在dataSource上自定义闭包：<ul><li>titleForHeaderInSection</li><li>titleForFooterInSection</li><li>etc</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataSource.titleForHeaderInSection = &#123; dataSource, index <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.titleForFooterInSection = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].footer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canEditRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canMoveRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将实际数据定义为 CustomData 对象的 Observable序列，并将其绑定到tableView</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sections = [</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"First section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">0</span>, aString: <span class="string">"zero"</span>, aCGPoint: <span class="type">CGPoint</span>.zero), <span class="type">CustomData</span>(anInt: <span class="number">1</span>, aString: <span class="string">"one"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)) ]),</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"Second section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">2</span>, aString: <span class="string">"two"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)), <span class="type">CustomData</span>(anInt: <span class="number">3</span>, aString: <span class="string">"three"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">3</span>, y: <span class="number">3</span>)) ])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.just(sections)</span><br><span class="line">  .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="数据源动画"><a class="markdownIt-Anchor" href="#数据源动画"></a> 数据源动画</h2><p>RxDataSources 提供了两种特殊的数据源类型，它们可以自动处理绑定数据源中的动画变化：<code>RxTableViewSectionedAnimatedDataSource</code> 和 <code>RxCollectionViewSectionedAnimatedDataSource</code> 。</p><p>要使用两个动画数据源之一，你必须在上述概述的基础上采取一些额外的步骤：</p><ul><li>SectionOfCustomData需要遵守 AnimatableSectionModelType 协议</li><li>数据模型必须符合<ul><li>IdentifiableType：IdentifiableType 协议提供的 <code>identity</code> 必须是表示模型实例的不可变标识符(identifier)。例如，对于 Car 模型，你可能要使用 Car 的plateNumber 作为其标识。</li><li>Equatable：遵从 Equatable 协议 有助于RxDataSources确定哪些 cell 已更改，因此它只能为这些特定 cell 设置动画。这意味着，更改Car模型的任何属性都会触发该 cell 的动画重新加载。</li></ul></li></ul><h2 id="需要"><a class="markdownIt-Anchor" href="#需要"></a> 需要</h2><p>Xcode 10.2</p><p>Swift 5.0</p><p>For Swift 4.x version please use versions 3.0.0 … 3.1.0 For Swift 3.x version please use versions 1.0 … 2.0.2 For Swift 2.3 version please use versions 0.1 … 0.9</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="cocoapods"><a class="markdownIt-Anchor" href="#cocoapods"></a> CocoaPods</h3><p>Podfile</p><blockquote><p>pod ‘RxDataSources’, ‘~&gt; 4.0’</p></blockquote><h3 id="carthage"><a class="markdownIt-Anchor" href="#carthage"></a> Carthage</h3><p>Cartfile</p><blockquote><p>github “RxSwiftCommunity/RxDataSources” ~&gt; 4.0</p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>load和initialize</title>
      <link href="/2019/01/12/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/load%E5%92%8Cinitialize/"/>
      <url>/2019/01/12/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/load%E5%92%8Cinitialize/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="load"><a class="markdownIt-Anchor" href="#load"></a> + load</h2><ol><li>load 是通过 c 函数调用的</li><li>load 调用在 main 函数之前，动态链接器通知调用 load_images，执行load 方法</li><li>load 加载顺序：父类-&gt; 类-&gt; 分类</li><li>load 方法中最常用的就是方法交换 method swizzling</li></ol><h3 id="load-方法的调用栈"><a class="markdownIt-Anchor" href="#load-方法的调用栈"></a> load 方法的调用栈</h3><p>在 <code>+ load</code> 方法出打断点，查看 load 调用栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  +[XXObject load]</span><br><span class="line"><span class="number">1</span>  call_class_loads()</span><br><span class="line"><span class="number">2</span>  call_load_methods</span><br><span class="line"><span class="number">3</span>  load_images</span><br><span class="line"><span class="number">4</span>  dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*)</span><br><span class="line"><span class="number">11</span> _dyld_start</span><br></pre></td></tr></table></figure><blockquote><p>dyld(dynamic link editor)，它是苹果的动态链接器。<br>在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作</p></blockquote><p>在 runtime 时调用 <code>load_images</code> 方法,那么就看下他的源码(objc4-756.2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Discover load methods</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock2(runtimeLock);</span><br><span class="line">    prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">  call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">  runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">    _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">    Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">      _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">            <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    realizeClassWithoutSwift(cls);</span><br><span class="line">    assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">    add_category_to_loadable_list(cat);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">  assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">  schedule_class_load(cls-&gt;superclass); </span><br><span class="line">  add_class_to_loadable_list(cls);</span><br><span class="line">  cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">  IMP method;</span><br><span class="line"></span><br><span class="line">  method = cls-&gt;getLoadMethod();</span><br><span class="line">  <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">    loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 分配类对象空间，加载类</span></span><br><span class="line">    loadable_classes = (struct loadable_class *)</span><br><span class="line">      <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                loadable_classes_allocated *</span><br><span class="line">                <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">  loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">  loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*  (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*  (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*    still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure "parent class first" </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">  <span class="keyword">bool</span> more_categories; </span><br><span class="line"><span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">  loading = YES; </span><br><span class="line">  <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      call_class_loads();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories); </span><br><span class="line">  objc_autoreleasePoolPop(pool); </span><br><span class="line">  loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initialize"><a class="markdownIt-Anchor" href="#initialize"></a> initialize</h2><ol><li>惰性方法，第一次初始化实例对象的时候会调用这个方法</li><li>正常情况，只会调用一次</li><li>不正常情况，调用多次，多个子类没有实现 initialize，那么会多次调用父类的 initialize</li></ol><h3 id="分析-initialize"><a class="markdownIt-Anchor" href="#分析-initialize"></a> 分析 initialize</h3><p>调用栈分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> +[XXObject initialize]</span><br><span class="line"><span class="number">1</span> _class_initialize</span><br><span class="line"><span class="number">2</span> lookUpImpOrForward</span><br><span class="line"><span class="number">3</span> _class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="number">4</span> objc_msgSend</span><br><span class="line"><span class="number">5</span> main</span><br><span class="line"><span class="number">6</span> start</span><br></pre></td></tr></table></figure><ol><li>使用 oc 消息机制发送的</li><li>父类的initialize方法会比子类先执行</li><li>当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. <code>cls.isInitialized</code> 判断该类是否被实例化过</li><li>当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个</li></ol><blockquote><p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md" target="_blank" rel="noopener">你真的了解 load 方法么？</a><br><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%87%92%E6%83%B0%E7%9A%84%20initialize%20%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">懒惰的 initialize 方法</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从GCD 到 Operation</title>
      <link href="/2018/12/25/thread/%E4%BB%8EGCD-%E5%88%B0-Operation/"/>
      <url>/2018/12/25/thread/%E4%BB%8EGCD-%E5%88%B0-Operation/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="operation-的优势"><a class="markdownIt-Anchor" href="#operation-的优势"></a> Operation 的优势</h2><p>Operation 底层是由 GCD 实现的，他的最大的优点是 复用性</p><p>向GCD 中的 queue 中放 task 的方式有两种</p><ol><li>添加 block(闭包)</li><li>添加 WorkItem(对象类型)</li></ol><p>虽然 workItem 也拥有复用性，但是用户可控性没有 Operation 好</p><details><summary>WorkItem 接口</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchWorkItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(qos: <span class="type">DispatchQoS</span> = .unspecified, flags: <span class="type">DispatchWorkItemFlags</span> = [], block: @escaping <span class="meta">@convention</span>(block) () -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(timeout: DispatchTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(wallTimeout: DispatchWallTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], queue: DispatchQueue, execute: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="comment">// 制定 workItem 的依赖关系</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(queue: DispatchQueue, execute: DispatchWorkItem)</span></span></span><br><span class="line"><span class="comment">// 取消 work，如果没有开始，那么删除这个 work</span></span><br><span class="line"><span class="comment">// 如果 work 执行中，那么isCancel 会被设置为 true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isCancelled: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 item 的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">DispatchWorkItemFlags</span> : <span class="title">OptionSet</span>, <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> barrier: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> detached: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> assignCurrentContext: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> noQoS: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> inheritQoS: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> enforceQoS: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"xyz"</span>) </span><br><span class="line"><span class="keyword">let</span> backgroundWorkItem = <span class="type">DispatchWorkItem</span> &#123; &#125; </span><br><span class="line"><span class="keyword">let</span> updateUIWorkItem = <span class="type">DispatchWorkItem</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">backgroundWorkItem.notify(queue: <span class="type">DispatchQueue</span>.main,execute: updateUIWorkItem) </span><br><span class="line">queue.async(execute: backgroundWorkItem)</span><br></pre></td></tr></table></figure></pre></details><p>对于每个 Operation 都有自己的 state</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> : <span class="title">NSObject</span> </span>&#123; </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span><span class="comment">// 内部会调用 main方法，内部将 isExecuting = true，同步方法</span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span><span class="comment">// 异步需要实现的方法，用户不该自己调用这个方法，当 operation 放到queue中后，isReady = true，会有 OperationQueue 调用</span></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isCancelled: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isReady: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isExecuting: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isFinished: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isConcurrent: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// 弃用</span></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isAsynchronous: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// 重写 AsyncOperation 的时候要改成 true，默认 false</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addDependency</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">removeDependency</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> dependencies: [<span class="type">Operation</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> queuePriority: <span class="type">Operation</span>.<span class="type">QueuePriority</span> </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> qualityOfService: <span class="type">QualityOfService</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> completionBlock: (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不像 gcd 你要把 gcd block or workItem 放在 queue 里才能执行<br>Operation 自己可以执行，不过默认情况是 sync 的 eg:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> op = <span class="type">SubOperation</span>()</span><br><span class="line">op.start()<span class="comment">// 此时operation 还没有 ready好。会在当前 thread，sync 执行 Operation.main</span></span><br></pre></td></tr></table></figure><p>如果想要 Operation 异步操作，需要做额外操作，eg 使用OperationQueue</p><h2 id="blockoperation"><a class="markdownIt-Anchor" href="#blockoperation"></a> BlockOperation</h2><p>如果不想使用 OperationQueue 异步并发调度 Operation<br>可以使用 BlockOperation: Operation，执行在 default global queue.</p><ol><li>内部管理 concurrent queue(default global queue)</li><li>内部管理 一个 group<br>BlockOperation 的效果跟 GCD 中的 Group 相同<br>不过内部执行是 异步并发的，<code>NSInvocationOperation</code> 在swift 中没有 <code>invocation</code> 相关方法在 swift 中都没有</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 oc 想要使用 invocation 调用 swift 的方法，那么 swift 中 该方法应该 是 @objc的，响应类也要继承 NSObject</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"Ray's courses are the best!"</span></span><br><span class="line"><span class="keyword">let</span> wordOperation = <span class="type">BlockOperation</span>()</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sentence.<span class="built_in">split</span>(separator: <span class="string">" "</span>) &#123;</span><br><span class="line">  wordOperation.addExecutionBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(word)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wordOperation.completionBlock = &#123;<span class="comment">// group notify</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Thank you for your patronage!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">duration &#123;</span><br><span class="line">  wordOperation.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印结果</span></span><br><span class="line"><span class="comment">the</span></span><br><span class="line"><span class="comment">are</span></span><br><span class="line"><span class="comment">courses</span></span><br><span class="line"><span class="comment">Ray's</span></span><br><span class="line"><span class="comment">best!</span></span><br><span class="line"><span class="comment">Thank you for your patronage!*/</span></span><br></pre></td></tr></table></figure><h2 id="operationqueue"><a class="markdownIt-Anchor" href="#operationqueue"></a> OperationQueue</h2><p>Operation 当你使用 Queue 来管理 Operation 的时候，才能体现他真正的强大的地方，将 Operation 放到 Queue，你不需要自己调用 start，当Queue Scheduler 分配好 thread 给 Operation 的时候，就会 start，operation 的状态由系统决定</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationQueue</span> : <span class="title">NSObject</span>, <span class="title">ProgressReporting</span> </span>&#123;</span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">13.0</span>, *)</span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> progress: <span class="type">Progress</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperations</span><span class="params">(<span class="number">_</span> ops: [Operation], waitUntilFinished wait: Bool)</span></span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="number">_</span> block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">13.0</span>, *)</span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addBarrierBlock</span><span class="params">(<span class="number">_</span> barrier: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> maxConcurrentOperationCount: <span class="type">Int</span> <span class="comment">// is 1, 表示串行</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isSuspended: <span class="type">Bool</span><span class="comment">// 已经 executing 的 operation不会停止，后进入 queue的会suspend</span></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> qualityOfService: <span class="type">QualityOfService</span></span><br><span class="line">  <span class="keyword">unowned</span>(unsafe) <span class="keyword">open</span> <span class="keyword">var</span> underlyingQueue: <span class="type">DispatchQueue?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelAllOperations</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">waitUntilAllOperationsAreFinished</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">current</span>: <span class="title">OperationQueue</span>? </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">main</span>: <span class="title">OperationQueue</span> </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Operation 中放一个 异步操作是可以的，但是要手动管理 state 变化，因为操作不知道什么时候 finish。<br>Operation 自己的state 属性又是只读的，所以重写个异步操作自己管理 state</p><h2 id="如何创建一个-asyncoperation"><a class="markdownIt-Anchor" href="#如何创建一个-asyncoperation"></a> 如何创建一个 AsyncOperation</h2><ol><li>自己维护 operation 的state</li><li>重写属性，isAsynchronous = true</li><li>注意属性加锁</li></ol><p>一个简单的 <a href="https://github.com/Changzw/AsyncOperation" target="_blank" rel="noopener">AsyncOperation</a> 例子</p><details><summary>source code</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncOperation</span>: <span class="title">Operation</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">State</span>: <span class="title">String</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> ready, executing, finished</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> keyPath: <span class="type">String</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"is\(rawValue.capitalized)"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> rwlockQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"com.czw.asyncoperation"</span>, attributes: .concurrent)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> _state: <span class="type">State</span> = <span class="type">State</span>.ready</span><br><span class="line">  <span class="keyword">var</span> state: <span class="type">State</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      rwlockQueue.sync &#123; <span class="keyword">return</span> _state &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      willChangeValue(forKey: newValue.keyPath)</span><br><span class="line">      rwlockQueue.sync(flags: .barrier) &#123;</span><br><span class="line">        _state = newValue</span><br><span class="line">      &#125;</span><br><span class="line">      didChangeValue(forKey: state.keyPath)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> isReady: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.isReady &amp;&amp; state == .ready</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> isExecuting: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state == .executing</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> isFinished: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state == .finished</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// When implementing an asynchronous operation object, you must implement this property and return true.</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">open</span> <span class="keyword">var</span> isAsynchronous: <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> isCancelled &#123;</span><br><span class="line">      state = .finished</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    main()</span><br><span class="line">    state = .executing</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// call this method at main() async block</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">finish</span><span class="params">()</span></span> &#123;</span><br><span class="line">    state = .finished</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">ImageOperationCompletion</span> = ((<span class="type">Data?</span>, <span class="type">URLResponse?</span>, <span class="type">Error?</span>) -&gt; <span class="type">Void</span>)?</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkImageOperation</span>: <span class="title">AsyncOperation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> image: <span class="type">UIImage?</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> url: <span class="type">URL</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> completion: <span class="type">ImageOperationCompletion</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(url: <span class="type">URL</span>, completion: <span class="type">ImageOperationCompletion</span> = <span class="literal">nil</span>) &#123; </span><br><span class="line">    <span class="keyword">self</span>.url = url</span><br><span class="line">    <span class="keyword">self</span>.completion = completion </span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>?(string: <span class="type">String</span>, completion: <span class="type">ImageOperationCompletion</span> = <span class="literal">nil</span>) &#123; </span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: string) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(url: url, completion: completion)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] data, response, error <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">defer</span> &#123; <span class="keyword">self</span>.state = .finished &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> completion = <span class="keyword">self</span>.completion &#123;</span><br><span class="line">        completion(data, response, error)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">guard</span> error == <span class="literal">nil</span>, <span class="keyword">let</span> data = data <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125; </span><br><span class="line">      <span class="keyword">self</span>.image = <span class="type">UIImage</span>(data: data)</span><br><span class="line">    &#125;.resume()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD 原理+API 分析+实践</title>
      <link href="/2018/12/21/thread/GCD-%E5%8E%9F%E7%90%86-API-%E5%88%86%E6%9E%90/"/>
      <url>/2018/12/21/thread/GCD-%E5%8E%9F%E7%90%86-API-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>GCD 是操作系统层级的概念，他给用户提供了操作线程的 API<br>任务派发中心，内部实现原理是有了 FIFO 分发队列,<a href="http://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a><br>使用 GCD 用户不需要直接操作繁琐的 thread，线程池由系统管理，用户只需要维护分发队列，向分发队列中放 task 就可以了。<br>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长，每个线程都会消耗一些内存和内核资源。</p><h2 id="主要原理"><a class="markdownIt-Anchor" href="#主要原理"></a> 主要原理</h2><p>主要理解三个概念</p><ol><li>queue: 管理任务的队列，确定任务派发方式</li><li>task: 用户自定义需要执行的 task (代码段)</li><li>thread: GCD 根据 queue 定义的方式，将 task 派发给线程池中的指定线程（thread 不需要自己创建）</li></ol><p><img src="/img/GCD-thread-mode.jpg" alt="GCD Queue task thread"></p><ul><li>queue<ul><li>串行队列，所有任务都在同一个 thread 上一个接着一个的执行<ul><li>特例：主队列 main_queue，所有 task 在 mainThread 中执行</li></ul></li><li>并发队列，任务可以在多个 thread 中执行没有固定执行顺序<ul><li>特例：global 队列</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">concurrent</span><br><span class="line">adj. adj. 并发的；一致的；同时发生的；并存的</span><br><span class="line">n. [数] 共点；同时发生的事件</span><br><span class="line"></span><br><span class="line">对于并行跟并发</span><br><span class="line">并发：值得是程序上多thread并发执行，其实是多线程抢占资源 -- cpu 执行（任务是以在单核 CPU 上分时（时间共享））</span><br><span class="line">并行：是硬件上，多个thread在多个 cpu 上同事执行着</span><br></pre></td></tr></table></figure><ul><li><p>同步异步执行任务</p><ul><li>sync 所有任务要在一个 thread 中执行，一个接着一个</li><li>async 具备开启线程的能力，可以在多个thread 中并发执行任务</li></ul></li><li><p>thread</p><ul><li>使用 GCD，不用再直接跟线程打交道了，只需要向队列中添加代码块(task)即可，GCD 在后端管理着一个线程池。</li><li>作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</li><li>根据👆图 task 真正的并发只有 右下角的才能出现，并发队列中异步执行任务<br>P.S.：async 执行 task的时候 thread 的个数跟 task 的个数没有关系（现在 iOS系统是开辟 6个 thread，以前低版本的是 3个，thread 开辟太多，会用掉大量内存）</li></ul></li></ul><p>接下来说一些 GCD 接口，根据接口分析原理</p><h2 id="分发队列"><a class="markdownIt-Anchor" href="#分发队列"></a> 分发队列</h2><h3 id="队列的创建"><a class="markdownIt-Anchor" href="#队列的创建"></a> 队列的创建</h3><ol><li>GCD 公开有 5 个不同的全局队列：<ul><li>运行在主线程中的 main queue（串行队列）</li><li>global 队列，3 个不同优先级的后台队列（并发队列）</li><li>以及一个优先级更低的后台队列（用于 I/O）（并发队列）</li></ul></li></ol><p>得到系统的全局队列</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_main_t mainDispatchQueue = dispatch_get_main_queue();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_queue_global_t globalDispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义队列：串行或者并行队列。自定义队列非常强大，<strong>在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</strong></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue</span><br><span class="line">concurrentQueue = dispatch_queue_create(<span class="string">"concurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serial"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure><p><img src="https://objccn.io/images/issues/issue-2/gcd-queues.png" alt=""></p><h3 id="创建队列并设置优先级"><a class="markdownIt-Anchor" href="#创建队列并设置优先级"></a> 创建队列并设置优先级</h3><ol><li>获取全局 global 系统队列时传递优先级</li><li>dipatch_queue_attr_make_with_qos_class</li><li>dispatch_set_target_queue</li></ol><p>使用 <code>dispatch_queue_attr_t</code> 属性设置优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr;</span><br><span class="line">attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.myqueue"</span>, attr);</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>DISPATCH_QUEUE_PRIORITY_HIGH</td><td>QOS_CLASS_USER_INITIATED</td></tr><tr><td>DISPATCH_QUEUE_PRIORITY_DEFAULT</td><td>QOS_CLASS_DEFAULT</td></tr><tr><td>DISPATCH_QUEUE_PRIORITY_LOW</td><td>QOS_CLASS_UTILITY</td></tr><tr><td>DISPATCH_QUEUE_PRIORITY_BACKGROUND</td><td>QOS_CLASS_BACKGROUND</td></tr></tbody></table><ul><li>QOS_CLASS_USER_INTERACTIVE 指定为该QOS class的队列负责执行与用户交互相关的任务，比如动画、事件处理、更新UI等，所以有最高优先级。该优先级的队列应该只限于做与用户交互相关的任务，所以在上面优先级的宏定义中并没有将其暴露出来。(推测主队列优先级是这个)</li><li>QOS_CLASS_USER_INITIATED 指定为该QOS class的队列用来执行那些会阻碍用户使用你的App的任务，所以优先级也很高。</li><li>QOS_CLASS_DEFAULT 默认优先级。</li><li>QOS_CLASS_UTILITY 指定为该QOS class的队列用于执行那些用户不需要立即得到结果的任务，所以优先级相对较低。(long-running computations, I/O, networking or continuous data feeds.)</li><li>QOS_CLASS_BACKGROUND 指定为该QOS class的队列用于执行维护或清理等任务，用户不需要关心其结果。</li></ul><p>设置目标队列</p><details><summary>dispatch_set_target_queue 相关注释说明</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* When no quality of service <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">relative</span> <span class="title">priority</span> <span class="title">is</span> <span class="title">specified</span> <span class="title">for</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">* <span class="title">dispatch</span> <span class="title">queue</span> <span class="title">at</span> <span class="title">the</span> <span class="title">time</span> <span class="title">of</span> <span class="title">creation</span>, <span class="title">a</span> <span class="title">dispatch</span> <span class="title">queue</span>'<span class="title">s</span> <span class="title">quality</span> <span class="title">of</span> <span class="title">service</span></span></span><br><span class="line"><span class="class">* <span class="title">class</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">its</span> <span class="title">target</span> <span class="title">queue</span>. <span class="title">The</span> <span class="title">dispatch_get_global_queue</span>()</span></span><br><span class="line"><span class="class">* <span class="title">function</span> <span class="title">may</span> <span class="title">be</span> <span class="title">used</span> <span class="title">to</span> <span class="title">obtain</span> <span class="title">a</span> <span class="title">target</span> <span class="title">queue</span> <span class="title">of</span> <span class="title">a</span> <span class="title">specific</span> <span class="title">quality</span> <span class="title">of</span></span></span><br><span class="line"><span class="class">* <span class="title">service</span> <span class="title">class</span>, <span class="title">however</span> <span class="title">the</span> <span class="title">use</span> <span class="title">of</span> <span class="title">dispatch_queue_attr_make_with_qos_class</span>()</span></span><br><span class="line"><span class="class">* <span class="title">is</span> <span class="title">recommended</span> <span class="title">instead</span>.</span></span><br></pre></td></tr></table></figure></pre></details><ol><li>将自定义 queue 中的 task 都将被放入到系统的全局队列和线程池中：默认情况下会把开发者创建的队列放入到<strong>默认优先级</strong>的全局队列中。但是也可以给自定义的队列设置一个目标队列</li><li>改变自定义 queue 的优先级：让其执行优先级与该目标队列的执行优先级一致。</li><li>改变 queue 中 task 执行的方式：不仅能改变优先级，如果一个队列是并行的，但是其目标队列是串行的，那么实际上这个队列也会转换为串行队列。再者，不同串行队列中的任务是可以同时执行的，如果把这些串行队列的目标队列都设置为同一个串行队列，那这些串行队列中的任务将不会并行执行。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> * @param object</span><br><span class="line"> * The object to modify.</span><br><span class="line"> * The result of passing <span class="literal">NULL</span> in <span class="keyword">this</span> parameter is undefined.</span><br><span class="line"> *</span><br><span class="line"> * @param <span class="built_in">queue</span></span><br><span class="line"> * The <span class="keyword">new</span> target <span class="built_in">queue</span> <span class="keyword">for</span> the object. The <span class="built_in">queue</span> is retained, <span class="keyword">and</span> the</span><br><span class="line"> * previous target <span class="built_in">queue</span>, <span class="keyword">if</span> any, is released.</span><br><span class="line"> * If <span class="built_in">queue</span> is DISPATCH_TARGET_QUEUE_DEFAULT, <span class="built_in">set</span> the object<span class="number">'</span>s target <span class="built_in">queue</span></span><br><span class="line"> * to the <span class="keyword">default</span> target <span class="built_in">queue</span> <span class="keyword">for</span> the given object type.</span><br><span class="line"> */</span><br><span class="line">DISPATCH_EXPORT DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_set_target_queue(<span class="keyword">dispatch_object_t</span> object, <span class="keyword">dispatch_queue_t</span> _Nullable <span class="built_in">queue</span>);</span><br></pre></td></tr></table></figure><p>dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行</p><details><summary>dispatch_set_target_queue使用后的效果</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setTarget</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> serialQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"serialQueue"</span>)</span><br><span class="line">  <span class="keyword">let</span> aQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.0"</span>, attributes: .concurrent, target: serialQueue)</span><br><span class="line">  <span class="keyword">let</span> bQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.1"</span>, attributes: .concurrent, target: serialQueue)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> alabel = aQueue.label</span><br><span class="line">  <span class="keyword">let</span> blabel = bQueue.label</span><br><span class="line">  aQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(alabel): 1"</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 2"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 3"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">concurrent.queue.0: 1</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 2</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nosetTarget</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> aQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.0"</span>, attributes: .concurrent)</span><br><span class="line">  <span class="keyword">let</span> bQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.1"</span>, attributes: .concurrent)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> alabel = aQueue.label</span><br><span class="line">  <span class="keyword">let</span> blabel = bQueue.label</span><br><span class="line">  aQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(alabel): 1"</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 2"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 3"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">concurrent.queue.0: 1</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 3</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></pre></details><h2 id="gcd-任务调度"><a class="markdownIt-Anchor" href="#gcd-任务调度"></a> GCD 任务调度</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sync</span><span class="params">(execute workItem: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(execute workItem: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(group: DispatchGroup, execute workItem: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(group: DispatchGroup? = <span class="literal">nil</span>, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sync</span>&lt;T&gt;<span class="params">(execute work: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sync</span>&lt;T&gt;<span class="params">(flags: DispatchWorkItemFlags, execute work: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(deadline: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(wallDeadline: DispatchWallTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(deadline: DispatchTime, execute: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(wallDeadline: DispatchWallTime, execute: DispatchWorkItem)</span></span></span><br></pre></td></tr></table></figure><h3 id="只执行一次-task"><a class="markdownIt-Anchor" href="#只执行一次-task"></a> 只执行一次 task</h3><p>dispatch_once 只执行一次指定的block。它的性能要比@synchronized要好。@synchronized每一次都要先获取锁，而dispatch_once使用一个token标识代码是否执行过。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在Swift 3.0中这个函数被废弃了，但是可以使用懒加载的全局变量或静态变量，也能保证线程安全。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onceTask: <span class="type">String</span> = &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"onceTask"</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="添加栅栏函数"><a class="markdownIt-Anchor" href="#添加栅栏函数"></a> 添加栅栏函数</h3><p><img src="/img/barrier.jpeg" alt=""></p><p>Dispatch Barrier解决多线程多读单写同一个资源发生死锁问题<br>同步队列中不会出现这个问题<br>在并发队列中，如果添加了 <code>.barrier</code> task 那么在 <code>.barrier</code> task 之前添加的任务所有任务执行之前都会有任务执行，在全局并发队列和串行队列上，效果和dispatch_sync一样</p><p><img src="/img/GCD_barrier.jpg" alt="barrier"></p><p>有两个接口</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Submits a barrier block object for execution and waits until that block completes.</span></span><br><span class="line"><span class="comment">//The queue you specify should be a concurrent queue that you create yourself using the dispatch_queue_create function. If the queue you pass to this function is a serial queue or one of the global concurrent queues, this function behaves like the dispatch_sync function.</span></span><br><span class="line">dispatch_barrier_sync(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Submits a barrier block for asynchronous execution and returns immediately.</span></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">barrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"barrier"</span>, attributes: .concurrent)</span><br><span class="line">  q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  q.async(flags: .barrier) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sleep 2s----"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际开发中一个很好的使用 barrier 控制多读单写的例子，就是重写 getter，setter 方法<br>多读单写特点：</p><ul><li>读者与读者并发</li><li>读者与写者互斥</li><li>写者与写者互斥</li></ul><p><img src="/img/multi-read-single-write.jpeg" alt="多读单写"></p><ol><li>要在 concurrent queue 中执行</li><li><code>dispatch_barrier_async</code></li><li>重写需要加锁数据的 getter，setter 方法<ol><li>getter 方法需要立即得到数据所以使用 <code>sync</code></li><li>setter 方法 <code>async</code> ，因为读的过程不需要立即得到结果</li></ol></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于变量</span></span><br><span class="line"><span class="keyword">let</span> rwQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"multireadsinglewrite"</span>, attributes: .concurrent)</span><br><span class="line"><span class="keyword">var</span> test_ = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> test: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    rwQueue.sync &#123;</span><br><span class="line">      <span class="keyword">return</span> test_</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123;</span><br><span class="line">    rwQueue.async(flags: .barrier) &#123;</span><br><span class="line">      <span class="keyword">self</span>.test_ = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加-group-通知"><a class="markdownIt-Anchor" href="#添加-group-通知"></a> 添加 group 通知</h3><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。</p><p>当group里所有事件都完成GCD API有两种方式发送通知<br>第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时<br>第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notify 任务组完成后，执行 notify 要做的事，notify不阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], queue: DispatchQueue, execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(queue: DispatchQueue, work: DispatchWorkItem)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待直到完成or超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(timeout: DispatchTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(wallTimeout timeout: DispatchWallTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br></pre></td></tr></table></figure><p>如果放入组里面的任务内部没有嵌套任务，那么一切正常<br>可是如果组里面的 task 内部异步任务呢？eg task0{ async(task1) }<br>这个时候我想，task1 异步回调执行完，才算task0 这个组任务完成该怎么做？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">enter</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">leave</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>实际使用group的例子</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> downloadGroup = <span class="type">DispatchGroup</span>()</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> [url0,url1,url2] &#123;</span><br><span class="line">  downloadGroup.enter()</span><br><span class="line">  <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url) &#123; <span class="number">_</span>, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> error != <span class="literal">nil</span> &#123; &#125;</span><br><span class="line">    downloadGroup.leave()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">PhotoManager</span>.shared.addPhoto(photo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">downloadGroup.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"finish"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="挂起恢复队列"><a class="markdownIt-Anchor" href="#挂起恢复队列"></a> 挂起/恢复队列</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.suspend()<span class="comment">// 当前 isExcuting = true 的operation 不会听通知</span></span><br><span class="line">queue.resume()</span><br></pre></td></tr></table></figure><p>这里挂起不会暂停正在执行的block</p><h3 id="dispatch_apply进行快速迭代"><a class="markdownIt-Anchor" href="#dispatch_apply进行快速迭代"></a> dispatch_apply进行快速迭代</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"apply"</span>, attributes: .concurrent)</span><br><span class="line">  __dispatch_apply(<span class="number">5</span>, q)&#123; idx <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(idx)<span class="comment">// 异步并发</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"apply end"</span>)<span class="comment">// 同步等待</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">apply end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>dispatch_apply</p><ul><li>在并发队列中使用</li><li>将 task 追加到队列中</li><li>所有 task 并发执行完以后同步执行后面的打印</li><li>dispatch_apply 添加的 task 是异步并发执行，外部是同步执行</li></ul><p><img src="/img/GCD_apply.jpg" alt="apply"></p><p>用dispatch_apply替代对数组等的for循环，把这些block放到并行队列中可以提高执行效率。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P.S. apply 主要针对于大量并发的时候使用，少量的时候没有必要</span><br></pre></td></tr></table></figure><h3 id="dispatch-semaphore"><a class="markdownIt-Anchor" href="#dispatch-semaphore"></a> Dispatch Semaphore</h3><p>使用变量管理多线程的同步方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> dispatch_semaphore_create(<span class="keyword">long</span> value);</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">并发编程：API 及挑战</a><br><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简化设计 App 的过程</title>
      <link href="/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>一个 app 原型&amp;需求来了以后，如何实现呢？<br>本来一个完成的东西如何把需求翻译成程序呢？</p><h2 id="正常节奏"><a class="markdownIt-Anchor" href="#正常节奏"></a> 正常节奏：</h2><ol><li>分析需求<ol><li>原型分析</li><li>需求分析</li></ol></li><li>技术点调研分析<ol><li>架构方式</li><li>使用什么框架（框架对比）</li><li>View 层使用什么渲染方式，Model层使用什么组件，中间层使用什么工具</li></ol></li><li>时间预估<ol><li>新技术学习时间</li><li>开发时间</li><li>调试时间</li></ol></li></ol><h2 id="遇到问题"><a class="markdownIt-Anchor" href="#遇到问题"></a> 遇到问题</h2><ol><li>需求量大，强调代码的复用性！思考时间过长</li><li>需求理解错误，理解不深，差异性问题没有解决</li><li>新技术，熟练度问题，错误使用</li><li>沟通问题！</li></ol><h2 id="简单思考"><a class="markdownIt-Anchor" href="#简单思考"></a> 简单思考</h2><ol><li>简化开发流程！</li><li>App 编码过程<ol><li>照着画 UI</li><li>确定数据渲染方式！</li><li>简化让 model 层数据传到 UI 层渲染的过程，让水流通（我喜欢的方式是函数响应式 rx）</li><li>数据流连接完成以后，添加各种逻辑<ol><li>单链逻辑</li><li>一条条加</li><li>复用的地方在复用</li></ol></li></ol></li><li>代码不是一下子完美的！<ol><li>开始的时候不要太复杂</li><li>不要用太高端自己又不熟悉的技巧</li><li>重构优化使用更好地技术手段都是迭代的过程</li></ol></li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>viewController transitions</title>
      <link href="/2018/11/06/UI%20%E7%9B%B8%E5%85%B3/viewController-transitions/"/>
      <url>/2018/11/06/UI%20%E7%9B%B8%E5%85%B3/viewController-transitions/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>iOS 系统提供了像 <code>push, pop, cover vertically</code> 这样的 <code>ViewController</code> 过渡，该篇分析如何自定义自己的 ViewController transitions。为啥要写这个因为“看着很麻烦”，比起 push，pop，present 来说……</p><p>思考：</p><ol><li>ViewController 的 过渡流程步骤是什么样的</li><li>都有什么组成，他们之间的逻辑是什么样的</li><li>用户如何使用</li></ol><p>过渡的过程，应该有：</p><ol><li>负责触发事件</li><li>负责管理过渡动画</li><li>负责过渡相关的ViewControllers，Views</li></ol><h2 id="transitions-结构"><a class="markdownIt-Anchor" href="#transitions-结构"></a> transitions 结构</h2><p>transitioning API 一组 protocols 结合，允许我们自定义化，使用一个现有的 transition 对象 or 自己定义一个新的。<br><img src="/img/Transition-Frame.jpeg" alt="transitioning API"></p><p>Q: 每个协议的责任是什么？<br>Q: 执行步骤是什么</p><h3 id="transitioning-delegate"><a class="markdownIt-Anchor" href="#transitioning-delegate"></a> Transitioning Delegate</h3><p>每个 ViewController 都有对象—— <code>transitioningDelegate: UIViewControllerTransitioningDelegate</code> 用来得到 Animation controller 对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CardViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlipPresentAnimationController</span>(originFrame: cardView.frame)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你 present or dismiss <code>ViewController</code> 的时候，UIKit 会向 <code>transitioningDelegate</code> 要你自定义的 <code>Animation controller</code> 来替代默认动画。你要做的是实现 <code>UIViewControllerTransitioningDelegate</code> 代理方法返回 <code>Animation controller</code></p><h3 id="animation-controller"><a class="markdownIt-Anchor" href="#animation-controller"></a> Animation Controller</h3><p>用来做过渡动画，他实现自 <code>UIViewControllerAnimatedTransitioning</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipPresentAnimationController</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置动画时间</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 从UIViewControllerContextTransitioning 中得到 toVc &amp; fromVc，对其制作动画</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1 通过 transitionContext 得到 fromVC 是触发 present的VC，toVC 是要被呈现的 VC，snapShot，是toVC 呈现以后的view 截图用于做动画</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: .from),</span><br><span class="line">      <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: .to),</span><br><span class="line">      <span class="keyword">let</span> snapshot = toVC.view.snapshotView(afterScreenUpdates: <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//containerView 是过渡过程中的容器 view</span></span><br><span class="line">    <span class="keyword">let</span> containerView = transitionContext.containerView</span><br><span class="line">    <span class="keyword">let</span> finalFrame = transitionContext.finalFrame(<span class="keyword">for</span>: toVC)</span><br><span class="line"></span><br><span class="line">    snapshot.frame = originFrame</span><br><span class="line">    snapshot.layer.cornerRadius = <span class="type">CardViewController</span>.cardCornerRadius</span><br><span class="line">    snapshot.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    containerView.addSubview(toVC.view)</span><br><span class="line">    containerView.addSubview(snapshot)</span><br><span class="line">    toVC.view.isHidden = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnimationHelper</span>.perspectiveTransform(<span class="keyword">for</span>: containerView)</span><br><span class="line">    snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(.pi / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 view 做动画处理</span></span><br><span class="line">    <span class="type">UIView</span>.animateKeyframes(</span><br><span class="line">      withDuration: duration,</span><br><span class="line">      delay: <span class="number">0</span>,</span><br><span class="line">      options: .calculationModeCubic,</span><br><span class="line">      animations: &#123;</span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">0.0</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          fromVC.view.layer.transform = <span class="type">AnimationHelper</span>.yRotation(-.pi / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">1</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(<span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">2</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.frame = finalFrame</span><br><span class="line">          snapshot.layer.cornerRadius = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">      completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        toVC.view.isHidden = <span class="literal">false</span></span><br><span class="line">        snapshot.removeFromSuperview()</span><br><span class="line">        fromVC.view.layer.transform = <span class="type">CATransform3DIdentity</span></span><br><span class="line">        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><p>对于需要自定义的 transitioning 的 ViewController，CustomViewController</p><ol><li>CustomViewController: UIViewControllerTransitioningDelegate 实现协议</li><li>实现协议的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animationController(presented:, presenting:, source:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br><span class="line">animationController(dismiss:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 Animation Controller（CustomeAnimationController: UIViewControllerAnimatedTransitioning)</li><li>实现 UIViewControllerAnimatedTransitioning 中的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transitionDuration(using transitionContext: <span class="type">UIViewControllerContextTransitioning?</span>) -&gt; <span class="type">TimeInterval</span></span><br><span class="line">animateTransition(transitionContext:)</span><br></pre></td></tr></table></figure><h2 id="给-dismiss-添加手势交互"><a class="markdownIt-Anchor" href="#给-dismiss-添加手势交互"></a> 给 dismiss 添加手势交互</h2><p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/settings.gif" alt=""></p><blockquote><p><a href="https://www.raywenderlich.com/322-custom-uiviewcontroller-transitions-getting-started#toc-anchor-011" target="_blank" rel="noopener">Custom UIViewController Transitions: Getting Started</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>App 架构</title>
      <link href="/2018/09/18/architecture/App-%E6%9E%B6%E6%9E%84/"/>
      <url>/2018/09/18/architecture/App-%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>objc 《App 架构》 笔记</p><h2 id="如何设计架构"><a class="markdownIt-Anchor" href="#如何设计架构"></a> 如何设计架构</h2><ol><li>确定模块（Model 层，View 层，协调器……）<ol><li>如何确定模块？联想实际场景，分析责任、行为，确定模块！！</li><li>为什么要确定模块？确定模块后，程序不会被应用框架中的实现细节所支配</li></ol></li><li>模块间的联系，依赖，变换，通知行为如何定义。<ol><li>尽可能让数据流向单向清晰</li><li>确定数据流向行为统一一致，统一程序开发维护<ol><li>delegate，notification，block，kvo，Rx……</li></ol></li></ol></li></ol><h2 id="mvc"><a class="markdownIt-Anchor" href="#mvc"></a> MVC</h2><p><img src="/img/MVC.jpeg" alt="mvc"></p><p>Model 层包括，data model和server model<br>controler：引用 server model</p><h2 id="mvvm-c"><a class="markdownIt-Anchor" href="#mvvm-c"></a> MVVM-C</h2><p><img src="/img/mvvm-c.jpeg" alt="mvvm-c"></p><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><h2 id="mvcviewstate"><a class="markdownIt-Anchor" href="#mvcviewstate"></a> MVC+ViewState</h2><p><img src="/img/mvc-viewstate.jpeg" alt="mvc-viewstate"></p><h2 id="model-适配器-view-绑定器"><a class="markdownIt-Anchor" href="#model-适配器-view-绑定器"></a> Model 适配器 + View 绑定器</h2><h2 id="elm-架构"><a class="markdownIt-Anchor" href="#elm-架构"></a> Elm 架构</h2><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 设计思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>block 底层分析</title>
      <link href="/2018/09/11/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/block-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/"/>
      <url>/2018/09/11/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/block-%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p>为什么oc 会设计block 呢？<br>oc 是 c扩展，c 中第一个想到的事回调函数—— 用来做控制翻转<br>可是 callback 不能捕获变量</p><p>而 block 本质 objc_object 类型，它可以捕获变量，更好地做到控制翻转</p><p>block 会将捕获的变量封装称自己的成员变量</p><p>捕获变量的类型</p><ol><li>auto：copy，所以block跟外部的值不一样</li><li>static：指针引用</li><li>全局变量：不捕获，直接访问</li><li>pointer：指针引用</li></ol><h2 id="block-源码分析"><a class="markdownIt-Anchor" href="#block-源码分析"></a> block 源码分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *isa;</span><br><span class="line">  <span class="keyword">int</span> Flags;</span><br><span class="line">  <span class="keyword">int</span> Reserved;</span><br><span class="line">  <span class="keyword">void</span> *FuncPtr;<span class="comment">// block 方法-- __test_block_func_1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">test_block_impl_1</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">block_impl</span> <span class="title">impl</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">test_block_desc_1</span>* <span class="title">Desc</span>;</span></span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  __test_block_impl_1(<span class="keyword">void</span> *fp, struct __test_block_desc_1 *desc, <span class="keyword">int</span> _age, <span class="keyword">int</span> flags=<span class="number">0</span>) : age(_age) &#123;</span><br><span class="line">    impl.isa = &amp;_NSConcreteStackBlock;</span><br><span class="line">    impl.Flags = flags;</span><br><span class="line">    impl.FuncPtr = fp;</span><br><span class="line">    Desc = desc;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __test_block_func_1(struct __test_block_impl_1 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> age = __cself-&gt;age; <span class="comment">// bound by copy</span></span><br><span class="line">  NSLog(<span class="string">"block:%d"</span>, age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> __<span class="title">test_block_desc_1</span> &#123;</span></span><br><span class="line">  <span class="keyword">size_t</span> reserved;</span><br><span class="line">  <span class="keyword">size_t</span> Block_size;<span class="comment">// block结构体大小</span></span><br><span class="line">&#125; __test_block_desc_1_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(struct __test_block_impl_1)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">// Stack：访问了auto变量</span></span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">      NSLog(@<span class="string">"block:%d"</span>, age);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="__block"><a class="markdownIt-Anchor" href="#__block"></a> __block</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">Block_byref_age_0</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> *__isa;</span><br><span class="line">  __Block_byref_age_0 *__forwarding;</span><br><span class="line">  <span class="keyword">int</span> __flags;</span><br><span class="line">  <span class="keyword">int</span> __size;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>__block int age = 10;<br>此时 age 就已经被编译成一个 oc对象了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^Block)(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    __block <span class="keyword">int</span> age = <span class="number">10</span>;<span class="comment">//这个 age 是__Block_byref_age_0结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的 age 都是临时变量，__Block_byref_age_0 的age 属性</span></span><br><span class="line">    printf(<span class="string">"1:%p\n"</span>, &amp;age);</span><br><span class="line">    Block block = ^&#123;</span><br><span class="line">      printf(<span class="string">"2:%p\n"</span>, &amp;age);</span><br><span class="line">    &#125;;</span><br><span class="line">    block();</span><br><span class="line">    printf(<span class="string">"3:%p\n"</span>, &amp;age);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1:0x7ffeefbff458</span></span><br><span class="line"><span class="comment">2:0x100719078</span></span><br><span class="line"><span class="comment">3:0x100719078</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>将变量封装了一个 objc_object 类型，这样对于 auto 变量使用 __block 修饰，就可以跟外面一致了</p><h2 id="block-的类型"><a class="markdownIt-Anchor" href="#block-的类型"></a> block 的类型</h2><ul><li>__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）</li><li>__NSStackBlock__ （ _NSConcreteStackBlock ）</li><li>__NSMallocBlock__ （ _NSConcreteMallocBlock ）</li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“T” 字模型</title>
      <link href="/2018/08/24/%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/08/24/%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="架构的时候容易乱使用-t-字模型思考"><a class="markdownIt-Anchor" href="#架构的时候容易乱使用-t-字模型思考"></a> 架构的时候容易乱——使用 “T” 字模型思考</h2><p>原因：<br>架构代码的时候，总想有没有更好地解决方案，如何尽可能的模块解耦，责任单一……，如何查分类，架构中需要有什么模块，需要使用什么工具链……</p><p>可是一下子把所有问放在一起，整个人很多时候会乱，而且想的越多越乱</p><p>解决方案：</p><ol><li>简单化模块，现有最基本的框架 eg MVVM，MVC</li><li>把最简单的模型先搭建起来，然后实现一个主流程功能</li><li>接着在实现其他主流程功能</li><li>想想可以添加那些 模块组件 让自己的架构更加优美</li><li>重构，然后再先有个主流程线</li></ol><p>总结：</p><ol><li>现有要做的东西有个 外在的整体认识，想给用户提供什么 接口！</li><li>先实现一个接口的功能，然后再把所有线的实现出来</li><li>重构</li></ol><p>整体思想方式 是 “T” 字思考</p><h2 id="模块组件间交互繁杂-为什么有-中介者"><a class="markdownIt-Anchor" href="#模块组件间交互繁杂-为什么有-中介者"></a> 模块组件间交互繁杂—— 为什么有 中介者</h2><ol><li>程序调用流程是线性的，思维混乱的程序员很容易把这条线搞的杂乱无章，虽然可以让程序跑起来，可是维护费劲</li><li>中介者：模块中提供中介者，定义一种编程规范，使用 中介者 让代码分类，这样把模块减少，减少杂乱的线，这些线放在中介者中</li></ol><p><img src="/img/meditator_chaos.jpg" alt="chaos"><br><img src="/img/meditator_order.jpg" alt="order"></p><p>中介者—— 像个管理者一样，在实际中调度各个部门，部门有什么问题想中介者汇报</p><p>如果没有中介者——管理者，那么 部门之间问题相互穿插 orz</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 源码分析</title>
      <link href="/2018/08/18/RxSwfit+RAC/RxSwift-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/18/RxSwfit+RAC/RxSwift-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><p><img src="/img/RxSwift001.jpg" alt="frame"></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>objc_msgSend 流程分析</title>
      <link href="/2018/08/10/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/objc_msgSend%20%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/10/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/objc_msgSend%20%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p><a href="https://changzw.github.io/2018/01/09/deep%20analyse/OC-%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/">OC对象分析</a></p><h2 id="系统在-runtime-时如何查找方法"><a class="markdownIt-Anchor" href="#系统在-runtime-时如何查找方法"></a> 系统在 runtime 时如何查找方法</h2><p>oc 实例对象不存储方法的，方法都在类对象里面</p><p><img src="/img/objc_msgSend.jpg" alt="整体流程图"></p><h3 id="objc_class-源码结构"><a class="markdownIt-Anchor" href="#objc_class-源码结构"></a> objc_class 源码结构</h3><p><img src="/img/objc_class_struct.jpg" alt="objc_class"></p><ul><li>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容</li><li>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容</li></ul><h3 id="method_t"><a class="markdownIt-Anchor" href="#method_t"></a> method_t</h3><p>对方法\函数的封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">  SEL name;             <span class="comment">// char* 函数名</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *types;    <span class="comment">// 参数，返回值编码 </span></span><br><span class="line">  MethodListIMP imp;    <span class="comment">// 函数实现地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><details><summary>ivar_t, property_t 源码</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">int32_t</span> *offset;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">  <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">  <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> alignment() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (alignment_raw == ~(<span class="keyword">uint32_t</span>)<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1U</span> &lt;&lt; WORD_SHIFT;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; alignment_raw;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *attributes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><h3 id="type-encoding"><a class="markdownIt-Anchor" href="#type-encoding"></a> Type Encoding</h3><p><img src="/img/type_encode1.png" alt=""><br><img src="/img/type_encode2.png" alt="type_encode"></p><h3 id="方法缓存"><a class="markdownIt-Anchor" href="#方法缓存"></a> 方法缓存</h3><p>objc_class 中有个方法缓存（cache_t），用散列表（哈希表）来缓存曾经调用过的方法，可以提高方法的查找速度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span> <span class="comment">// 散列表</span></span><br><span class="line">  <span class="keyword">mask_t</span> _mask;              <span class="comment">// 散列表长度 - 1</span></span><br><span class="line">  <span class="keyword">mask_t</span> _occupied;          <span class="comment">// 已经缓存方法的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line">  SEL _sel;         <span class="comment">// 作为 key</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> _imp;   <span class="comment">// value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="objc_msgsend执行流程"><a class="markdownIt-Anchor" href="#objc_msgsend执行流程"></a> objc_msgSend执行流程</h2><p>oc 是 c 的扩展，在 oc 方法的触发有两种 1. 发送消息，2. 函数调用<br>发送消息都是转换为objc_msgSend函数的调用<br>objc_msgSend的执行流程可以分为3个阶段</p><ol><li>消息发送</li><li>动态方法解析</li><li>消息转发</li></ol><h3 id="消息发送"><a class="markdownIt-Anchor" href="#消息发送"></a> 消息发送</h3><p><img src="/img/message-searching.jpg" alt="消息查找过程"></p><h3 id="动态方法解析"><a class="markdownIt-Anchor" href="#动态方法解析"></a> 动态方法解析</h3><ol><li>消息查找失败，跑到 <code>resolveClassMethod</code> or <code>resolveInstanceMethod</code></li><li>这个时候得到要添加方法的 name，参数列表</li><li>动态添加方法，<code>class_addMethod</code>，添加的方法会加到 object_class 对象的 class_rw_t 的 methods 中</li><li>然后 retry 消息发送流程</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以添加 c 函数</span></span><br><span class="line"><span class="keyword">void</span> c_func(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"c_func: %@-%@"</span>, <span class="keyword">self</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;</span><br><span class="line">  <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(test)) &#123;</span><br><span class="line">    <span class="comment">// 第一个参数是object_getClass(self)</span></span><br><span class="line">    class_addMethod(object_getClass(<span class="keyword">self</span>), sel, (IMP)c_other, <span class="string">"v16@0:8"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">super</span> resolveClassMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">  <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(unfound)) &#123;</span><br><span class="line">    <span class="comment">// 动态添加 unfound 方法的实现</span></span><br><span class="line">    Method method = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(customFunc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态添加test方法的实现</span></span><br><span class="line">    class_addMethod(<span class="keyword">self</span>, sel,</span><br><span class="line">                          method_getImplementation(method),</span><br><span class="line">                          method_getTypeEncoding(method));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)customFunc&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转发"><a class="markdownIt-Anchor" href="#消息转发"></a> 消息转发</h3><p>如果重载动态方法解析 <code>resolveClassMethod</code> or <code>resolveInstanceMethod</code> 但方法内部没有添加方法那么就会走消息转发</p><h4 id="forwarding"><a class="markdownIt-Anchor" href="#forwarding"></a> forwarding</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __forwarding__(<span class="keyword">void</span> *frameStackPointer, <span class="keyword">int</span> isStret) &#123;</span><br><span class="line">  id receiver = *(id *)frameStackPointer;</span><br><span class="line">  SEL sel = *(SEL *)(frameStackPointer + <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *selName = sel_getName(sel);</span><br><span class="line">  Class receiverClass = object_getClass(receiver);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 forwardingTargetForSelector:</span></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(forwardingTargetForSelector:))) &#123;</span><br><span class="line">    id forwardingTarget = [receiver forwardingTargetForSelector:sel];</span><br><span class="line">    <span class="keyword">if</span> (forwardingTarget &amp;&amp; forwardingTarget != receiver) &#123;</span><br><span class="line">      <span class="keyword">return</span> objc_msgSend(forwardingTarget, sel, ...);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 methodSignatureForSelector 获取方法签名后再调用 forwardInvocation</span></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass, @selector(methodSignatureForSelector:))) &#123;</span><br><span class="line">    NSMethodSignature *methodSignature = [receiver methodSignatureForSelector:sel];</span><br><span class="line">    <span class="keyword">if</span> (methodSignature &amp;&amp; class_respondsToSelector(receiverClass, @selector(forwardInvocation:))) &#123;</span><br><span class="line">      NSInvocation *invocation = [NSInvocation _invocationWithMethodSignature:methodSignature frame:frameStackPointer];</span><br><span class="line"></span><br><span class="line">      [receiver forwardInvocation:invocation];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">void</span> *returnValue = <span class="literal">NULL</span>;</span><br><span class="line">      [invocation getReturnValue:&amp;value];</span><br><span class="line">      <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (class_respondsToSelector(receiverClass,@selector(doesNotRecognizeSelector:))) &#123;</span><br><span class="line">    [receiver doesNotRecognizeSelector:sel];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The point of no return.</span></span><br><span class="line">  kill(getpid(), <span class="number">9</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法签名"><a class="markdownIt-Anchor" href="#方法签名"></a> 方法签名</h4><p>如果 forwarding 方法没有是实现，or 返回的是 nil，那么会 objc 会调用 方法签名<br>此时你要实现下面两个方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;</span><br><span class="line">  <span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(test:)) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="string">"i@:i"</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation&#123;</span><br><span class="line">  <span class="comment">// 参数顺序：receiver、selector、other arguments</span></span><br><span class="line">  <span class="comment">// 如果不设置那么就是最开始 发送消息的 实例对象&amp;方法</span></span><br><span class="line">  anInvocation.target == [[NewObjec alloc] init]</span><br><span class="line">  anInvocation.selector == otherFunc:</span><br><span class="line">  <span class="keyword">int</span> ret;</span><br><span class="line">  [anInvocation getReturnValue:&amp;ret];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>NSMethodSignature, NSInvocation(swift 不可用)</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法签名封装方法参数，返回值，对象</span></span><br><span class="line"><span class="built_in">NS_SWIFT_UNAVAILABLE</span>(<span class="string">"NSInvocation and related APIs not available"</span>)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMethodSignature</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSMethodSignature</span> *)signatureWithObjCTypes:(<span class="keyword">const</span> <span class="keyword">char</span> *)types;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> numberOfArguments;</span><br><span class="line">- (<span class="keyword">const</span> <span class="keyword">char</span> *)getArgumentTypeAtIndex:(<span class="built_in">NSUInteger</span>)idx <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> frameLength;</span><br><span class="line">- (<span class="built_in">BOOL</span>)isOneway;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">const</span> <span class="keyword">char</span> *methodReturnType <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> methodReturnLength;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据方法签名获得</span></span><br><span class="line"><span class="built_in">NS_SWIFT_UNAVAILABLE</span>(<span class="string">"NSInvocation and related APIs not available"</span>)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSInvocation</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="built_in">NSInvocation</span> *)invocationWithMethodSignature:(<span class="built_in">NSMethodSignature</span> *)sig;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">NSMethodSignature</span> *methodSignature;</span><br><span class="line">- (<span class="keyword">void</span>)retainArguments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> argumentsRetained;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">assign</span>) <span class="keyword">id</span> target;</span><br><span class="line"><span class="keyword">@property</span> SEL selector;</span><br><span class="line">- (<span class="keyword">void</span>)getReturnValue:(<span class="keyword">void</span> *)retLoc;</span><br><span class="line">- (<span class="keyword">void</span>)setReturnValue:(<span class="keyword">void</span> *)retLoc; </span><br><span class="line">- (<span class="keyword">void</span>)getArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx;</span><br><span class="line">- (<span class="keyword">void</span>)setArgument:(<span class="keyword">void</span> *)argumentLocation atIndex:(<span class="built_in">NSInteger</span>)idx; </span><br><span class="line">- (<span class="keyword">void</span>)invoke;</span><br><span class="line">- (<span class="keyword">void</span>)invokeWithTarget:(<span class="keyword">id</span>)target; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></pre></details><h2 id="runtime-api"><a class="markdownIt-Anchor" href="#runtime-api"></a> Runtime API</h2><h3 id="类相关"><a class="markdownIt-Anchor" href="#类相关"></a> 类相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态创建一个类（参数：父类，类名，额外的内存空间）</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//注册一个类（要在类注册之前添加成员变量）</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//销毁一个类</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取isa指向的Class</span></span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//设置isa指向的Class</span></span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//判断一个OC对象是否为Class</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">object_isClass</span><span class="params">(id obj)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//判断一个Class是否为元类</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取父类</span></span></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></span><br></pre></td></tr></table></figure><h3 id="成员变量相关"><a class="markdownIt-Anchor" href="#成员变量相关"></a> 成员变量相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个实例变量信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//拷贝实例变量列表（最后需要调用free释放）</span></span></span><br><span class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//设置和获取成员变量的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span></span><br><span class="line"><span class="function">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//动态添加成员变量（已经注册的类是不能动态添加成员变量的）</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> * name, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> * types)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取成员变量的相关信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar v)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar v)</span></span></span><br></pre></td></tr></table></figure><h3 id="属性相关"><a class="markdownIt-Anchor" href="#属性相关"></a> 属性相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取一个属性</span></span><br><span class="line"><span class="keyword">objc_property_t</span> class_getProperty(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name) </span><br><span class="line"><span class="comment">//拷贝属性列表（最后需要调用free释放）</span></span><br><span class="line"><span class="keyword">objc_property_t</span> *class_copyPropertyList(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount) </span><br><span class="line"><span class="comment">//动态添加属性</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//动态替换属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attributes, <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取属性的一些信息</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> property)</span></span></span><br></pre></td></tr></table></figure><h3 id="方法相关"><a class="markdownIt-Anchor" href="#方法相关"></a> 方法相关</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得一个实例方法、类方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span><span class="params">(Class cls, SEL name)</span></span></span><br><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span><span class="params">(Class cls, SEL name)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//方法实现相关操作</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span> </span></span><br><span class="line"><span class="function">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//拷贝方法列表（最后需要调用free释放）</span></span></span><br><span class="line"><span class="function">Method *<span class="title">class_copyMethodList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//动态添加方法</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//动态替换方法</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取方法的相关信息（带有copy的需要调用free去释放）</span></span></span><br><span class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span></span><br><span class="line"><span class="function">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">method_copyReturnType</span><span class="params">(Method m)</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//选择器相关</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//用block作为方法实现</span></span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></span></span><br></pre></td></tr></table></figure><h2 id="具体应用"><a class="markdownIt-Anchor" href="#具体应用"></a> 具体应用</h2><ol><li>利用关联对象（AssociatedObject）给分类添加属性</li><li>遍历类的所有成员变量（修改textfield的占位文字颜色KVC、字典转模型、自动归档解档）</li><li>hook 方法（交换系统的方法）</li><li>利用消息转发机制解决方法找不到的异常问题</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>objectivec/swift 程序内存</title>
      <link href="/2018/07/13/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/objectivec-swift-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98/"/>
      <url>/2018/07/13/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/objectivec-swift-%E7%A8%8B%E5%BA%8F%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="程序的内存布局"><a class="markdownIt-Anchor" href="#程序的内存布局"></a> 程序的内存布局</h2><p><img src="/img/process_memory.jpg" alt="程序内存地址"></p><ol><li>代码段 __TEXT：编译之后的代码</li><li>数据段 __DATA<ol><li>字符串常量：比如NSString *str = @“123”</li><li>已初始化数据：已初始化的全局变量、静态变量等</li><li>未初始化数据：未初始化的全局变量、静态变量等</li></ol></li><li>栈stack：函数调用开销，比如局部变量。分配的内存空间地址越来越小</li><li>堆heap：通过alloc、malloc、calloc等动态分配的空间，分配的内存空间地址越来越大</li></ol><h2 id="tagged-pointer"><a class="markdownIt-Anchor" href="#tagged-pointer"></a> Tagged Pointer</h2><p>从64bit开始，iOS引入了Tagged Pointer技术，用于优化NSNumber、NSDate、NSString等小对象的存储</p><ul><li>没使用 tagged pointer 技术之前</li></ul><p>在没有使用Tagged Pointer之前， NSNumber等对象需要动态分配内存、维护引用计数等，NSNumber指针存储的是堆中NSNumber对象的地址值</p><ul><li>使用 tagged pointer 技术之后</li></ul><p>使用Tagged Pointer之后，NSNumber指针里面存储的数据变成了：<code>Tag + Data</code>，也就是将数据直接存储在了指针中</p><p>当指针不够存储数据时，才会使用动态分配内存的方式来存储数据</p><p>objc_msgSend内部判断Tagged Pointer类型，比如NSNumber的intValue方法，直接从指针提取数据，节省了以前的调用开销</p><h2 id="copy"><a class="markdownIt-Anchor" href="#copy"></a> copy</h2><p>拷贝的目的：产生一个副本对象，跟源对象互不影响</p><p>iOS提供了2个拷贝方法</p><ol><li>copy，不可变拷贝，产生不可变副本</li><li>mutableCopy，可变拷贝，产生可变副本</li></ol><p>深拷贝和浅拷贝</p><ol><li>深拷贝：内容拷贝，产生新的对象</li><li>浅拷贝：指针拷贝，没有产生新的对象</li></ol><p><img src="/img/copy_deep_shallow.jpeg" alt="copy"></p><h2 id="autoreleasepool"><a class="markdownIt-Anchor" href="#autoreleasepool"></a> autoreleasePool</h2><p><img src="https://changzw.github.io/2018/05/31/autoreleasepool-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/" alt="autoreleasePool"></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSProxy 做代理方法(解决 NSTimer 循环引用)</title>
      <link href="/2018/07/10/NSProxy%20%E5%81%9A%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95(%E8%A7%A3%E5%86%B3%20NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8)/"/>
      <url>/2018/07/10/NSProxy%20%E5%81%9A%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95(%E8%A7%A3%E5%86%B3%20NSTimer%20%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8)/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:41 GMT+0800 (CST) --><a id="more"></a><p><code>CADisplayLink</code> 跟 <code>NSTimer</code> 会对target产生强引用，如果target又对它们产生强引用，那么就会引发循环引用</p><p>两个定时器的差别</p><ol><li>CADisplayLink 是页面的刷新频率，如果掉帧，他的频率也会变低</li><li>NSTimer 是放在 RunLoop 里面的</li></ol><h2 id="解决循环引用的方法"><a class="markdownIt-Anchor" href="#解决循环引用的方法"></a> 解决循环引用的方法</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="comment">// 只有闭包才会拿到强引用</span></span><br><span class="line"><span class="comment">// strong ptr = weakptr  是没有用的</span></span><br><span class="line"><span class="comment">// weak ptr = strongptr  是弱引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span> target:weakSelf selector:<span class="keyword">@selector</span>(executeTimer) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.link = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:weakSelf selector:<span class="keyword">@selector</span>(executeTimer)];</span><br><span class="line">[<span class="keyword">self</span>.link addToRunLoop:[<span class="built_in">NSRunLoop</span> mainRunLoop] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br></pre></td></tr></table></figure><p><img src="/img/timer_cycle.jpg" alt="cycle reference"></p><h2 id="使用block"><a class="markdownIt-Anchor" href="#使用block"></a> 使用block</h2><p><img src="/img/timer_block.jpg" alt="block"></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1</span> repeats:<span class="literal">true</span> block:^(<span class="built_in">NSTimer</span> * _Nonnull timer) &#123;</span><br><span class="line">   [weakSelf executeTimer]</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h2 id="使用代理对象nsproxy"><a class="markdownIt-Anchor" href="#使用代理对象nsproxy"></a> 使用代理对象（NSProxy）</h2><p><img src="/img/timer_proxy.jpg" alt="proxy"></p><p>NSProxy 本身就是用来作消息转发的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt; </span>&#123;</span><br><span class="line">    Class isa;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel <span class="built_in">NS_SWIFT_UNAVAILABLE</span>(<span class="string">"NSInvocation and related APIs not available"</span>);</span><br><span class="line">- (<span class="keyword">void</span>)dealloc;</span><br><span class="line">- (<span class="keyword">void</span>)finalize;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector; </span><br><span class="line">- (<span class="built_in">BOOL</span>)allowsWeakReference API_UNAVAILABLE(macos, ios, watchos, tvos);</span><br><span class="line">- (<span class="built_in">BOOL</span>)retainWeakReference API_UNAVAILABLE(macos, ios, watchos, tvos);</span><br><span class="line"><span class="comment">// - (id)forwardingTargetForSelector:(SEL)aSelector; </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyProxy</span> </span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">  <span class="comment">// NSProxy对象不需要调用init，因为它本来就没有init方法</span></span><br><span class="line">  MyProxy *proxy = [MyProxy alloc];</span><br><span class="line">  proxy.target = target;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到需要代理的 方法签名</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)sel &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span>.target methodSignatureForSelector:sel];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接调用</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">  [invocation invokeWithTarget:<span class="keyword">self</span>.target];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>如果使用 NSObject 作代理</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyProxy</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)proxyWithTarget:(<span class="keyword">id</span>)target &#123;</span><br><span class="line">  MyProxy *proxy = [[MyProxy alloc] init];</span><br><span class="line">  proxy.target = target;</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>.target;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>两者有什么差别呢？<br>使用 NSObject 要执行所有的消息查找流程，而是用NSProxy 他会直接找到target对应消息</p><p>NSProxy 就只做消息转发提供的类，他的大部分方法都是通过消息转发找到 target 的消息列表里</p><h2 id="gcd-timer"><a class="markdownIt-Anchor" href="#gcd-timer"></a> GCD timer</h2><ol><li>跟RunLoop 没关，是系统时钟</li><li>tracingMode 当然也没有影响</li><li>精准</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"timer"</span>, DISPATCH_QUEUE_SERIAL); </span><br><span class="line"><span class="comment">// 创建定时器</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue); </span><br><span class="line"></span><br><span class="line">uint64_t start = <span class="number">2.0</span>; <span class="comment">// 2秒后开始执行</span></span><br><span class="line">uint64_t interval = <span class="number">1.0</span>; <span class="comment">// 每隔1秒执行</span></span><br><span class="line">dispatch_source_set_timer(timer,</span><br><span class="line">              dispatch_time(DISPATCH_TIME_NOW, start * <span class="built_in">NSEC_PER_SEC</span>),</span><br><span class="line">              interval * <span class="built_in">NSEC_PER_SEC</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">dispatch_source_set_event_handler_f(timer, fire);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动定时器</span></span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消定时器</span></span><br><span class="line">dispatch_source_cancel(timer);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 设计思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决资源竞争的方法，控制线程同步</title>
      <link href="/2018/07/10/thread/%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
      <url>/2018/07/10/thread/%E8%A7%A3%E5%86%B3%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%8E%A7%E5%88%B6%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>如何检查资源竞争的问题？<br>打开 thread Sanitizer 然后 run project</p><h2 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h2><p>锁是操作系统解决资源冲突的一种机制，用来控制线程同步<br>在 apple 平台中使用的锁有</p><p>OSSpinLock<br>os_unfair_lock<br>pthread_mutex<br>dispatch_semaphore<br>dispatch_queue(DISPATCH_QUEUE_SERIAL)<br>NSLock<br>NSRecursiveLock<br>NSCondition<br>NSConditionLock<br>@synchronized<br>automic</p><p>源码： <a href="http://www.gnustep.org/resources/downloads.php" target="_blank" rel="noopener">GNUstep</a>是GNU计划的项目之一，它将Cocoa的OC库重新开源实现了一遍</p><h3 id="osspinloc"><a class="markdownIt-Anchor" href="#osspinloc"></a> OSSpinLoc</h3><ol><li>OSSpinLock(自旋锁)，等待锁的线程会处于忙等(while(1))(不是内核级的轮询触发中断处理事件，而是用户级别的强占cpu资源)</li><li>不再安全，可能会出现优先级反转问题<ol><li>thread1.priority &gt; thread2.priority</li><li>thread1 得到cpu的时间片的几率多很多，没有获取lock，所以出于 while(1)</li><li>thread2 此时拿到 lock，可是拿不到 cpu，没办法执行</li></ol></li></ol><h3 id="os_unfair_lock"><a class="markdownIt-Anchor" href="#os_unfair_lock"></a> os_unfair_lock</h3><p>os_unfair_lock用于代替的OSSpinLock(iOS &gt;= 10)<br>从底层调用看，等待os_unfair_lock锁的线程会处于休眠状态，并非忙等</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">os_unfair_lock_</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> lock = os_unfair_lock()</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> globalQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"test"</span>, attributes: .concurrent)</span><br><span class="line">  <span class="keyword">let</span> group = <span class="type">DispatchGroup</span>()</span><br><span class="line">  <span class="keyword">while</span> a&lt;<span class="number">3</span> &#123;</span><br><span class="line">    globalQueue.async(group: group, execute: <span class="type">DispatchWorkItem</span>(block: &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"\(#function)---thread: \(Thread.current) value:\(a)"</span>)</span><br><span class="line">      os_unfair_lock_lock(&amp;lock)</span><br><span class="line">      a += <span class="number">1</span></span><br><span class="line">      os_unfair_lock_unlock(&amp;lock)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"value:\(a)"</span>) </span><br><span class="line">  group.notify(queue: globalQueue) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"final result: \(a)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread_mutex"><a class="markdownIt-Anchor" href="#pthread_mutex"></a> pthread_mutex</h3><p>互斥锁，等待锁的线程会处于休眠状态</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);</span><br></pre></td></tr></table></figure><h4 id="递归锁"><a class="markdownIt-Anchor" href="#递归锁"></a> 递归锁</h4><p>递归锁：允许同一个线程对一把锁进行重复加锁，当同一把锁上锁解锁的个数相同时，其他线程可继续执行</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_init(mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br></pre></td></tr></table></figure><h4 id="condition锁"><a class="markdownIt-Anchor" href="#condition锁"></a> condition锁</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化属性</span></span><br><span class="line">pthread_mutexattr_t attr;</span><br><span class="line">pthread_mutexattr_init(&amp;attr);</span><br><span class="line">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line"><span class="comment">// 初始化锁</span></span><br><span class="line">pthread_mutex_init(&amp;_mutex, &amp;attr);</span><br><span class="line"><span class="comment">// 销毁属性</span></span><br><span class="line">pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line"><span class="comment">// 初始化条件</span></span><br><span class="line">pthread_cond_init(&amp;_cond, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>生产者-消费者模式</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程1</span></span><br><span class="line"><span class="comment">// 删除数组中的元素</span></span><br><span class="line">- (<span class="keyword">void</span>)remove &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"remove - begin"</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span>.data.count == <span class="number">0</span>) &#123;<span class="comment">// 等待</span></span><br><span class="line">    pthread_cond_wait(&amp;_cond, &amp;_mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span>.data removeLastObject];</span><br><span class="line">  pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程2</span></span><br><span class="line"><span class="comment">// 往数组中添加元素</span></span><br><span class="line">- (<span class="keyword">void</span>)add &#123;</span><br><span class="line">  pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">  </span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span>.data addObject:<span class="string">@"Test"</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 信号</span></span><br><span class="line">  pthread_cond_signal(&amp;_cond);</span><br><span class="line">  <span class="comment">// 广播,激活所有等待该条件的锁</span></span><br><span class="line"><span class="comment">// pthread_cond_broadcast(&amp;_cond);</span></span><br><span class="line">  </span><br><span class="line">  pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nslocknsrecursivelocknsconditionlock"><a class="markdownIt-Anchor" href="#nslocknsrecursivelocknsconditionlock"></a> NSLock，NSRecursiveLock，NSConditionLock</h3><p>NSLock: mutex(PTHREAD_MUTEX_DEFAULT) 的封装<br>NSRecursiveLock: mutex(PTHREAD_MUTEX_RECURSIVE) 的封装<br>NSConditionLock: mutex 和 cond 的封装</p><h3 id="dispatch_semaphore"><a class="markdownIt-Anchor" href="#dispatch_semaphore"></a> dispatch_semaphore</h3><p>信号量<br>信号量的初始值，可以用来控制线程并发访问的最大数量<br>信号量的初始值为1，同 mutex，代表同时只允许1条线程访问资源，保证线程同步</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> res = dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<span class="comment">// 第二个参数是，等待时间，如果超过该时间thread 就会穿过这个信号量(res != 0)</span></span><br><span class="line">dispatch_semaphore_signal(semaphore);</span><br></pre></td></tr></table></figure><h3 id="synchronized"><a class="markdownIt-Anchor" href="#synchronized"></a> @synchronized</h3><p>内部是 os_unfair_lock 实现的</p><p>看下 objc4-756.2 <code>objc-sync.mm</code> 的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 调用</span></span><br><span class="line">objc_sync_enter(obj)</span><br><span class="line">objc_sync_exit(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部根据对象从字典中拿到 该对象数据列表&amp;锁</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCK_FOR_OBJ(obj) sDataLists[obj].lock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIST_FOR_OBJ(obj) sDataLists[obj].data</span></span><br><span class="line"><span class="keyword">static</span> StripedMap&lt;SyncList&gt; sDataLists;</span><br><span class="line"></span><br><span class="line"><span class="keyword">spinlock_t</span> *lockp = &amp;LOCK_FOR_OBJ(object);</span><br><span class="line">SyncData **listp = &amp;LIST_FOR_OBJ(object);</span><br></pre></td></tr></table></figure><p><code>spinlock_t</code> ??</p><p>在看下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">spinlock_t</span> = mutex_tt&lt;LOCKDEBUG&gt;;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">mutex_t</span> = mutex_tt&lt;LOCKDEBUG&gt;;</span><br></pre></td></tr></table></figure><p><code>mutex_tt</code> ??</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mutex_tt</span> :</span> <span class="keyword">nocopy_t</span> &#123;</span><br><span class="line">  os_unfair_lock mLock;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="atomic"><a class="markdownIt-Anchor" href="#atomic"></a> atomic</h3><p>atomic用于保证属性setter、getter的原子性操作，相当于在getter和setter内部加了线程同步的锁<br>看下 objc4-756.2 <a href="http://objc-accessors.mm" target="_blank" rel="noopener">objc-accessors.mm</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_getProperty</span><span class="params">(id self, SEL _cmd, <span class="keyword">ptrdiff_t</span> offset, BOOL atomic)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> object_getClass(self);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Retain release world</span></span><br><span class="line">  id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line">  <span class="keyword">if</span> (!atomic) <span class="keyword">return</span> *slot;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Atomic retain release world</span></span><br><span class="line">  <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">  slotlock.lock();</span><br><span class="line">  id value = objc_retain(*slot);</span><br><span class="line">  slotlock.unlock();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.</span></span><br><span class="line">  <span class="keyword">return</span> objc_autoreleaseReturnValue(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reallySetProperty</span><span class="params">(id self, SEL _cmd, id newValue, <span class="keyword">ptrdiff_t</span> offset, <span class="keyword">bool</span> atomic, <span class="keyword">bool</span> copy, <span class="keyword">bool</span> mutableCopy)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (offset == <span class="number">0</span>) &#123;</span><br><span class="line">    object_setClass(self, newValue);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  id oldValue;</span><br><span class="line">  id *slot = (id*) ((<span class="keyword">char</span>*)self + offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (copy) &#123;</span><br><span class="line">    newValue = [newValue copyWithZone:nil];</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mutableCopy) &#123;</span><br><span class="line">    newValue = [newValue mutableCopyWithZone:nil];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (*slot == newValue) <span class="keyword">return</span>;</span><br><span class="line">    newValue = objc_retain(newValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!atomic) &#123;</span><br><span class="line">    oldValue = *slot;</span><br><span class="line">    *slot = newValue;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">spinlock_t</span>&amp; slotlock = PropertyLocks[slot];</span><br><span class="line">    slotlock.lock();</span><br><span class="line">    oldValue = *slot;</span><br><span class="line">    *slot = newValue;</span><br><span class="line">    slotlock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  objc_release(oldValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它并不能保证使用属性的过程是线程安全的<br>eg: NSMutableArray 添加元素，线程不安全</p><h3 id="pthread_rwlock"><a class="markdownIt-Anchor" href="#pthread_rwlock"></a> pthread_rwlock</h3><p>读写锁, 读操作可以并发执行，但是 写操作只能一个个执行，写操作期间不能 read</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 初始化锁</span></span><br><span class="line">pthread_rwlock_init(&amp;_lock, <span class="literal">NULL</span>); </span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> read];</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    [<span class="keyword">self</span> write];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)read &#123;</span><br><span class="line">  pthread_rwlock_rdlock(&amp;_lock);</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">  </span><br><span class="line">  pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)write &#123;</span><br><span class="line">  pthread_rwlock_wrlock(&amp;_lock);</span><br><span class="line">  </span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%s"</span>, __func__);</span><br><span class="line">  </span><br><span class="line">  pthread_rwlock_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他同步的手段"><a class="markdownIt-Anchor" href="#其他同步的手段"></a> 其他同步的手段</h2><h3 id="group"><a class="markdownIt-Anchor" href="#group"></a> Group</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> group = <span class="type">DispatchGroup</span>() </span><br><span class="line">someQueue.async(group: group) &#123; ... your work ... &#125; someQueue.async(group: group) &#123; ... more work .... &#125; someOtherQueue.async(group: group) &#123; ... other work ... &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步通知</span></span><br><span class="line">group.notify(queue: <span class="type">DispatchQueue</span>.main) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span> </span><br><span class="line">  <span class="keyword">self</span>?.textLabel.text = <span class="string">"All jobs have completed"</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步等待</span></span><br><span class="line"><span class="keyword">if</span> group.wait(timeout: .now() + <span class="number">60</span>) == .timedOut &#123; </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"The jobs didn’t finish in 60 seconds"</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queue.dispatch(group: group) &#123;</span><br><span class="line">  <span class="comment">// count is 1 </span></span><br><span class="line">  group.enter() </span><br><span class="line">  <span class="comment">// count is 2 </span></span><br><span class="line">  someAsyncMethod &#123; <span class="keyword">defer</span> &#123; group.leave() &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步队列"><a class="markdownIt-Anchor" href="#同步队列"></a> 同步队列</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> threadSafeCountQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"..."</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _count = <span class="number">0</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">get</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> threadSafeCountQueue.sync &#123; _count &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> &#123;</span><br><span class="line">    threadSafeCountQueue.sync &#123; _count = newValue &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="thread-barrier"><a class="markdownIt-Anchor" href="#thread-barrier"></a> Thread barrier</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> threadSafeCountQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"..."</span>,attributes: .concurrent) </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _count = <span class="number">0</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123; </span><br><span class="line">  <span class="keyword">get</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> threadSafeCountQueue.sync &#123; <span class="keyword">return</span> _count &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">set</span> &#123; </span><br><span class="line">    threadSafeCountQueue.async(flags: .barrier) &#123;[<span class="keyword">unowned</span> <span class="keyword">self</span>] <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">self</span>._count = newValue </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dependency"><a class="markdownIt-Anchor" href="#dependency"></a> dependency</h3><h4 id="workitem"><a class="markdownIt-Anchor" href="#workitem"></a> WorkItem</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"xyz"</span>) </span><br><span class="line"><span class="keyword">let</span> backgroundWorkItem = <span class="type">DispatchWorkItem</span> &#123; &#125; </span><br><span class="line"><span class="keyword">let</span> updateUIWorkItem = <span class="type">DispatchWorkItem</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">backgroundWorkItem.notify(queue: <span class="type">DispatchQueue</span>.main,execute: updateUIWorkItem) </span><br><span class="line">queue.async(execute: backgroundWorkItem)</span><br></pre></td></tr></table></figure><h4 id="operation"><a class="markdownIt-Anchor" href="#operation"></a> Operation</h4><p>addDependance</p><h2 id="管理单例"><a class="markdownIt-Anchor" href="#管理单例"></a> 管理单例</h2><p>单例是个让人又爱又恨的东西<br>单例不是线程安全的，当多个 controllers 同时调用单例的时候，很容易引起线程冲突</p><p>swift 中实现单例很容易</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">PhotoManager</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 swift 中</p><ul><li>let 修饰的变量 thread-safe</li><li>var not thread-safe</li><li>Array and Dictionary are not thread-safe when declared mutable.</li><li>struct 是值类型，赋值过程都会发成 值copy，所以值类型的数据是线程安全的</li><li>swift 值copy是写时 copy（eg: 改变 array 中的一个元素）</li><li></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> thread </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬楼梯</title>
      <link href="/2018/07/03/%E7%AE%97%E6%B3%95/%E7%88%AC%E6%A5%BC%E6%A2%AF/"/>
      <url>/2018/07/03/%E7%AE%97%E6%B3%95/%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p><a href="https://leetcode-cn.com/problems/climbing-stairs" target="_blank" rel="noopener">爬楼梯</a></p><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。<br>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">注意：给定 n 是一个正整数。</span><br><span class="line">示例 <span class="number">1</span>：</span><br><span class="line">输入： <span class="number">2</span></span><br><span class="line">输出： <span class="number">2</span></span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">2</span> 阶</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>：</span><br><span class="line">输入： <span class="number">3</span></span><br><span class="line">输出： <span class="number">3</span></span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line"><span class="number">1.</span>  <span class="number">1</span> 阶 + <span class="number">1</span> 阶 + <span class="number">1</span> 阶</span><br><span class="line"><span class="number">2.</span>  <span class="number">1</span> 阶 + <span class="number">2</span> 阶</span><br><span class="line"><span class="number">3.</span>  <span class="number">2</span> 阶 + <span class="number">1</span> 阶</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li>可以查分为子问题，division 使用递归暴力解决问题<ol><li>找到递归关系</li><li>递归终止条件</li></ol></li><li>优化使用记忆化递归</li><li>动态规划</li></ol><p><img src="/img/division.jpg" alt="假设只有 5 个台阶"></p><p>根据图总共有 8 个方式走到第 5 个台阶</p><p>可以得到递归关系<br><code>climbStairs(i,n) = climbStairs(i+1,n) + climbStairs(i+2,n)</code></p><p>参数:<br>i: 当前第几层台阶<br>n: 总台阶数，为了提供终止递归条件</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">climbStairs_</span><span class="params">(<span class="number">_</span> i: Int, <span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; n &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> i == n &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> climbStairs_(i+<span class="number">1</span>, n) + climbStairs_(i+<span class="number">2</span>, n)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> climbStairs_(<span class="number">0</span>, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上图可以看出有很多重复的节点，每个节点都是一次 <code>climbStairs(i,n)</code> 调用所以可以给递归添加缓存</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> memo: [<span class="type">Int?</span>] = <span class="type">Array</span>(repeating: <span class="literal">nil</span>, <span class="built_in">count</span>: n)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int, <span class="number">_</span> memo: <span class="keyword">inout</span> [Int?])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">2</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> index = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> memo[index] != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> memo[index]!</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      memo[index] = climbStairs(n - <span class="number">1</span>, &amp;memo) + climbStairs(n - <span class="number">2</span>, &amp;memo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo[index]!</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> res = climbStairs(n, &amp;memo)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上都是自顶向下的逐一拆分子问题<br>分冶算法dp表存储路径</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> n &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> dp: [<span class="type">Int</span>] = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line">  <span class="keyword">while</span> i &lt;= n &#123;</span><br><span class="line">    dp.append(dp[i-<span class="number">1</span>] + dp[i - <span class="number">2</span>])</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">斐波那契数列</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">climbStairs</span><span class="params">(<span class="number">_</span> n: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">guard</span> n &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> n &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> first = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> second = <span class="number">2</span></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line">  <span class="keyword">while</span> i &lt;= n &#123;</span><br><span class="line">    <span class="keyword">let</span> third = first + second</span><br><span class="line">    first = second</span><br><span class="line">    second = third</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> second</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>合并两个有序数组</title>
      <link href="/2018/07/02/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
      <url>/2018/07/02/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">说明:</span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line">  </span><br><span class="line">示例:</span><br><span class="line">输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><p>有序数组合并，空间足够，那么不使用缓存处理</p><p>使用两个指针，分别指向两个数组的最后面<br>pt1 = m - 1<br>pt2 = n - 1<br>数组长度<br>len = 3 + 3<br>nums1 当前指针 curr = len - 1</p><p>因为 nums1 是连续的，nums2 放到 nums1 里面，那么当 nums2 遍历完后整个遍历就结束了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(<span class="number">_</span> nums1: <span class="keyword">inout</span> [Int], <span class="number">_</span> m: Int, <span class="number">_</span> nums2: [Int], <span class="number">_</span> n: Int)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> cur = m + n - <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> idx1 = m - <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> idx2 = n - <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span> idx2 &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> idx1 &gt;= <span class="number">0</span> &amp;&amp; nums1[idx1] &gt; nums2[idx2] &#123;</span><br><span class="line">      nums1[cur] = nums1[idx1]</span><br><span class="line">      idx1 -= <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">      nums1[cur] = nums2[idx2]</span><br><span class="line">      idx2 -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    cur -= <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2018/07/02/%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/07/02/%E7%AE%97%E6%B3%95/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">无重复字符的最长子串</a></p><h2 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">1</span>:</span><br><span class="line">输入: <span class="string">"abcabcbb"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"abc"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">2</span>:</span><br><span class="line">输入: <span class="string">"bbbbb"</span></span><br><span class="line">输出: <span class="number">1</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"b"</span>，所以其长度为 <span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">示例 <span class="number">3</span>:</span><br><span class="line">输入: <span class="string">"pwwkew"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">"wke"</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">"pwke"</span> 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><h2 id="分析"><a class="markdownIt-Anchor" href="#分析"></a> 分析</h2><ol><li>使用什么方法呢？<ol><li>每个是不是都是 ascii 码？如果是就尝试使用ascii做映射做</li><li>滑动窗口，从左向右滑动</li><li>动态规划缩小范围</li></ol></li></ol><p>先使用滑动窗口的方法做</p><h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口"></a> 滑动窗口</h3><ol><li>要有左右指针指明窗口位置，大小</li><li>右指针先行走做遍历，左指针根据具体条件向右滑动</li><li>当右指针走到尽头，遍历结束</li></ol><p>题目分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">left, right = <span class="number">0</span></span><br><span class="line">right: <span class="number">0</span> -&gt; n</span><br><span class="line">  left 向右移动条件：</span><br><span class="line">   s[right]是否存在在窗口子串中</span><br><span class="line">   left 移动到窗口子串中字符 s[right] 的下一个位置</span><br><span class="line">   记录长度length</span><br><span class="line">返回 <span class="built_in">max</span>(right - left, length)</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">left</span> = s.startIndex</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">right</span> = <span class="keyword">left</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> window = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> <span class="keyword">right</span> != s.endIndex &#123;</span><br><span class="line">    <span class="keyword">let</span> curChar = s[<span class="keyword">right</span>]</span><br><span class="line">    <span class="keyword">if</span> window.<span class="built_in">contains</span>(curChar) &#123;</span><br><span class="line">      <span class="keyword">let</span> index = window.firstIndex(of: curChar)!</span><br><span class="line">      <span class="keyword">let</span> <span class="built_in">distance</span> = window.<span class="built_in">distance</span>(from: window.startIndex, to: index)</span><br><span class="line">      <span class="keyword">left</span> = s.index(<span class="keyword">left</span>, offsetBy: <span class="built_in">distance</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">right</span> = s.index(after: <span class="keyword">right</span>)</span><br><span class="line">    window = <span class="type">String</span>(s[<span class="keyword">left</span>..&lt;<span class="keyword">right</span>])</span><br><span class="line">    len = <span class="built_in">max</span>(len, s.<span class="built_in">distance</span>(from: <span class="keyword">left</span>, to: <span class="keyword">right</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">leetcode 结果</span><br><span class="line"><span class="number">104</span> ms<span class="number">21.1</span> <span class="type">MB</span><span class="type">Swift</span></span><br></pre></td></tr></table></figure><p>使用 hashMap 缓存window 以后优化执行时间</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="number">_</span> s: String)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> itemMap: [<span class="type">Character</span>: <span class="type">Int</span>] = [:]</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> len = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> e <span class="keyword">in</span> s &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> idx = itemMap[e] &#123;</span><br><span class="line">      <span class="comment">//1. 使用max 去掉 left 之前的元素，之前是这样会有问题left = idx + 1</span></span><br><span class="line">      <span class="keyword">left</span> = <span class="built_in">max</span>(idx + <span class="number">1</span>, <span class="keyword">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    itemMap[e] = <span class="keyword">right</span></span><br><span class="line">    len = <span class="built_in">max</span>(len, <span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">right</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> len</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">44</span> ms<span class="number">21.1</span> <span class="type">MB</span></span><br></pre></td></tr></table></figure><p>对于上面注释的 1，如果使用 left = idx + 1 的话 eg “abba”<br>当 curr 指针指到第二个 b 时，left = 2<br>当 curr 指针指到第二个 a 时，left = 1<br>我们要做的是如何把 itemMap 中第二个 b 之前不在 window 的元素清空掉？<br>因为结果是 index 相关，所以直接使用 max 就可以了 left = max(idx + 1, left)</p><p>P.S: 使用 max方法截断数组</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关联对象</title>
      <link href="/2018/07/01/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/07/01/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="关联对象是什么"><a class="markdownIt-Anchor" href="#关联对象是什么"></a> 关联对象是什么</h2><ul><li>他是 objective-c runtime 机制中提供的一个接口，让用户在运行时，动态的给类添加关联属性</li></ul><h2 id="关联对象的主要作用"><a class="markdownIt-Anchor" href="#关联对象的主要作用"></a> 关联对象的主要作用</h2><p>开发中如何给 category 添加成员属性呢？或者说，如何在运行时给 class 关联新的属性？</p><ul><li>主要作用：给category 添加成员变量<ul><li>category 底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接添加。</li><li>分类中的 @property 只能声明属性，不提供 _name, getName, setName 的实现</li><li>类中 @property 提供 _name, getName, setName 的实现</li></ul></li></ul><h2 id="如何使用关联对象呢"><a class="markdownIt-Anchor" href="#如何使用关联对象呢"></a> 如何使用关联对象呢</h2><h3 id="关联对象接口"><a class="markdownIt-Anchor" href="#关联对象接口"></a> 关联对象接口</h3><p><code>&lt;objc/runtime.h&gt;</code> 中定义的以下三个允许你将任何键值在运行时关联到对象上的函数：</p><ul><li>objc_setAssociatedObject</li><li>objc_getAssociatedObject</li><li>objc_removeAssociatedObjects</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object   :表示关联者，是一个对象，变量名理所当然也是object</span></span><br><span class="line"><span class="comment">key      :获取被关联者的索引key</span></span><br><span class="line"><span class="comment">value    :被关联者</span></span><br><span class="line"><span class="comment">policy   :关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line"><span class="comment">//移除某个对象身上的所有关联的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure><h2 id="实际使用效果"><a class="markdownIt-Anchor" href="#实际使用效果"></a> 实际使用效果</h2><p>对比字典实现给分类添加 property</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> weight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Key [NSString stringWithFormat:@<span class="meta-string">"%p"</span>, self]</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *names_;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *weights_;</span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    weights_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    names_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    names_[Key] = name;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> names_[Key];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    weights_[Key] = @(weight);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    <span class="keyword">return</span> [weights_[Key] intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面使用全局字典的方式，给分类中的成员变量添加get，set 实现体</p><p>那么如何使用关联对象呢？</p><ul><li>关联对象实现分类添加成员属性</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 隐式参数_cmd == @selector(name)</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="关联对象源码分析"><a class="markdownIt-Anchor" href="#关联对象源码分析"></a> 关联对象源码分析</h2><p>关联对象也是用全局 hash 表来保存的。<br><a href="https://opensource.apple.com/tarballs/objc4/objc4-779.1.tar.gz" target="_blank" rel="noopener">objc4-779.1源码</a> 这个文件中 <a href="http://objc-references.mm" target="_blank" rel="noopener">objc-references.mm</a></p><p>关联对象的核心类</p><div align="left"><img src="/img/ao.jpeg" style="width:800px;height:370px"></div><ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">  <span class="comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">  <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsHashMap</span> :</span> <span class="keyword">public</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAssociationMap</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">  id _value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关联对象何时释放"><a class="markdownIt-Anchor" href="#关联对象何时释放"></a> 关联对象何时释放</h3><p>…… 不想看了，想看了再补充，总之他在所关联的对象释放后，会释放的</p><h3 id="关联时采用的协议"><a class="markdownIt-Anchor" href="#关联时采用的协议"></a> 关联时采用的协议</h3><table><thead><tr><th>Behavior</th><th>@property Equivalent</th><th>Description</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) 或 @property (unsafe_unretained)</td><td>指定一个关联对象的弱引用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (nonatomic, strong)</td><td>指定一个关联对象的强引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (nonatomic, copy)</td><td>指定一个关联对象的copy引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (atomic, strong)</td><td>指定一个关联对象的强引用，能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (atomic, copy)</td><td>指定一个关联对象的copy引用，能被原子化使用。</td></tr></tbody></table><h2 id="实际中使用关联对象的例子"><a class="markdownIt-Anchor" href="#实际中使用关联对象的例子"></a> 实际中使用关联对象的例子</h2><p><a href="https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/">使用 closures 添加 Gesture Recognizers</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>__weak 实现分析</title>
      <link href="/2018/06/01/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/weak-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
      <url>/2018/06/01/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/weak-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>runtime 维护了一个weak表，用于存储指向某个对象的所有weak指针。<br>weak表其实是一个hash（哈希）表：</p><ul><li>key是所指对象的地址</li><li>value是weak指针的地址（这个地址的值是所指对象指针的地址）数组</li></ul><h2 id="weak-源码分析"><a class="markdownIt-Anchor" href="#weak-源码分析"></a> weak 源码分析</h2><p>初始化一个新的weak指针指向对象的地址</p><p>__weak变量的存储</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 编译器模拟代码 */</span></span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Initialize a fresh weak pointer to some object location. </span></span><br><span class="line"><span class="comment"> * It would be used for code like: </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (The nil case) </span></span><br><span class="line"><span class="comment"> * __weak id weakPtr;</span></span><br><span class="line"><span class="comment"> * (The non-nil case) </span></span><br><span class="line"><span class="comment"> * NSObject *o = ...;</span></span><br><span class="line"><span class="comment"> * __weak id weakPtr = o;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * This function IS NOT thread-safe with respect to concurrent </span></span><br><span class="line"><span class="comment"> * modifications to the weak variable. (Concurrent weak clear is safe.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param location Address of __weak ptr. </span></span><br><span class="line"><span class="comment"> * @param newObj Object ptr. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> HaveOld &#123; DontHaveOld = <span class="literal">false</span>, DoHaveOld = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="keyword">enum</span> HaveNew &#123; DontHaveNew = <span class="literal">false</span>, DoHaveNew = <span class="literal">true</span> &#125;;</span><br><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">    *location = nil;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt;</span><br><span class="line">      (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;HaveOld haveOld, HaveNew haveNew,</span><br><span class="line">      CrashIfDeallocating crashIfDeallocating&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> id <span class="title">storeWeak</span><span class="params">(id *location, objc_object *newObj)</span> </span>&#123;</span><br><span class="line">  Class previouslyInitializedClass = nil;</span><br><span class="line">  id oldObj;</span><br><span class="line">  SideTable *oldTable;</span><br><span class="line">  SideTable *newTable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Acquire locks for old and new values.</span></span><br><span class="line">  <span class="comment">// Order by lock address to prevent lock ordering problems. </span></span><br><span class="line">  <span class="comment">// Retry if the old value changes underneath us.</span></span><br><span class="line"> retry:</span><br><span class="line">  <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">    oldObj = *location;</span><br><span class="line">    oldTable = &amp;SideTables()[oldObj];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    oldTable = nil;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">    newTable = &amp;SideTables()[newObj];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    newTable = nil;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (haveOld  &amp;&amp;  *location != oldObj) &#123;</span><br><span class="line">    SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">    <span class="keyword">goto</span> retry;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prevent a deadlock between the weak reference machinery</span></span><br><span class="line">  <span class="comment">// and the +initialize machinery by ensuring that no </span></span><br><span class="line">  <span class="comment">// weakly-referenced object has an un-+initialized isa.</span></span><br><span class="line">  <span class="keyword">if</span> (haveNew  &amp;&amp;  newObj) &#123;</span><br><span class="line">    Class cls = newObj-&gt;getIsa();</span><br><span class="line">    <span class="keyword">if</span> (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123;</span><br><span class="line">      SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line">      class_initialize(cls, (id)newObj);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this class is finished with +initialize then we're good.</span></span><br><span class="line">      <span class="comment">// If this class is still running +initialize on this thread </span></span><br><span class="line">      <span class="comment">// (i.e. +initialize called storeWeak on an instance of itself)</span></span><br><span class="line">      <span class="comment">// then we may proceed but it will appear initializing and </span></span><br><span class="line">      <span class="comment">// not yet initialized to the check above.</span></span><br><span class="line">      <span class="comment">// Instead set previouslyInitializedClass to recognize it on retry.</span></span><br><span class="line">      previouslyInitializedClass = cls; </span><br><span class="line">      <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Clean up old value, if any.</span></span><br><span class="line">  <span class="keyword">if</span> (haveOld) &#123;</span><br><span class="line">    weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assign new value, if any.</span></span><br><span class="line">  <span class="keyword">if</span> (haveNew) &#123;</span><br><span class="line">    newObj = (objc_object *)</span><br><span class="line">      weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, </span><br><span class="line">                  crashIfDeallocating);</span><br><span class="line">    <span class="comment">// weak_register_no_lock returns nil if weak store should be rejected</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set is-weakly-referenced bit in refcount table.</span></span><br><span class="line">    <span class="keyword">if</span> (newObj  &amp;&amp;  !newObj-&gt;isTaggedPointer()) &#123;</span><br><span class="line">      newObj-&gt;setWeaklyReferenced_nolock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do not set *location anywhere else. That would introduce a race.</span></span><br><span class="line">    *location = (id)newObj;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// No new value. The storage is not changed.</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (id)newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sidetable"><a class="markdownIt-Anchor" href="#sidetable"></a> SideTable</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">  <span class="comment">// spinlock_t 内部实现是 os_unfair_lock，用于对SideTable操作时进行加锁</span></span><br><span class="line">  <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">  <span class="comment">// 存储对象的引用计数</span></span><br><span class="line">  RefcountMap refcnts;</span><br><span class="line">  <span class="comment">// 存储对象的弱引用</span></span><br><span class="line">  <span class="keyword">weak_table_t</span> weak_table; </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 SideTables 是一个 StripedMap<sidetable></sidetable></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> StripedMap&lt;SideTable&gt;&amp; SideTables() &#123;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StripedMap</span> &#123;</span></span><br><span class="line">  <span class="comment">// 定义散列表的大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; StripeCount = <span class="number">8</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">enum</span> &#123; StripeCount = <span class="number">64</span> &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">PaddedT</span> &#123;</span></span><br><span class="line">    <span class="function">T value <span class="title">alignas</span><span class="params">(CacheLineSize)</span></span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  PaddedT <span class="built_in">array</span>[StripeCount];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 散列函数：通过指针地址计算出index</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">indexForPointer</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> addr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(p);</span><br><span class="line">    <span class="keyword">return</span> ((addr &gt;&gt; <span class="number">4</span>) ^ (addr &gt;&gt; <span class="number">9</span>)) % StripeCount;</span><br><span class="line">  &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发生散列冲突的时候，多个对象会共用一个SideTable，也就是多个对象会共用一个refcnts和weak_table。</p><p>weak_table_t</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">weak_table_t</span> &#123;</span></span><br><span class="line">  <span class="comment">// 存储weak_entry_t</span></span><br><span class="line">  <span class="keyword">weak_entry_t</span> *weak_entries;</span><br><span class="line">  <span class="comment">// 当前weak_entry_t的个数</span></span><br><span class="line">  <span class="keyword">size_t</span>    num_entries;</span><br><span class="line">  <span class="comment">// 当前数组能够容纳的最大个数</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> mask;</span><br><span class="line">  <span class="comment">// 发生散列冲突时，能够遍历的元素的最大个数</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> max_hash_displacement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>autoreleasepool 实现分析</title>
      <link href="/2018/05/31/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/autoreleasepool-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/"/>
      <url>/2018/05/31/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/autoreleasepool-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="autorelease-内部结构"><a class="markdownIt-Anchor" href="#autorelease-内部结构"></a> AutoRelease 内部结构</h2><p>AutoReleasePool 是利用语言上的特性，程序内存自动回收问题的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@autoreleasepool 是什么？在命令行中使用 clang -rewrite-objc main.m 让编译器重新改写这个文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">AtAutoreleasePool</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span> * atautoreleasepoolobj;</span><br><span class="line">  __AtAutoreleasePool() &#123; <span class="comment">// 构造函数</span></span><br><span class="line">     atautoreleasepoolobj = objc_autoreleasePoolPush();</span><br><span class="line">  &#125;</span><br><span class="line">  ~__AtAutoreleasePool() &#123;<span class="comment">// 析构函数</span></span><br><span class="line">     objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">void</span> * atautoreleasepoolobj = objc_autoreleasePoolPush(); </span><br><span class="line">    <span class="comment">// do whatever you want</span></span><br><span class="line">    objc_autoreleasePoolPop(atautoreleasepoolobj);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有 AutoreleasePool 相关的类，而在 objc 源码中搜 <code>objc_autoreleasePoolPush</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">objc_autoreleasePoolPush</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> AutoreleasePoolPage::push();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_autoreleasePoolPop</span><span class="params">(<span class="keyword">void</span> *ctxt)</span> </span>&#123;</span><br><span class="line">  AutoreleasePoolPage::pop(ctxt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="autoreleasepage-结构"><a class="markdownIt-Anchor" href="#autoreleasepage-结构"></a> AutoreleasePage 结构</h3><p><code>AutoreleasePage</code> 是实现 AutoreleasePool 的主要类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoreleasePoolPage</span> &#123;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">pthread_key_t</span> <span class="keyword">const</span> key = AUTORELEASE_POOL_KEY;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint8_t</span> <span class="keyword">const</span> SCRIBBLE = <span class="number">0xA3</span>;  <span class="comment">// 0xA3A3A3A3 after releasing</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> SIZE =</span><br><span class="line">#<span class="keyword">if</span> PROTECT_AUTORELEASEPOOL</span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// must be multiple of vm page size</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        PAGE_MAX_SIZE;  <span class="comment">// size and alignment, power of 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> <span class="keyword">const</span> COUNT = SIZE / <span class="keyword">sizeof</span>(id);<span class="comment">//一个page里要管理释放对象的个数</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTY_POOL_PLACEHOLDER ((id*)1)    <span class="comment">// 空池占位 </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POOL_BOUNDARY nil <span class="comment">// 释放池边界</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">magic_t</span> <span class="keyword">const</span> magic;  <span class="comment">// 用来校验 AutoreleasePoolPage 的结构是否完整</span></span><br><span class="line">  id *next;             <span class="comment">// 存储要用 AutoRelease 释放的对象的指针，初始化时指向 begin()</span></span><br><span class="line">  <span class="keyword">pthread_t</span> <span class="keyword">const</span> thread; <span class="comment">// 所属 thread</span></span><br><span class="line">  AutoreleasePoolPage * <span class="keyword">const</span> parent; <span class="comment">// 指向父结点，第一个结点的 parent 值为 nil</span></span><br><span class="line">  AutoreleasePoolPage *child;         <span class="comment">// 指向子结点，最后一个结点的 child 值为 nil</span></span><br><span class="line">  <span class="keyword">uint32_t</span> <span class="keyword">const</span> depth; <span class="comment">// 代表深度，从 0 开始，往后递增 1</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hiwat;       <span class="comment">// (high water mark)数据容纳的一个上限</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POOL_BOUNDARY 是一个边界对象 nil,之前的源代码变量名是 POOL_SENTINEL哨兵对象,用来区别每个page即每个 AutoreleasePoolPage 边界</p><h3 id="autoreleasepage-原理分析"><a class="markdownIt-Anchor" href="#autoreleasepage-原理分析"></a> AutoreleasePage 原理分析</h3><p>以上知道 AutoreleasePage 的结构，根据分析过程，思考为何如此设计</p><h4 id="pagepush"><a class="markdownIt-Anchor" href="#pagepush"></a> Page::push</h4><p>一开始调用的就是 <code>AutoreleasePage::push()</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *<span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  id *dest;</span><br><span class="line">  dest = autoreleaseFast(POOL_BOUNDARY); <span class="comment">// POOL_BOUNDARY 是 nil的宏定义</span></span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> id *<span class="title">autoreleaseFast</span><span class="params">(id obj)</span></span>&#123;</span><br><span class="line">  AutoreleasePoolPage *page = hotPage();</span><br><span class="line">  <span class="keyword">if</span> (page &amp;&amp; !page-&gt;full()) &#123;</span><br><span class="line">      <span class="keyword">return</span> page-&gt;add(obj);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (page) &#123;</span><br><span class="line">      <span class="keyword">return</span> autoreleaseFullPage(obj, page);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> autoreleaseNoPage(obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>autoreleaseFast</code> 插入新 oc 对象元素的时候分三种情况需要处理：</p><ul><li>page未满，直接插入到当前page</li><li>page已满，创建一个新page并插入</li><li>page不存在，创建一个新page并插入</li></ul><p>最终都会通过 <code>add</code> 方法把当前需要背 AutoRelease 的对象放到 page 中，next++</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id *<span class="title">add</span><span class="params">(id obj)</span></span>&#123;</span><br><span class="line">  assert(!full());</span><br><span class="line">  unprotect();</span><br><span class="line">  id *ret = next;</span><br><span class="line">  *next++ = obj;</span><br><span class="line">  protect();</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/runtime-autorelease-push.jpg" alt="push 的过程"></p><p>hotPage 是当前使用的页<br>对于autoreleasePool 多层嵌套问题，每一次push 首先插入 POOL_BOUNDARY 作为哨兵，然后接着 hotPage 中的 next 指针一个个添加对象</p><h4 id="pagepopctxt"><a class="markdownIt-Anchor" href="#pagepopctxt"></a> Page::pop(ctxt)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">void</span> *token)</span> </span>&#123;</span><br><span class="line">  AutoreleasePoolPage *page;</span><br><span class="line">  id *<span class="built_in">stop</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (token == (<span class="keyword">void</span>*)EMPTY_POOL_PLACEHOLDER) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hotPage()) &#123;</span><br><span class="line">      pop(coldPage()-&gt;<span class="built_in">begin</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      setHotPage(nil);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  page = pageForPointer(token);</span><br><span class="line">  <span class="built_in">stop</span> = (id *)token;</span><br><span class="line"></span><br><span class="line">  page-&gt;releaseUntil(<span class="built_in">stop</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// memory: delete empty children</span></span><br><span class="line">  <span class="keyword">if</span> (page-&gt;lessThanHalfFull()) &#123;</span><br><span class="line">     page-&gt;child-&gt;kill();</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (page-&gt;child-&gt;child) &#123;</span><br><span class="line">     page-&gt;child-&gt;child-&gt;kill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>token : pop到参数元素所在的地址,整体过程</p><ol><li>判断是不是EMPTY_POOL_PLACEHOLDER（<code>EMPTY_POOL_PLACEHOLDER是存储在TLS中的用来表示链表最上层没有元素的pool,这样就不用创建pool可以节约内存。TLS是什么以及具体实现这篇[文章](https://blog.csdn.net/cywosp/article/details/26469435)介绍的比较详细</code>）<ol><li>如果当前 pool里面有数据，就把里面的数据清空；否者就把hotPage设置为nil。</li><li>接着调用page-&gt;releaseUntil(stop)给此参数之前的所有对象发送release释放内存，对象内存释放之后终点page之前的page都会变成空的</li><li>最后调用page-&gt;child-&gt;kill()回收这些空page资源。</li></ol></li></ol><p><img src="/img/runtime-autorelease-pop.jpg" alt="pop 的过程"></p><h2 id="如何使用-autoreleasepool呢"><a class="markdownIt-Anchor" href="#如何使用-autoreleasepool呢"></a> 如何使用 AutoReleasePool呢</h2><p><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmAutoreleasePools.html" target="_blank" rel="noopener">官网文档</a></p><ol><li>使用 Cocoa 框架 创建的 thread 都会维护自己的 autorelease pool. 如果你用其他方式自己创建的 thread 需要添加 autorelease pool.</li><li>如果你的 thread 常驻的，会产生大量临时对象，那就需要使用 autorelease pool (like AppKit and UIKit do on the main thread)</li></ol><p>使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[array enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="comment">// 这里被一个局部@autoreleasepool包围着</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="主线程的-autoreleasepool"><a class="markdownIt-Anchor" href="#主线程的-autoreleasepool"></a> 主线程的 AutoReleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><p>当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</p><h3 id="子线程-autoreleasepool"><a class="markdownIt-Anchor" href="#子线程-autoreleasepool"></a> 子线程 AutoReleasePool</h3><p>子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？</p><ol><li>如果创建了 pool 产生的对象由 pool 管理</li><li>如果没有创建 pool 产生了 AutoRelease 对象，就会调用 autoreleaseNoPage 方法。在这个方法中，会自动帮你创建一个 hotpage，并调用 page-&gt;add(obj)将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏</li><li>Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</li></ol><h3 id="什么对象自动加入到-autoreleasepool中"><a class="markdownIt-Anchor" href="#什么对象自动加入到-autoreleasepool中"></a> 什么对象自动加入到 autoreleasepool中</h3><blockquote><p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/#autorelease" target="_blank" rel="noopener">深入理解RunLoop</a><br><a href="https://stackoverflow.com/questions/24952549/does-nsthread-create-autoreleasepool-automatically-now" target="_blank" rel="noopener">does NSThread create autoreleasepool automatically now</a><br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
            <tag> obj </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift 序列化Codable</title>
      <link href="/2018/05/10/swift%20%E8%AF%AD%E6%B3%95/swift-%E5%BA%8F%E5%88%97%E5%8C%96Codable/"/>
      <url>/2018/05/10/swift%20%E8%AF%AD%E6%B3%95/swift-%E5%BA%8F%E5%88%97%E5%8C%96Codable/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>序列化是将对象的状态信息转换为可以存储或传输的形式的过程(对象&lt;–&gt;I/O流)。<br>对象信息序列化以后变成 I/O 流：</p><ol><li>可以本地化存储（持久化对象）</li><li>网络通讯（网络传输对象）</li><li>定制协议，跨平台、跨语言通讯</li></ol><h2 id="swift-中的序列化"><a class="markdownIt-Anchor" href="#swift-中的序列化"></a> Swift 中的序列化</h2><ol><li>Swift 4.0 之前仍需要手动解析</li><li>Swift 4.0 以后，提供 Codable 协议</li><li>仍然存在问题</li></ol><h3 id="没有encoder和decoder"><a class="markdownIt-Anchor" href="#没有encoder和decoder"></a> 没有Encoder和Decoder</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json: [<span class="type">String</span> : <span class="type">Any</span>] = [</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"cap"</span>,</span><br><span class="line">  <span class="string">"points"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"this is a cat"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要手动解析</span></span><br><span class="line">  <span class="keyword">init</span>?(json: [<span class="type">String</span>: <span class="type">Any</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = json[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">      <span class="keyword">let</span> points = json[<span class="string">"points"</span>] <span class="keyword">as</span>? <span class="type">Int</span>,</span><br><span class="line">      <span class="keyword">let</span> description = json[<span class="string">"description"</span>] <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.points = points</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> p = <span class="type">Product</span>(json: json) &#123;</span><br><span class="line">  <span class="built_in">print</span>(p.name + <span class="string">" \(p.points) "</span> + p.description!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用编码器类型遵循-codableencodable-decodable-协议"><a class="markdownIt-Anchor" href="#使用编码器类型遵循-codableencodable-decodable-协议"></a> 使用编码器，类型遵循 Codable(Encodable &amp; Decodable) 协议</h3><ol><li>类型遵循Codable</li><li>Encode</li><li>Decode</li></ol><p>2017年6月发布的 Swift4.0 中的 Codable(Encodable &amp; Decodable) 协议，表明该协议具有被序列化和/或反序列化的能⼒。<br>Swift 标准库中的所有基本类型都遵循 <code>Codable</code> 协议，<code>Data，Date， URL，CGPoint 和 CGRect</code> 在内的许多 Apple 框架中的常⽤数据类型，也已经适配了 Codable。<br>自定义类型需要用户遵循 Codable协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 某个类型可以将⾃身编码为⼀种外部表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Encodable</span> </span>&#123; <span class="comment">/// 将值编码到给定的 encoder 中</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 某个类型可以从外部表示中解码得到⾃身</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123; <span class="comment">/// 通过从给定的 decoder 中解码来创建新的实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⼀旦你拥有 codable 类型的值，你可以创建⼀个编码器，并让它将这个值转换到像是 JSON 这样的序列化格式。反过来，⼀个解码器可以将序列化后的数据转回为它原来类型的⼀个实例。</p><p>Swift ⾃带两套编码解码器，<code>JSONEncoder/JSONDecoder</code> 和 <code>PropertyListEncoder/PropertyListDecoder</code>，它们存在于 Foundation 中。</p><h2 id="jsonencoderjsondecoder"><a class="markdownIt-Anchor" href="#jsonencoderjsondecoder"></a> JSONEncoder/JSONDecoder</h2><h3 id="不需要手动解码"><a class="markdownIt-Anchor" href="#不需要手动解码"></a> 不需要手动解码</h3><p>属性名 = key，属性类型 = value 类型一致，使用 decoder 对json解码，不需要手动解码了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"""</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "name": "Banana",</span></span><br><span class="line"><span class="string">        "points": 200,</span></span><br><span class="line"><span class="string">        "description": "A banana grown in Ecuador."</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "name": "Orange",</span></span><br><span class="line"><span class="string">        "points": 100</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span>.data(using: .utf8)!</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> products = <span class="keyword">try</span> decoder.decode([<span class="type">GroceryProduct</span>].<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following products are available:"</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\t\(product.name) (\(product.points) points)"</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> description = product.description &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t\t\(description)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上文无关，只描述下编码过程</span></span><br><span class="line"><span class="keyword">let</span> jsonEncoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="keyword">try</span>? jsonEncoder.encode(products)</span><br><span class="line"><span class="keyword">let</span> str = <span class="type">String</span>(decoding: jsonData!, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"><span class="keyword">let</span> jsonObject = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: jsonData!, options: .allowFragments)</span><br><span class="line"><span class="built_in">print</span>(jsonObject)</span><br></pre></td></tr></table></figure><p>GroceryProduct 类中属性都遵循 <code>Codable</code> 协议，Array也是，所以不需要实现 <code>encode(to encoder: Encoder)</code> 和 <code>init(from decoder: Decoder)</code> 方法</p><h3 id="需要手动解码"><a class="markdownIt-Anchor" href="#需要手动解码"></a> 需要手动解码</h3><h4 id="json中的key值与属性名称不一致"><a class="markdownIt-Anchor" href="#json中的key值与属性名称不一致"></a> json中的key值与属性名称不一致</h4><p>但是这个类型实际上并不⼀定需要是枚 举)。提供⾃定义的编码键是⼀种很简单，⽽且是声明式的改变类型编码的⽅式。在枚举中，我 们可以：</p><p>→ 使⽤明确给定的字符串值，在编码后的输出中重命名字段，或者</p><p>→ 将某个键从枚举中移除，以此完全跳过字段。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"""</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "product_name": "Bananas",</span></span><br><span class="line"><span class="string">        "product_cost": 200,</span></span><br><span class="line"><span class="string">        "description": "A banana grown in Ecuador."</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "product_name": "Oranges",</span></span><br><span class="line"><span class="string">        "product_cost": 100,</span></span><br><span class="line"><span class="string">        "description": "A juicy orange."</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span>.data(using: .utf8)!</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> name = <span class="string">"product_name"</span></span><br><span class="line">    <span class="keyword">case</span> points = <span class="string">"product_cost"</span></span><br><span class="line">    <span class="keyword">case</span> description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> products = <span class="keyword">try</span> decoder.decode([<span class="type">GroceryProduct</span>].<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following products are available:"</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\t\(product.name) (\(product.points) points)"</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> description = product.description &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t\t\(description)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型嵌套"><a class="markdownIt-Anchor" href="#类型嵌套"></a> 类型嵌套</h3><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 开发语言 </category>
          
          <category> swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Texture 布局</title>
      <link href="/2018/04/11/UI%20%E7%9B%B8%E5%85%B3/Texture-%E5%B8%83%E5%B1%80/"/>
      <url>/2018/04/11/UI%20%E7%9B%B8%E5%85%B3/Texture-%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="texture-目标优点"><a class="markdownIt-Anchor" href="#texture-目标优点"></a> Texture 目标&amp;优点</h2><p>Texture 的 Layout API是 UIKit AutoLayout 的高效替代品</p><ul><li>Fast：自动布局比 AutoLayout 快的多</li><li>Asynchronous &amp; Concurrent: Layout 在后台计算，所以用户交互不会被终端</li><li>Declarative：布局用不可变的数据结构声明。这使布局代码更易于开发，文档编制，代码审查，测试，调试，配置文件和维护。</li><li>Cacheable：布局结果是不可变的数据结构，因此可以在后台对其进行预先计算并进行缓存以提高用户的感知性能。</li><li>Extensible：易于在类之间共享代码。</li></ul><p>受 CSS Flexbox 模型启发<a href="https://changzw.github.io/2017/12/09/flexbox-model/">flexbox model</a></p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>Texture 布局系统的两个核心概念：</p><ol><li>Layout Specs</li><li>Layout Elements</li></ol><h3 id="layout-specs"><a class="markdownIt-Anchor" href="#layout-specs"></a> Layout Specs</h3><p>class <code>ASLayoutSpec</code><br>布局规范（layout specification）通过了解这些子布局元素之间的相互关系布局元素，是布局元素的容器。</p><h3 id="layout-elements"><a class="markdownIt-Anchor" href="#layout-elements"></a> Layout Elements</h3><p>protocol <code>&lt;ASLayoutElement&gt;</code><br>Layout Specs 包含并排列 Layout Elements<br>所有 <code>ASDisplayNodes</code> &amp; <code>ASLayoutSpecs</code> 都遵循<aslayoutelement>协议</aslayoutelement></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------------------ASStackLayoutSpec----------------------</span><br><span class="line">|  -----ASStackLayoutSpec-----  -----ASStackLayoutSpec-----  |</span><br><span class="line">|  |       ASImageNode       |  |       ASImageNode       |  |</span><br><span class="line">|  |       ASImageNode       |  |       ASImageNode       |  |</span><br><span class="line">|  ---------------------------  ---------------------------  |</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="layout-specs-子类"><a class="markdownIt-Anchor" href="#layout-specs-子类"></a> Layout Specs 子类</h2><ul><li>ASWrapperLayoutSpec</li><li>ASStackLayoutSpec</li><li>ASInsetLayoutSpec</li><li>ASOverlayLayoutSpec</li><li>ASBackgroundLayoutSpec</li><li>ASCenterLayoutSpec</li><li>ASRatioLayoutSpec</li><li>ASRelativeLayoutSpec</li><li>ASAbsoluteLayoutSpec</li><li>ASCornerLayoutSpec</li></ul><h3 id="aswrapperlayoutspec"><a class="markdownIt-Anchor" href="#aswrapperlayoutspec"></a> ASWrapperLayoutSpec</h3><p>它可以包裹一个 <code>ASLayoutElement</code> ，通过这个 element 的siez set 计算这个 element 的layout。</p><p>用于：<br><code>ASWrapperLayoutSpec</code> 对于在 <code>-layoutSpecThatFits:</code> 中包裹单个 node，返回spec.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a single subnode from layoutSpecThatFits:</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASWrapperLayoutSpec</span>(layoutElement: _subnode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set a size (but not position)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  _subnode.style.preferredSize = <span class="type">CGSize</span>(width: constrainedSize.<span class="built_in">max</span>.width,</span><br><span class="line">                                        height: constrainedSize.<span class="built_in">max</span>.height / <span class="number">2.0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASWrapperLayoutSpec</span>(layoutElement: _subnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asinsetlayoutspec"><a class="markdownIt-Anchor" href="#asinsetlayoutspec"></a> ASInsetLayoutSpec</h3><p>给 element 添加 inset margin。element 必须有 instrinsic size or 显示设置的size</p><div align="left"><img src="/img/texture-insetlayout.jpeg" alt="runloop" style="width:150px;height:96px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> insets = <span class="type">UIEdgeInsets</span>(top: <span class="number">10.0</span>, <span class="keyword">left</span>: <span class="number">10.0</span>, bottom: <span class="number">10.0</span>, <span class="keyword">right</span>: <span class="number">10.0</span>)</span><br><span class="line">  <span class="keyword">let</span> headerWithInset = <span class="type">ASInsetLayoutSpec</span>(insets: insets, child: textNode)</span><br><span class="line">  <span class="keyword">return</span> headerWithInset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asoverlaylayoutspec"><a class="markdownIt-Anchor" href="#asoverlaylayoutspec"></a> ASOverlayLayoutSpec</h3><p>重叠布局规范尺寸是根据 element 的尺寸计算得出的。在下图中，element 是蓝色层<br>重叠布局规范尺寸是根据包裹 element 的尺寸计算出来的。在下图中，子元素是蓝色图层。蓝色 element 会把他的 size 作为 <code>constrainedSize</code> 传给重叠布局元素（红色图层）。所以 element （蓝色layer）必须要有自己的 intrinsic size 或者 已经设置 size了。</p><div align="left"><img src="/img/texture-OverlayLayout.jpeg" alt="OverlayLayout" style="width:150px;height:96px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> backgroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.blue)</span><br><span class="line">  <span class="keyword">let</span> foregroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.red)</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASOverlayLayoutSpec</span>(child: backgroundNode, overlay: foregroundNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asbackgroundlayoutspec"><a class="markdownIt-Anchor" href="#asbackgroundlayoutspec"></a> ASBackgroundLayoutSpec</h3><p>ASBackgroundLayoutSpec 布局一个组件（蓝色），并拉伸其后的另一个组件作为背景（红色）。</p><p>background 规范 size根据 child 的尺寸计算。下图中，蓝色是child。将 blue child 的size 当做 <code>constrainedSize</code> 传给 background layout element (red layer). so child(blue layer) 一定要有自己的intrinsic size 或者 已经设置 size了。</p><div align="left"><img src="/img/Texture-BackgroundLayout.jpeg" alt="Texture-BackgroundLayout" style="width:150px;height:110px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> backgroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.red)</span><br><span class="line">  <span class="keyword">let</span> foregroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.blue)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASBackgroundLayoutSpec</span>(child: foregroundNode, background: backgroundNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ascenterlayoutspec"><a class="markdownIt-Anchor" href="#ascenterlayoutspec"></a> ASCenterLayoutSpec</h3><p>ASCenterLayoutSpec 在最大 <code>constrainedSize</code> 将放在 child 中心位置。<br>如果center spec’s width 和 height 没有限制，那么 ASCenterLayoutSpec 缩到 child 的size大小。</p><p><code>ASCenterLayoutSpec</code> 两个属性:</p><ul><li>centeringOptions. 确定 child 如何在中心规格内居中。选项包括：None, X, Y, XY.</li><li>sizingOptions. 确定中心规格将占用多少空间。选项包括：Default, minimum X, minimum Y, minimum XY.</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> subnode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.green, <span class="type">CGSize</span>(width: <span class="number">60.0</span>, height: <span class="number">100.0</span>))</span><br><span class="line">  <span class="keyword">let</span> centerSpec = <span class="type">ASCenterLayoutSpec</span>(centeringOptions: .<span class="type">XY</span>, sizingOptions: [], child: subnode)</span><br><span class="line">  <span class="keyword">return</span> centerSpec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asratiolayoutspec"><a class="markdownIt-Anchor" href="#asratiolayoutspec"></a> ASRatioLayoutSpec</h3><p>ASRatioLayoutSpec 使用固定宽高比来布局组件。ASRatioLayoutSpec 他的 <code>constrainedSize</code> 必须要配置 width or height。这样才能够使用 scale</p><p>ASRatioLayoutSpec 经常用于那些没有 intrinsic size 的node（ASNetworkImageNode or ASVideoNode）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="comment">// Half Ratio</span></span><br><span class="line">  <span class="keyword">let</span> subnode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.green, <span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100.0</span>))</span><br><span class="line">  <span class="keyword">let</span> ratioSpec = <span class="type">ASRatioLayoutSpec</span>(ratio: <span class="number">0.5</span>, child: subnode)</span><br><span class="line">  <span class="keyword">return</span> ratioSpec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asrelativelayoutspec"><a class="markdownIt-Anchor" href="#asrelativelayoutspec"></a> ASRelativeLayoutSpec</h3><p>并根据垂直和水平位置说明符对组件进行布局.<br>与“ 9部分”图像区域相似，可以将孩子放置在4个角的任意一个或4个边缘中的任意一个的中间以及中心。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> backgroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.blue)</span><br><span class="line">  <span class="keyword">let</span> foregroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.red, <span class="type">CGSize</span>(width: <span class="number">70.0</span>, height: <span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> relativeSpec = <span class="type">ASRelativeLayoutSpec</span>(horizontalPosition: .start,</span><br><span class="line">                                          verticalPosition: .start,</span><br><span class="line">                                          sizingOption: [],</span><br><span class="line">                                          child: foregroundNode)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> backgroundSpec = <span class="type">ASBackgroundLayoutSpec</span>(child: relativeSpec, background: backgroundNode)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asabsolutelayoutspec"><a class="markdownIt-Anchor" href="#asabsolutelayoutspec"></a> ASAbsoluteLayoutSpec</h3><p>通过设置其子节点的layoutPosition属性来指定其子节点的确切位置（x / y坐标）。<br>绝对布局比其他类型的布局更不灵活且难以维护。</p><p>唯一属性sizing: 确定 ASAbsoluteLayoutSpec 占用多少空间。选项包括：Default 和 Size to Fit。请注意，Size to Fit 选项将复制旧的ASStaticLayoutSpec的行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> maxConstrainedSize = constrainedSize.<span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Layout all nodes absolute in a static layout spec</span></span><br><span class="line">  guitarVideoNode.style.layoutPosition = <span class="type">CGPoint</span>.zero</span><br><span class="line">  guitarVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  nicCageVideoNode.style.layoutPosition = <span class="type">CGPoint</span>(x: maxConstrainedSize.width / <span class="number">2.0</span>, y: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line">  nicCageVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width / <span class="number">2.0</span>, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  simonVideoNode.style.layoutPosition = <span class="type">CGPoint</span>(x: <span class="number">0.0</span>, y: maxConstrainedSize.height - (maxConstrainedSize.height / <span class="number">3.0</span>))</span><br><span class="line">  simonVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width / <span class="number">2.0</span>, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  hlsVideoNode.style.layoutPosition = <span class="type">CGPoint</span>(x: <span class="number">0.0</span>, y: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line">  hlsVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width / <span class="number">2.0</span>, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASAbsoluteLayoutSpec</span>(children: [guitarVideoNode, nicCageVideoNode, simonVideoNode, hlsVideoNode])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ascornerlayoutspec"><a class="markdownIt-Anchor" href="#ascornerlayoutspec"></a> ASCornerLayoutSpec</h3><p>ASCornerLayoutSpec 提供一个简单方法，把 element 放在角落。</p><div align="left"><img src="/img/texture-CornerLayout.jpeg" alt="Texture-BackgroundLayout" style="width:80px;height:80px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Layout the center of badge to the top right corner of avatar.</span></span><br><span class="line">  <span class="keyword">let</span> cornerSpec = <span class="type">ASCornerLayoutSpec</span>(child: avatarNode, corner: badgeNode, location: .topRight)</span><br><span class="line">  <span class="comment">// Slightly shift center of badge inside of avatar.</span></span><br><span class="line">  cornerSpec.offset = <span class="type">CGPoint</span>(x: -<span class="number">3</span>, y: <span class="number">3</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aslayoutspec"><a class="markdownIt-Anchor" href="#aslayoutspec"></a> ASLayoutSpec</h3><ol><li>所有 layout spec 都继承自它</li><li>主要任务：处理 children 布局管理，用户可以 子类化它实现自己自定义 layout spec。</li><li>作为间隔区：充当 <code>ASStackLayoutSpec</code> 的spacer，当使用 <code>.flexGrow</code> and/or <code>.flexShrink</code> 时候</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> spacer = <span class="type">ASLayoutSpec</span>()</span><br><span class="line">  spacer.style.flexGrow = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">  stack.children = [imageNode, spacer, textNode]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asstacklayoutspecflexbox-container"><a class="markdownIt-Anchor" href="#asstacklayoutspecflexbox-container"></a> ASStackLayoutSpec(Flexbox Container)</h3><p>相关属性对照<a href="https://changzw.github.io/2017/12/09/flexbox-model/">flexbox-model</a></p><p>有 7 个属性：</p><ul><li>direction. 确定 stack 方向。如果已经设置了 horizontalAlignment and verticalAlignment, 他们会被重新解析一遍。导致 justifyContent and alignItems也会相应的变化。</li><li>spacing. 每个 child element 之间的距离.</li><li>horizontalAlignment. 指定 children 是如何水平对齐的。根据stack direction方向。设置对齐方式 会导致 justifyContent or alignItems 更新。</li><li>verticalAlignment. 指定 children 是如何垂直对齐的。根据stack direction方向。设置对齐方式 会导致 justifyContent or alignItems 更新。</li><li>justifyContent. 沿主轴的对齐方式.</li><li>alignItems. 沿交叉轴的方向布局.</li><li>flexWrap. element 堆叠成单行还是多行。默认为单行。</li><li>alignContent. 元素组成有多行，cross-axis方向空间充足，内容行的对齐方式。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mainStack = <span class="type">ASStackLayoutSpec</span>(direction: .horizontal,</span><br><span class="line">                                    spacing: <span class="number">6.0</span>,</span><br><span class="line">                                    justifyContent: .start,</span><br><span class="line">                                    alignItems: .center,</span><br><span class="line">                                    children: [titleNode, subtitleNode])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set some constrained size to the stack</span></span><br><span class="line">  mainStack.style.minWidth = <span class="type">ASDimensionMakeWithPoints</span>(<span class="number">60.0</span>)</span><br><span class="line">  mainStack.style.maxHeight = <span class="type">ASDimensionMakeWithPoints</span>(<span class="number">40.0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mainStack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="layout-element-属性"><a class="markdownIt-Anchor" href="#layout-element-属性"></a> Layout Element 属性</h2><ul><li>ASStackLayoutElement Properties：只会在 StackLayoutSpec 中的元素(node or layout spec)生效</li><li>ASAbsoluteLayoutElement Properties：只会在AbsoluateLayoutSpec中的元素（ subnode 或 layoutSpec）生效；</li><li>ASLayoutElement Properties：适用于所有 Node 和 layoutSpec；</li></ul><h3 id="asstacklayoutelementflex-item属性"><a class="markdownIt-Anchor" href="#asstacklayoutelementflex-item属性"></a> ASStackLayoutElement(flex-item)属性</h3><p>相关属性对照<a href="https://changzw.github.io/2017/12/09/flexbox-model/">flexbox-model</a></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>.style.spacingBefore</td><td>CGFloat</td><td>direction 上与前一个 node 的间隔</td></tr><tr><td>.style.spacingAfter</td><td>CGFloat</td><td>direction 上与后一个 node 的间隔</td></tr><tr><td>.style.flexGrow</td><td>Bool</td><td>子节点尺寸总和小于 minimum即存在剩余空间时，是否放大</td></tr><tr><td>.style.flexShrink</td><td>Bool</td><td>子节点总和大于 maximum，即空间不足时，是否缩小</td></tr><tr><td>.style.flexBasis</td><td>ASDimension</td><td>在使用flexGrow 或 flexShrink 属性之前，并且剩余空间被均分之前，指定item的初始size</td></tr><tr><td>.style.alignSelf</td><td>ASStackLayoutAlignSelf</td><td>item 在cross-axis方向布局方式，此属性会覆盖 layoutSpec(flex-container) 属性alignItems，可选值有：Auto、Start、End、Center、Stretch</td></tr><tr><td>.style.ascender</td><td>CGFloat</td><td>用于基线对齐，描述对象从顶部到其基线的距离</td></tr><tr><td>.style.descender</td><td>CGFloat</td><td>用于基线对齐，描述对象从基线到其底部的距离</td></tr></tbody></table><h3 id="asabsolutelayoutelement-属性"><a class="markdownIt-Anchor" href="#asabsolutelayoutelement-属性"></a> ASAbsoluteLayoutElement 属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>.style.layoutPosition</td><td>CGPoint</td><td>该对象在 ASAbsoluteLayoutSpec 中的位置</td></tr></tbody></table><h3 id="aslayoutelement-属性"><a class="markdownIt-Anchor" href="#aslayoutelement-属性"></a> ASLayoutElement 属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>.style.width</td><td>ASDimension</td><td>指定 ASLayoutElement 内容区域的宽度。minWidth 和 maxWidth 属性会覆盖 width，默认值为 ASDimensionAuto</td></tr><tr><td>.style.height</td><td>ASDimension</td><td>指定ASLayoutElement 内容区域的高度。minHeight 和 maxHeight 属性会覆盖 height，默认值为 ASDimensionAuto</td></tr><tr><td>.style.minWidth</td><td>ASDimension</td><td>minWidth 属性用于设置一个特定布局元素的最小宽度.它可以防止 width 属性值小于 minWidth 指定的值，minWidth 的值会覆盖 maxWidth 和 width. 默认值为 ASDimensionAuto</td></tr><tr><td>.style.maxWidth</td><td>ASDimension</td><td>maxWidth 属性用于设置一个特定布局元素的最大宽度.它可以防止 width 属性值大于 maxWidth 指定的值. maxWidth 的值会覆盖 width，minWidth 会覆盖 maxWidth. 默认值为 ASDimensionAuto</td></tr><tr><td>.style.minHeight</td><td>ASDimension</td><td>minHeight 属性用于设置一个特定布局元素的最小高度.它可以防止 height 属性值小于 minHeight 指定的值.minHeight 的值会覆盖 maxHeight 和 height. 默认值为 ASDimensionAuto</td></tr><tr><td>.style.maxHeight</td><td>ASDimension</td><td>maxHeight 属性用于设置一个特定布局元素的最大高度，它可以防止 height 属性值大于 maxHeight 指定的值.maxHeight 的值会覆盖 height，minHeight 会覆盖 maxHeight.默认值为 ASDimensionAuto</td></tr><tr><td>.style.preferredSize</td><td>CGSize</td><td>提供布局元素的建议 size.如果提供了 minSize 或 maxSize，并且 preferredSize 超过了这些值，则强制使用 minSize 或 maxSize.如果未提供 preferredSize，则布局元素的 size 默认为 calculateSizeThatFits: 方法提供的固有大小.此方法是可选的，但是对于没有固有大小或需要用与固有大小不同的的 size 进行布局的节点，则必须指定 preferredSize 或 preferredLayoutSize 中的一个，比如没这个属性可以在 ASImageNode 上设置，使这个节点的 size 和图片 size 不同, 警告：当 size 的宽度或高度是相对值时调用 getter 将进行断言</td></tr><tr><td>.style.minSize</td><td>CGSize</td><td>可选属性，为布局元素提供最小尺寸，如果提供，minSize 将会强制使用.如果父级布局元素的 minSize 小于其子级的 minSize，则强制使用子级的 minSize，并且其大小将扩展到布局规则之外,例如，如果给全屏容器中的某个元素设置 50％ 的 preferredSize 相对宽度，和 200pt 的 minSize 宽度，preferredSize 会在 iPhone 屏幕上产生 160pt 的宽度，但由于 160pt 低于 200pt 的 minSize 宽度，因此最终该元素的宽度会是 200pt</td></tr><tr><td>.style.maxSize</td><td>CGSize</td><td>可选属性，为布局元素提供最大尺寸，如果提供，maxSize 将会强制使用</td></tr><tr><td>.style.preferredLayoutSize</td><td>ASLayoutSize</td><td>为布局元素提供建议的相对 size.ASLayoutSize 使用百分比而不是点来指定布局.例如，子布局元素的宽度应该是父宽度的 50％.如果提供了可选的 minLayoutSize 或 maxLayoutSize，并且 preferredLayoutSize 超过了这些值，则将使用 minLayoutSize 或 maxLayoutSize</td></tr><tr><td>.style.minLayoutSize</td><td>ASLayoutSize</td><td>可选属性，为布局元素提供最小的相对尺寸， 如果提供，minLayoutSize 将会强制使用.如果父级布局元素的 minLayoutSize 小于其子级的 minLayoutSize，则会强制使用子级的 minLayoutSize，并且其大小将扩展到布局规则之外</td></tr><tr><td>.style.maxLayoutSize</td><td>ASLayoutSize</td><td>可选属性，为布局元素提供最大的相对尺寸.如果提供，maxLayoutSize 将会强制使用.如果父级布局元素的 maxLayoutSize 小于其子级的 maxLayoutSize，那么将强制使用子级的 maxLayoutSize，并且其大小将扩展到布局规则之外</td></tr></tbody></table><h2 id="layout-api-sizing"><a class="markdownIt-Anchor" href="#layout-api-sizing"></a> Layout API Sizing</h2><p>在Layout API中，理解复合尺寸类型的最简单方法是查看所有的 unit 之间的关系。</p><div align="left"><img src="/img/texture-sizing.jpeg" alt="texture-sizing" style="width:400px;height:100px"></div><h3 id="values-cgfloat-asdimension"><a class="markdownIt-Anchor" href="#values-cgfloat-asdimension"></a> Values (CGFloat, ASDimension)</h3><p>ASDimension本质上是一个普通的CGFloat，支持表示点值，相对百分比值或自动值。</p><p>unit 允许相同的API接受固定值和相对值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dimension returned is relative (%)</span></span><br><span class="line"><span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line"><span class="type">ASDimensionMakeWithFraction</span>(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dimension returned in points</span></span><br><span class="line"><span class="type">ASDimensionMake</span>(<span class="string">"70pt"</span>)</span><br><span class="line"><span class="type">ASDimensionMake</span>(<span class="number">70</span>)</span><br><span class="line"><span class="type">ASDimensionMakeWithPoints</span>(<span class="number">70</span>)</span><br></pre></td></tr></table></figure><h3 id="使用-asdimension-的例子"><a class="markdownIt-Anchor" href="#使用-asdimension-的例子"></a> 使用 ASDimension 的例子</h3><p>ASDimension 用于设置 <code>ASStackLayoutSpec</code> 中element 的 <code>flexBasis</code>. <code>flexBasis</code> 属性在 stack layout 中指定对象的初始大小，</p><p>在下面的视图中，我们希望左侧堆栈占据水平宽度的40％，右侧堆栈占据宽度的60％。</p><div align="left"><img src="/img/flexbasis.jpeg" alt="flexbasis" style="width:300px;height:450px"></div><p>为此，我们在水平堆栈的两个子级上设置.flexBasis属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.leftStack.style.flexBasis = <span class="type">ASDimensionMake</span>(<span class="string">"40%"</span>)</span><br><span class="line"><span class="keyword">self</span>.rightStack.style.flexBasis = <span class="type">ASDimensionMake</span>(<span class="string">"60%"</span>)</span><br><span class="line"></span><br><span class="line">horizontalStack.children = [<span class="keyword">self</span>.leftStack, <span class="keyword">self</span>.rightStack]</span><br></pre></td></tr></table></figure><h3 id="sizes-cgsize-aslayoutsize"><a class="markdownIt-Anchor" href="#sizes-cgsize-aslayoutsize"></a> Sizes (CGSize, ASLayoutSize)</h3><p>ASLayoutSize与CGSize相似，但是其宽度和高度值可以表示点或百分比值。宽度和高度的类型是独立的；一个可以是点或百分比值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ASLayoutSizeMake</span>(<span class="type">ASDimension</span> width, <span class="type">ASDimension</span> height);</span><br></pre></td></tr></table></figure><p>ASLayoutSize用于设置布局元素的 <code>.preferredLayoutSize</code> , <code>.minLayoutSize</code> 和 <code>.maxLayoutSize</code> 属性。它允许相同的API接受固定大小以及相对大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dimension type "Auto" indicates that the layout element may </span></span><br><span class="line"><span class="comment">// be resolved in whatever way makes most sense given the circumstances</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="type">ASDimensionMake</span>(.auto, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> height = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.preferredLayoutSize = <span class="type">ASLayoutSizeMake</span>(width, height)</span><br></pre></td></tr></table></figure><p>如果不需要相对值，则可以设置布局元素的.preferredSize，.minSize和.maxSize属性。这些属性采用常规CGSize值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layoutElement.style.preferredSize = <span class="type">CGSize</span>(width: <span class="number">30</span>, height: <span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>大多数时候，都不想同时限制宽度和高度。在这种情况下，可以使用ASDimension值分别设置布局元素的尺寸属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layoutElement.style.width     = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.minWidth  = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.maxWidth  = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line"></span><br><span class="line">layoutElement.style.height    = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.minHeight = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.maxHeight = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br></pre></td></tr></table></figure><h3 id="size-range-assizerange"><a class="markdownIt-Anchor" href="#size-range-assizerange"></a> Size Range (ASSizeRange)</h3><p>UIKit没有提供组合最小和最大CGSize的 struct。因此，创建了ASSizeRange以支持最小和最大CGSize对。</p><p>ASSizeRange通常用于布局API的内部。但是，作为输入传递给layoutSpecThatFits：的constrainedSize值是ASSizeRange。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span></span><br></pre></td></tr></table></figure><p>传递给ASDisplayNode子类的layoutSpecThatFits：方法的constrainedSize是节点应适合的最小和最大大小。constrainedSize中包含的最小CGSize和最大CGSize可用于调整节点的布局元素的大小。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> UI 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> swift </tag>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dealloc的调用时机</title>
      <link href="/2018/04/02/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/dealloc%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/"/>
      <url>/2018/04/02/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/dealloc%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>一般想法 delloc 会在对象释放的时候调用。用户重载该方法释放自己分配的堆控件，移除订阅……</p><p>在 MRC 中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">  <span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">self</span>.string = <span class="literal">nil</span>;</span><br><span class="line">  <span class="comment">// ... //</span></span><br><span class="line">  <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">  <span class="comment">// ... //</span></span><br><span class="line">  [<span class="keyword">super</span> dealloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ARC 中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">  <span class="comment">// ... //</span></span><br><span class="line">  <span class="comment">// 非Objc对象内存的释放，如CFRelease(...)</span></span><br><span class="line">  <span class="comment">// ... //</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两端代码：</p><ol><li>这个对象实例变量（Ivars）的释放去哪儿了？</li><li>没有显示的调用[super dealloc]，上层的析构去哪儿了？</li></ol><h2 id="arc文档"><a class="markdownIt-Anchor" href="#arc文档"></a> <a href="http://clang.llvm.org/docs/AutomaticReferenceCounting.html#dealloc" target="_blank" rel="noopener">ARC文档</a>中对dealloc过程的解释</h2><blockquote><p>A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.</p></blockquote><p>大概意思是：dealloc方法在最后一次release后被调用，但<strong>此时实例变量（Ivars）并未释放</strong>，<strong>父类的dealloc的方法将在子类dealloc方法返回后自动调用</strong></p><blockquote><p>The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.</p></blockquote><p>理解：<strong>ARC下对象的<code>Ivars</code>在根类[NSObject dealloc]中释放</strong>（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）</p><p>问题：</p><ol><li>[super delloc] 为什么可以在子类的 delloc 返回后自动调用</li><li>对象的 <code>Ivars</code> 为什么会在根类的 delloc 中释放</li></ol><h2 id="delloc-调用栈分析"><a class="markdownIt-Anchor" href="#delloc-调用栈分析"></a> delloc 调用栈分析</h2><p>调用过程</p><p><code>dealloc -&gt; _objc_rootDealloc -&gt; object_dispose -&gt; objc_destructInstance</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123; _objc_rootDealloc(self); &#125; </span><br><span class="line"><span class="keyword">void</span> _objc_rootDealloc(id obj) &#123; obj-&gt;rootDealloc(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::rootDealloc() &#123;</span><br><span class="line">  <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span>;  <span class="comment">// fixme necessary? </span></span><br><span class="line">  <span class="keyword">if</span> (fastpath(isa.nonpointer  &amp;&amp;  </span><br><span class="line">         !isa.weakly_referenced  &amp;&amp; <span class="comment">// 弱引用</span></span><br><span class="line">         !isa.has_assoc  &amp;&amp;         <span class="comment">// 关联对象</span></span><br><span class="line">         !isa.has_cxx_dtor  &amp;&amp;      <span class="comment">// 析构器</span></span><br><span class="line">         !isa.has_sidetable_rc)) &#123;  <span class="comment">// 散列表</span></span><br><span class="line">    assert(!sidetable_present());</span><br><span class="line">    <span class="built_in">free</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    object_dispose((id)<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">object_dispose</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">  objc_destructInstance(obj);</span><br><span class="line">  <span class="built_in">free</span>(obj);</span><br><span class="line">  <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* objc_destructInstance</span></span><br><span class="line"><span class="comment">* Destroys an instance without freeing memory.</span></span><br><span class="line"><span class="comment">* Calls C++ destructors.</span></span><br><span class="line"><span class="comment">* Calls ARC ivar cleanup.</span></span><br><span class="line"><span class="comment">* Removes associative references.</span></span><br><span class="line"><span class="comment">* Returns `obj`. Does nothing if `obj` is nil.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// Read all of the flags at once for performance.</span></span><br><span class="line">    <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</span><br><span class="line">    <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This order is important.</span></span><br><span class="line">    <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);<span class="comment">// 清理 ivars</span></span><br><span class="line">    <span class="keyword">if</span> (assoc) _object_remove_assocations(obj);<span class="comment">// 清理关联对象</span></span><br><span class="line">    obj-&gt;clearDeallocating();<span class="comment">// 清理 weak 表</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是这个方法<code>objc_destructInstance</code>，根据他的注释</p><ol><li>销毁实例对象，但没有释放内存</li><li>调用 C++ 的 destructor</li><li>掉用 ARC 将 ivar 清理</li><li>清理关联对象</li></ol><p>object_cxxDestruct 做了什么？<br>clearDeallocating 做了什么？</p><h3 id="cleardeallocating-清空弱引用"><a class="markdownIt-Anchor" href="#cleardeallocating-清空弱引用"></a> clearDeallocating 清空弱引用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> objc_object::clearDeallocating() &#123;</span><br><span class="line">  <span class="keyword">if</span> (slowpath(!isa.nonpointer)) &#123;</span><br><span class="line">    <span class="comment">// Slow path for raw pointer isa.</span></span><br><span class="line">    sidetable_clearDeallocating();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) &#123;</span><br><span class="line">    <span class="comment">// Slow path for non-pointer isa with weak refs and/or side table data.</span></span><br><span class="line">    clearDeallocating_slow();</span><br><span class="line">  &#125; </span><br><span class="line">  assert(!sidetable_present());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok clearDeallocating 用于清空引用计数表并清除弱引用表，将所有weak引用指nil</p><h3 id="object_cxxdestruct"><a class="markdownIt-Anchor" href="#object_cxxdestruct"></a> object_cxxDestruct</h3><p>从<a href="http://my.safaribooksonline.com/book/programming/objective-c/9780132908641/3dot-memory-management/ch03" target="_blank" rel="noopener">这篇文章</a>中：</p><blockquote><p>ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.</p></blockquote><p><code>object_cxxDestruct</code> 方法用于释放实例的 ivars</p><p>和《Effective Objective-C 2.0》中提到的：</p><blockquote><p>When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.</p></blockquote><p>可以了解到，.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_cxxDestruct</span><span class="params">(id obj)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!obj) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (obj-&gt;isTaggedPointer()) <span class="keyword">return</span>;</span><br><span class="line">  object_cxxDestructFromClass(obj, obj-&gt;ISA());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* object_cxxDestructFromClass.</span></span><br><span class="line"><span class="comment">* Call C++ destructors on obj, starting with cls's </span></span><br><span class="line"><span class="comment">*   dtor method (if any) followed by superclasses' dtors (if any), </span></span><br><span class="line"><span class="comment">*   stopping at cls's dtor (if any).</span></span><br><span class="line"><span class="comment">* Uses methodListLock and cacheUpdateLock. The caller must hold neither.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">object_cxxDestructFromClass</span><span class="params">(id obj, Class cls)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> (*dtor)(id); </span><br><span class="line">  <span class="comment">// Call cls's dtor first, then superclasses's dtors. </span></span><br><span class="line">  <span class="keyword">for</span> ( ; cls; cls = cls-&gt;superclass) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;hasCxxDtor()) <span class="keyword">return</span>; </span><br><span class="line">    dtor = (<span class="keyword">void</span>(*)(id))</span><br><span class="line">      lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct);</span><br><span class="line">    <span class="keyword">if</span> (dtor != (<span class="keyword">void</span>(*)(id))_objc_msgForward_impcache) &#123;</span><br><span class="line">      <span class="keyword">if</span> (PrintCxxCtors) &#123;</span><br><span class="line">        _objc_inform(<span class="string">"CXX: calling C++ destructors for class %s"</span>, </span><br><span class="line">               cls-&gt;nameForLogging());</span><br><span class="line">      &#125;</span><br><span class="line">      (*dtor)(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在实例对象的最后一个 release 方法调用，引用计数 = 0 调用dealloc</li><li>实例对象是否是 isTaggedPointer</li><li>通过 C++ 的析构器释放 ivars 成员变量内存</li><li>移除关联对象</li><li>移除 weak 引用相关数据，weak 变量置为 nil</li></ol><blockquote><p><a href="http://blog.sunnyxx.com/2014/04/02/objc_dig_arc_dealloc/" target="_blank" rel="noopener">ARC下dealloc过程及.cxx_destruct的探究</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>功能细节记录</title>
      <link href="/2018/03/24/%E5%8A%9F%E8%83%BD%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/03/24/%E5%8A%9F%E8%83%BD%E7%BB%86%E8%8A%82%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="使得系统setting页面中有自己app-的设置"><a class="markdownIt-Anchor" href="#使得系统setting页面中有自己app-的设置"></a> 使得系统setting页面中有自己app 的设置</h2><p><a href="https://www.jianshu.com/p/27fe365202b4" target="_blank" rel="noopener">iOS开发之Settings Bundle的使用</a></p><h2 id="app-和-app-extension-共享数据"><a class="markdownIt-Anchor" href="#app-和-app-extension-共享数据"></a> app 和 app Extension 共享数据</h2><ol><li>UserDefault 使用 groupName 初始化就可以了</li><li>FileManager 数据获取一定使用 URL 格式拼接 group，如果使用 String 会读不到数据</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22-比较级倒装</title>
      <link href="/2018/03/15/English/22-%E5%80%92%E8%A3%85%E5%8F%A5/"/>
      <url>/2018/03/15/English/22-%E5%80%92%E8%A3%85%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>倒装句是⼀种把动词（或助动词）移到主语前⾯的句型。以这个定义来看，⼀般 的疑问句都可以算是倒装句。</p><p>撇开疑问句这种只具有语法功能的倒装句不谈，⽐较值得研究的是具有修辞功能的倒装句。恰当地运⽤倒装句，可以强调语⽓、增强清楚性与简洁性，以及 更流畅地衔接前后的句⼦。以下分别就⼏种重要的倒装句来看看它倒装的条件， 以及可达到的修辞效果。</p><p><img src="/img/english/daozhuang.jpeg" alt="frame"></p><h2 id="比较级的倒装"><a class="markdownIt-Anchor" href="#比较级的倒装"></a> 比较级的倒装</h2><ol><li>Girls like cats more than boys.(不清楚） 这个句⼦可能有两种意思：</li><li>Girls like cats more than boys do. (⼥孩比男孩更喜欢猫。）</li><li>Girls like cats more than they like boys. (⼥孩比较喜欢猫，比较不喜欢男孩。）</li></ol><p>⽐较级的句型通常会牵涉到两个从句互相⽐较。这两个从句间应有重复的部 分才能⽐较。⼀旦有重复，就有省略的空间。但是如果省略不当，就会伤害句⼦ 的清楚性。</p><h2 id="关系从句的倒装"><a class="markdownIt-Anchor" href="#关系从句的倒装"></a> 关系从句的倒装</h2><h2 id="假设语气的倒装"><a class="markdownIt-Anchor" href="#假设语气的倒装"></a> 假设语气的倒装</h2><h2 id="引用句的倒装"><a class="markdownIt-Anchor" href="#引用句的倒装"></a> 引用句的倒装</h2><h2 id="类似-there-isare-的倒装"><a class="markdownIt-Anchor" href="#类似-there-isare-的倒装"></a> 类似 there is/are 的倒装</h2><h2 id="否定副词开头的倒装"><a class="markdownIt-Anchor" href="#否定副词开头的倒装"></a> 否定副词开头的倒装</h2><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>英语语法学习</title>
      <link href="/2018/03/15/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/03/15/English/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><p>使用数据：<a href="https://pan.baidu.com/s/1eza61t93vBhh2-cPejuPuw" target="_blank" rel="noopener">英语魔法师之语法俱乐部</a></p><p><img src="/img/english/english_grammer.jpeg" alt="english_grammer"></p><p>记录自己学习英语的过程</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 英语学习 </category>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> English </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何给自己的库添加前缀</title>
      <link href="/2018/03/12/%E5%A6%82%E4%BD%95%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80/"/>
      <url>/2018/03/12/%E5%A6%82%E4%BD%95%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E5%BA%93%E6%B7%BB%E5%8A%A0%E5%89%8D%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="在-rxswift中"><a class="markdownIt-Anchor" href="#在-rxswift中"></a> 在 Rxswift中</h2><ul><li>rx_tap : 原始语法The original syntax</li><li>rxTap : 同上，但是语义有歧义，如果不是 Rxswift库中却是用 rxABC 这样的</li><li>reactiveTap : 语义很清楚，但是太长了</li><li>rx.tap : ✨😲✨ 这样就很好了，一个漂亮的命名空间.</li></ul><h2 id="想法来源"><a class="markdownIt-Anchor" href="#想法来源"></a> 想法来源</h2><p><a href="https://github.com/apple/swift/blob/master/stdlib/public/core/LazySequence.swift" target="_blank" rel="noopener">LazySequence</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myArray.<span class="built_in">map</span> &#123; ... &#125;</span><br><span class="line">myArray.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>我们也可以在 RxCocoa 中有同样的语法:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> myButton.enabled &#123; ... &#125;</span><br><span class="line">myButton.rx.enabled.subscribeNext &#123; ... &#125;</span><br></pre></td></tr></table></figure><h2 id="实现细节"><a class="markdownIt-Anchor" href="#实现细节"></a> 实现细节</h2><h3 id="共享的代码"><a class="markdownIt-Anchor" href="#共享的代码"></a> 共享的代码</h3><p>我想我们可以把 <code>Reactive</code> protocol 转换成一个泛型 struct :</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span>&lt;<span class="title">Base</span>: <span class="title">AnyObject</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.base = base</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们扩展 <code>NSObjectProtocol</code> 协议来创建 <code>rx</code> 代理 :</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Reactive</span>(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>RxSwift 中的实现</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Reactive</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// Base object to extend.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.base = base</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A type that has reactive extensions.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ReactiveCompatible</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Extended type</span></span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">ReactiveBase</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(*, deprecated, message: <span class="string">"Use `ReactiveBase` instead."</span>)</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">CompatibleType</span> = <span class="type">ReactiveBase</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Reactive extensions.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">ReactiveBase</span>&gt;.<span class="type">Type</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Reactive extensions.</span></span><br><span class="line">  <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">ReactiveBase</span>&gt; &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ReactiveCompatible</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Reactive extensions.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt;.<span class="type">Type</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt;.<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="comment">// this enables using Reactive to "mutate" base type</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Reactive extensions.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> rx: <span class="type">Reactive</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Reactive</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="comment">// this enables using Reactive to "mutate" base object</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> class Foundation.NSObject</span><br><span class="line"><span class="comment">/// Extend NSObject with `rx` proxy.</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span>: <span class="title">ReactiveCompatible</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></pre></details><p>因为我们使用Self，所以我们需要扩展协议而不是具体类型。为了方便起见，我建议使用NSObjectProtocol，但我们也可以使用更有意义的协议，例如ReactiveCompatible或类似的协议。</p><details><summary>自己实现一个小的扩展</summary><p>使用 泛型（模板）创建自己的类型</p><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Czw</span>&lt;<span class="title">Base</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">let</span> base: <span class="type">Base</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> base: <span class="type">Base</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.base = base</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">CzwCompatible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">CzwBase</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> czw: <span class="type">Czw</span>&lt;<span class="type">CzwBase</span>&gt;.<span class="type">Type</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> czw: <span class="type">Czw</span>&lt;<span class="type">CzwBase</span>&gt; &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CzwCompatible</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> czw: <span class="type">Czw</span>&lt;<span class="type">Self</span>&gt;.<span class="type">Type</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Czw</span>&lt;<span class="type">Self</span>&gt;.<span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="comment">// this enables using Czw to "mutate" base type</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// Czw extensions.</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> czw: <span class="type">Czw</span>&lt;<span class="type">Self</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Czw</span>(<span class="keyword">self</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="comment">// this enables using Czw to "mutate" base object</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> class Foundation.NSObject</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSObject</span>: <span class="title">CzwCompatible</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">String</span>: <span class="title">CzwCompatible</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Czw</span> <span class="title">where</span> <span class="title">Base</span> == <span class="title">String</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x: <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="string">"233"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"1"</span></span><br><span class="line"><span class="keyword">let</span> b = a.czw.x</span><br></pre></td></tr></table></figure></pre></details><h3 id="具体扩展"><a class="markdownIt-Anchor" href="#具体扩展"></a> 具体扩展</h3><p>现在要将 reactive extensions 添加到类型，我们需要使用通用约束来扩展Reactive，而不是扩展目标类型本身。</p><p>因此对于下面这段代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIButton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> rx_tap: <span class="type">ControlEvent</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rx_controlEvent(.touchUpInside)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这么做</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIButton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> tap: <span class="type">ControlEvent</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> controlEvent(.touchUpInside)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存管理注意事项"><a class="markdownIt-Anchor" href="#内存管理注意事项"></a> 内存管理注意事项</h3><p>我看到的这种新语法的主要缺点是，它可能导致闭包内部不太直观的内存管理。<br>实际上，现在，响应式扩展属于Reactive类型（代理）。因此，无论在方法实现中使用 <code>self</code> 的什么地方，它都引用代理而不是 <code>base</code>。<br>但是由于这个 proxy 是一种值类型，无法弱化(weakify)它，并且每次在闭包内使用 <code>self</code> 时，它实际上都会 strongify（retain）其所有引用类型成员（即 <code>base</code> ）。<br>因此，在实现扩展时需要格外小心。 让我们以UISearchBar为例。</p><p>Sample 1 : 当前的实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UISearchBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> rx_delegate: <span class="type">DelegateProxy</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">RxSearchBarDelegateProxy</span>.proxyForObject(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> rx_text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> source: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = <span class="type">Observable</span>.deferred &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] () -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> text = <span class="keyword">self</span>?.text ?? <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">self</span>?.rx_delegate.observe(#selector(<span class="type">UISearchBarDelegate</span>.searchBar(<span class="number">_</span>:textDidChange:))) ?? <span class="type">Observable</span>.empty())</span><br><span class="line">    .<span class="built_in">map</span> &#123; a <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span> ?? <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    .startWith(text)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> bindingObserver = <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: <span class="keyword">self</span>) &#123; (searchBar, text: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">    searchBar.text = text</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="type">ControlProperty</span>(values: source, valueSink: bindingObserver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sample 2 : 错误内存管理的新实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UISearchBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> delegate: <span class="type">DelegateProxy</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">RxSearchBarDelegateProxy</span>.proxyForObject(<span class="keyword">self</span>.base)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> source: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = <span class="type">Observable</span>.deferred &#123; [<span class="keyword">weak</span> searchBar = <span class="keyword">self</span>.base] () -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> text = searchBar?.text ?? <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.delegate.observe(#selector(<span class="type">UISearchBarDelegate</span>.searchBar(<span class="number">_</span>:textDidChange:)))</span><br><span class="line">    .<span class="built_in">map</span> &#123; a <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span> ?? <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    .startWith(text)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> bindingObserver = <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: <span class="keyword">self</span>.base) &#123; (searchBar, text: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">    searchBar.text = text</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="type">ControlProperty</span>(values: source, valueSink: bindingObserver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sample 3 : 具有良好内存管理的新实现</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UISearchBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> delegate: <span class="type">DelegateProxy</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">RxSearchBarDelegateProxy</span>.proxyForObject(<span class="keyword">self</span>.base)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">ControlProperty</span>&lt;<span class="type">String</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> source: <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; = <span class="type">Observable</span>.deferred &#123; [<span class="keyword">weak</span> searchBar = <span class="keyword">self</span>.base] () -&gt; <span class="type">Observable</span>&lt;<span class="type">String</span>&gt; <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> text = searchBar?.text ?? <span class="string">""</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (searchBar?.rx.delegate.observe(#selector(<span class="type">UISearchBarDelegate</span>.searchBar(<span class="number">_</span>:textDidChange:))) ?? <span class="type">Observable</span>.empty())</span><br><span class="line">    .<span class="built_in">map</span> &#123; a <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> a[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span> ?? <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    .startWith(text)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> bindingObserver = <span class="type">UIBindingObserver</span>(<span class="type">UIElement</span>: <span class="keyword">self</span>.base) &#123; (searchBar, text: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">    searchBar.text = text</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="type">ControlProperty</span>(values: source, valueSink: bindingObserver)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键部分是在每个 sample 代码的第 10行<br>sample2 很容易通过 self 访问 <code>delegate</code> 观察者，因为 <code>delegate</code> 是在同一 <code>proxy</code> 扩展上定义的。但是这样做，闭包捕获了 <code>self</code> 并保留了其所有引用成员。因此，它取消了 <code>[weak searchBar = self.base]</code> 捕获列表</p><p>避免这种情况的正确方法是，总是在旧的实现中用 <code>base</code> 替换 <code>self</code> ，并且每当有rx_前缀时，都应该用 rx. 代理替换它。</p><blockquote><p><a href="https://github.com/ReactiveX/RxSwift/issues/826#issue-169876139" target="_blank" rel="noopener">Move from <code>rx_</code> prefix to a <code>rx.</code> proxy (for swift3 update ?)</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
            <tag> 翻译 </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rx+MVVM 实际应用</title>
      <link href="/2018/03/04/RxSwfit+RAC/Rx-MVVM-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/"/>
      <url>/2018/03/04/RxSwfit+RAC/Rx-MVVM-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><p>在看文 RxSwift 相关官方文档以后，知道 RxSwift 提供的多种功能以后，在实际场景中我们该怎么使用呢？</p><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>本篇文章只谈 rx 在 MVVM 中如何使用。<br>RxSwift 的功能强大，加上 Apple 提供的framework也提供了很多方式，来处理 MVVM 中事件监听回调……<br>使用 RxSwift 的优缺点不谈，单单说 RxSwift 代码零散在 View层，ViewModel层就让人困扰，到底什么样的事件流才是最合适的，这个因人而异，不过在团队开发中框架使用的方式要统一！<br>这样可以大大提高开发效率……</p><p>MVVM 复合模式的样子</p><p><img src="/img/mvvm.jpeg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ViewController</span><br><span class="line">    * 管理视图布局渲染</span><br><span class="line">    * 控制器生命周期</span><br><span class="line">    * 接受视图 actions，并作出相应</span><br><span class="line">    * 控制器跳转</span><br><span class="line">    * ....</span><br><span class="line"></span><br><span class="line">ViewModel</span><br><span class="line">    * 各种 <span class="built_in">Server</span> 的中介器</span><br><span class="line">    * netServer，DBServer，OtherManager……</span><br><span class="line">    * ....</span><br></pre></td></tr></table></figure><h2 id="为什么要在-mvvm-中使用-rx"><a class="markdownIt-Anchor" href="#为什么要在-mvvm-中使用-rx"></a> 为什么要在 MVVM 中使用 Rx</h2><p>抛去上段补充信息，只关注<font color="red">event/data</font>的流动方向，得出下图</p><p><img src="/img/mvvm_1.jpeg" alt=""></p><p>那么可不可以把 input/output 当做槽口</p><p><img src="/img/mvvm_2.jpeg" alt=""></p><p><strong>槽口！</strong>，如果看 RxSwift 源码可以看到大量的 sink(水槽) 类，sink 是连接各种 Observable 和 Observer 的管道:</p><p>Observable 流进水槽的槽口，流出（event(data?)）<br>Observer 流出水槽的槽口，接受（event(data?)）<br>所以，使用 RxSwift 来制作 View层和ViewModel 层的槽口，RxSwift vs 事件/数据的流程 vs App 流程</p><p><img src="/img/mvvm_3.jpeg" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">ViewModelType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">Input</span></span><br><span class="line">  <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line">  <span class="keyword">var</span> input: <span class="type">Input</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">var</span> output: <span class="type">Output</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个详细的 demo</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloViewModel</span>: <span class="title">ViewModelType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> input: <span class="type">Input</span></span><br><span class="line">  <span class="keyword">let</span> output: <span class="type">Output</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Input</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">AnyObserver</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">    <span class="keyword">let</span> validate: <span class="type">AnyObserver</span>&lt;<span class="type">Void</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Output</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> greeting: <span class="type">Driver</span>&lt;<span class="type">String</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> nameSubject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> validateSubject = <span class="type">PublishSubject</span>&lt;<span class="type">Void</span>&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> greeting = validateSubject</span><br><span class="line">      .withLatestFrom(nameSubject)</span><br><span class="line">      .<span class="built_in">map</span> &#123; name <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello \(name)!"</span></span><br><span class="line">      &#125;</span><br><span class="line">      .asDriver(onErrorJustReturn: <span class="string">":-("</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.output = <span class="type">Output</span>(greeting: greeting)</span><br><span class="line">    <span class="keyword">self</span>.input = <span class="type">Input</span>(name: nameSubject.asObserver(), validate: validateSubject.asObserver())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Subject是私有的。没有非法侵入ViewModel的方式，只能通过公共的Input和output属性。</p><p>ViewModel 可以插入到任何view，容易单元测试和Rx绑定。<br><a href="https://gist.github.com/MartinMoizard/449be0d30920010210988f1773a2ca90" target="_blank" rel="noopener">view 使用这种方式绑定的 demo</a></p><h2 id="cell-监听复用问题"><a class="markdownIt-Anchor" href="#cell-监听复用问题"></a> cell 监听复用问题</h2><p>cell 引用的 Observable <code>tableView:cellForRowAtIndexPath:</code> 中被订阅，该方法反复调用的过程 cell 不会被释放，只是被复用，所以每次 cell 在该方法中订阅的时候都应该先解除上一次的订阅。如果不解除，这个 Observable 会有多个订阅者</p><p>那么如何有效的解除上次 cell 复用产生的订阅呢？</p><p>思路一：有三种实现方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"><span class="comment">// Clean Rx subscriptions</span></span><br><span class="line">  disposeBag = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bind</span><span class="params">(to viewModel: ViewModel)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> bag = <span class="type">DisposeBag</span>()</span><br><span class="line">  nameTextField.rx</span><br><span class="line">      .text</span><br><span class="line">      .orEmpty</span><br><span class="line">      .bind(to: viewModel.input.name)</span><br><span class="line">      .disposed(by: bag)</span><br><span class="line">  disposeBag = bag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">super</span>.prepareForReuse()</span><br><span class="line"><span class="comment">// Clean Rx subscriptions</span></span><br><span class="line">  disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三那种 使用 swizzle <a href="https://github.com/bmoliveira/Cell-Rx" target="_blank" rel="noopener">cell-rx</a></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UITableViewCell</span>: <span class="title">SelfAware</span> </span>&#123;</span><br><span class="line">  <span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">rx_prepareForReuse</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.rx_prepareForReuse()</span><br><span class="line">    rx_reusableDisposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">swizzle</span>() </span>&#123;</span><br><span class="line">    <span class="comment">// make sure this isn't a subclass</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">self</span> === <span class="type">UITableViewCell</span>.<span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">self</span>.swizzleMethodForSelector(#selector(<span class="keyword">self</span>.prepareForReuse), withMethodForSelector: #selector(<span class="keyword">self</span>.rx_prepareForReuse))</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">awake</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">UITableViewCell</span>.swizzle()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>or 自定义 Rx extension，使用 takeUntil(rx.prepareReuse)</p><p>引用：</p><blockquote><p><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">RxSwift + MVVM: how to feed ViewModels</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>swift 语法小记</title>
      <link href="/2018/02/09/swift%20%E8%AF%AD%E6%B3%95/swift-%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/"/>
      <url>/2018/02/09/swift%20%E8%AF%AD%E6%B3%95/swift-%E8%AF%AD%E6%B3%95%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="swift-语法"><a class="markdownIt-Anchor" href="#swift-语法"></a> Swift 语法</h2><h3 id="swift-中位移枚举如何表示"><a class="markdownIt-Anchor" href="#swift-中位移枚举如何表示"></a> Swift 中位移枚举如何表示</h3><p>OC 中位移枚举</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位移枚举</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, Direction) &#123;</span><br><span class="line">    Top       = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,   <span class="comment">// 0000 0001,</span></span><br><span class="line">    Bottom    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,   <span class="comment">// 0000 0010,</span></span><br><span class="line">    Left      = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,   <span class="comment">// 0000 0100,</span></span><br><span class="line">    Right     = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,   <span class="comment">// 0000 1000,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Swift中位移枚举,替换方案是选项集合(OptionSet)</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Direction</span>: <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> rawValue: <span class="type">UInt</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> top = <span class="type">Direction</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> bottom = <span class="type">Direction</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="keyword">left</span> = <span class="type">Direction</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="keyword">right</span> = <span class="type">Direction</span>(rawValue: <span class="number">1</span> &lt;&lt; <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在<span class="type">Swift</span>就不再使用 &amp;, | 运算了， 如果想使用多选，需要用数组代替，例如</span><br><span class="line"></span><br><span class="line">```swift</span><br><span class="line"><span class="keyword">let</span> options: <span class="type">Direction</span> = [.top, .bottom]  <span class="comment">// 与OC中 Top | Bottom 相同的作用</span></span><br><span class="line">options.<span class="built_in">contains</span>(.top)</span><br><span class="line">options.<span class="built_in">contains</span>(.<span class="keyword">left</span>)</span><br></pre></td></tr></table></figure><h3 id="counter-loop"><a class="markdownIt-Anchor" href="#counter-loop"></a> Counter loop</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = (<span class="number">0</span>..&lt;<span class="number">10</span>).generate()</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">let</span> i = g.next() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate over every other integer</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>.<span class="built_in">stride</span>(to: <span class="number">10</span>, by: <span class="number">2</span>) &#123; <span class="built_in">print</span>(i) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// skip a specific number</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> (<span class="number">0</span>..&lt;<span class="number">10</span>).<span class="built_in">filter</span>(&#123; $<span class="number">0</span> != <span class="number">5</span> &#125;) &#123; <span class="built_in">print</span>(i) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"four"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok so this one’s a bit convoluted...</span></span><br><span class="line"><span class="keyword">let</span> everyOther = a.<span class="built_in">enumerate</span>().<span class="built_in">filter</span> &#123; $<span class="number">0.0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;.<span class="built_in">map</span> &#123; $<span class="number">0.1</span> &#125;.<span class="built_in">lazy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> everyOther &#123;</span><br><span class="line">    <span class="built_in">print</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译符"><a class="markdownIt-Anchor" href="#编译符"></a> 编译符</h3><p>@discardableResult</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">sum(a: <span class="number">1</span>, b: <span class="number">2</span>) <span class="comment">// Result of call to 'sum(a:b:)' is unused</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示取消不使用返回值的警告</span></span><br><span class="line"><span class="meta">@discardableResult</span> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(a: Int, b: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line">sum(a: <span class="number">1</span>, b: <span class="number">2</span>) <span class="comment">// No longer produce the warning</span></span><br></pre></td></tr></table></figure><p>在 Objective-c中</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)greeting __attribute__((warn_unused_result));</span><br></pre></td></tr></table></figure><h3 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h3><p>使用 String(describing: Class.self) 方法 代替 NSStringFromClass 得到 类的字符串</p><h3 id="gcd"><a class="markdownIt-Anchor" href="#gcd"></a> GCD</h3><h4 id="once"><a class="markdownIt-Anchor" href="#once"></a> once</h4><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 开发语言 </category>
          
          <category> swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Texture 浅析</title>
      <link href="/2018/02/09/UI%20%E7%9B%B8%E5%85%B3/Texture-%E6%B5%85%E6%9E%90/"/>
      <url>/2018/02/09/UI%20%E7%9B%B8%E5%85%B3/Texture-%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><h2 id="nodes"><a class="markdownIt-Anchor" href="#nodes"></a> Nodes</h2><p><code>ASDisplayNode</code> 是 <code>UIView</code> 的抽象层, 就像 <code>UIView</code> 是 <code>CALayer</code> 的抽象层一样. 不同的是 UIKit 只能运行在主线程，nodes 是线程安全的，可以在后台线程上并行实例化和配置它们的整个层次结构。</p><p><img src="/img/Texture.jpg" alt="texture_node"></p><h2 id="子类化"><a class="markdownIt-Anchor" href="#子类化"></a> 子类化</h2><h3 id="自定义-asdisplaynode-子类"><a class="markdownIt-Anchor" href="#自定义-asdisplaynode-子类"></a> 自定义 ASDisplayNode 子类</h3><p>如果想使用 Texture，需要自定义类继承自 <code>ASDisplayNode</code> 需要注意方法：</p><p>注意：UIKit 相关属性方法只能在 main thread 中使用，注意 <code>ASDisplayNode</code> 方法在 main/background thread 中实现很重要</p><table><thead><tr><th>ASDisplayNode方法</th><th>线程</th><th>功能描述</th></tr></thead><tbody><tr><td>init</td><td>background</td><td>这个方法很少用（因为background），使用 nodeBlocks 的时调用，初始化方法调用才可以调用其他方法</td></tr><tr><td>didLoad</td><td>main</td><td>类似 viewDidLoad，添加 UIKit objects初始化，配置objects 属性，事件……</td></tr><tr><td>layoutSpecThatFits</td><td>background</td><td>布局代码(返回 layout spec object布局nodes)，layout spec object 对象不会cache，而是在合适(啥时候？)的时候调用重新创建</td></tr><tr><td>layout</td><td>main</td><td>调用 super.layout 方法会调用layoutSpecThatFits，这样所有的 nodes 都会布局完成，类似 viewWillLayoutSubviews 方法，很少使用，如果想这样subnode.frame = self.bounds 那就用吧</td></tr></tbody></table><h3 id="自定义-asviewcontroller-子类"><a class="markdownIt-Anchor" href="#自定义-asviewcontroller-子类"></a> 自定义 ASViewController 子类</h3><p><code>ASViewController</code> 是 <code>UIViewController</code> 的子类，所以 <code>ASViewController</code> 需要在 main thread 中使用。</p><p><code>ASViewController</code> 管理 node 就像 <code>UIViewController</code> 管理 view 一样<br>但是 <code>ASViewController</code> 的指派构造函数与 UIViewController 不同</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span>() &#123;</span><br><span class="line">  <span class="keyword">let</span> pagerNode = <span class="type">ASPagerNode</span>()</span><br><span class="line">  <span class="keyword">super</span>.<span class="keyword">init</span>(node: pagerNode)</span><br><span class="line"></span><br><span class="line">  pagerNode.setDataSource(<span class="keyword">self</span>)</span><br><span class="line">  pagerNode.setDelegate(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>-loadView</strong><br>在 loadView 如果你不改变 <code>self.view</code> 的值，就可以，不过建议你使用 <code>viewDidLoad</code> 方法. 调用 [super loadView] 会设置 <code>node.view</code> .</p><p><strong>-viewDidLoad</strong><br>在 <code>ASViewController</code> 的生命周期中，这个方法只会，在 <code>loadView</code> 调用以后立即调用一次。那些只会调用一次的配置放在这里最好。</p><p>布局代码不应该放在这里，因为几何元素改变这个方法不会调用（当然可以在viewDidLoad中配置监听者模式监听）</p><p><strong>-viewWillLayoutSubviews</strong><br>该方法与 <code>node</code> 的 <code>-layout</code> 方法在同一时间被调用，并且在ASViewController的生命周期中可能被多次调用。<br>只要 ASViewController 的 node 的 bounds 改变（包括旋转，分屏，键盘显示），以及层次结构发生了更改（添加，删除或更改了 children），它就会被调用<br>为了保持一致性，最佳做法是将所有布局代码放入此方法中。因为它的调用频率不高，所以不直接依赖于大小的代码也属于此处。</p><p><strong>-viewWillAppear: / -viewDidDisappear:</strong><br>这些方法在ASViewController的node出现在屏幕上之前（最早可见）和刚从视图层次结构中删除之后（不再可见的最早时间）被调用。这些方法提供了一个很好的机会来启动或停止与控制器的演示或解雇有关的动画。这也是记录用户操作的好地方。</p><p>尽管可以多次调用这些方法并且可以获取几何图形信息，但是并不能为所有几何图形更改调用它们，因此，不应将它们用于核心布局代码（超出特定动画所需的设置）。</p><h2 id="布局"><a class="markdownIt-Anchor" href="#布局"></a> 布局</h2><h2 id="node-是如何绘制的"><a class="markdownIt-Anchor" href="#node-是如何绘制的"></a> Node 是如何绘制的</h2><p>下面是 一个 swift 版本的 YYAyncLayer</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncLayer</span>: <span class="title">CALayer</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 多串行队列控制thread并发数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> queues: [<span class="type">DispatchQueue</span>] = &#123;</span><br><span class="line">    (<span class="number">0</span> ... $<span class="number">0</span>).<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="type">DispatchQueue</span>(label: <span class="string">"com.lee.async.render"</span>) &#125;</span><br><span class="line">  &#125; (<span class="built_in">max</span>(<span class="built_in">min</span>(<span class="type">ProcessInfo</span>().activeProcessorCount, <span class="number">16</span>), <span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> current = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 拿到指定的 queue 分配任务</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> display: <span class="type">DispatchQueue</span> &#123;</span><br><span class="line">    objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">    current += current == <span class="type">Int</span>.<span class="built_in">max</span> ? -current : <span class="number">1</span></span><br><span class="line">    objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">return</span> queues[current % queues.<span class="built_in">count</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sentinel = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 是否异步处理</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isAsynchronously: <span class="type">Bool</span> = <span class="literal">true</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="class"><span class="keyword">class</span> <span class="title">func</span> <span class="title">defaultValue</span>(<span class="title">forKey</span> <span class="title">key</span>: <span class="title">String</span>) -&gt; <span class="title">Any</span>? </span>&#123;</span><br><span class="line">    <span class="keyword">guard</span> key == <span class="string">"isAsynchronously"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">super</span>.defaultValue(forKey: key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果通知重新渲染了就取消，就取消当前渲染</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">setNeedsDisplay</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cancel()</span><br><span class="line">    <span class="keyword">super</span>.setNeedsDisplay()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.contents = <span class="keyword">super</span>.contents</span><br><span class="line">    display(isAsynchronously)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">    objc_sync_enter(<span class="keyword">self</span>)</span><br><span class="line">    sentinel += <span class="number">1</span></span><br><span class="line">    objc_sync_exit(<span class="keyword">self</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123; cancel() &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AsyncLayer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">display</span><span class="params">(<span class="number">_</span> async: Bool)</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> delegate = delegate <span class="keyword">as</span>? <span class="type">AsyncLayerDelegate</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">    delegate.display(will: <span class="keyword">self</span>)</span><br><span class="line">    <span class="keyword">if</span> async &#123;</span><br><span class="line">      <span class="keyword">let</span> size = bounds.size</span><br><span class="line">      <span class="keyword">let</span> opaque = isOpaque</span><br><span class="line">      <span class="keyword">let</span> scale = <span class="type">UIScreen</span>.main.scale</span><br><span class="line">      <span class="keyword">let</span> background = (opaque &amp;&amp; (backgroundColor != <span class="literal">nil</span>)) ? backgroundColor : <span class="literal">nil</span></span><br><span class="line">      <span class="comment">// 使用闭包捕获当前值，跟 self.sentinel 比较，如果self.sentinel 的值变了，说明渲染取消</span></span><br><span class="line">      <span class="keyword">let</span> current = sentinel</span><br><span class="line">      <span class="keyword">let</span> isCancelled = &#123; <span class="keyword">return</span> current != <span class="keyword">self</span>.sentinel &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">AsyncLayer</span>.display.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">guard</span> !isCancelled() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIGraphicsBeginImageContextWithOptions</span>(size, opaque, scale)</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> opaque &#123;<span class="comment">// 不透明</span></span><br><span class="line">          context.saveGState()</span><br><span class="line">          <span class="keyword">let</span> rect = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: size.width * scale, height: size.height * scale)</span><br><span class="line">          <span class="keyword">if</span> background == <span class="literal">nil</span> || background?.alpha != <span class="number">1</span> &#123;</span><br><span class="line">            context.setFillColor(#colorLiteral(red: <span class="number">1</span>, green: <span class="number">1</span>, blue: <span class="number">1</span>, alpha: <span class="number">1</span>))</span><br><span class="line">            context.addRect(rect)</span><br><span class="line">            context.fillPath()</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">let</span> color = background &#123;</span><br><span class="line">            context.setFillColor(color)</span><br><span class="line">            context.addRect(rect)</span><br><span class="line">            context.fillPath()</span><br><span class="line">          &#125;</span><br><span class="line">          context.restoreGState()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        delegate.display(draw: <span class="keyword">self</span>, at: context, with: size, isCancelled: isCancelled)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isCancelled() &#123;</span><br><span class="line">          <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line"><span class="comment">// 主线程会回调渲染</span></span><br><span class="line">          <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            delegate.display(did: <span class="keyword">self</span>, with: <span class="literal">false</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">        <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> isCancelled() &#123;</span><br><span class="line">          <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">          <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">            delegate.display(did: <span class="keyword">self</span>, with: <span class="literal">false</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">          <span class="keyword">if</span> isCancelled() &#123;</span><br><span class="line">            delegate.display(did: <span class="keyword">self</span>, with: <span class="literal">false</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.contents = image?.cgImage</span><br><span class="line">            delegate.display(did: <span class="keyword">self</span>, with: <span class="literal">true</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">UIGraphicsBeginImageContextWithOptions</span>(bounds.size, isOpaque, <span class="type">UIScreen</span>.main.scale)</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> context = <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> isOpaque &#123;</span><br><span class="line">        <span class="keyword">var</span> size = bounds.size</span><br><span class="line">        size.width *= contentsScale</span><br><span class="line">        size.height *= contentsScale</span><br><span class="line">        context.saveGState()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> backgroundColor == <span class="literal">nil</span> || backgroundColor!.alpha &lt; <span class="number">1</span> &#123;</span><br><span class="line">          context.setFillColor(<span class="type">UIColor</span>.white.cgColor)</span><br><span class="line">          context.addRect(<span class="type">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">          context.fillPath()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> color = backgroundColor &#123;</span><br><span class="line">          context.setFillColor(color)</span><br><span class="line">          context.addRect(<span class="type">CGRect</span>(origin: .zero, size: size))</span><br><span class="line">          context.fillPath()</span><br><span class="line">        &#125;</span><br><span class="line">        context.restoreGState()</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      delegate.display(draw: <span class="keyword">self</span>, at: context, with: bounds.size) &#123; <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> image = <span class="type">UIGraphicsGetImageFromCurrentImageContext</span>()</span><br><span class="line">      <span class="type">UIGraphicsEndImageContext</span>()</span><br><span class="line">      contents = image?.cgImage</span><br><span class="line">      delegate.display(did: <span class="keyword">self</span>, with: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发绘画的事务</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Transaction</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">commit</span><span class="params">(<span class="number">_</span> target: AnyObject, with selector: Selector)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> item = <span class="type">Item</span>(target, with: selector)</span><br><span class="line">    <span class="type">Transaction</span>.configObserver</span><br><span class="line">    waits.insert(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="comment">// transaction item 集合，确保插入事务唯一</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> waits: <span class="type">Set</span>&lt;<span class="type">Item</span>&gt; = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> configObserver: <span class="type">Void</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> runloop = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line"><span class="comment">// observer 通知什么时候渲染</span></span><br><span class="line">    <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreate</span>(</span><br><span class="line">      kCFAllocatorDefault,</span><br><span class="line">      <span class="type">CFRunLoopActivity</span>.beforeWaiting.rawValue | <span class="type">CFRunLoopActivity</span>.exit.rawValue,</span><br><span class="line">      <span class="literal">true</span>,       <span class="comment">// repeat</span></span><br><span class="line">      <span class="number">0xFFFFFF</span>,   <span class="comment">// after CATransaction(2000000)</span></span><br><span class="line">      callback,</span><br><span class="line">      <span class="literal">nil</span></span><br><span class="line">    )</span><br><span class="line">    <span class="type">CFRunLoopAddObserver</span>(runloop, observer, .commonModes)</span><br><span class="line">  &#125; ()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> callback: <span class="type">CFRunLoopObserverCallBack</span> = &#123; <span class="number">_</span>,<span class="number">_</span>,<span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">    waits.forEach &#123; <span class="number">_</span> = $<span class="number">0</span>.target.perform($<span class="number">0</span>.selector) &#125;</span><br><span class="line">    waits = []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">struct</span> <span class="title">Item</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target: <span class="type">AnyObject</span></span><br><span class="line">    <span class="keyword">let</span> selector: <span class="type">Selector</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> target: <span class="type">AnyObject</span>, with selector: <span class="type">Selector</span>) &#123;</span><br><span class="line">      <span class="keyword">self</span>.target = target</span><br><span class="line">      <span class="keyword">self</span>.selector = selector</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">hash</span><span class="params">(into hasher: <span class="keyword">inout</span> Hasher)</span></span> &#123;</span><br><span class="line">      hasher.combine(target.hash)</span><br><span class="line">      hasher.combine(selector)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: Transaction.Item, rhs: Transaction.Item)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> lhs.target === rhs.target &amp;&amp; lhs.selector == rhs.selector</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：</p><blockquote><p><a href="http://texturegroup.org/" target="_blank" rel="noopener">Texture</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> UI 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 学习笔记</title>
      <link href="/2018/02/06/RxSwfit+RAC/RxSwift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/02/06/RxSwfit+RAC/RxSwift-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="学习目的"><a class="markdownIt-Anchor" href="#学习目的"></a> 学习目的</h2><ol><li>知道 rxswift 都有什么</li><li>知道他们都怎么用</li><li>知道为什么有这些东西</li><li>根类归纳整理</li><li>如何自己扩展</li><li>适当分析源码</li></ol><h2 id="主要概念"><a class="markdownIt-Anchor" href="#主要概念"></a> 主要概念</h2><ol><li>可监听序列(信号)</li><li>operator(信号变换&amp;组合)</li><li>observer(观察者)</li><li>订阅（绑定）</li><li>Disposable取消订阅</li></ol><h2 id="如何创建信号"><a class="markdownIt-Anchor" href="#如何创建信号"></a> 如何创建信号</h2><h3 id="可监听序列"><a class="markdownIt-Anchor" href="#可监听序列"></a> 可监听序列</h3><p>event</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> next(<span class="type">Element</span>) </span><br><span class="line">  <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>) </span><br><span class="line">  <span class="keyword">case</span> completed </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers: <span class="type">Observable</span>&lt;<span class="type">Int</span>&gt; = <span class="type">Observable</span>.create &#123; observer -&gt; <span class="type">Disposable</span> <span class="keyword">in</span></span><br><span class="line">  observer.onNext(<span class="number">0</span>)</span><br><span class="line">  observer.onNext(<span class="number">1</span>)</span><br><span class="line">  observer.onCompleted()</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Disposables</span>.create()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.just(one)</span><br><span class="line"><span class="type">Observable</span>.of(one, two, three)</span><br><span class="line"><span class="type">Observable</span>.from([one, two, three])</span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Void</span>&gt;.empty()</span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Any</span>&gt;.never()</span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">Int</span>&gt;.range(start: <span class="number">1</span>, <span class="built_in">count</span>: <span class="number">10</span>)</span><br><span class="line"><span class="type">Observable</span>&lt;<span class="type">String</span>&gt;.create</span><br></pre></td></tr></table></figure><h3 id="特征序列"><a class="markdownIt-Anchor" href="#特征序列"></a> 特征序列</h3><h4 id="single"><a class="markdownIt-Anchor" href="#single"></a> Single</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEvent</span>&lt;<span class="title">Element</span>&gt; </span>&#123; </span><br><span class="line">  <span class="keyword">case</span> success(<span class="type">Element</span>) </span><br><span class="line">  <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发出⼀个元素，或⼀个error 事件</li><li>不会共享附加作⽤</li></ul><p>⼀个⽐较常⻅的例⼦就是执⾏ HTTP 请求，然后返回⼀个应答或错误。不过你也可以⽤ Single 来描述任何只有⼀个元素的序列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRepo</span><span class="params">(<span class="number">_</span> repo: String)</span></span> -&gt; <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="type">Any</span>]&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="type">Any</span>]&gt;.create &#123; single <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://api.github.com/repos/\(repo)"</span>)! </span><br><span class="line">    <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, <span class="number">_</span>, error <span class="keyword">in</span> </span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123; </span><br><span class="line">        single(.error(error)) </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> data = data, </span><br><span class="line">            <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .mutableLeaves), </span><br><span class="line">            <span class="keyword">let</span> result = json <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">else</span> &#123; </span><br><span class="line">        single(.error(<span class="type">DataError</span>.cantParseJSON)) </span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">      &#125;</span><br><span class="line">      single(.success(result)) </span><br><span class="line">    &#125; </span><br><span class="line">    task.resume() </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; task.cancel() &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以对 Observable 调⽤ .asSingle() ⽅法，将它转换为 Single。</p><h4 id="completable"><a class="markdownIt-Anchor" href="#completable"></a> Completable</h4><ul><li>没有 next 时间</li><li>发出 completed 或error 事件</li><li>不会共享附加作</li></ul><p>Completable 适⽤于那种你只关⼼任务是否完成，⽽不需要在意任务返回值的情况。它和 Observable<void>有点相似。</void></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheLocally</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; completable <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// Store some data locally</span></span><br><span class="line">    ... </span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">guard</span> success <span class="keyword">else</span> &#123;</span><br><span class="line">      completable(.error(<span class="type">CacheError</span>.failedCaching))</span><br><span class="line">      <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    completable(.completed)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="maybe"><a class="markdownIt-Anchor" href="#maybe"></a> Maybe</h4><ul><li>发出⼀个next，completed或error 事件</li><li>不会共享附加作⽤</li></ul><p>如果你遇到那种可能需要发出⼀个元素，⼜可能不需要发出时，就可以使⽤ Maybe。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateString</span><span class="params">()</span></span> -&gt; <span class="type">Maybe</span>&lt;<span class="type">String</span>&gt; &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="type">Maybe</span>&lt;<span class="type">String</span>&gt;.create &#123; maybe <span class="keyword">in</span> </span><br><span class="line">    maybe(.success(<span class="string">"RxSwift"</span>)) </span><br><span class="line">    <span class="comment">// OR </span></span><br><span class="line">    maybe(.completed) </span><br><span class="line">    <span class="comment">// OR </span></span><br><span class="line">    maybe(.error(error)) </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以对 Observable 调⽤ .asMaybe() ⽅法，将它转换为 Maybe。</p><h4 id="driver"><a class="markdownIt-Anchor" href="#driver"></a> Driver</h4><p>主要是为了简化 UI 层的代码</p><ul><li>不会产⽣ error 事件</li><li>⼀定在 MainScheduler 监听（主线程监听）</li><li>共享附加作⽤</li></ul><p>使用 driver 的原因</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text </span><br><span class="line">  .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance) </span><br><span class="line">  .flatMapLatest &#123; query <span class="keyword">in</span> </span><br><span class="line">  fetchAutoCompleteItems(query) </span><br><span class="line">    .observeOn(<span class="type">MainScheduler</span>.instance) <span class="comment">// 结果在主线程返回 </span></span><br><span class="line">    .catchErrorJustReturn([]) <span class="comment">// 错误被处理了，这样⾄少不会终⽌整个序列 </span></span><br><span class="line">  &#125; </span><br><span class="line">  .share(replay: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTTP 请求是被共享的</span></span><br><span class="line">results</span><br><span class="line">  .<span class="built_in">map</span> &#123; <span class="string">"\($0.count)"</span> &#125;</span><br><span class="line">  .bind(to: resultCount.rx.text)</span><br><span class="line">  .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">  .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span> </span><br><span class="line">    cell.textLabel?.text = <span class="string">"\(result)"</span></span><br><span class="line">  &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>使用 drive</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text.asDriver() <span class="comment">// 将ControlProperty 转换为 Driver</span></span><br><span class="line">  .throttle(<span class="number">0.3</span>, scheduler: <span class="type">MainScheduler</span>.instance) </span><br><span class="line">  .flatMapLatest &#123; query <span class="keyword">in</span> </span><br><span class="line">    fetchAutoCompleteItems(query) </span><br><span class="line">    .asDriver(onErrorJustReturn: []) <span class="comment">// 仅仅提供发⽣错误时的备选返回值 </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">results </span><br><span class="line">  .<span class="built_in">map</span> &#123; <span class="string">"\($0.count)"</span> &#125; </span><br><span class="line">  .drive(resultCount.rx.text) <span class="comment">// 这⾥改⽤ `drive` ⽽不是 `bindTo`</span></span><br><span class="line">  .disposed(by: disposeBag) <span class="comment">// 这样可以确保必备条件都已经满⾜了</span></span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">  .drive(resultsTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span> </span><br><span class="line">    cell.textLabel?.text = <span class="string">"\(result)"</span> </span><br><span class="line">  &#125;</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h4 id="signal"><a class="markdownIt-Anchor" href="#signal"></a> Signal</h4><p>Signal 和 Driver 相似，唯⼀的区别是，Driver 会对新观察者回放（重新发送）上⼀个元素，⽽ Signal 不会对新观察者回放上⼀个元素。</p><ul><li>不会产⽣ error 事件</li><li>⼀定在 MainScheduler 监听（主线程监听）</li><li>共享附加作⽤</li></ul><p>⼀般情况下状态序列我们会选⽤ Driver 这个类型，事件序列我们会选⽤ Signal 这个类型。</p><h4 id="controlevent"><a class="markdownIt-Anchor" href="#controlevent"></a> ControlEvent</h4><p>ControlEvent 专⻔⽤于描述 UI 控件所产⽣的事件，它具有以下特征：</p><ul><li>不会产⽣ error 事件</li><li>⼀定在 MainScheduler</li><li>⼀定在 MainScheduler 订阅（主线程订阅） 监听（主线程监听）</li><li>共享附加作⽤</li></ul><h3 id="观察者-anyobserver"><a class="markdownIt-Anchor" href="#观察者-anyobserver"></a> 观察者 AnyObserver</h3><h4 id="特征观察者-binder"><a class="markdownIt-Anchor" href="#特征观察者-binder"></a> 特征观察者 Binder</h4><ul><li>不会处理错误事件</li><li>确保绑定都是在给定 Scheduler 上执⾏（默认 MainScheduler）</li><li>只处理 next 事件</li></ul><p>在介绍 AnyObserver 时，我们举了这样⼀个例⼦：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span> </span><br><span class="line">  <span class="keyword">switch</span> event &#123; </span><br><span class="line">    <span class="keyword">case</span> .next(<span class="keyword">let</span> isHidden): </span><br><span class="line">      <span class="keyword">self</span>?.usernameValidOutlet.isHidden = isHidden </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">      <span class="keyword">break</span> </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid </span><br><span class="line">  .bind(to: observer) </span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>由于这个观察者是⼀个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执⾏。<br>因此⼀个更好的⽅案就是使⽤ Binder：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">Binder</span>(usernameValidOutlet) &#123; (view, isHidden) <span class="keyword">in</span></span><br><span class="line">  view.isHidden = isHidden </span><br><span class="line">&#125; </span><br><span class="line">usernameValid </span><br><span class="line">  .bind(to: observer) </span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>Binder 可以只处理 next 事件，并且保证响应 next 事件的代码一定会在给定 Scheduler 上执⾏，这⾥采⽤默认的 MainScheduler。</p><ul><li>复用</li></ul><p>由于⻚⾯是否隐藏是⼀个常⽤的观察者，所以应该让所有的 UIView 都提供这种观察者：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIView</span> </span>&#123; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isHidden: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; view, hidden <span class="keyword">in</span> </span><br><span class="line">      view.isHidden = hidden </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----</span></span><br><span class="line">usernameValid </span><br><span class="line">  .bind(to: usernameValidOutlet.rx.isHidden) </span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="即使观察序列又是观察者"><a class="markdownIt-Anchor" href="#即使观察序列又是观察者"></a> 即使观察序列又是观察者</h3><h4 id="asyncsubject"><a class="markdownIt-Anchor" href="#asyncsubject"></a> AsyncSubject</h4><h4 id="publishsubject"><a class="markdownIt-Anchor" href="#publishsubject"></a> PublishSubject</h4><h4 id="replaysubject"><a class="markdownIt-Anchor" href="#replaysubject"></a> ReplaySubject</h4><h4 id="behaviorsubject"><a class="markdownIt-Anchor" href="#behaviorsubject"></a> BehaviorSubject</h4><h4 id="controlproperty"><a class="markdownIt-Anchor" href="#controlproperty"></a> ControlProperty</h4><h4 id="rxrelay"><a class="markdownIt-Anchor" href="#rxrelay"></a> RxRelay</h4><h4 id="publishrelay"><a class="markdownIt-Anchor" href="#publishrelay"></a> PublishRelay</h4><p>PublishRelay 就是 PublishSubject 去掉终⽌事件 onError 或 onCompleted 。</p><h4 id="behaviorrelay"><a class="markdownIt-Anchor" href="#behaviorrelay"></a> BehaviorRelay</h4><p>BehaviorRelay 就是 BehaviorSubject 去掉终⽌事件 演示 onError 或 onCompleted 。</p><h3 id="如何选择operator"><a class="markdownIt-Anchor" href="#如何选择operator"></a> 如何选择operator</h3><p><strong>Observable 创建</strong></p><ul><li>产⽣特定的⼀个元素：just<ul><li>经过⼀段延时：timer</li></ul></li><li>从⼀个序列拉取元素：from</li><li>重复的产⽣某⼀个元素：repeatElement</li><li>存在⾃定义逻辑：create</li><li>每次订阅时产⽣：deferred</li><li>每隔⼀段时间，发出⼀个元素：interval<ul><li>在⼀段延时后：timer</li></ul></li><li>⼀个空序列，只有⼀个完成事件：empty</li><li>⼀个任何事件都没有产⽣的序列：never</li></ul><p><strong>Observable组合</strong></p><ul><li>任意⼀个 Observable 产⽣了元素，就发出这个元素：merge</li><li>当上⼀个 Observable 才能开始发出元素：concat</li><li>组合多个 Observables 的元素<ul><li>当每⼀个 Observable 都发出⼀个新的元素：zip</li><li>当任意⼀个 Observable 发出⼀个新的元素：combineLatest</li></ul></li></ul><p><strong>Observable转换</strong></p><ul><li>对每个元素直接转换：map</li><li>转换到另⼀个 Observable ：flatMap<ul><li>只接收最新的元素转换的 Observable 所产⽣的元素：flatMapLatest</li><li>每⼀个元素转换的 Observable 按顺序产⽣元素：concatMap</li></ul></li><li>基于所有遍历过的元素：scan</li></ul><p><strong>基于时间序</strong></p><ul><li>拖延⼀段时间后再发出：delay</li></ul><p><strong>想要将产⽣的事件封装成元素发送出来</strong></p><ul><li>将他们封装成 Event<element>：materialize</element></li><li>然后解封出来：dematerialize</li></ul><p><strong>基于数量的操作</strong></p><ul><li><p>忽略掉所有的 next 事件，只接收 completed 和 error 事件：ignoreElements</p></li><li><p>创建⼀个新的 Observable 在原有的序列前⾯加⼊⼀些元素：startWith</p></li><li><p>我想从 Observable 中收集元素，缓存这些元素之后在发出：buffer</p></li><li><p>我想将 Observable 拆分成多个 Observables ：window</p><ul><li>基于元素的共同特征：groupBy</li></ul></li><li><p>我想只接收 Observable 中特定的元素</p><ul><li>发出唯⼀的元素：single</li></ul></li><li><p>我想重新从 Observable 中发出某些元素</p><ul><li>通过判定条件过滤出⼀些元素：filter</li><li>仅发出头⼏个元素：take</li><li>仅发出尾部的⼏个元素：takeLast</li><li>仅仅发出第 n 个元素：elementAt</li></ul></li><li><p>跳过头⼏个元素</p><ul><li>跳过头 n 个元素：skip</li><li>跳过头⼏个满⾜判定的元素：skipWhile，skipWhileWithIndex</li><li>跳过某段时间内产⽣的头⼏个元素：skip</li><li>跳过头⼏个元素直到另⼀个 Observable 发出⼀个元素：skipUntil</li></ul></li><li><p>只取头⼏个元素</p><ul><li>只取头⼏个满⾜判定的元素：takeWhile，takeWhileWithIndex</li><li>只取某段时间内产⽣的头⼏个元素：take</li><li>只取头⼏个元素直到另⼀个 Observable 发出⼀个元素：takeUntil</li></ul></li><li><p>周期性的对 Observable 抽样：sample</p></li><li><p>发出那些元素，这些元素产⽣后的特定的时间内，没有新的元素产⽣：debounce</p></li><li><p>直到元素的值发⽣变化，才发出新的元素：distinctUntilChanged</p><ul><li>并提供元素是否相等的判定函数：distinctUntilChanged</li></ul></li><li><p>在开始发出元素时，延时后进⾏订阅：delaySubscription</p></li><li><p>我想要从⼀些 Observables 中，只取第⼀个产⽣元素的 Observable ：amb</p></li><li><p>我想评估 Observable 的全部元素</p><ul><li>并且对每个元素应⽤聚合⽅法，待所有元素都应⽤聚合⽅法后，发出结果：reduce</li><li>并且对每个元素应⽤聚合⽅法，每次应⽤聚合⽅法后，发出结果：scan</li></ul></li><li><p>我想在某个 Scheduler 应⽤操作符：subscribeOn</p><ul><li>在某个 Scheduler 监听：observeOn</li></ul></li><li><p>我想要 Observable 发⽣某个事件时, 采取某个⾏动：do</p></li><li><p>我想要 Observable 发出⼀个 error 事件：error</p></li><li><p>如果规定时间内没有产⽣元素：timeout</p></li><li><p>我想要 Observable 发⽣错误时，优雅的恢复</p><ul><li>如果规定时间内没有产⽣元素，就切换到备选 Observable ：timeout</li><li>如果产⽣错误，将错误替换成某个元素 ：catchErrorJustReturn</li><li>如果产⽣错误，就切换到备选 Observable ：catchError</li><li>如果产⽣错误，就重试 ：retry</li></ul></li><li><p>我创建⼀个 Disposable 资源，使它与 Observable 具有相同的寿命：using</p></li><li><p>我创建⼀个 Observable ，直到我通知它可以产⽣元素后，才能产⽣元素：publish</p><ul><li>并且，就算是在产⽣元素后订阅，也要发出全部元素：replay</li><li>并且，⼀旦所有观察者取消观察，他就被释放掉：refCount</li><li>通知它可以产⽣元素了：connect</li></ul></li></ul><h3 id="动态信号"><a class="markdownIt-Anchor" href="#动态信号"></a> 动态信号</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *s = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">  [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">  [subscriber sendCompleted];</span><br><span class="line">  <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="cocoa-桥接"><a class="markdownIt-Anchor" href="#cocoa-桥接"></a> Cocoa 桥接</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) bridge &#123;</span><br><span class="line">  RACSignal *sO = RACObserver(<span class="keyword">self</span>, button);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.sigSetFrame = [<span class="keyword">self</span>.button rac_signalForSelector:<span class="keyword">@selector</span>(setFrame:)];</span><br><span class="line">  [_sigSetFrame</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setFrame:%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span>.sigClick = [<span class="keyword">self</span>.button rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">  [_sigClick</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"event: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignals:_sigClick, <span class="literal">nil</span>]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalsFromArray:@[[_sigClick map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @[@<span class="number">3</span>];</span><br><span class="line">  &#125;]]]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@<span class="number">1</span>)]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) lift:(<span class="keyword">id</span>)value&#123;</span><br><span class="line">  printf(<span class="string">"lift: %s"</span>, __func__);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号变化内部是产生一个新信号的"><a class="markdownIt-Anchor" href="#信号变化内部是产生一个新信号的"></a> 信号变化(内部是产生一个新信号的)</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[_sigClick map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> @[@<span class="number">3</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="序列转换"><a class="markdownIt-Anchor" href="#序列转换"></a> 序列转换</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.sigSequence = [[RACSequence <span class="keyword">return</span>:@<span class="number">3</span>] concat:[RACSequence <span class="keyword">return</span>:@<span class="number">4</span>]].signal;</span><br></pre></td></tr></table></figure><h2 id="订阅绑定信号的方式"><a class="markdownIt-Anchor" href="#订阅绑定信号的方式"></a> 订阅（绑定）信号的方式</h2><h3 id="直接订阅方法"><a class="markdownIt-Anchor" href="#直接订阅方法"></a> 直接订阅方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.sigSample</span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"sample: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="绑定"><a class="markdownIt-Anchor" href="#绑定"></a> 绑定</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>, a) = Signal;</span><br></pre></td></tr></table></figure><h3 id="cocoa-桥接-2"><a class="markdownIt-Anchor" href="#cocoa-桥接-2"></a> Cocoa 桥接</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signal &#123;</span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignals:_sigClick, <span class="literal">nil</span>]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalsFromArray:@[[_sigClick map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @[@<span class="number">3</span>];</span><br><span class="line">  &#125;]]]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@<span class="number">1</span>)]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) lift:(<span class="keyword">id</span>)value&#123;</span><br><span class="line">  printf(<span class="string">"lift: %s"</span>, __func__);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号变化组合"><a class="markdownIt-Anchor" href="#信号变化组合"></a> 信号变化&amp;组合</h2><ol><li>单个信号的变化</li><li>多个信号的组合</li><li>高阶操作</li></ol><p><img src="/img/signal_transform.jpeg" alt="signal 变化"></p><h3 id="值操作"><a class="markdownIt-Anchor" href="#值操作"></a> 值操作</h3><p>问题：</p><ul><li>为什么会有这样的值操作方法？</li><li>自己如何扩展新的值方法</li></ul><hr><ul><li>transform 这些用的比较多<ol><li>map</li><li>MapReplace</li><li>ReduceEach tuple(a, b) -&gt; c</li></ol></li><li>值判断逻辑变换<ol><li>not</li><li>and</li><li>or</li></ol></li><li>用的比较少<ol><li>reduceApply 这个不太清楚为什么要这么设计，用combineLatest: reduceEach: 就可以做了，而且代码看起来更好。</li><li>materialize</li><li>dematerialize</li></ol></li></ul><h3 id="数量操作"><a class="markdownIt-Anchor" href="#数量操作"></a> 数量操作</h3><ol><li>repeat 一直会有值</li></ol><ul><li><p>条件过滤1</p><ol><li>ignore</li><li>ignoreValues</li><li>distinctUntilChanged</li></ol></li><li><p>条件过滤2</p><ol><li>takeUntilBlock:(BOOL (^)(id x))predicate</li><li>takeWhileBlock:(BOOL (^)(id x))predicate;</li><li>skipUntilBlock:(BOOL (^)(id x))predicate;</li><li>skipWhileBlock:(BOOL (^)(id x))predicate;</li></ol></li><li><p>数量判断，如果有值就发送</p><ol><li>any;</li><li>any:(BOOL (^)(id object))predicateBlock;</li><li>all:(BOOL (^)(id object))predicateBlock;</li></ol></li><li><p>重试</p><ol><li>retry</li><li>retry: Count</li><li>collect <code>汇聚</code> 信号必须有返回值</li></ol></li></ul><p>副作用：<br>– 对于信号值变化以外的一些操作</p><ul><li>doNext</li><li>doCompleted</li><li>doError</li></ul><p><code>折叠函数</code></p><p>不听对一个value 操作，使用折叠函数解决这个问题</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[sig10 aggregateWithStart:@<span class="number">0</span> reduce:^<span class="keyword">id</span>(<span class="keyword">id</span> running, <span class="keyword">id</span> next) &#123;</span><br><span class="line">  <span class="keyword">return</span> @([running intValue] + [next intValue]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ol><li>(RACSignal *)aggregateWithStart:(id)start reduce:(id (^)(id running, id next))reduceBlock;</li><li>(RACSignal *)aggregateWithStart:(id)start reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock;</li><li>(RACSignal *)aggregateWithStartFactory:(id (^)(void))startFactory reduce:(id (^)(id running, id next))reduceBlock;</li><li>(instancetype)scanWithStart:(id)startingValue reduce:(id (^)(id running, id next))reduceBlock;</li><li>(instancetype)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock;</li></ol><h3 id="时间操作"><a class="markdownIt-Anchor" href="#时间操作"></a> 时间操作</h3><ol><li>+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler;</li><li>+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler withLeeway:(NSTimeInterval)leeway;</li><li>delay</li><li>throttle 阀门，在固定时间内没有新值发送的时候，会发送最后的值</li></ol><h3 id="多个信号组合"><a class="markdownIt-Anchor" href="#多个信号组合"></a> 多个信号组合</h3><p>问题：</p><ol><li>受哪个信号终止而终止？</li><li>错误传递？</li><li>各个信号何时开始开始订阅？</li><li>在哪个线程发出？</li></ol><ul><li>concat<ul><li>第一个结束后，订阅第二个</li><li>第一个error 后，就直接 error</li></ul></li><li>merge</li><li>zip</li><li>combineLatest</li><li>sample</li><li>takeUntil</li><li>takeUntilReplacement, 当 B 来了直接替换 A，开始订阅 B</li></ul><h3 id="信号的高阶操作升阶降阶"><a class="markdownIt-Anchor" href="#信号的高阶操作升阶降阶"></a> 信号的高阶操作（升阶降阶）</h3><ol><li>升阶 S(v) -&gt; S(s(v))</li><li>降阶 S(s(v)) -&gt; S(v)</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>].rac_sequence.signal;</span><br><span class="line">RACSignal *signalB = [[signal map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> [[RACSignal <span class="keyword">return</span>:value] delay:<span class="number">1</span>];</span><br><span class="line">&#125;] concat];</span><br></pre></td></tr></table></figure><ul><li><p>降阶操作</p></li><li><p>switchToLatests</p></li></ul><p><img src="/img/switchToLatests.jpeg" alt="switchToLatests"></p><ul><li><p>if/then/else<br><img src="/img/if-then-else.jpeg" alt="if/then/else"></p></li><li><p>switch/cases/default</p></li><li><p>flatten</p></li></ul><p><img src="/img/flatten.jpeg" alt="flatten"></p><p>flatten 类似 merge 只不过一个是接收的 value是 signal，另一个接收的就是 value</p><ul><li>flatten:count 按个数展开信号，当信号个数 &gt; count 以后等待，如果有 sig completed，那么把等待中的sig 放入展开数组里面</li></ul><p><img src="/img/flatten-count.jpeg" alt="flatten-count"></p><p>flatten:1 == concat</p><ul><li>flattenMap</li></ul><p>满足 monad 的部分定义，绝大部分函数都可以使用 flattenMap 实现</p><ul><li>bind</li></ul><p>大部分函数都可以使用 bind 实现</p><h2 id="冷信号热信号"><a class="markdownIt-Anchor" href="#冷信号热信号"></a> 冷信号&amp;热信号</h2><h2 id="一些习题"><a class="markdownIt-Anchor" href="#一些习题"></a> 一些习题</h2><ol><li>如何获得无限递增的信号</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *increment(<span class="keyword">int</span> inc) &#123;</span><br><span class="line">  RACSignal *repeat = [[RACSignal <span class="keyword">return</span>:@(inc)] repeat];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [[repeat scanWithStart:<span class="number">0</span> reduce:^<span class="keyword">id</span>(<span class="keyword">id</span> running, <span class="keyword">id</span> next) &#123;</span><br><span class="line">    <span class="keyword">return</span> @([running intValue] + [next intValue]);</span><br><span class="line">  &#125;]</span><br><span class="line">  delay:<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>fibonacci</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *fibonacci() &#123;</span><br><span class="line">  RACSignal *repeat = [[RACSignal <span class="keyword">return</span>:<span class="literal">nil</span>] repeat];</span><br><span class="line">  <span class="keyword">return</span> [repeat scanWithStart:RACTuplePack(@<span class="number">1</span>, @<span class="number">1</span>) reduce:^<span class="keyword">id</span>(RACTuple *running, <span class="keyword">id</span> _) &#123;</span><br><span class="line">    <span class="keyword">int</span> next = [running.first intValue] + [running.second intValue];</span><br><span class="line">    <span class="keyword">return</span> RACTuplePack(running.second, @(next));</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 4.Action</title>
      <link href="/2018/02/03/RxSwfit+RAC/RxSwift-Action/"/>
      <url>/2018/02/03/RxSwfit+RAC/RxSwift-Action/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/RxSwiftCommunity/Action" target="_blank" rel="noopener">原文：Action</a></p><p>该库与RxSwift一起使用，以在可观察对象之上提供抽象：Action。</p><p><code>Action</code> 是说“嘿，稍后我需要你订阅此内容”的一种方式。实际上，它涉及的更多。</p><p><code>Action</code> 初始化时需要 <code>workFactory:</code> 一个需要一些输入并产生可观察值的闭包。调用 <code>execute()</code> 时，它将参数传递给此闭包并订阅工作。</p><ul><li>只有在“enabled”时才可以执行（如果未指定，则为true）</li><li>一次只执行一件事。</li><li>汇总各个执行中的 next/error 事件</li></ul><p>Action 和 UIButton 配合使用。它管理按钮的 enable 状态，确保在工作完成时禁用按钮</p><h2 id="如何使用"><a class="markdownIt-Anchor" href="#如何使用"></a> 如何使用</h2><ul><li>必须传递一个 <code>workFactory</code> ，该工厂接受输入并返回一个 <code>Observable</code></li><li>每当你调用 <code>execute(input)</code>，你传入的 input 传入到 <code>workFactory</code> 执行</li><li>该 <code>Action</code> 订阅 <code>Observable</code> 对象，然后在 <code>Action</code> 的 <code>elements</code> 属性上发 <code>Observable</code> 的 Next事件</li><li>如果 <code>Observable</code> 发出 event 事件，这个 error 会以 next 事件在 <code>Action</code> 的 <code>errors</code> 属性中以 next 事件发出</li></ul><p>Actions 每次只能执行一次，如果你尝试执行一个正在 executing 的 action，会得到一个 error。<code>Action</code> 的 <code>executing</code> 属性会发送 next 事件，关联值是 ture or false</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">action: <span class="type">Action</span>&lt;<span class="type">String</span>, <span class="type">Bool</span>&gt; = <span class="type">Action</span>(workFactory: &#123; input <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> networkLibrary.checkEmailExists(input)</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br><span class="line">action.execute(<span class="string">"ash@ashfurrow.com"</span>)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>第一个泛型参数是 input 的类型。</li><li>第二个泛型是 workFactory 闭包创建的 Observable 发送 next 事件的数据类型（你可以把它看做 Action 的Output）</li></ul><p>还可以为 Action 初始化程序指定 enabledIf 参数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> validEmailAddress = emailTextField.rx.text.<span class="built_in">map</span>(isValidEmail)</span><br><span class="line">action: <span class="type">Action</span>&lt;<span class="type">String</span>, <span class="type">Bool</span>&gt; = <span class="type">Action</span>(enabledIf: validEmailAddress, workFactory: &#123; input <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> networkLibrary.checkEmailExists(input)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时 <code>execute()</code> 只有当 email address 合法才会执行.</p><p>注意， <code>enabledIf</code> 与 <code>enabled</code> 属性不同。</p><p>UIButton 扩展：它接受CocoaAction，它的类型是 <code>Action &lt;Void，Void&gt;</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.rx.action = action</span><br></pre></td></tr></table></figure><p>当按下按钮时，action 执行操作。button 的 enable 属性和 action 的 <code>enabled</code> 属性绑定。这意味着你可以将表单验证逻辑作为信号输入到 action 中，并为你处理按钮的启用状态。同样，用户不能在动作完成执行之前再次按下按钮，因为它一次只能处理一件事。看看这个实际的CocoaAction代码示例。</p><p>如果你想使用 <code>Action</code> 进行复杂的操作，例如使用下载进度报告下载文件（例如，更新UI中的进度条），那么可以使用 <code>Action&lt;Void，Int&gt;</code> 代替CocoaAction。开箱即用的CocoaAction无法发出进度值，你自己的 <code>Action&lt;Void，Int&gt;</code> 将做到这一点。有关详细信息，请参阅<a href="http://www.sm-cloud.com/rxswift-action/" target="_blank" rel="noopener">本文</a>。</p><p>如果你的方案涉及许多需要触发同一操作以提供不同输入的按钮，则可以在每个UIButton上使用bindTo，并使用闭包返回正确的输入。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button1 = <span class="type">UIButton</span>()</span><br><span class="line"><span class="keyword">let</span> button2 = <span class="type">UIButton</span>()</span><br><span class="line"><span class="keyword">let</span> action = <span class="type">Action</span>&lt;<span class="type">String</span>, <span class="type">String</span>&gt; &#123; input <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(input)</span><br><span class="line">    <span class="keyword">return</span> .just(input)</span><br><span class="line">&#125;</span><br><span class="line">button1.rx.bindTo(action) &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">return</span> <span class="string">"Hello"</span>&#125;</span><br><span class="line">button2.rx.bindTo(action) &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="keyword">return</span> <span class="string">"Goodbye"</span>&#125;</span><br></pre></td></tr></table></figure><p>button1和button2共享相同的Action，但是它们使用不同的输入（相应的输出Hello和Goodbye）</p><p>更复杂的用例可以是与UIViewController相关的单个操作，该操作管理你的导航，错误处理和加载状态。通过这种方法，可以根据需要拥有任意数量的 UIButton（或UIBarButtonItems），在一个公共位置一次性订阅 <code>executing</code> ，<code>errors</code> 和 <code>elements</code>。</p><p>UIAlertController 还使用了一个非常酷的 <code>UIAlertAction</code> 扩展。一招：由于该类的限制，你无法使用常规的初始化程序实例化它。相反，请调用此类方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> action = <span class="type">UIAlertAction</span>.<span class="type">Action</span>(<span class="string">"Hi"</span>, style: .<span class="keyword">default</span>)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 3.Subject(Observable &amp; Observer)</title>
      <link href="/2018/02/02/RxSwfit+RAC/RxSwift-3-Subject(Observable&amp;Observer)/"/>
      <url>/2018/02/02/RxSwfit+RAC/RxSwift-3-Subject(Observable&amp;Observer)/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><div align="center"><img src="/img/subject.jpeg" alt="subject" style="width:180px;height:150px"></div><p>首先在开发的时候思考，他是一个 Observable</p><h2 id="asyncsubject"><a class="markdownIt-Anchor" href="#asyncsubject"></a> AsyncSubject</h2><ol><li>特点：<ul><li>当 Observable Sequence 发送 complete 事件，<code>AsyncSubject</code> 才会发送最后一个 next 事件和 complete</li><li>当 Observable Sequence 发送 error 事件，<code>AsyncSubject</code> 只发送 error 事件，不会发送最后一个 next</li></ul></li></ol><details><summary>2. 演示</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>() </span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">AsyncSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 1 Event:"</span>, $<span class="number">0</span>) &#125; </span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject.onCompleted()</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Subscription: <span class="number">1</span> Event: next(ί )</span><br><span class="line">Subscription: <span class="number">1</span> Event: completed</span><br></pre></td></tr></table></figure></pre></details><h2 id="publishsubject"><a class="markdownIt-Anchor" href="#publishsubject"></a> PublishSubject</h2><ol><li>特点：<ul><li><code>PublishSubject</code> 发送订阅后产⽣的元素.</li><li><code>PublishSubject</code> 不发送订阅前产⽣的元素.</li></ul></li></ol><div align="left"><img src="/img/publicSubject.jpeg" alt="publicSubject" style="width:300px;height:200px"></div><details><summary>2. 演示</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">PublishSubject</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 1 Event:"</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 2 Event:"</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(<span class="string">"A "</span>)</span><br><span class="line">subject.onNext(<span class="string">"B "</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(A )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(A )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(B )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(B )</span><br></pre></td></tr></table></figure></pre></details><h2 id="replaysubject"><a class="markdownIt-Anchor" href="#replaysubject"></a> ReplaySubject</h2><ol><li>特点：<ul><li><code>ReplaySubject</code> 将对观察者发送全部的元素，⽆论观察者是何时进⾏订阅的。</li></ul></li></ol><div align="left"><img src="/img/replaySubject.jpeg" alt="replaySubject" style="width:300px;height:200px"></div><details><summary>2. 演示</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">ReplaySubject</span>&lt;<span class="type">String</span>&gt;.create(bufferSize: <span class="number">1</span>)</span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 1 Event:"</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 2 Event:"</span>, $<span class="number">0</span>) &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">subject.onNext(<span class="string">"A "</span>)</span><br><span class="line">subject.onNext(<span class="string">"B "</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Subscription: <span class="number">1</span> Event: next(  ) </span><br><span class="line">Subscription: <span class="number">1</span> Event: next(  ) </span><br><span class="line">Subscription: <span class="number">2</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(A )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(A )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(B )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(B )</span><br></pre></td></tr></table></figure></pre></details><h2 id="behaviorsubject"><a class="markdownIt-Anchor" href="#behaviorsubject"></a> BehaviorSubject</h2><ol><li>特点：<ol><li>具有默认值</li><li>当订阅 BehaviorSubject 时，它会将源 Observable 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产⽣的元素发送出来。</li><li>如果 Observable 发 error 事件，那么BehaviorSubject不会再发送 next 事件，而只是传递来自源 Observable 的 error 事件。</li></ol></li></ol><p>normal</p><div align="left"><img src="/img/behaviorSubject1.jpeg" alt="behaviorSubject1" style="width:300px;height:200px"></div><p>error</p><div align="left"><img src="/img/behaviorSubject2.jpeg" alt="behaviorSubject2" style="width:300px;height:200px"></div><details><summary>2. 演示</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line"><span class="keyword">let</span> subject = <span class="type">BehaviorSubject</span>(value: <span class="string">"  "</span>)</span><br><span class="line">subject</span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 1 Event:"</span>, $<span class="number">0</span>) &#125; </span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"  "</span>) </span><br><span class="line">subject.onNext(<span class="string">"  "</span>) </span><br><span class="line">subject </span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 2 Event:"</span>, $<span class="number">0</span>) &#125; </span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">subject.onNext(<span class="string">"A "</span>) </span><br><span class="line">subject.onNext(<span class="string">"B "</span>) </span><br><span class="line">subject </span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Subscription: 3 Event:"</span>, $<span class="number">0</span>) &#125; </span><br><span class="line">    .disposed(by: disposeBag) </span><br><span class="line">subject.onNext(<span class="string">"  "</span>) </span><br><span class="line">subject.onNext(<span class="string">"  "</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(A )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(A )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(B )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(B )</span><br><span class="line">Subscription: <span class="number">3</span> Event: next(B )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">3</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">1</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">2</span> Event: next(  )</span><br><span class="line">Subscription: <span class="number">3</span> Event: next(  )</span><br></pre></td></tr></table></figure></pre></details><h2 id="variable弃用"><a class="markdownIt-Anchor" href="#variable弃用"></a> Variable（弃用）</h2><p>在 RxSwift 5.x 中，他被官⽅的正式的弃⽤了，并且在需要时，推荐使⽤ BehaviorRelay 或者 BehaviorSubject。</p><h2 id="relay"><a class="markdownIt-Anchor" href="#relay"></a> Relay</h2><div align="left"><img src="/img/RxRelay.jpeg" alt="RxRelay" style="width:450px;height:175px"></div><br><p>RxRelay提供两种中继：PublishRelay 和 BehaviorRelay。它们的行为与对应的 Subjects 完全相同，但有两个变化：</p><ul><li>Relays never complete.</li><li>Relays never emit errors.</li></ul><p>本质上，中继仅发出.next事件，并且永不终止，有了他，我们将 API 转化为 Rx 样式时，就不必担⼼⼀个意外的终⽌事件，导致后续事件转发失效。</p><h3 id="publishrelay"><a class="markdownIt-Anchor" href="#publishrelay"></a> PublishRelay</h3><p>PublishRelay 就是 PublishSubject 去掉终⽌事件 onError 和 onCompleted。</p><p>示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>() </span><br><span class="line"><span class="keyword">let</span> relay = <span class="type">PublishRelay</span>&lt;<span class="type">String</span>&gt;() </span><br><span class="line">relay </span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Event:"</span>, $<span class="number">0</span>) &#125; </span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">relay.accept(<span class="string">"  "</span>)</span><br><span class="line">relay.accept(<span class="string">"  "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="type">Event</span>: next( )</span><br><span class="line"><span class="type">Event</span>: next( )</span><br></pre></td></tr></table></figure><h3 id="behaviorrelay"><a class="markdownIt-Anchor" href="#behaviorrelay"></a> BehaviorRelay</h3><p>BehaviorRelay 就是 BehaviorSubject 去掉终⽌事件 onError 和 onCompleted。</p><p>示例：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>() </span><br><span class="line"><span class="keyword">let</span> relay = <span class="type">BehaviorRelay</span>(value: <span class="string">"  "</span>)</span><br><span class="line">relay </span><br><span class="line">    .subscribe &#123; <span class="built_in">print</span>(<span class="string">"Event:"</span>, $<span class="number">0</span>) &#125; </span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">relay.accept(<span class="string">"  "</span>)</span><br><span class="line">relay.accept(<span class="string">"  "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="type">Event</span>: next( )</span><br><span class="line"><span class="type">Event</span>: next( )</span><br><span class="line"><span class="type">Event</span>: next( )</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 2.Observer</title>
      <link href="/2018/02/02/RxSwfit+RAC/RxSwift-Observer/"/>
      <url>/2018/02/02/RxSwfit+RAC/RxSwift-Observer/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>Observer: 监听 Observable Sequence，接受它传来的 events</p><div align="center"><img src="/img/observer.jpeg" alt="observer" style="width:200px;height:100px"></div><h2 id="如何创建-observer"><a class="markdownIt-Anchor" href="#如何创建-observer"></a> 如何创建 Observer</h2><h3 id="observable-的-subscribe-方法"><a class="markdownIt-Anchor" href="#observable-的-subscribe-方法"></a> Observable 的 subscribe 方法</h3><p>创建观察者最直接的⽅法就是在 Observable 的 subscribe ⽅法后⾯描述，事件发⽣时，需要如 何做出响应。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tap.subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.showAlert()</span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"发⽣错误： \(error.localizedDescription)"</span>)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"任务完成"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>subscribe 方法内部会产生 <code>AnonymousObserver</code> 对象（RxSwift 库私有的）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">subscribe</span><span class="params">(<span class="number">_</span> on: @escaping <span class="params">(Event&lt;Element&gt;)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">    -&gt; <span class="type">Disposable</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> observer = <span class="type">AnonymousObserver</span> &#123; e <span class="keyword">in</span></span><br><span class="line">            on(e)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.asObservable().subscribe(observer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="anyobserver-任意观察者"><a class="markdownIt-Anchor" href="#anyobserver-任意观察者"></a> AnyObserver-- 任意观察者</h3><p>类注释：</p><blockquote><p>A type-erased <code>ObserverType</code>.<br>将操作转发到具有相同 <code>Element</code> 类型的任意基础观察者，隐藏基础观察者类型的细节。</p></blockquote><p>AnyObserver 可以⽤来描叙任意⼀种观察者。<br>eg: 打印⽹络请求结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url)) </span><br><span class="line">    .subscribe(onNext: &#123; data <span class="keyword">in</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Data Task Success with count: \(data.count)"</span>) </span><br><span class="line">    &#125;, onError: &#123; error <span class="keyword">in</span> </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Data Task Error: \(error)"</span>) </span><br><span class="line">&#125;) </span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>可以看作是：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Data</span>&gt; = <span class="type">AnyObserver</span> &#123; (event) <span class="keyword">in</span> </span><br><span class="line">    <span class="keyword">switch</span> event &#123; </span><br><span class="line">        <span class="keyword">case</span> .next(<span class="keyword">let</span> data): </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Data Task Success with count: \(data.count)"</span>) </span><br><span class="line">        <span class="keyword">case</span> .error(<span class="keyword">let</span> error): </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Data Task Error: \(error)"</span>) </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url)) </span><br><span class="line">    .subscribe(observer) </span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>⽤户名提示语是否隐藏：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">usernameValid </span><br><span class="line">    .bind(to: usernameValidOutlet.rx.isHidden) </span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>可以看作是：<span id="anchor"></span></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">AnyObserver</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">AnyObserver</span> &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] (event) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">switch</span> event &#123; </span><br><span class="line">        <span class="keyword">case</span> .next(<span class="keyword">let</span> isHidden): </span><br><span class="line">            <span class="keyword">self</span>?.usernameValidOutlet.isHidden = isHidden </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">break</span> </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid </span><br><span class="line">    .bind(to: observer) </span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h3 id="binderui-观察者"><a class="markdownIt-Anchor" href="#binderui-观察者"></a> Binder–UI 观察者</h3><p>类注释：</p><blockquote><p>强制执行接口绑定规则的观察者:</p><ul><li>无法绑定错误（在调试版本中，错误的绑定会导致致命错误，在发布版本中的错误会被记录）</li><li>确保在特定的调度程序上执行绑定</li></ul><p><code>Binder</code> 不会保留目标，并且在释放目标的情况下，元素也不会绑定。</p><p>默认情况下，它绑定主调度程序上的元素</p></blockquote><ol><li>Binder 主要有以下特征：</li></ol><ul><li>处理 next 事件</li><li>不处理错误事件</li><li>确保绑定都是在给定 Scheduler 上执⾏（默认 MainScheduler）</li></ul><p>⼀旦产⽣错误事件，在调试环境下将执⾏ fatalError，在发布环境下将打印错误信息。</p><ol start="2"><li>示例，对比上面的 <a href="#anchor">AnyObserver示例</a></li></ol><p>由于这个观察者是⼀个 UI 观察者，所以它在响应事件时，只会处理 next 事件 并且更新 UI 的操作需要在主线程上执⾏。 因此⼀个更好的⽅案就是使⽤ Binder：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> observer: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; = <span class="type">Binder</span>(usernameValidOutlet) &#123; (view, isHidden) <span class="keyword">in</span> </span><br><span class="line">    view.isHidden = isHidden </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">usernameValid </span><br><span class="line">    .bind(to: observer) </span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><ol start="3"><li>RxCocoa 中的 rx 扩展对于 Binder 的使用：</li></ol><p>你也可以⽤这种⽅式来创建⾃定义的 UI 观察者。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isHidden: <span class="type">Binder</span>&lt;<span class="type">Bool</span>&gt; &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; view, hidden <span class="keyword">in</span> </span><br><span class="line">            view.isHidden = hidden </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UILabel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> text: <span class="type">Binder</span>&lt;<span class="type">String?</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; label, text <span class="keyword">in</span></span><br><span class="line">            label.text = text </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：</p><blockquote><p><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/rxswift_core/observer.html" target="_blank" rel="noopener">Observer - 观察者</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hot 和 Cold Observables</title>
      <link href="/2018/02/02/RxSwfit+RAC/Hot-%E5%92%8C-Cold-Observables/"/>
      <url>/2018/02/02/RxSwfit+RAC/Hot-%E5%92%8C-Cold-Observables/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/HotAndColdObservables.md" target="_blank" rel="noopener">原文: Hot and Cold Observables</a></p><p>恕我直言，我建议更多地将其视为序列的属性，而不是单独的类型，因为它们由完全适合它们的相同抽象表示，即可观察序列。</p><p>这是ReactiveX.io的定义:</p><blockquote><p>Observable何时开始发出其项目序列？这取决于 Observable.<br>“hot” Observable 对象可能会在创建后立即开始发射项目，因此以后订阅该 Observable 对象的任何观察者都可以开始观察中间位置的序列。<br>“cold”Observable对象要等到观察者订阅它，然后才能开始发射项目，因此可以保证这样的观察者从一开始就可以看到整个序列。</p></blockquote><table><thead><tr><th>Hot Observables</th><th>Cold observables</th></tr></thead><tbody><tr><td>… are sequences</td><td>… are sequences</td></tr><tr><td>Use resources (“produce heat”) no matter if there is any observer subscribed.</td><td>Don’t use resources (don’t produce heat) until observer subscribes.</td></tr><tr><td>Variables / properties / constants, tap coordinates, mouse coordinates, UI control values, current time</td><td>Async operations, HTTP Connections, TCP connections, streams</td></tr><tr><td>Usually contains ~ N elements</td><td>Usually contains ~ 1 element</td></tr><tr><td>Sequence elements are produced no matter if there is any observer subscribed.</td><td>Sequence elements are produced only if there is a subscribed observer.</td></tr><tr><td>Observable Sequence 被多个订阅它的 observers 共享</td><td>每个订阅的 observer 都会有一个 Observable Sequence</td></tr><tr><td>Usually stateful</td><td>Usually stateless</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 翻译 </tag>
            
            <tag> RAC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxSwift 1.特征</title>
      <link href="/2018/01/31/RxSwfit+RAC/RxSwift-%E7%89%B9%E5%BE%81/"/>
      <url>/2018/01/31/RxSwfit+RAC/RxSwift-%E7%89%B9%E5%BE%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>特性完全是可选的。你可以自由地在程序中的任何地方使用原始的Observable序列，因为所有核心RxSwift / RxCocoa API都支持它们。</p><div align="center"><img src="/img/Traits.jpeg" alt="Traits" style="width:300px;height:240px"></div><h2 id="特征是如何工作的"><a class="markdownIt-Anchor" href="#特征是如何工作的"></a> 特征是如何工作的</h2><p>特性只是 Observable sequence 的包装器结构。</p><p>你可以将它们视为可观察序列的一种构建器模式实现。构建特质后，调用.asObservable() 会将其转换回原始的可观察序列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Single</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Driver</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> source: <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可观察序列"><a class="markdownIt-Anchor" href="#可观察序列"></a> 可观察序列</h2><p>Observable Sequence: 它是信号源，产生事件，RxSwift 重视 <code>Observable&lt;T&gt;</code> 类。</p><p>下面介绍的几个类型都是在 <code>Observable&lt;T&gt;</code> 类的基础上定制化出来的特征序列。</p><p><code>Observable&lt;T&gt;</code> 可发送出来的事件类型</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span>&lt;<span class="title">Element</span>&gt; </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> next(<span class="type">Element</span>) </span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>) </span><br><span class="line">    <span class="keyword">case</span> completed </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rxswift-特征-singlecompletablemaybe"><a class="markdownIt-Anchor" href="#rxswift-特征-singlecompletablemaybe"></a> RxSwift 特征 Single/Completable/Maybe</h3><h4 id="single"><a class="markdownIt-Anchor" href="#single"></a> Single</h4><ol><li>Single 只能发送两个事件</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEvent</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)</span></span><br><span class="line">  <span class="keyword">case</span> success(<span class="type">Element</span>)</span><br><span class="line">  <span class="comment">/// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)</span></span><br><span class="line">  <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 Single 的初始化中可以看到做了 SingleEvent -&gt; Event 的处理</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(subscribe: @escaping <span class="params">(@escaping SingleObserver)</span></span></span> -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">Single</span>&lt;<span class="type">Element</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> source = <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">switch</span> event &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> element):</span><br><span class="line">          observer.on(.next(element))</span><br><span class="line">          observer.on(.completed)</span><br><span class="line">        <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">          observer.on(.error(error))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">PrimitiveSequence</span>(raw: source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>.success</code> 事件中，<code>Single</code> 发送了一个 .next 后紧跟着又发送了 .completed 事件，所以:</li></ol><ul><li>success - 产⽣⼀个单独的元素</li><li>error - 产⽣⼀个错误</li><li>不会共享附加作用</li></ul><ol start="4"><li><code>Single</code> 实际场景：</li></ol><p><code>Single</code> 的例⼦就是执⾏ HTTP 请求，然后返回⼀个应答或错误。不过你也可以⽤ Single 来描述 任何只有⼀个元素的序列。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getRepo</span><span class="params">(<span class="number">_</span> repo: String)</span></span> -&gt; <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="type">Any</span>]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Single</span>&lt;[<span class="type">String</span>: <span class="type">Any</span>]&gt;.create &#123; single <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: <span class="string">"https://api.github.com/repos/\(repo)"</span>)!) &#123; data, <span class="number">_</span>, error <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">                single(.error(error))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> data = data,</span><br><span class="line">                  <span class="keyword">let</span> json = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject(with: data, options: .mutableLeaves),</span><br><span class="line">                  <span class="keyword">let</span> result = json <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">else</span> &#123;</span><br><span class="line">                single(.error(<span class="type">DataError</span>.cantParseJSON))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            single(.success(result))</span><br><span class="line">        &#125;</span><br><span class="line">        task.resume() </span><br><span class="line">        <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123; task.cancel() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getRepo(<span class="string">"ReactiveX/RxSwift"</span>)</span><br><span class="line">    .subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> json):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"JSON: "</span>, json)</span><br><span class="line">            <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Error: "</span>, error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getRepo(<span class="string">"ReactiveX/RxSwift"</span>)</span><br><span class="line">    .subscribe(onSuccess: &#123; json <span class="keyword">in</span></span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">"JSON: "</span>, json)</span><br><span class="line">               &#125;,</span><br><span class="line">               onError: &#123; error <span class="keyword">in</span></span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">"Error: "</span>, error)</span><br><span class="line">               &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><ol start="4"><li>可以对 Observable 调⽤ .asSingle() ⽅法，将它转换为 Single。</li></ol><h4 id="completable"><a class="markdownIt-Anchor" href="#completable"></a> Completable</h4><ol><li>Completable 也只能发送两个事件，他没有 .next 事件，所以他们有接受数据值相关的事件！</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">CompletableEvent</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)</span></span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    <span class="comment">/// Sequence completed successfully.</span></span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Completable 创建方法同 Single，也是做了 CompletableEvent -&gt; Event 的处理</li></ol><ul><li>没有 next 事件，不会发出元素</li><li>只发送 completed 或者 error</li><li>不会共享附加作⽤</li></ul><ol start="3"><li><code>Completable</code> 实际场景：</li></ol><p><code>Completable</code> 适⽤于那种你只关⼼任务是否完成，⽽不需要在意任务返回值的情况。它和 Observable<void>有点相似。</void></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cacheLocally</span><span class="params">()</span></span> -&gt; <span class="type">Completable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Completable</span>.create &#123; completable <span class="keyword">in</span></span><br><span class="line">       <span class="comment">// Store some data locally</span></span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">guard</span> success <span class="keyword">else</span> &#123;</span><br><span class="line">           completable(.error(<span class="type">CacheError</span>.failedCaching))</span><br><span class="line">           <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">       completable(.completed)</span><br><span class="line">       <span class="keyword">return</span> <span class="type">Disposables</span>.create &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cacheLocally()</span><br><span class="line">    .subscribe &#123; completable <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">switch</span> completable &#123;</span><br><span class="line">            <span class="keyword">case</span> .completed:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Completed with no error"</span>)</span><br><span class="line">            <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Completed with an error: \(error.localizedDescription)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cacheLocally()</span><br><span class="line">    .subscribe(onCompleted: &#123;</span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">"Completed with no error"</span>)</span><br><span class="line">               &#125;,</span><br><span class="line">               onError: &#123; error <span class="keyword">in</span></span><br><span class="line">                   <span class="built_in">print</span>(<span class="string">"Completed with an error: \(error.localizedDescription)"</span>)</span><br><span class="line">               &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h4 id="maybe"><a class="markdownIt-Anchor" href="#maybe"></a> Maybe</h4><ol><li>它介于 Single 和 Completable 之间，它要么只能发出⼀个元素，要么产⽣⼀个 completed 事件，要么产⽣⼀个 error 事件。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">MaybeEvent</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`)</span></span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Element</span>) </span><br><span class="line">    <span class="comment">/// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`)</span></span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">    <span class="comment">/// Sequence completed successfully.</span></span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>Maybe 初始化方法，做了 MaybeEvent -&gt; Event 的处理</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">(subscribe: @escaping <span class="params">(@escaping MaybeObserver)</span></span></span> -&gt; <span class="type">Disposable</span>) -&gt; <span class="type">PrimitiveSequence</span>&lt;<span class="type">Trait</span>, <span class="type">Element</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> source = <span class="type">Observable</span>&lt;<span class="type">Element</span>&gt;.create &#123; observer <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> subscribe &#123; event <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">switch</span> event &#123;</span><br><span class="line">            <span class="keyword">case</span> .success(<span class="keyword">let</span> element):</span><br><span class="line">                observer.on(.next(element))</span><br><span class="line">                observer.on(.completed)</span><br><span class="line">            <span class="keyword">case</span> .error(<span class="keyword">let</span> error):</span><br><span class="line">                observer.on(.error(error))</span><br><span class="line">            <span class="keyword">case</span> .completed:</span><br><span class="line">                observer.on(.completed)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">PrimitiveSequence</span>(raw: source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用场景</p></li><li><p>Observable 调⽤ .asMaybe() ⽅法，将它转换为 Maybe。</p></li></ol><h3 id="rxcocoa-特征-driversignalcontrolevent"><a class="markdownIt-Anchor" href="#rxcocoa-特征-driversignalcontrolevent"></a> RxCocoa 特征 Driver/Signal/ControlEvent</h3><h4 id="driver"><a class="markdownIt-Anchor" href="#driver"></a> Driver</h4><ol><li>主要是为了简化 UI 层的代码。不过如果你遇到的序 列具有以下特征，你也可以使⽤它：</li></ol><ul><li>不会产⽣ error 事件</li><li>⼀定在 MainScheduler 监听（主线程监听）</li><li>共享附加作⽤</li></ul><ol start="2"><li>为什么要叫 Driver 呢？</li></ol><p>它的目的是让 model 数据层驱动 UI 变化。</p><p>E.g.</p><ul><li>Drive UI from CoreData model.</li><li>Drive UI using values from other UI elements (bindings). …</li></ul><p>初学者会使用这样的：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text</span><br><span class="line">    .throttle(.milliseconds(<span class="number">300</span>), scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"\($0.count)"</span> &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"\(result)"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>上面的代码会有什么问题？</p><ul><li>如果 fetchAutoCompleteItems observable sequence 发出 error (eg连接失败，解析错误), 这样的错误不会解绑订阅，UI再也不会响应新的查询</li><li>如果 fetchAutoCompleteItems 返回的结果在某个后台线程，后台线程返回的结果会绑定到 UI元素，导致确定性的 crashs</li><li>结果绑定到两个 UI 元素上，意味着每次用户查询都会发送 2次 HTTP 请求，这不是开发者的本意</li></ul><p>该代码的更合适版本如下所示：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text</span><br><span class="line">    .throttle(.milliseconds(<span class="number">300</span>), scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .observeOn(<span class="type">MainScheduler</span>.instance)</span><br><span class="line">            <span class="comment">// results are returned on MainScheduler</span></span><br><span class="line">            .catchErrorJustReturn([])</span><br><span class="line">            <span class="comment">// in the worst case, errors are handled</span></span><br><span class="line">    &#125;</span><br><span class="line">    .share(replay: <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// HTTP requests are shared and results replayed</span></span><br><span class="line">    <span class="comment">// to all UI elements</span></span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"\($0.count)"</span> &#125;</span><br><span class="line">    .bind(to: resultCount.rx.text)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .bind(to: resultsTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"\(result)"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>确保在大型系统中正确处理所有需求很具有挑战性，但是有一种更简单的方法，使用编译器和特征来证明满足这些要求。</p><p>以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> results = query.rx.text.asDriver()</span><br><span class="line"><span class="comment">// This converts a normal sequence into a `Driver` sequence.</span></span><br><span class="line">    .throttle(.milliseconds(<span class="number">300</span>), scheduler: <span class="type">MainScheduler</span>.instance)</span><br><span class="line">    .flatMapLatest &#123; query <span class="keyword">in</span></span><br><span class="line">        fetchAutoCompleteItems(query)</span><br><span class="line">            .asDriver(onErrorJustReturn: [])  </span><br><span class="line">            <span class="comment">// Builder just needs info about what to return in case of error.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">results</span><br><span class="line">    .<span class="built_in">map</span> &#123; <span class="string">"\($0.count)"</span> &#125;</span><br><span class="line">    <span class="comment">//Driver 的订阅要使用 drive来做</span></span><br><span class="line">    .drive(resultCount.rx.text)</span><br><span class="line">    <span class="comment">// If there is a `drive` method available instead of `bind(to:)`,</span></span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    <span class="comment">// that means that the compiler has proven that all properties</span></span><br><span class="line">    <span class="comment">// are satisfied.</span></span><br><span class="line">results</span><br><span class="line">    .drive(resultsTableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; (<span class="number">_</span>, result, cell) <span class="keyword">in</span></span><br><span class="line">        cell.textLabel?.text = <span class="string">"\(result)"</span></span><br><span class="line">    &#125;</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>所以上面代码发生了什么？</p><ol><li>asDriver方法将ControlProperty特性转换为Driver特性。</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query.rx.text.asDriver()</span><br></pre></td></tr></table></figure><p>注意，没有什么特别的事情要做。<br>Driver 具有 ControlProperty 特性的所有属性，以及其他一些属性。底层的 observable sequence 只是包装为Driver trait，仅此而已。</p><ol start="2"><li>observable sequence 转化为 Driver</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.asDriver(onErrorJustReturn: [])</span><br></pre></td></tr></table></figure><p>P.S. 任何 observable sequence 转化为 Driver 都必须满足下面三点</p><ul><li>Can’t error out.</li><li>Observe on main scheduler.</li><li>Sharing side effects (share(replay: 1, scope: .whileConnected)).</li></ul><p>那么，如何确保满足这些呢？只需使用普通的Rx运算符即可。asDriver(onErrorJustReturn:[])等效于以下代码。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> safeSequence = xs</span><br><span class="line">  .observeOn(<span class="type">MainScheduler</span>.instance)        <span class="comment">// observe events on main scheduler</span></span><br><span class="line">  .catchErrorJustReturn(onErrorJustReturn)  <span class="comment">// can't error out</span></span><br><span class="line">  .share(replay: <span class="number">1</span>, scope: .whileConnected) <span class="comment">// side effects sharing</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="type">Driver</span>(raw: safeSequence)            <span class="comment">// wrap it up</span></span><br></pre></td></tr></table></figure><p>最后一步是使用 <code>drive</code> ，而不是使用 <code>bind(to:)</code>。</p><h4 id="signal"><a class="markdownIt-Anchor" href="#signal"></a> Signal</h4><ol><li>Signal 和 Driver 相似，唯⼀的区别是，Driver 会对新观察者回放（重新发送）上⼀个元素，⽽ Signal 不会对新观察者回放上⼀个元素。</li></ol><ul><li>不会产⽣ error 事件</li><li>在 MainScheduler 监听（主线程监听）</li><li>共享附加作⽤</li></ul><ol start="2"><li>Signal 和 Driver 的区别示例</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> textField: <span class="type">UITextField</span> = ... </span><br><span class="line"><span class="keyword">let</span> nameLabel: <span class="type">UILabel</span> = ... </span><br><span class="line"><span class="keyword">let</span> nameSizeLabel: <span class="type">UILabel</span> = ... </span><br><span class="line"><span class="keyword">let</span> state: <span class="type">Driver</span>&lt;<span class="type">String?</span>&gt; = textField.rx.text.asDriver() </span><br><span class="line"><span class="keyword">let</span> observer = nameLabel.rx.text </span><br><span class="line">state.drive(observer) </span><br><span class="line"><span class="comment">// ... 假设以下代码是在⽤户输⼊姓名后运⾏ </span></span><br><span class="line"><span class="keyword">let</span> newObserver = nameSizeLabel.rx.text </span><br><span class="line">state.<span class="built_in">map</span> &#123; $<span class="number">0</span>?.<span class="built_in">count</span>.description &#125;.drive(newObserver)</span><br></pre></td></tr></table></figure><p>这个例⼦是将⽤户输⼊的姓名绑定到对应的标签上。当⽤户输⼊姓名后，我们创建了⼀个新的观察者，⽤于订阅姓名的字数。<br>那么问题来了，订阅时，展示字数的标签会⽴即更新吗？ 因为 Driver 会对新观察者回放上⼀个元素（当前姓名），所以这⾥是会更新的。在对他进⾏订阅时，标签的默认⽂本会被刷新。这是合理的。</p><p>那如果我们⽤ Driver 来描述点击事件呢，这样合理吗？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button: <span class="type">UIButton</span> = ... </span><br><span class="line"><span class="keyword">let</span> showAlert: (<span class="type">String</span>) -&gt; <span class="type">Void</span> = ... </span><br><span class="line"><span class="keyword">let</span> event: <span class="type">Driver</span>&lt;<span class="type">Void</span>&gt; = button.rx.tap.asDriver() </span><br><span class="line"><span class="keyword">let</span> observer: () -&gt; <span class="type">Void</span> = &#123; showAlert(<span class="string">"弹出提示框1"</span>) &#125; </span><br><span class="line">event.drive(onNext: observer) </span><br><span class="line"><span class="comment">// ... 假设以下代码是在⽤户点击 button 后运⾏ </span></span><br><span class="line"><span class="keyword">let</span> newObserver: () -&gt; <span class="type">Void</span> = &#123; showAlert(<span class="string">"弹出提示框2"</span>) &#125; </span><br><span class="line">event.drive(onNext: newObserver)</span><br></pre></td></tr></table></figure><p>当⽤户点击⼀个按钮后，创建⼀个新的观察者，来响应点击事件。此时会发⽣什么？<br>Driver 会把上⼀次的点击事件回放给新观察者。所以，这⾥的 newObserver 在订阅时，就会接受到上次的点击事件，然后弹出提示框。这似乎不太合理。</p><p>于是我们就引⼊了 Signal:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> event: <span class="type">Signal</span>&lt;<span class="type">Void</span>&gt; = button.rx.tap.asSignal()</span><br><span class="line"><span class="keyword">let</span> observer: () -&gt; <span class="type">Void</span> = &#123; showAlert(<span class="string">"弹出提示框1"</span>) &#125; </span><br><span class="line">event.emit(onNext: observer) </span><br><span class="line"><span class="comment">// ... 假设以下代码是在⽤户点击 button 后运⾏ </span></span><br><span class="line"><span class="keyword">let</span> newObserver: () -&gt; <span class="type">Void</span> = &#123; showAlert(<span class="string">"弹出提示框2"</span>) &#125; </span><br><span class="line">event.emit(onNext: newObserver)</span><br></pre></td></tr></table></figure><p>在同样的场景中，Signal 不会把上⼀次的点击事件回放给新观察者，⽽只会将订阅后产⽣的点击事件，发布给新观察者。这正是我们所需要的。</p><ol start="3"><li>结论: ⼀般情况下状态序列我们会选⽤ Driver 这个类型，事件序列我们会选⽤ Signal 这个类型。</li></ol><h4 id="controlproperty"><a class="markdownIt-Anchor" href="#controlproperty"></a> ControlProperty</h4><ol><li>它是 Observable / ObservableType 特性，表示UI元素的属性。</li></ol><p>值序列仅表示初始控制值和用户启动的值更改。程序化价值的变化将不会报告。</p><ol start="2"><li><p>它的特点：</p><ul><li>永远不会失败</li><li>share(replay: 1)共享最新值<ul><li>它是有状态的，一旦订阅如果有产生过值，那么最新的值会立即重播</li></ul></li><li>当控件销毁的时候发送 complete 事件</li><li>不发送 error 事件</li><li>在主线程上传播 events</li></ul></li><li><p>实际使用案例</p></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UISearchBar</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Reactive wrapper for `text` property.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">ControlProperty</span>&lt;<span class="type">String?</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> source: <span class="type">Observable</span>&lt;<span class="type">String?</span>&gt; = <span class="type">Observable</span>.deferred &#123; [<span class="keyword">weak</span> searchBar = <span class="keyword">self</span>.base <span class="keyword">as</span> <span class="type">UISearchBar</span>] () -&gt; <span class="type">Observable</span>&lt;<span class="type">String?</span>&gt; <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">let</span> text = searchBar?.text</span><br><span class="line">            <span class="keyword">return</span> (searchBar?.rx.delegate.methodInvoked(#selector(<span class="type">UISearchBarDelegate</span>.searchBar(<span class="number">_</span>:textDidChange:))) ?? <span class="type">Observable</span>.empty())</span><br><span class="line">                    .<span class="built_in">map</span> &#123; a <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">return</span> a[<span class="number">1</span>] <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    .startWith(text)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> bindingObserver = <span class="type">Binder</span>(<span class="keyword">self</span>.base) &#123; (searchBar, text: <span class="type">String?</span>) <span class="keyword">in</span></span><br><span class="line">            searchBar.text = text</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ControlProperty</span>(values: source, valueSink: bindingObserver)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UISegmentedControl</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Reactive wrapper for `selectedSegmentIndex` property.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> selectedSegmentIndex: <span class="type">ControlProperty</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Reactive wrapper for `selectedSegmentIndex` property.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> value: <span class="type">ControlProperty</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">UIControl</span>.rx.value(</span><br><span class="line">            <span class="keyword">self</span>.base,</span><br><span class="line">            getter: &#123; segmentedControl <span class="keyword">in</span></span><br><span class="line">                segmentedControl.selectedSegmentIndex</span><br><span class="line">            &#125;, setter: &#123; segmentedControl, value <span class="keyword">in</span></span><br><span class="line">                segmentedControl.selectedSegmentIndex = value</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="controlevent"><a class="markdownIt-Anchor" href="#controlevent"></a> ControlEvent</h4><ol><li><p>它是 Observable / ObservableType 特性，表示UI元素的事件。</p></li><li><p>特点：</p><ul><li>永不失败</li><li>订阅的时候不会发送初试值</li><li>当控件销毁时，发送 complete</li><li>不发送 errors 事件</li><li>在主线程发送 events</li></ul></li><li><p>实际使用案例</p></li></ol><p>这是一个典型的示例，你可以在开发中使用它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Reactive wrapper for `viewDidLoad` message `UIViewController:viewDidLoad:`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> viewDidLoad: <span class="type">ControlEvent</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> source = <span class="keyword">self</span>.methodInvoked(#selector(<span class="type">Base</span>.viewDidLoad)).<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ControlEvent</span>(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在UICollectionView + Rx中，我们可以通过以下方式找到它：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UICollectionView</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`.</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> itemSelected: <span class="type">ControlEvent</span>&lt;<span class="type">IndexPath</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> source = delegate.methodInvoked(#selector(<span class="type">UICollectionViewDelegate</span>.collectionView(<span class="number">_</span>:didSelectItemAt:)))</span><br><span class="line">            .<span class="built_in">map</span> &#123; a <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] <span class="keyword">as</span>! <span class="type">IndexPath</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ControlEvent</span>(events: source)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：</p><blockquote><p><a href="https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Traits.md" target="_blank" rel="noopener">Traits</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协调器 Redux</title>
      <link href="/2018/01/24/architecture/%E5%8D%8F%E8%B0%83%E5%99%A8-Redux/"/>
      <url>/2018/01/24/architecture/%E5%8D%8F%E8%B0%83%E5%99%A8-Redux/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p><a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">原文：Coordinators Redux</a></p><p>今年年初我写过关于 <a href="http://khanlou.com/2015/01/the-coordinator/" target="_blank" rel="noopener">协调器</a>的文章, 但是自从那以后对于协调器的思考已经成熟了很多，我想通过这几个月所学的东西来来重新介绍这个话题。</p><p>这是根据我<a href="http://nsspain.com/2015/" target="_blank" rel="noopener">今年在NSSpain</a>的一次演讲改编而成。<a href="https://www.slideshare.net/secret/3jJlEE1weo0RRl" target="_blank" rel="noopener">此处</a>找到幻灯片。在<a href="https://vimeo.com/144116310" target="_blank" rel="noopener">这里</a>找到视频。</p><h2 id="三个问题"><a class="markdownIt-Anchor" href="#三个问题"></a> 三个问题</h2><h3 id="1-app-delegates-中放的东西太多了"><a class="markdownIt-Anchor" href="#1-app-delegates-中放的东西太多了"></a> 1. App Delegates 中放的东西太多了</h3><p>苹果公司在指导我们将代码放在合适的地方方面做得非常糟糕。弄清如何构建 App 完全由我们自己决定。最开始写代码的地方显而易见是 app’s delegate.</p><p>app delegate 是每个 App 的入口。它的主要职责是从操作系统到应用程序的子系统来回传递消息。不幸的是，由于它位于所有事物的中心，因此很容易在东西放在这。这样设计方式中的一个受害者就是 rootViewController 的配置。如果你的使用 tabbarController 作为 root，那么你必须要在某个配置所有的 tabbarController 的 children，并且 App delegate 就是个很好的场所。</p><p>我写的第一个 App（对于大多数读者我猜测，这是真的），我在我的AppDelegate中，为 rootviewcontroller 配置了所有配置。那些代码真的不属于这里，写在这里只是为了方便。</p><p>在我写完我第一个 app 以后我意识到了这个，然后我变得聪明了，我是用了这样的技巧：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SKTabBarController</span> : <span class="title">UITabBarController</span></span></span><br></pre></td></tr></table></figure><p>我会创建一个我想要使用的 rootViewController 子类，然后我会把代码挪到这里。这只是关于这个问题的临时补丁，最后发现这也不是此代码该放的地方。我建议我们研究这个对象——rootViewController，从责任的角度。管理子视图控制器属于这些职责，但分配和配置它们的职责不多。我们正在对一个从未打算进行子类化的东西进行子类化，只是为了我们可以隐藏一些无家可归的代码。</p><p>对于此应用程序配置逻辑，我们需要一个更好的家。</p><h3 id="2太多责任"><a class="markdownIt-Anchor" href="#2太多责任"></a> 2.太多责任</h3><p>这里有另外一个问题。单个ViewController也遇到这样的问题，把大量的责任放倾倒App delegate里面。</p><p>ViewController 中负责的一些事情：</p><ol><li>模型视图绑定</li><li>子视图分配内存</li><li>获取数据</li><li>布局</li><li>数据转换</li><li>导航流程</li><li>用户输入</li><li>模型变化</li><li>还有更多</li></ol><p>我提过一些方法将这些责任藏到 ViewController 的 children中，方法在<a href="http://khanlou.com/2014/09/8-patterns-to-help-you-destroy-massive-view-controller/" target="_blank" rel="noopener">8 Patterns to Help You Destroy Massive View Controller</a>中. 所有责任不能在一个地方，这样 ViewController 中的代码就会少于 3000行了。</p><p>哪些东西应该在这个类？哪些应该在别的地方？ViewController的工作是什么？这些问题还没有理清楚。</p><p>引用 Graham Lee 说的一句话，我很喜欢。</p><blockquote><p>When you get overly attached to MVC, then you look at every class you create and ask the question “is this a model, a view, or a controller?”. Because this question makes no sense, the answer doesn’t either: anything that isn’t evidently data or evidently graphics gets put into the amorphous “controller” collection, which eventually sucks your entire codebase into its innards like a black hole collapsing under its own weight.</p></blockquote><p>什么是ViewController？Smalltalkian意义上的控制器<a href="http://khanlou.com/2014/03/model-view-whatever/" target="_blank" rel="noopener">最初严格是为用户输入而设计</a>的。甚至“控制”一词也给我们带来了麻烦。如我<a href="http://khanlou.com/2014/11/a-controller-by-any-other-name/" target="_blank" rel="noopener">之前所写</a>：</p><blockquote><p>When you call something a Controller, it absolves you of the need to separate your concerns. Nothing is out of scope, since its purpose is to control things. Your code quickly devolves into a procedure, reaching deep into other objects to query their state and manipulate them from afar. Boundless, it begins absorbing responsibilities.</p></blockquote><h3 id="平缓的-flow"><a class="markdownIt-Anchor" href="#平缓的-flow"></a> 平缓的 Flow</h3><p>最后一个我想要讨论的问题是：navigation flow</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;  </span><br><span class="line">  <span class="keyword">id</span> object = [<span class="keyword">self</span>.dataSource objectAtIndexPath:indexPath];  </span><br><span class="line">  <span class="built_in">SKDetailViewController</span> *detailViewController = [[<span class="built_in">SKDetailViewController</span> alloc] initWithDetailObject:object];  </span><br><span class="line">  [<span class="keyword">self</span>.navigationController pushViewController:detailViewController animated:<span class="literal">YES</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这事一段很常见的代码，不幸的是，他是垃圾代码。让我们一行行看：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> object = [<span class="keyword">self</span>.dataSource objectAtIndexPath:indexPath];</span><br></pre></td></tr></table></figure><p>第一行的 <code>dataSource</code> 是 ViewController 逻辑上的 child，然后我们正在跟他要我们需要引用的的对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SKDetailViewController</span> *detailViewController = [[<span class="built_in">SKDetailViewController</span> alloc] initWithDetailObject:object];</span><br></pre></td></tr></table></figure><p>这里事情开始变得麻烦。ViewController 正在实例化一个新的 ViewController，然后配置它。这个 ViewController ”知道“ 在 flow 中接下来会流出什么。他知道新的 ViewController 是怎么配置的。正在执行 Presenting 的 ViewController 知道他所在 App 位置中的大量细节（新 ViewController的配置细节）。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.navigationController pushViewController:detailViewController animated:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>第三行是它完全偏离轨道的地方。这个 ViewController 知道了他的父级 ViewController，因为请记住，这些视图控制器在同一层次结构中，子 ViewController 会向父 ViewController 发送消息，告诉他要做什么。子 ViewController 正在指挥他的父亲。在现实世界里，孩子不应该到处指挥自己的父亲。<strong>在编程中，我会说孩子甚至不应该知道他们的父亲是谁！</strong></p><p>在<a href="http://khanlou.com/2014/09/8-patterns-to-help-you-destroy-massive-view-controller/" target="_blank" rel="noopener">8种模式帮助你干掉大量的ViewController</a>, 我建议使用一个 <code>Navigator</code> 类型，它可以注入到那些包含导航逻辑的 ViewControllers 中。如果你想要把导航逻辑放到同一个地方， <code>Navigators</code> 是一个不错的解决方案，但是我们很快遇到一个导航器没办法帮我们解决的问题。</p><p>在这三行代码中有很多逻辑，但是 ViewController 不是这些逻辑发生的地方。想象你有个编辑图像的 app</p><p>你的 <code>PhotoSelectionViewController</code> presents <code>StraighteningViewController</code> presents <code>FilteringViewController</code> presents <code>CaptioningViewController</code>。你的导航 flow 现在分布在三个不同的对象之间。进一步说，某个 ViewController presenting <code>PhotoSelectionViewController</code> ，但是 dismissal 逻辑必须要在 <code>CaptioningViewController</code> 中处理。</p><p>传递 <code>Navigator</code> 使这些 ViewControllers 保持链状连接在一起，并不能真正解决每个 ViewController 知道链中下一个的问题。</p><p>我们也需要解决这个问题。</p><h3 id="libraries-vs-frameworks"><a class="markdownIt-Anchor" href="#libraries-vs-frameworks"></a> Libraries vs Frameworks</h3><p>我认为Apple 希望我们以所有这些方式编写代码。他们希望我们使用 ViewController 成为世界中心，因为所有以相同样式编写的 app 都可以通过更改SDK发挥最大的影响力。不幸的是，对于开发者，这并不总是最好的举动。我们是负责将来维护 app 的人，可靠的设计和代码可扩展性是我们最看重的。</p><p>他们说libraries 和 frameworks 的区别是，你调用 libraries，frameworks 调用你。我想尽可能像依赖 libraries 的方式，对待 3rd-party 依赖。</p><p>当使用 <code>UIKit</code> ，你不需要负责什么。调用 <code>-pushViewController:animated:</code> 然后它做一些工作。并且在将来的某个不确定的时间，下一个ViewController出现他会调用 <code>viewDidLoad:</code> 在这里面你可做更多事。你不应该让 <code>UIKit</code> 决定何时运行代码，而是应尽快退出 <code>UIKit</code> -land, 以便你可以完全控制代码的流向。</p><p>我曾经将ViewController为 app 中最高等级的东西，这些东西知道如何运行整个app。但是我开始想颠覆这个想法后他会是什么样子。view 对其 ViewController是透明的。view 由 ViewController 控制。如果我们以相同的方式使视图控制器只是另一透明的东西怎么办？</p><h2 id="coordinators"><a class="markdownIt-Anchor" href="#coordinators"></a> Coordinators</h2><p><strong>什么是 Coordinators ？</strong></p><p>Coordinator 是用于管理一个or 多个ViewController的对象。将所有驱动逻辑从 ViewController中移除，并将这些内容向上移动一层，这会使你的生活变得更加美好。</p><p>这一切都从 app Coordinator 开始。Coordinator解决 app delegate 中内容过多的问题。app delegate 可以保留app Coordinator并启动它。app Coordinator 将为app 设置主视图控制器。可以在文献中找到这种模式，例如<a href="https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420" target="_blank" rel="noopener">企业应用程序体系结构模式</a>之类的书。他们把 Coordinator 叫做 <a href="http://martinfowler.com/eaaCatalog/applicationController.html" target="_blank" rel="noopener">Application Controller</a>. app coordinator 是 Application Controller 的特别版，尤其对于 iOS。app coordinator 可以创建并配置 ViewController，或者它可以长生新的子 Coordinator来执行子任务。</p><p>coordinators 可以接管 ViewController的哪些任务？主要是 navigation 和 model 变化.(我的意思是通过模型变化将用户的更改保存在数据库中，或者对 API 进行 <code>PUT</code> or <code>POST</code> 请求，这些都会破坏性地修改用户的数据。)</p><p>当你把这些任务从ViewController中拿走，我们最终得到了一个惰性的 ViewController。它可以呈现，可以获取数据，对其进行转换以进行呈现、显示，但至关重要的是无法对其进行更改。现在我们知道，每当展示 ViewController 时，都不会让他自己控制。每当需要让我们知道事件或用户输入时，它都会使用委托方法。让我们看一个代码示例。</p><h3 id="代码示例"><a class="markdownIt-Anchor" href="#代码示例"></a> 代码示例</h3><p>让我们从 App delegate开始</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;  </span><br><span class="line">  <span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];  </span><br><span class="line">  <span class="keyword">self</span>.rootViewController = [[<span class="built_in">UINavigationController</span> alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.appCoordinator = [[<span class="built_in">SKAppCoordinator</span> alloc] initWithNavigationController:<span class="keyword">self</span>.rootViewController];  </span><br><span class="line">  [<span class="keyword">self</span>.appCoordinator start]; </span><br><span class="line">  [<span class="keyword">self</span>.window makeKeyAndVisible];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app delegate 构建 app 的window 和 root ViewController，然后开启 app Coordinator。Coordinator的初始化与开始工作是分开的。这样我们就可以按自己的意愿（懒惰，贪婪等）创建它，并且只有在准备好后才能启动它。</p><p>Coordinator 就是一个 NSObject:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SKAppCoordinator</span> : <span class="title">NSObject</span></span></span><br></pre></td></tr></table></figure><p>这很棒，这里没有秘密，<code>UIViewController</code> 有上千行代码，我们不知道当我们调用他的方法时会发生什么，因为他是闭源的。简单的 <code>NSObject</code> 类型对象运行app，可使一切变得更加简单。</p><p>app coordinator 使用他需要的数据初始化，这些数据包括 root ViewController</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithNavigationController:(<span class="built_in">UINavigationController</span> *)navigationController &#123;  </span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];  </span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>; </span><br><span class="line">  _navigationController = navigationController; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦我们调用 <code>-start</code> 方法，coordinator就会开始工作</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;  </span><br><span class="line">  <span class="keyword">if</span> ([<span class="keyword">self</span> isLoggedIn]) &#123;  </span><br><span class="line">    [<span class="keyword">self</span> showContent];  </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    [<span class="keyword">self</span> showAuthentication];  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从一开始 Coordinator 就做决定！以前像这样的逻辑没有固定位置，你可以把他放在 appdelegate中或者 ViewController中，但是放这两个地方都有各自的缺陷。在 ViewController中，你有一个 ViewController做超出它本身责任的事情。在 appdelegate中，你会放入一些与他不相关的代码污染他。</p><p>让我们研究一下 <code>-showAuthentication</code> 方法。在这里，base Coordinator 生成 子 Coordinator，并让其执行子任务</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showAuthentication &#123;  </span><br><span class="line">  <span class="built_in">SKAuthenticationCoordinator</span> *authCoordinator = [[<span class="built_in">SKKAuthenticationCoordinator</span> alloc] initWithNavigationViewController:<span class="keyword">self</span>.navigationController];  </span><br><span class="line">  authCoordinator.delegate = <span class="keyword">self</span>;  </span><br><span class="line">  [authCoordinator start];  </span><br><span class="line">  [<span class="keyword">self</span>.childCoordinators addObject:authCoordinator];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用 <code>childCoordinators</code> 数组引用 Coordinators，防止其被销毁。</p><p>ViewController存在一棵树中，并且每个 ViewController都包含一个 view。 view存在于 subViews 树中，而且每个 subview 有一个 layer。layers也存在于一棵树中。因为 <code>childCoordinators</code> ，你也会得到一棵 Coordinators 树。</p><p>子 Coordinator 会创建一些 ViewControllers，等待他们工作，viewcontroller 工作完后 Coordinator会通知我们。当 Coordinator 发送信号告知ViewController工作完时，它会清理自己，弹出他添加的所有 ViewController，然后使用委托将消息发送到父级。</p><p>一旦我们已认证，我们会得到一个 delegate 消息，然后我们允许子 Coordinator 销毁，然后我们返回平常的程序中。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)coordinatorDidAuthenticate:(<span class="built_in">SKAuthenticationCoordinator</span> *)coordinator &#123;  </span><br><span class="line">  [<span class="keyword">self</span>.childCoordinators removeObject:coordinator];  </span><br><span class="line">  [<span class="keyword">self</span> showContent];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在身份验证 Coordinator 内部，它创建所需的任何Viewcontroller，并将其推入导航控制器。让我们看一下。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AuthCoordinator</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithNavigationController:(<span class="built_in">UINavigationController</span> *)navigationController &#123;  </span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];  </span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  </span><br><span class="line">  _navigationController = navigationController;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化类似于app coordinator.</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;  </span><br><span class="line">  <span class="built_in">SKFirstRunViewController</span> *firstRunViewcontroller = [<span class="built_in">SKFirstRunViewController</span> new];  </span><br><span class="line">  firstRunViewcontroller.delegate = <span class="keyword">self</span>;  </span><br><span class="line">  [<span class="keyword">self</span>.navigationController pushViewController:firstRunViewcontroller animated:<span class="literal">NO</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>身份验证需要从“首次运行 viewcontroller”开始。该viewcontroller具有用于注册和登录的按钮，还可能包含一些幻灯片，解释了app。让我们继续使用该Viewcontroller 并成为其代表。</p><p>该ViewController 有一个 delegate，因此当用户点击“注册”按钮时，我们可以得到通知。Coordinator 将处理该操作，而不是ViewController需要知道要创建和呈现的注册ViewController。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)firstRunViewControllerDidTapSignup:(<span class="built_in">SKFirstRunViewController</span> *)firstRunViewController &#123;  </span><br><span class="line">  <span class="built_in">SKSignUpViewController</span> *signUpViewController = [[<span class="built_in">SKSignUpViewController</span> alloc] init];  </span><br><span class="line">  signupViewController.delegate = <span class="keyword">self</span>;  </span><br><span class="line">  [<span class="keyword">self</span>.navigationController pushViewController:signupViewController animated:<span class="literal">YES</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Coordinator 成为这个注册过的 ViewController的代理，为了它可以在按下按钮时通知我们。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signUpViewController:(<span class="built_in">SKSignUpViewController</span> *)signupViewController didTapSignupWithEmail:(<span class="built_in">NSString</span> *)email password:(<span class="built_in">NSString</span> *)password &#123;  </span><br><span class="line">  <span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诸如此类。在这里，我们实际上执行了注册API请求并保存了身份验证 token，然后通知了父coordinator。</p><p>每当ViewController发生任何事情（例如用户输入）时，ViewController都会告诉其delegate（在这种情况下为Coordinator），并且Coordinator将执行用户想要的实际任务。让Coordinator来完成这项工作很重要，以便 ViewController 保持惰性。</p><h3 id="为什么-coordinators-很好用"><a class="markdownIt-Anchor" href="#为什么-coordinators-很好用"></a> 为什么 Coordinators 很好用</h3><h4 id="1每个-viewcontroller-现在是孤立的"><a class="markdownIt-Anchor" href="#1每个-viewcontroller-现在是孤立的"></a> 1.每个 ViewController 现在是孤立的</h4><p>除了知道如何呈现数据，ViewController 啥都不知道。每当有什么事发生时，它都会通知 delegate，但是当然它不知道其 delegate 是谁。</p><p>以前，当分支时，ViewController 需要问“好吧，我在iPad还是iPhone上？”。“用户是否正在接受A / B测试？” 他们不再需要提这样的问题。我们是否只是将这个有条件的问题推给了 Coordinator ？从某种意义上讲，但是我们可以以更好的方式解决它。</p><p>当确实需要一次具有两个 flow 时，对于A / B测试或多个 size classes，你可以交换整个 Coordinator 对象，而不必在整个 ViewController 上粘贴一堆条件。</p><p>如果你想了解 flow 的工作方式，那么这非常容易，因为所有代码都在一个地方。</p><h4 id="2viewcontrollers-现在可以复用"><a class="markdownIt-Anchor" href="#2viewcontrollers-现在可以复用"></a> 2.ViewControllers 现在可以复用</h4><p>ViewControllers 对要显示的上下文或按钮的用途不承担任何责任。它们可以被使用和重新使用，以保持其美观，而不会拖累任何逻辑。</p><p>如果你要编写iPad版本的app，则只需替换 Coordinator 即可，并且可以重复使用所有ViewControllers。</p><h4 id="3app中每个任务和子任务都有一种专用的封装方式"><a class="markdownIt-Anchor" href="#3app中每个任务和子任务都有一种专用的封装方式"></a> 3.app中每个任务和子任务都有一种专用的封装方式</h4><p>即使任务可以在多个 ViewControllers 上运行，它也会被封装。如果你的iPad版本重复使用了其中的一些子任务，但没有重复使用，则仅使用这些子任务就非常容易。</p><h4 id="4coordinator-将显示绑定与副作用分开"><a class="markdownIt-Anchor" href="#4coordinator-将显示绑定与副作用分开"></a> 4.Coordinator 将显示绑定与副作用分开</h4><p>你再也不必担心在呈现 ViewController时，ViewController破坏数据了。它只能读取和显示，不能写入或破坏数据。这与<a href="https://en.wikipedia.org/wiki/Command%E2%80%93query_separation" target="_blank" rel="noopener">命令查询分离</a>相似。</p><h4 id="5-coordinator是完全由你控制的对象"><a class="markdownIt-Anchor" href="#5-coordinator是完全由你控制的对象"></a> 5. Coordinator是完全由你控制的对象</h4><p>你不必等待 <code>-viewDidLoad</code> 调用了，才可以进行工作。现在完全可以自己控制工作。在UIViewController超类中没有看不见的代码在做你不知道的事。取代被调用，你开始这个调用。</p><p>翻转此模型可以更轻松地了解发生了什么。app的行为对你完全透明，<code>UIKit</code> 现在只是你要使用它时调用的库。</p><p><a href="https://github.com/backchannel/BackchannelSDK-iOS" target="_blank" rel="noopener">Backchannel SDK</a> 使用此模式来管理其所有 ViewControllers。app coordinator 和身份验证 coordinator 示例来自该项目。</p><p>最后，Coordinator 只是一种组织模式。没有你能使用的 Coordinator 库，因为它很简单。没有可以 <code>pod</code> 的 Coordinator库，也米有可以继承的子类。甚至没有一个可遵循的协议。这不是缺点，而是使用像Coordinator这样的模式的优点：它只是你的代码，没有依赖项。</p><p>他们将使你的app和代码更易于管理。ViewController将具有更高的可重用性，并且比以往任何时候都更容易开发你的 app。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 设计思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxFlow 3: 提示和技巧</title>
      <link href="/2018/01/22/RxSwfit+RAC/RxFlow-3-%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7/"/>
      <url>/2018/01/22/RxSwfit+RAC/RxFlow-3-%E6%8F%90%E7%A4%BA%E5%92%8C%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><img src="https://twittemb.github.io/uploads/Weavy_part3.png" alt="-"></p><p>这篇是 RxFlow 系列文章的最后一章。在前两篇文章中，我已经介绍了所有关键功能/原理</p><p>让我们深入探讨我在响应式编程中发现的技巧和窍门。</p><h2 id="uiviewcontroller-支持-reactive"><a class="markdownIt-Anchor" href="#uiviewcontroller-支持-reactive"></a> UIViewController 支持 Reactive</h2><p>正如我们在第2篇中所看到的，我们有时需要以响应方式知道何时显示一个Presentable。一个 <strong>Presentable</strong> 暴露三个 Observables：</p><details><summary>code</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Observable that triggers a bool indicating if</span></span><br><span class="line"><span class="comment">/// the current Presentable is being displayed</span></span><br><span class="line"><span class="keyword">var</span> rxVisible: <span class="type">Observable</span>&lt;<span class="type">Bool</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Single triggered when this presentable is displayed</span></span><br><span class="line"><span class="comment">/// for the first time</span></span><br><span class="line"><span class="keyword">var</span> rxFirstTimeVisible: <span class="type">Single</span>&lt;<span class="type">Void</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Single triggered when this presentable is dismissed</span></span><br><span class="line"><span class="keyword">var</span> rxDismissed: <span class="type">Single</span>&lt;<span class="type">Void</span>&gt; &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure></pre></details><p>在 <strong>RxFlow</strong> 中，UIViewController 遵从 <strong>Presentable</strong> 协议，因此我们必须找到方法让他们支持 Reactive。</p><p>幸运的是在此过程中发现的一个项目在此方面起到了很大作用：<a href="https://github.com/devxoul/RxViewController" target="_blank" rel="noopener">RxViewController</a>.</p><p>通过应用我在这篇文章中(<a href="https://twittemb.github.io/swift/generics/reactive/rxswift/pattern/name%20space/2017/11/22/versatile-namespace/" target="_blank" rel="noopener">Swift中的静态名称空间</a>)描述的模式，它为UIViewControllers提供了Reactive扩展。它使用RxCocoa内置函数允许观察选择器调用。一旦理解了这一概念，便对UIViewController进行了自己的扩展。</p><details><summary>code</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Reactive</span> <span class="title">where</span> <span class="title">Base</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// Observable, triggered when the view has appeared for the first time</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> firstTimeViewDidAppear: <span class="type">Single</span>&lt;<span class="type">Void</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> sentMessage(#selector(<span class="type">Base</span>.viewDidAppear)).<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">Void</span>()</span><br><span class="line">        &#125;.take(<span class="number">1</span>).asSingle()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Observable, triggered when the view is being dismissed</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> dismissed: <span class="type">ControlEvent</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> source = sentMessage(#selector(<span class="type">Base</span>.dismiss))</span><br><span class="line">                     .<span class="built_in">map</span> &#123; $<span class="number">0</span>.first <span class="keyword">as</span>? <span class="type">Bool</span> ?? <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">ControlEvent</span>(events: source)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Observable, triggered when the view appearance state changes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> displayed: <span class="type">Observable</span>&lt;<span class="type">Bool</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> viewDidAppearObs = sentMessage(#selector(<span class="type">Base</span>.viewDidAppear))</span><br><span class="line">                               .<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">let</span> viewWillDisappearObs = sentMessage(#selector(<span class="type">Base</span>.viewWillDisappear))</span><br><span class="line">                                   .<span class="built_in">map</span> &#123; <span class="number">_</span> <span class="keyword">in</span> <span class="literal">false</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">Observable</span>&lt;<span class="type">Bool</span>&gt;.merge(viewDidAppearObs, viewWillDisappearObs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><p>作为记录，这就是 <strong>Coordinator</strong> 的用法，其中 <strong>“nextPresentable”</strong> 是由 <strong>Flow</strong> 上的 <strong>“navigate（to : )”</strong> 函数生成的 <strong>Presentable</strong> 。在已经关联的Presentable首次显示之后，我们仅监听下一个Stepper。</p><details><summary>code</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">nextPresentable.rxFirstTimeVisible.subscribe(onSuccess: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>,</span><br><span class="line">                                                           <span class="keyword">unowned</span> nextPresentable,</span><br><span class="line">                                                           <span class="keyword">unowned</span> nextStepper] (<span class="number">_</span>) <span class="keyword">in</span></span><br><span class="line">    <span class="comment">// we listen to the presentable's Stepper.</span></span><br><span class="line">    <span class="comment">// For each new Step value, we trigger a new navigation process</span></span><br><span class="line">    <span class="comment">// this is the core principle of the whole RxFlow mechanism</span></span><br><span class="line">    <span class="comment">// The process is paused each time the presentable is not currently displayed</span></span><br><span class="line">    <span class="comment">// for instance when another presentable is above it in the VCs hierarchy.</span></span><br><span class="line">    nextStepper.steps</span><br><span class="line">        .pausable(nextPresentable.rxVisible.startWith(<span class="literal">true</span>))</span><br><span class="line">        .asDriver(onErrorJustReturn: <span class="type">NoStep</span>())</span><br><span class="line">        .drive(onNext: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>] (step) <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// the nextPresentable's Stepper fires a new Step</span></span><br><span class="line">            <span class="keyword">self</span>.steps.onNext(step)</span><br><span class="line">        &#125;).disposed(by: nextPresentable.disposeBag)</span><br><span class="line"></span><br><span class="line">&#125;).disposed(by: <span class="keyword">self</span>.disposeBag)</span><br></pre></td></tr></table></figure></pre></details><h2 id="暂停"><a class="markdownIt-Anchor" href="#暂停"></a> 暂停</h2><p>在 RxFlow 中另一个关键原则：<strong>Flow</strong> 中发生什么就要停留在 <strong>Flow</strong> 中。因此我必须找到一个方式</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxFlow 2: 实践</title>
      <link href="/2018/01/21/RxSwfit+RAC/RxFlow-2-%E5%AE%9E%E8%B7%B5/"/>
      <url>/2018/01/21/RxSwfit+RAC/RxFlow-2-%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><strong>注意！！！</strong></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">NextFlowItems</span> = <span class="type">FlowContributors</span></span><br></pre></td></tr></table></figure><p><a href="https://twittemb.github.io/swift/coordinator/reactive/rxflow/reactive%20programming/2017/12/09/rxflow-part-2-in-practice/" target="_blank" rel="noopener">原文RxFlow Part 2: In Practice</a><br><img src="https://twittemb.github.io/uploads/RxFlowPart2.png" alt="-"></p><p>上篇：<a href="../RxFlow-1-%E5%8E%9F%E7%90%86">RxFlow-1-原理</a></p><p>几周前我介绍了 RxFlow 框架，我已经在这个框架上工作了几个月，现在可以使用了。如果您尚未阅读，建议您看一下这篇<a href="https://twittemb.github.io/swift/coordinator/rxswift/rxflow/reactive%20programming/2017/11/08/rxflow-part-1-in-theory/" target="_blank" rel="noopener">文章</a>。</p><p>总结，RxFlow 旨在：</p><ul><li>轻松的将你的导航切成逻辑部分</li><li>把导航代码从 ViewController 中删除</li><li>鼓励 ViewController 复用性</li><li>促进 响应式编程</li><li>促进 依赖注入</li></ul><p>快速回忆下以下术语：</p><ul><li>Flow: 每个 Flow 都在应用程序中定义了一个导航区域。</li><li>Step: 在应用中，每个 Step 就是一个导航状态，Flows 和 Steps 的结合描述了有所导航操作的可能。</li><li>Stepper: 任何可以发出 Steps 的东西。Steppers 负责触发每个在 Flows 中的导航操作</li><li>Presentable: 可以被呈现出来的事物的抽象（基本上是 UIViewController 和 可以呈现的 Flow）</li><li>NextFlowItem(FlowContributors): 他会告诉 Coordinator，在他的响应机制中，接下来将会是什么产生新的 Steps</li><li>Coordinator: Coordinator 的工作是以一种一直的方式混合Flows and Steps组合</li></ul><p>同样重要的是要记住，RxFlow使用面向协议的程序设计，这样它才不会将代码冻结在继承层次结构中。</p><p>在 <a href="https://github.com/RxSwiftCommunity/RxFlow" target="_blank" rel="noopener">RxFlow repo</a> 中，你将找到一个演示应用程序。它几乎显示了每种可能的导航类型</p><ul><li>Navigation stack</li><li>Tab bar</li><li>Master / detail</li><li>Modal popup</li></ul><p><img src="https://twittemb.github.io/uploads/versions/demoweavy-mov---x----185-400x---.gif" alt="-"></p><h2 id="都是关于-states"><a class="markdownIt-Anchor" href="#都是关于-states"></a> 都是关于 States</h2><p><strong>RxFlow</strong> 主要是使用响应式的方式处理导航状态。为了在多个上下文中复用，这些状态一定要不知道当前使用的导航 Flow。因此，状态不是表示“我要跳转到此屏幕”，而是表示“某人或某物执行此操作”，然后RxFlow会根据当前导航 Flow 选择正确的screen。对于 RxFlow，这个导航状态称为“<strong>Steps</strong>”。</p><p>枚举是描述 <strong>Steps</strong> 的好方法:</p><ul><li>枚举方便使用</li><li>一个 value 只可以被定义一次(因此一个状态是惟一的)</li><li>枚举可以安全使用，因为Swift在 switch 语法中要求你实现所有可能值</li><li>枚举可以关联 value，这些value 可以从一个 screen 传到另一个 screen</li><li>枚举是值类型，因此不存在传递不受控制的共享参考</li></ul><details><summary>eg: 在 demo App 中，这些都是我们涵盖导航可能性所需的所有 Steps。</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RxFlow</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DemoStep</span>: <span class="title">Step</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> apiKey</span><br><span class="line">    <span class="keyword">case</span> apiKeyIsComplete</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> movieList</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> moviePicked (withMovieId: <span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> castPicked (withCastId: <span class="type">Int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> settings</span><br><span class="line">    <span class="keyword">case</span> settingsDone</span><br><span class="line">    <span class="keyword">case</span> about</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h2 id="使用-flow"><a class="markdownIt-Anchor" href="#使用-flow"></a> 使用 Flow</h2><p>对于 <strong>RxFlow</strong>，所有导航代码都在 Flow 中声明，eg：presenting 或者 pushing ViewController。在你的 App 中一个 <strong>Flow</strong> 代表了导航逻辑段，当 Flow 和一个明确的 Step 结合后，Flow触发导航动作。</p><p>为此，<strong>Flow</strong> 要实现：</p><ul><li>一个 “<strong>navigate(to:)</strong>” 方法根据 Flow 和 Step，执行导航操作</li><li>一个 “<strong>root</strong>” UIViewController，他将基于在此 <strong>Flow</strong> 中的导航</li></ul><p>有个 <strong>Flow</strong> 控制 UINavigationController 和 stack的例子。</p><details><summary>在这个 Flow 中，可以执行3个导航操作。</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RxFlow</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchedFlow</span>: <span class="title">Flow</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> root: <span class="type">UIViewController</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.rootViewController</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> rootViewController = <span class="type">UINavigationController</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> service: <span class="type">MoviesService</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(withService service: <span class="type">MoviesService</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.service = service</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">navigate</span><span class="params">(to step: Step)</span></span> -&gt; [<span class="type">NextFlowItem</span>] <span class="comment">/*FlowContributors*/</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> step = step <span class="keyword">as</span>? <span class="type">DemoStep</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="type">NextFlowItem</span>.noNavigation &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> step &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .movieList:</span><br><span class="line">            <span class="keyword">return</span> navigateToMovieListScreen()</span><br><span class="line">        <span class="keyword">case</span> .moviePicked(<span class="keyword">let</span> movieId):</span><br><span class="line">            <span class="keyword">return</span> navigateToMovieDetailScreen(with: movieId)</span><br><span class="line">        <span class="keyword">case</span> .castPicked(<span class="keyword">let</span> castId):</span><br><span class="line">            <span class="keyword">return</span> navigateToCastDetailScreen(with: castId)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="type">NextFlowItem</span>.noNavigation</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">navigateToMovieListScreen</span> <span class="params">()</span></span> -&gt; [<span class="type">NextFlowItem</span>]<span class="comment">/*FlowContributors*/</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">WatchedViewModel</span>(with: <span class="keyword">self</span>.service)</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">WatchedViewController</span>.instantiate(with: viewModel)</span><br><span class="line">        viewController.title = <span class="string">"Watched"</span></span><br><span class="line">        <span class="keyword">self</span>.rootViewController.pushViewController(viewController, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="type">NextFlowItem</span>(nextPresentable: viewController, nextStepper: viewModel)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">navigateToMovieDetailScreen</span> <span class="params">(with movieId: Int)</span></span> -&gt; [<span class="type">NextFlowItem</span>]<span class="comment">/*FlowContributors*/</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">MovieDetailViewModel</span>(withService: <span class="keyword">self</span>.service,</span><br><span class="line">                                             andMovieId: movieId)</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">MovieDetailViewController</span>.instantiate(with: viewModel)</span><br><span class="line">        viewController.title = viewModel.title</span><br><span class="line">        <span class="keyword">self</span>.rootViewController.pushViewController(viewController, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="type">NextFlowItem</span>(nextPresentable: viewController, nextStepper: viewModel)]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">navigateToCastDetailScreen</span> <span class="params">(with castId: Int)</span></span> -&gt; [<span class="type">NextFlowItem</span>]<span class="comment">/*FlowContributors*/</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">CastDetailViewModel</span>(withService: <span class="keyword">self</span>.service,</span><br><span class="line">                                            andCastId: castId)</span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">CastDetailViewController</span>.instantiate(with: viewModel)</span><br><span class="line">        viewController.title = viewModel.name</span><br><span class="line">        <span class="keyword">self</span>.rootViewController.pushViewController(viewController, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NextFlowItem</span>.noNavigation</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h2 id="导航是一个副作用"><a class="markdownIt-Anchor" href="#导航是一个副作用"></a> 导航是一个副作用</h2><p>在学习函数响应式编程的时候，我们经常读到 <strong>副作用</strong>。FRP 的目的是传递事件，然后再整过程中使用 FRP 的函数处理事件。这些functions 可以转换事件，最终(但是不是必须)将执行你想要的任何功能的代码(网络请求，保存文件，显示一个 alert……)：这些是 <strong>副作用</strong></p><p>因为 RxFlow 依赖响应式编程，我们可以轻松地识别出固有的概念：</p><ul><li>events：发出 Steps</li><li>function：就是 “<strong>navigate(to:)</strong>” function</li><li>transformation：“<strong>navigate(to:)</strong>” 将 Step 转换成另一个 <strong>NextFlowItem</strong> (FlowContributors)</li><li>side effects：执行在“<strong>navigate(to:)</strong>”中的导航操作（eg: <strong>“navigateToMovieListScreen()”</strong> 方法在navigation stack 上 push 一个新的UIViewController）</li></ul><h2 id="navigating-是为了生成-nextflowitemsflowcontributors"><a class="markdownIt-Anchor" href="#navigating-是为了生成-nextflowitemsflowcontributors"></a> Navigating 是为了生成 NextFlowItems(FlowContributors)</h2><p>接着来说，一个 NextFlowItem(FlowContributors) 是一个持有一个 Presentable 和一个 Stepper 简单的数据结构。</p><ul><li><strong>Presentable</strong> 告诉 <strong>Coordinator</strong> 接下来你要 present 出来的是什么</li><li><strong>Stepper</strong> 告诉 <strong>Coordinator</strong> 接下来是什么东西发出 <strong>Steps</strong></li></ul><p>默认情况，所有的 UIViewController 都是 <strong>Presentable</strong>. <strong>Flows</strong> 也是 <strong>Presentable</strong>，因为有事，你想启动一个新的导航区域，该区域在他自己的 <strong>Flow</strong> 中描述，所以 RxFlow 也会把他当做可以被 present 的东西</p><p>为什么 <strong>Coordinator</strong> 要知道 <strong>Presentables</strong>？</p><p><strong>Presentable</strong> 是一个描述可以被呈现的事物的抽象类。因为 <strong>Step</strong> 不会被发出，除非他关联的 <strong>Presentable</strong> 被显示，<strong>Presentable</strong> 提供 Observables，<strong>Coordinator</strong> 会订阅这个 Observables（所以 <strong>Coordinator</strong> 会知道 <strong>Presentable</strong> 的显示状态）。因此 <strong>Presentable</strong> 没有完全显示的时候发送一个 <strong>Step</strong> 不存在任何危险。</p><p><strong>Stepper</strong> 可以是任何东西：自定义的 UIViewController，ViewModel，Presenter…… 一旦他在 <strong>Coordinator</strong> 中注册，<strong>Stepper</strong> 就可以通过他的 ”<strong>step</strong>&quot; 属性发送 <strong>Steps</strong>(step 是 RxSwift 中的 subject)。 <strong>Coordinator</strong> 会监听 <strong>Stepper</strong> 发送出来的 <strong>Steps</strong>，调用 <strong>Flow’s “navigate(to:)”</strong></p><details><summary>在 demo App 中有一个 Stepper 例子：</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RxFlow</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchedViewModel</span>: <span class="title">Stepper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> movies: [<span class="type">MovieViewModel</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(with service: <span class="type">MoviesService</span>) &#123;</span><br><span class="line">        <span class="comment">// we can do some data refactoring in order to display</span></span><br><span class="line">        <span class="comment">// things exactly the way we want (this is the aim of a ViewModel)</span></span><br><span class="line">        <span class="keyword">self</span>.movies = service.watchedMovies().<span class="built_in">map</span>(&#123; (movie) -&gt; <span class="type">MovieViewModel</span> <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">MovieViewModel</span>(id: movie.id,</span><br><span class="line">                                  title: movie.title,</span><br><span class="line">                                  image: movie.image)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pick</span> <span class="params">(movieId: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.step.onNext(<span class="type">DemoStep</span>.moviePicked(withMovieId: movieId))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><p>在这个例子中，当用户选择一个 movie的时候会调用 pick 函数。这个函数在 <strong>“self.step”</strong> Rx Stream 中发出一个new value。</p><p>总结导航过程：</p><ul><li><strong>navigate(to:)</strong> 函数调用时，传入一个 <strong>Step</strong> 作为参数</li><li>根据这个 <strong>Step</strong>，一些导航代码被调用（<strong>side effects</strong>）</li><li>也根据这个 <strong>Step</strong>，产生 <strong>NextFlowItems</strong> (FlowContributors)。因此，<strong>Presentables</strong> 和 <strong>Steppers</strong> 被注册进 <strong>Coordinator</strong> 中</li><li><strong>Steppers</strong> 发出新的 <strong>Steps</strong>，然后再来一次以上过程</li></ul><h2 id="为什么对与一个-flow-step-组合产生多个-nextflowitems-flowcontributors是可以的"><a class="markdownIt-Anchor" href="#为什么对与一个-flow-step-组合产生多个-nextflowitems-flowcontributors是可以的"></a> 为什么对与一个 Flow &amp; Step 组合产生多个 <strong>NextFlowItems</strong> (FlowContributors)是可以的？</h2><p>因为在某一个时间没有什么禁止一个app有多个导航。eg: tab bar上面的每一个item 多会导向一个 navigation stack。<strong>Step</strong> 触发UITabbarController 显示，将在每个navigation stack 中生成一个 NextFlowItem (FlowContributors)。</p><details><summary>你可以看一下 demo app 理解一下概念。这里有我们把一个 UITabbarController 和 2个Flows连接的一段代码。</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">navigationToDashboardScreen</span> <span class="params">()</span></span> -&gt; [<span class="type">NextFlowItem</span>] <span class="comment">/*(FlowContributors)*/</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tabbarController = <span class="type">UITabBarController</span>()</span><br><span class="line">    <span class="keyword">let</span> wishlistStepper = <span class="type">WishlistStepper</span>()</span><br><span class="line">    <span class="keyword">let</span> wishListFlow = <span class="type">WishlistWarp</span>(withService: <span class="keyword">self</span>.service,</span><br><span class="line">                                    andStepper: wishlistStepper)</span><br><span class="line">    <span class="keyword">let</span> watchedFlow = <span class="type">WatchedFlow</span>(withService: <span class="keyword">self</span>.service)</span><br><span class="line"></span><br><span class="line">    <span class="type">Flows</span>.whenReady(flow1: wishListFlow, flow2: watchedFlow, block: &#123; [<span class="keyword">unowned</span> <span class="keyword">self</span>]</span><br><span class="line">    (root1: <span class="type">UINavigationController</span>, root2: <span class="type">UINavigationController</span>) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> tabBarItem1 = <span class="type">UITabBarItem</span>(title: <span class="string">"Wishlist"</span>,</span><br><span class="line">                                       image: <span class="type">UIImage</span>(named: <span class="string">"wishlist"</span>),</span><br><span class="line">                                       selectedImage: <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">let</span> tabBarItem2 = <span class="type">UITabBarItem</span>(title: <span class="string">"Watched"</span>,</span><br><span class="line">                                       image: <span class="type">UIImage</span>(named: <span class="string">"watched"</span>),</span><br><span class="line">                                       selectedImage: <span class="literal">nil</span>)</span><br><span class="line">        root1.tabBarItem = tabBarItem1</span><br><span class="line">        root1.title = <span class="string">"Wishlist"</span></span><br><span class="line">        root2.tabBarItem = tabBarItem2</span><br><span class="line">        root2.title = <span class="string">"Watched"</span></span><br><span class="line"></span><br><span class="line">        tabbarController.setViewControllers([root1, root2], animated: <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">self</span>.rootViewController.pushViewController(tabbarController, animated: <span class="literal">true</span>)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ([<span class="type">NextFlowItem</span>(nextPresentable: wishListFlow,</span><br><span class="line">                      nextStepper: wishlistStepper),</span><br><span class="line">             <span class="type">NextFlowItem</span>(nextPresentable: watchedFlow,</span><br><span class="line">                      nextStepper: <span class="type">OneStepper</span>(withSingleStep: <span class="type">DemoStep</span>.movieList))])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><br><p>静态方法 <strong>“Flows.whenReady()”</strong> 带着参数 <strong>Flows</strong> 启动还带有一个闭包，当 <strong>Flows</strong> 准备显示的时候回调（即当Flow的第一个屏幕被选中的时候）</p><h2 id="为什么对于flow和step的组合完全不产生nextflowitemflowcontributors为什么可以"><a class="markdownIt-Anchor" href="#为什么对于flow和step的组合完全不产生nextflowitemflowcontributors为什么可以"></a> 为什么对于Flow和Step的组合完全不产生NextFlowItem(FlowContributors)，为什么可以？</h2><p>因为导航 Flow 必须要有一个终点！eg 导航stack的最后一个屏幕不会再向下导航，他只可以 pop back。在这种情况，<strong>“navigate(to:)”</strong> 返回 <strong>NextFlowItem.noNavigation</strong>。</p><h2 id="在-flow-中会发生什么停留在-flow-中"><a class="markdownIt-Anchor" href="#在-flow-中会发生什么停留在-flow-中"></a> 在 Flow 中会发生什么……停留在 Flow 中！</h2><p>正如我们已经看到的，在同一时间有多个 <strong>Flows</strong> 被导航是可以的。eg：在 navigation stack 中的一个 screen 可以启动弹出窗口，该弹出窗口也可以包含另一个navigation stack。从 UIKit 的角度上看，UIViewController的层级结构非常重要，我们不能弄混 Coordinator 内部的层次结构。</p><p>这就是为什么当一个 <strong>Flow</strong> 没有显示（在我们的例子中，就是当第一个 navigation stack 在弹出窗口之下），Coordinator将忽视 <strong>Flow</strong> 中可能发出来的 <strong>Steps</strong>。</p><p>从更一般的角度来看，在 <strong>Flow</strong> 上下文中发出的 <strong>Steps</strong> 只能在该 <strong>Flow</strong> 上下文中解释（它们不能被其他 <strong>Flow</strong> 捕获）。</p><h2 id="依赖注入变得容易"><a class="markdownIt-Anchor" href="#依赖注入变得容易"></a> 依赖注入变得容易</h2><p>DI 是RxFlow的一个主要目标。基本上，依赖注入可以通过将某种实现（服务，管理器等）作为参数传递给初始化程序或方法来完成（也可以通过属性来完成）。</p><p>在 <strong>RxFlow</strong> 中, 开发人员负责实例化UIViewControllers，ViewModels，Presenter等,这是一个注入你所需代码的绝佳机会。</p><details><summary>下面是ViewModel中依赖项注入的示例。</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> RxFlow</span><br><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WatchedFlow</span>: <span class="title">Flow</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> service: <span class="type">MoviesService</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span>(withService service: <span class="type">MoviesService</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.service = service</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">navigateToMovieListScreen</span> <span class="params">()</span></span> -&gt; [<span class="type">NextFlowItem</span>] <span class="comment">/*(FlowContributors)*/</span> &#123;</span><br><span class="line">        <span class="comment">// inject Service into ViewModel</span></span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">WatchedViewModel</span>(with: <span class="keyword">self</span>.service)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// injecy ViewMNodel into UIViewController</span></span><br><span class="line">        <span class="keyword">let</span> viewController = <span class="type">WatchedViewController</span>.instantiate(with: viewModel)</span><br><span class="line"></span><br><span class="line">        viewController.title = <span class="string">"Watched"</span></span><br><span class="line">        <span class="keyword">self</span>.rootViewController.pushViewController(viewController, animated: <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="type">NextFlowItem</span>(nextPresentable: viewController, nextStepper: viewModel)]</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h2 id="如何引导导航过程"><a class="markdownIt-Anchor" href="#如何引导导航过程"></a> 如何引导导航过程</h2><p>既然已经知道如何将事物组合在一起，将 <strong>Flows</strong> 和 <strong>Steps</strong> 混合在一起以触发导航动作并产生NextFlowItems (FlowContributors)，剩下要做的一件事：在应用程序启动时引导导航过程。</p><p>一切都在AppDelegate中发生，并且会发现这非常简单：</p><ul><li>实例化 <strong>Coordinator</strong></li><li>实例化要导航的第一个 <strong>Flow</strong></li><li>让 <strong>Coordinator</strong> 使用第一个 <strong>Step</strong> 来调度 <strong>Flow</strong></li><li>当第一个 <strong>Flow</strong> 准本好了，把他的 root 配置成 Window的 rootViewController</li></ul><details><summary>在 demo App 中：</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"><span class="keyword">import</span> RxFlow</span><br><span class="line"><span class="keyword">import</span> RxSwift</span><br><span class="line"><span class="keyword">import</span> RxCocoa</span><br><span class="line"></span><br><span class="line"><span class="meta">@UIApplicationMain</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIApplicationDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> disposeBag = <span class="type">DisposeBag</span>()</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    <span class="keyword">var</span> coordinator = <span class="type">Coordinator</span>()</span><br><span class="line">    <span class="keyword">let</span> movieService = <span class="type">MoviesService</span>()</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> mainFlow = &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">MainFlow</span>(with: <span class="keyword">self</span>.movieService)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication,</span></span></span><br><span class="line"><span class="function"><span class="params">                     didFinishWithOptions options: [UIApplicationLaunchOptionsKey: <span class="keyword">Any</span>]?)</span></span></span><br><span class="line">                     -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> window = <span class="keyword">self</span>.window <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Flows</span>.whenReady(flow: mainFlow, block: &#123; [<span class="keyword">unowned</span> window] (root) <span class="keyword">in</span></span><br><span class="line">            window.rootViewController = root</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        coordinator.coordinate(flow: mainFlow,</span><br><span class="line">                               withStepper: <span class="type">OneStepper</span>(withSingleStep: <span class="type">DemoStep</span>.apiKey))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h2 id="奖励"><a class="markdownIt-Anchor" href="#奖励"></a> 奖励</h2><p>协调器有两个响应式扩展：willNavigate和didNavigate。例如，你可以在AppDelegate中订阅它们。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">coordinator.rx.didNavigate.subscribe(onNext: &#123; (flow, step) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"did navigate to flow=\(flow) and step=\(step)"</span>)</span><br><span class="line">&#125;).disposed</span><br></pre></td></tr></table></figure><details><summary>将会生成如下 log：</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">MainFlow</span> step=apiKeyIsComplete</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WishlistFlow</span> step=movieList</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WatchedFlow</span> step=movieList</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WishlistFlow</span> step=moviePicked(<span class="number">23452</span>)</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WishlistFlow</span> step=castPicked(<span class="number">2</span>)</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WatchedFlow</span> step=moviePicked(<span class="number">55423</span>)</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WatchedFlow</span> step=castPicked(<span class="number">5</span>)</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">WishlistFlow</span> step=settings</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">SettingsFlow</span> step=settings</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">SettingsFlow</span> step=apiKey</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">SettingsFlow</span> step=about</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">SettingsFlow</span> step=apiKey</span><br><span class="line">did navigate flow=<span class="type">RxFlowDemo</span>.<span class="type">SettingsFlow</span> step=settingsDone</span><br></pre></td></tr></table></figure></pre></details><p>日志对于分析和debug 程序很有帮助</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxFlow 1: 原理</title>
      <link href="/2018/01/21/RxSwfit+RAC/RxFlow-1-%E5%8E%9F%E7%90%86/"/>
      <url>/2018/01/21/RxSwfit+RAC/RxFlow-1-%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><img src="https://twittemb.github.io/uploads/RxFlow_Logo.png" alt="-"><br><a href="https://twittemb.github.io/swift/coordinator/rxswift/rxflow/reactive%20programming/2017/11/08/rxflow-part-1-in-theory/" target="_blank" rel="noopener">原文RxFlow Part 1: In Theory</a></p><p>这篇是该系列文章的第一篇，该篇也是该系列文章的核心。我会介绍 <code>RxFlow</code> ：它是一个我基于 iOS App上设计实现的响应式流中介器(Reactive Flow Coordinator)</p><h2 id="事实"><a class="markdownIt-Anchor" href="#事实"></a> 事实</h2><p>关于iOS应用程序中的导航，有两种选择：</p><ul><li>使用 Apple Xcode 提供的内建机制：storyboards 和 segues</li><li>用代码实现一个自定义机制</li></ul><p>这两种解决方案的缺点：</p><ul><li>内建机制：navigation 相对来说静止，storyboards 相对来说过于庞大。导航代码污染了 UIViewControllers</li><li>自定义机制：代码可能难以设置，也可能很复杂，具体取决于所选的设计模式（Router，Coordinator）</li></ul><h4 id="rxflow-旨在"><a class="markdownIt-Anchor" href="#rxflow-旨在"></a> RxFlow 旨在</h4><ul><li>促进将 storyboards 切割成原子单元，以实现UIViewControllers的协作和可重用性</li><li>允许 UIViewController 根据导航上下文以不同方式呈现</li><li>简化依赖注入的实现</li><li>从UIViewControllers删除导航机制</li><li>促进响应式编程</li><li>在处理大多数导航案例的同时，以声明的方式表示导航（以声明式的方式处理导航过程）</li><li>促进将应用程序切成逻辑导航块</li></ul><h2 id="从-storyboard-到-coordinator-模式"><a class="markdownIt-Anchor" href="#从-storyboard-到-coordinator-模式"></a> 从 Storyboard 到 Coordinator 模式</h2><p>作为 iOS 开发人员，随着开发能力提高（Android或者web），我经常遇到关于导航的同样疑问。对于其他所有概念问题，有很多模式可以解决常见的体系结构问题和关注点分离需求（MVC,MVP,MVVM,VIPER)</p><p>但是，一旦设计导航，我就犯愁了：</p><ul><li>如何在Storyboard / Segues中使用依赖项注入？</li><li>如何控制应用程序的流程？</li><li>如何摆脱UIViewControllers中的导航样板代码？</li></ul><p>随着时间的流逝，我对iOS应用程序从 MVC模式带一个Storyboard 到 MVC模式待多个 Storyboards，最后到 MVVM模式 + Flow Coordinator —— 目前来说他是我们可以叫上名字的最佳实践了。MVVM模式 + Flow Coordinator 好是因为我们可以进行依赖注入，UIViewController 可复用行，可测试性。我有机会将此模式应用于生产中的大型复杂应用程序。但是最后，仍然有一些问题困扰着我：</p><ul><li>我总是不得不一次次地写 Coordinator 模式</li><li>使用大量 delegate 模式，让 ViewModels 得到 Coordinator 回调信息</li><li>一开始我看 Redux 模式，尤其是导航状态机。我们可以有个全局导航状态，使用 RxSwift Observables暴露出来，然后监听状态驱动导航。唯一困扰我的是导航状态的唯一性，以及它可能具有不受控制的责任（以及它可以存储的海量数据）</li></ul><p>出现了这样的一个想法：导航只是一种状态的反射，这种状态可以一步步修改。</p><p>一个状态，在整个应用程序结构中传播，不是存储在单个位置中，而是由观察者统一起来，可以对它作出反应并因此驱动导航。文章之后，这些分散在应用程序中的小状态称为“Steps”，观察者称为“Coordinator”。</p><p>RxFlow 来自经验总结，他解决了传统中仍然存在的两个主要问题;Coordinator pattern:</p><ul><li>开发人员不必再编写Coordinator，他只需要声明导航及其所针对的状态</li><li>不需要 delegate，因为 state 是由 Loom 监听 RxSwift Observable</li></ul><h2 id="关键原则"><a class="markdownIt-Anchor" href="#关键原则"></a> 关键原则</h2><p>要了解有关 Coordinator 模式的更多信息，我建议你开一下这篇文章 <a href="http://khanlou.com/2015/10/coordinators-redux/" target="_blank" rel="noopener">Coordinator Redux</a></p><p>尽管这是一个非常好的架构，但是Coordinator模式也有一些缺点：</p><ul><li>每次引导应用程序时都必须编写协调机制</li><li>因为要使用 delegate 模式来处理与 Coordinator 之间通信，所以会有很多样板代码</li></ul><p>RxFlow 是一个以响应式方式实现的 Coordinator 模式，它有 Coordinator 模式架构中的所有重要功能，但进行了一些改进：</p><ul><li>使导航更具声明性</li><li>提供一个内置的协调器，用于处理你声明的导航流</li><li>使用响应式编程处理和 Coordinator 通讯的问题</li></ul><h4 id="必须熟悉6个术语才能理解rxflow"><a class="markdownIt-Anchor" href="#必须熟悉6个术语才能理解rxflow"></a> 必须熟悉6个术语才能理解RxFlow</h4><ul><li>Flow：每个 Flow 都在应用程序中定义了一个导航区域。这是你声明导航动作的地方</li><li>Step：每个 Step 在 App 中是一个导航状态。Flows 和 Steps 的组合描述了所有可能的导航操作。Step 甚至可以内嵌值（eg：Ids，URLs…）将会传播到 Flows 中声明的屏幕</li><li>Stepper：它可以是任何发出 Steps 的东西，Steppers 负责触发 Flows中的每个导航过程。</li><li>Presentable：它是可以呈现的事物的抽象类（基本上是UIViewController和Flow是可呈现的）。Presentables 提供响应式 Observables， Coordinator 将以兼容 UIKit 的方式，订阅这个 Observables 来控制Flow的 Steps</li><li>Flowable：它是一个结合了Presentable和Stepper的简单数据结构。它告诉 Coordinator 下一步将发生什么，这将在您的响应式机制中产生新的 Steps</li><li>Coordinator：一旦开发人员定义完 代表导航可能性的流程和步骤的组合，Coordinator 的工作就是以一致的方式混合这些组合。</li></ul><p>第一篇文章只是说明框架的 概念理论，接下的文章将会从源码的角度讨论更多 有关 RxFlow 的技术点。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> RxSwift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC 对象分析</title>
      <link href="/2018/01/09/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/OC-%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/"/>
      <url>/2018/01/09/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/OC-%E5%AF%B9%E8%B1%A1%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><p>引用源码：<a href="https://opensource.apple.com/tarballs/objc4/" target="_blank" rel="noopener">objc4</a></p><p><img src="/img/oc_object.jpg" alt="oc对象结构"></p><p>思考：问自己的问题</p><ol><li>实例对象，类对象，元类对象之间的关系</li><li>对象的属性&amp;方法是怎么传的</li><li>对象方法是如何查询的</li><li>oc 的消息机制是什么样的</li><li>这些理论可以应用到什么地方？</li></ol><h2 id="objective-c中的对象有哪些"><a class="markdownIt-Anchor" href="#objective-c中的对象有哪些"></a> Objective-C中的对象有哪些</h2><p>Objective-C中万物接对象，对象主要分为3种</p><ul><li>instance对象</li><li>class对象</li><li>meta-class对象</li></ul><h2 id="objc_object-源码结构"><a class="markdownIt-Anchor" href="#objc_object-源码结构"></a> objc_object 源码结构</h2><p><img src="/img/objc_object_struct.jpg" alt="objc_object"></p><h2 id="objc_class-源码结构"><a class="markdownIt-Anchor" href="#objc_class-源码结构"></a> objc_class 源码结构</h2><p><img src="/img/objc_class_struct.jpg" alt="objc_class"></p><p>class 和 meta-class 的结构相同</p><ul><li>class_rw_t<ul><li>保存了class的 methodlists, propertylists, protocollists</li></ul></li><li>class_ro_t<ul><li>保存了父类的 methodlists, propertylists, protocollists</li></ul></li></ul><h3 id="isa-和-superclass-指针"><a class="markdownIt-Anchor" href="#isa-和-superclass-指针"></a> isa 和 superclass 指针</h3><p><img src="/img/isa_superclass.jpg" alt=""></p><p>isa 指向生产他这个对象的对象：</p><ol><li>instance 对象的isa 是class 对象</li><li>class 对象的 isa 是 meta-class 对象</li><li>meta-class 的 isa 是 root-metaclass 对象（所有元类的 isa 都指向他）</li></ol><p><img src="/img/message-searching.jpg" alt=""></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meta Class</title>
      <link href="/2018/01/03/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/Meta-Class/"/>
      <url>/2018/01/03/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/Meta-Class/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p>smallTalk 中 Metaclass 的 7个要素</p><ol><li>object 是 class 的实例</li><li>class 最终继承自 object</li><li>class 是 metaclass 的实例</li><li>metaclass 和 class 的继承是平行的</li><li>metaclass 继承自 class 和 behavior</li><li>metaclass 是 Metaclass 的实例</li><li>Metaclass 的 metaclass 是 Metaclass 的实例</li></ol><h2 id="object-是-class-的实例"><a class="markdownIt-Anchor" href="#object-是-class-的实例"></a> object 是 class 的实例</h2><p><img src="/img/object_is_class.jpeg" alt="object 是 class 的实例"></p><h2 id="每个-class-都继承自-object"><a class="markdownIt-Anchor" href="#每个-class-都继承自-object"></a> 每个 class 都继承自 Object</h2><p>实例对象的 class 都继承自 Object<br><img src="/img/classInheritsObject.jpeg" alt="objc_class: objc_object"></p><h3 id="is-a-的含义"><a class="markdownIt-Anchor" href="#is-a-的含义"></a> is-a 的含义</h3><p>当 Object 接收 msg 的时候，在他的 class 对象方法列表中找，一直沿着 superclasses ，知道 Object 对象查找这个消息<br><img src="/img/is-a.jpeg" alt="is-a用于查找消息"></p><h3 id="object-的责任"><a class="markdownIt-Anchor" href="#object-的责任"></a> Object 的责任</h3><ol><li>描述 Object 的公共行为<ul><li>error-handling, halting …</li></ul></li><li>所有类最终都继承自 Object</li></ol><h2 id="class-是-metaclass-的实例"><a class="markdownIt-Anchor" href="#class-是-metaclass-的实例"></a> class 是 metaclass 的实例</h2><p>Class 也是对象：每个 class A 是他的 metaclass 的唯一实例，叫做 A class<br><img src="/img/metaclass.jpeg" alt=""></p><h3 id="metaclasses-是隐式的"><a class="markdownIt-Anchor" href="#metaclasses-是隐式的"></a> metaclasses 是隐式的</h3><ol><li>当创建 class 的是时候，会隐式创建 Metaclass</li><li>没有共享的 metaclass(class 和 metaclass 是一一对应的)</li></ol><h2 id="metaclass-和-class-的继承是平行的"><a class="markdownIt-Anchor" href="#metaclass-和-class-的继承是平行的"></a> metaclass 和 class 的继承是平行的</h2><p>class 和 object 的一致性</p><ol><li><strong>object 有的东西，class 也有</strong></li><li><strong>同样的方法查询策略</strong><ol><li>object 在class 的 method 字典中查找</li><li>class 在 metaclass 的method 字典中查找</li></ol></li></ol><h2 id="metaclass-继承自-class-和-behavior"><a class="markdownIt-Anchor" href="#metaclass-继承自-class-和-behavior"></a> metaclass 继承自 class 和 behavior</h2><h2 id="metaclass-是-metaclass-的实例"><a class="markdownIt-Anchor" href="#metaclass-是-metaclass-的实例"></a> metaclass 是 Metaclass 的实例</h2><h2 id="metaclass-的-metaclass-是-metaclass-的实例"><a class="markdownIt-Anchor" href="#metaclass-的-metaclass-是-metaclass-的实例"></a> Metaclass 的 metaclass 是 Metaclass 的实例</h2><p><img src="/img/metaclass_relation.jpeg" alt=""></p><h2 id="为什么要有-metaclass"><a class="markdownIt-Anchor" href="#为什么要有-metaclass"></a> 为什么要有 MetaClass</h2><p>objc_class: objc_object, 所以object 有的东西 class 也有</p><ol><li>object 是 class 的实例，class 是 metaclass 的实例</li><li>object 方法，属性，协议方法都保存在 class 对象中；class方法，属性，协议方法都保存在 metaclass 对象中</li><li>class 是 object 的工厂，metaclass 是class 的工厂</li><li>因为class 继承自 object 所以消息查找方式相同</li></ol><p>如果没有 metaclass 呢？</p><ol><li>smalltalk-76，类的类都是 <code>Class</code> ，该类实现了任何类都需要的方法-eg. new方法。如果想添加一个类方法，必须添加到 <code>Class</code></li><li>objc_msgSend(void /* id self, SEL op, … */) 复用消息通道，类方法也可以放在Class里，但发送消息时，需要增加一个参数</li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flexbox model</title>
      <link href="/2017/12/09/UI%20%E7%9B%B8%E5%85%B3/flexbox-model/"/>
      <url>/2017/12/09/UI%20%E7%9B%B8%E5%85%B3/flexbox-model/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content" target="_blank" rel="noopener">flex-container 属性demo</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex" target="_blank" rel="noopener">flex-item 属性demo</a></p><h2 id="基础术语"><a class="markdownIt-Anchor" href="#基础术语"></a> 基础&amp;术语</h2><div align="center"><img src="/img/flex_terms.jpeg" alt="flex_terms" style="width:300px;height:180px"></div><ul><li>main axis - flex container 主轴，<code>flex-items</code> 沿着这个轴布局。具体哪个方向取决于 <code>flex-direction</code> 属性 (see below).</li><li>main-start | main-end - <code>flex-items</code> 在 flex-container 中从 main-start 到 main-end 布局.</li><li>main size - flex-item <code>main-axis</code> 方向的长度</li><li>cross axis - 垂直于 <code>main-axis</code> 的轴。即垂直于 <code>flex-items</code> 排列布局方向的轴。</li><li>cross-start | cross-end - <code>Flex-item</code> 布局垂直方向布局从 cross-start 到 cross-end.</li><li>cross size - flex-item <code>cross-axis</code> 方向长度</li></ul><h2 id="属性"><a class="markdownIt-Anchor" href="#属性"></a> 属性</h2><table><thead><tr><th>属性</th><th>描述</th><th>可取值</th></tr></thead><tbody><tr><td>display</td><td>指定 HTML 元素盒子类型</td><td>flex,inline-flex</td></tr><tr><td>flex-direction</td><td>指定了弹性容器中子元素的排列方式</td><td>row,column</td></tr><tr><td>flex-wrap</td><td>设置弹性盒子的子元素超出父容器时是否换行</td><td>wrap,nowrap,wrap-reverse</td></tr><tr><td>justify-content</td><td>设置弹性盒子元素在主轴（横轴）方向上的对齐方式</td><td>flex-start,flex-end,center,space-around,space-between</td></tr><tr><td>align-self</td><td>在弹性子元素上使用覆盖容器的 align-items 属性</td><td>flex-start,flex-end,center</td></tr><tr><td>align-items</td><td>设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式</td><td>flex-start ,flex-end,center,stretch,baseline</td></tr><tr><td>align-content</td><td>修改 flex-wrap 属性的行为，类似align-items, 但不是设置子元素对齐，而是设置行对齐</td><td>flex-start,flex-end,center,space-around,space-between,stretch</td></tr><tr><td>order</td><td>设置弹性盒子的子元素排列顺序</td><td>integer</td></tr><tr><td>flex</td><td>设置弹性盒子的子元素如何分配空间</td><td>integer</td></tr><tr><td>flex-basis</td><td>指定 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</td><td>integer</td></tr><tr><td>flex-grow</td><td>元素的扩大比率</td><td>integer</td></tr><tr><td>flex-shrink</td><td>元素的收缩比率</td><td>integer</td></tr></tbody></table><h3 id="父级的属性flex-container"><a class="markdownIt-Anchor" href="#父级的属性flex-container"></a> 父级的属性–flex-container</h3><h4 id="flex-direction"><a class="markdownIt-Anchor" href="#flex-direction"></a> flex-direction</h4><div align="left"><img src="/img/flex-direction.jpeg" alt="direction" style="width:200px;height:83"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex-wrap"><a class="markdownIt-Anchor" href="#flex-wrap"></a> flex-wrap</h4><div align="left"><img src="/img/flex-wrap.jpeg" alt="runloop" style="width:200px;height:93"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap (default): 所有 items 都在一行显示</li><li>wrap: flex items 将从上到下多行显示。</li><li>wrap-reverse: 将从下到上多行显示。</li></ul><p><a href="https://codepen.io/team/css-tricks/pen/1ea1ef35d942d0041b0467b4d39888d3/" target="_blank" rel="noopener">flex-wrap 可视化demo</a><br>使用 demo的时候调整浏览器大小</p><h4 id="justify-content"><a class="markdownIt-Anchor" href="#justify-content"></a> justify-content</h4><p>main-axis 方向 flex-items 布局方式。</p><div align="left"><img src="/img/flex-justify-content.jpeg" alt="runloop" style="width:150px;height:240"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content" target="_blank" rel="noopener">justify-content: demo</a></p><h4 id="align-items"><a class="markdownIt-Anchor" href="#align-items"></a> align-items</h4><p>cross-axis 方向 flex-items 布局方式</p><div align="left"><img src="/img/flex-align-items.jpeg" alt="runloop" style="width:156px;height:200"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="align-content"><a class="markdownIt-Anchor" href="#align-content"></a> align-content</h4><p>类似align-items, 但不是设置子元素对齐，而是设置行对齐</p><div align="left"><img src="/img/flex-align-content.jpeg" alt="content" style="width:156px;height:190"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="次级属性flex-items"><a class="markdownIt-Anchor" href="#次级属性flex-items"></a> 次级属性(flex items)</h3><h4 id="order"><a class="markdownIt-Anchor" href="#order"></a> order</h4><p>元素排列顺序</p><div align="left"><img src="/img/flex-order.jpeg" alt="order" style="width:156px;height:190"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* default is 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex-grow"><a class="markdownIt-Anchor" href="#flex-grow"></a> flex-grow</h4><p>元素的扩展比率</p><div align="left"><img src="/img/flex-grow.jpeg" alt="content" style="width:156px;height:60"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="flex-shrink"><a class="markdownIt-Anchor" href="#flex-shrink"></a> flex-shrink</h4><p>元素的收缩比率</p><h4 id="flex-basis"><a class="markdownIt-Anchor" href="#flex-basis"></a> flex-basis</h4><p>flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。</p><h4 id="align-self"><a class="markdownIt-Anchor" href="#align-self"></a> align-self</h4><p>在弹性子元素上使用。覆盖容器的 align-items 属性。</p><div align="left"><img src="/img/flex-align-self.jpeg" alt="content" style="width:156px;height:77"></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引用：</p><blockquote><p><a href="https://www.w3cschool.cn/css3/2h6g5xoy.html" target="_blank" rel="noopener">CSS3 弹性盒子(Flex Box)</a><br><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">A Complete Guide to Flexbox</a><br><a href="https://codebond.co/tutorial/css/complete-guide-to-flexbox" target="_blank" rel="noopener">Complete Guide to Flexbox</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 设计思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP</title>
      <link href="/2017/11/18/%E7%BD%91%E7%BB%9C/TCP-IP/"/>
      <url>/2017/11/18/%E7%BD%91%E7%BB%9C/TCP-IP/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip"></a> TCP/IP</h2><h3 id="tcpip-三次握手"><a class="markdownIt-Anchor" href="#tcpip-三次握手"></a> TCP/IP 三次握手</h3><p>http 是基于 TCP/IP 协议，双全工</p><p><img src="/img/TCP-IP-Connection.JPG" alt="tcp/ip 三次握手，四次挥手"></p><ul><li><p>为什么要3次握手？</p><ul><li>最简单的回答，后一个次握手都是确定前一次握手的接受成功！除了第一次是有 seq=x，其他每次握手都要带上 ack=x+1，确定上一次的 seq接受成功</li><li>这也说明最后一次握手永远是否能够接受都是无法保障的，但是 &gt;= 三次握手基本满足需求，无需再浪费资源</li></ul></li><li><p>为什么要4次挥手？三次就可以满足双方都知道结果了呀？</p><ul><li>分手要双方都提出，我要分手，每一方提出都要对方确认一下！所以有了一对 (fin=x – ack=x+1), (fin=y – ack=y+1)</li><li>fin=x 是提出分手，编号x，ack=x+1 是确定受到 fin=x报文数据，然后我也要发一次我要分手</li><li>为什么要双方都要主动发送 fin 呢？因为一方发送 fin 以后，另一发有可能还有没有发完的数据，确认双方都是没有事要做了</li></ul></li></ul><h3 id="wireshark-使用验证-tcpip-连接"><a class="markdownIt-Anchor" href="#wireshark-使用验证-tcpip-连接"></a> WireShark 使用验证 TCP/IP 连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -l 12345        //监听</span><br><span class="line">nc 127.0.0.1 12345 //建立连接</span><br></pre></td></tr></table></figure><p>WireShark, Loopback:lo0</p><p><img src="/img/tcp-ip-wireshark1.jpeg" alt="tcp/ip wire-shark1 建立连接三次握手"></p><p><img src="/img/tcp-ip-wireshark2.jpeg" alt="tcp/ip wire-shark2 全流程"></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Category分析</title>
      <link href="/2017/11/17/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/Category%E5%88%86%E6%9E%90/"/>
      <url>/2017/11/17/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/Category%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>当给类添加方法的时候，一般会想到使用 category，给类添加方法</p><p>oc 的在runtime 的时候</p><h2 id="分类是如何加载的"><a class="markdownIt-Anchor" href="#分类是如何加载的"></a> 分类是如何加载的</h2><p>查看 objc 源码调用过程</p><ol><li><p><a href="http://objc-os.mm" target="_blank" rel="noopener">objc-os.mm</a><br>_objc_init<br>map_images<br>map_images_nolock</p></li><li><p><a href="http://objc-runtime-new.mm" target="_blank" rel="noopener">objc-runtime-new.mm</a><br>_read_images<br>remethodizeClass<br>attachCategories<br>attachLists<br>realloc、memmove、 memcpy</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">  <span class="keyword">classref_t</span> cls;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">  <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">method_list_t</span> *methodsForMeta(<span class="keyword">bool</span> isMeta) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMeta) <span class="keyword">return</span> classMethods;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> instanceMethods;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">property_list_t</span> *propertiesForMeta(<span class="keyword">bool</span> isMeta, struct header_info *hi);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAShapeLayer 画图</title>
      <link href="/2017/10/27/UI%20%E7%9B%B8%E5%85%B3/CAShapeLayer-%E7%94%BB%E5%9B%BE/"/>
      <url>/2017/10/27/UI%20%E7%9B%B8%E5%85%B3/CAShapeLayer-%E7%94%BB%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="为什么要有-shapelayer"><a class="markdownIt-Anchor" href="#为什么要有-shapelayer"></a> 为什么要有 ShapeLayer？</h2><p>因为平常开发中 主要是 矩形的绘制，很少用到其他多边形的（一般都用图片代替）<br>使用 ShapeLayer，通过 path 来定义自己的图形<br>嗯 shapelayer 就是一个 绘制 path 的工具</p><p>也可以用 <code>Core Graphics</code> 直接向原始的CALyer的内容中绘制路径<br>CAShapeLayer是一个通过 <code>矢量</code> 图形而不是 <code>bitmap</code> 来绘制的图层CALayer的子类。</p><p>相比直下，使用CAShapeLayer有以下一些优点：</p><ul><li>渲染快速: CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多</li><li>高效使用内存: 一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存</li><li>不会被图层边界剪裁掉: 一个CAShapeLayer可以在边界之外绘制:你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉</li><li>不会出现像素化: 当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化</li></ul><p>CAShapeLayer 会造成离屏渲染</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 性能 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动布局包裹视图</title>
      <link href="/2017/09/21/UI%20%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%8C%85%E8%A3%B9%E8%A7%86%E5%9B%BE/"/>
      <url>/2017/09/21/UI%20%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80%E5%8C%85%E8%A3%B9%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><a href="http://devetc.org/code/2014/07/07/auto-layout-and-views-that-wrap.html" target="_blank" rel="noopener">原文 Auto Layout and Views that Wrap</a><br>理解包裹文本和其他流动布局。<br>在视屏中，盒子里的面，当container resized 的时候，UILabel (或者 Mac 系统里面的 NSTextField) 包裹的文字的行为像这样：</p><p><a href="http://devetc.org/assets/2014-07-07-auto-layout-and-views-that-wrap/label-default-resize.webm" target="_blank" rel="noopener">video1</a></p><p>这篇文章将会讲解，当 container resized 的时候 UILabel 的行为会是这样的：<br><a href="http://devetc.org/assets/2014-07-07-auto-layout-and-views-that-wrap/label-dynamic-preferred-max-layout-width.webm" target="_blank" rel="noopener">video2</a></p><h1 id="为什么没有这样的效果"><a class="markdownIt-Anchor" href="#为什么没有这样的效果"></a> 为什么没有这样的效果</h1><p>在自动布局中，view 有一个“固有尺寸”（intrinsic content size）的概念：宽和高（都有，或有其一，或都没有）刚好满足view 的大小。布局系统根据view的 “compression resistance”的 优先级，至少会给view 一个足够大的空间。<br>布局系统分别对待 width 和 height。<br>举例：如果一个 segmented control’s的文本很长以至于超出包裹view的宽度，它的固有高度仍然尝试满足 在view的高度。<br>这种效果对于已经定义size的 view 非常好，such as buttons, sliders, and small labels.<br>但是包裹的view 会有十分复杂的行为：他们的 width 和 height 相互关联，系统有的时候会让固有 width 照顾固有 height，反过来也是。<br>这种情况不能单纯的用 布局限制来解释<br><strong>证明:</strong> 思考一个简化模型，忽略word 截断和复杂的文本内容。我们想要一个有固定面积的 view,<br>i.e. <em>width</em> × <em>height</em> = <em>constant</em>. 布局限制一定要这也样的格式：<br><em>attribute1</em> = <em>multiplier</em> × <em>attribute2</em>+ <em>constant</em> (为了让系统可以提供确定的执行效果). 没有啥方式使用第二个等式来表示第一个等式。因此也没有啥方式描述布局限制包裹的 view。<br>我们必须使用布局引擎计算出来的 width 和 height 作为自由变量。<br>最简单的方式–也是apple 使用的一种–是固定 width，然后让 height 自适应（取决label 的内容大小）</p><h1 id="推断最大-布局-宽度"><a class="markdownIt-Anchor" href="#推断最大-布局-宽度"></a> 推断最大 布局 宽度</h1><p>UILabel 和 NSTextField 有 <strong>preferredMaxLayoutWidth</strong> 这个属性。如果它 非 0，他就会作为label 的固有尺寸的最大宽度，当 label有超过 container View 容量的文字是，label可以适配到 这个 width 上。这个 label 将会返回一个更大的<br>固有 height。(如果 label 只有少量文字，那么label 的固有width 就回小于__preferredMaxLayoutWidth__)<br>iOS 上，UILabel 的 <strong>preferredMaxLayoutWidth__被设置为label 的width在 它显示在nib 上的时候（即使在 runtime 它的size 改变）<br>OS X 上, NSTextField 可选__preferredMaxLayoutWidth</strong>，在布局之后。<br>如果 label 的有效空间可以改变，像最上面 video1里面的demo，或者如果container 可以resized （或者rotated），你就需要动态的改变 <strong>preferredMaxLayoutWidth</strong>。</p><h1 id="调整-preferredmaxlayoutwidth"><a class="markdownIt-Anchor" href="#调整-preferredmaxlayoutwidth"></a> 调整 <strong>preferredMaxLayoutWidth</strong></h1><p>为了动态的设置preferredMaxLayoutWidth, 需要重载 label 的父类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> -[UIView layoutSubviews]</span><br><span class="line"> -[NSView layout]</span><br></pre></td></tr></table></figure><p>为了得到最上面video2的效果，要将__preferredMaxLayoutWidth__设置为有效的label<br>例子的布局，label 要有这几个限制:<br><img src="http://upload-images.jianshu.io/upload_images/4042439-28f753957e39d9b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="layout"><br>固定左右限制，使label占据整个水平空间，<br><em>代码里不要使用 数字 硬编码你的 constrain</em>. 这会是你的布局十分脆弱。取而代替的, 可以利用布局系统来达到效果，需要做两步。<br>上面 video2里面，在label 中 使用下面的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">  [<span class="keyword">super</span> layoutSubviews]; </span><br><span class="line">  <span class="built_in">CGFloat</span> availableLabelWidth = <span class="keyword">self</span>.label.frame.size.width; </span><br><span class="line">  <span class="keyword">self</span>.label.preferredMaxLayoutWidth = availableLabelWidth; </span><br><span class="line">  [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现调用 [super layoutSubviews]，将会计算label上的 constraints（因为他是一个间接的子view）相应的改变它的frame。此时 width 是有用的，但是height不是；height 用的是label 的固有height，它依赖 以前 preferredMaxLayoutWidth 的值。<br>现在我们知道了 label 的实际width，我们设置它的最大布局width. 在内部,在下一次查询label 的固有尺寸时， label的固有尺寸是无效的，而对于当前的 width会有 精确的 height。<br>所有布局信息就绪, 再次调用 [super layoutSubviews]<br>again.</p><h1 id="创建属于你自己的-包裹view"><a class="markdownIt-Anchor" href="#创建属于你自己的-包裹view"></a> 创建属于你自己的 包裹view</h1><p><a href="https://github.com/jmah/WrapDemo" target="_blank" rel="noopener">WrapDemo</a><br>. 这个例子有一个 preferredMaxLayoutWidth 属性 that the superview sets, 和 一个共享布局方法 (-[MyWrappingView enumerateItemRectsForLayoutWidth:usingBlock:]<br>). 这个方法在 -intrinsicContentSize 中调用–通过preferredMaxLayoutWidth 计算基本尺寸。在 -layoutSubviews 中调用，算出那些 找色的item 的实际 size 和 位置<br><a href="http://devetc.org/assets/2014-07-07-auto-layout-and-views-that-wrap/custom-wrapping-view.webm" target="_blank" rel="noopener">video3</a></p><h1 id="压缩-包裹"><a class="markdownIt-Anchor" href="#压缩-包裹"></a> 压缩 包裹</h1><p>最后，有很多次我们想把包裹view 和内容抱紧 contenthugging 的方式组合。<br>可以添加约束，以使它以中心为中心，并<em>至少</em>有一些距离，而不是固定 label 的leading和trailing空间位置。<br><img src="http://upload-images.jianshu.io/upload_images/4042439-3195a7f9882b084a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Label shrink-wrap constraints"><br>将其与上面的- layoutsubviews结合起来实现提供以下行为:<br><a href="http://devetc.org/assets/2014-07-07-auto-layout-and-views-that-wrap/shrink-wrap-buggy.webm" target="_blank" rel="noopener">video4</a></p><p>边缘的空间是充足的，如果它大于或等于常数-它只会把标签推进去，它就不会把它拉出来。我们想要做的是找到标签可以占用的宽度，而不需要占用所有的宽度。<br>自动布局API只提供一种计算距离的方法:布局，然后测量。因此，为了找出标签的宽度，我们告诉它要变得非常宽(仔细选择优先级)，把它放在外面，测量它，然后使用结果作为首选的最大布局宽度。该标签的内在尺寸将完成其余部分。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)layoutSubviews &#123;</span><br><span class="line">    <span class="built_in">NSLayoutConstraint</span> *labelAsWideAsPossibleConstraint =</span><br><span class="line">         [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:<span class="keyword">self</span>.label</span><br><span class="line">                                      attribute:<span class="built_in">NSLayoutAttributeWidth</span></span><br><span class="line">                                      relatedBy:<span class="built_in">NSLayoutRelationGreaterThanOrEqual</span></span><br><span class="line">                                         toItem:<span class="literal">nil</span></span><br><span class="line">                                      attribute:<span class="number">0</span></span><br><span class="line">                                     multiplier:<span class="number">1.0</span></span><br><span class="line">                                       constant:<span class="number">1e8</span>]; <span class="comment">// a big number</span></span><br><span class="line">    labelAsWideAsPossibleConstraint.priority =</span><br><span class="line">        [<span class="keyword">self</span>.label contentCompressionResistancePriorityForAxis:<span class="built_in">UILayoutConstraintAxisHorizontal</span>];</span><br><span class="line">    [<span class="keyword">self</span>.label addConstraint:labelAsWideAsPossibleConstraint];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CGFloat</span> availableLabelWidth = <span class="keyword">self</span>.label.frame.size.width;</span><br><span class="line">    <span class="keyword">self</span>.label.preferredMaxLayoutWidth = availableLabelWidth;</span><br><span class="line">    [<span class="keyword">self</span>.label removeConstraint:labelAsWideAsPossibleConstraint];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">super</span> layoutSubviews];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有例子代码 <a href="https://github.com/jmah/WrapDemo" target="_blank" rel="noopener">WrapDemo</a> project on GitHub.<br>感谢Kevin Cathey在布局方面的帮助和见解。</p><p>总结：UILabel 的 preferredMaxLayoutWidth<br>当应用布局约束时，这个属性会影响标签的大小。在布局中，如果文本超出了该属性指定的宽度，则额外的文本将流向一个或多个新行，从而增加标签的高度。</p><h1 id="其他参考文章"><a class="markdownIt-Anchor" href="#其他参考文章"></a> 其他参考文章</h1><p><a href="https://developer.apple.com/documentation/uikit/uilabel#//apple_ref/occ/instp/UILabel/preferredMaxLayoutWidth" target="_blank" rel="noopener">Apple: iOS UILabel</a><br><a href="https://stackoverflow.com/questions/12789013/ios-multi-line-uilabel-in-auto-layout" target="_blank" rel="noopener">iOS: Multi-line UILabel in Auto Layout</a><br><a href="https://www.objc.io/issues/3-views/advanced-auto-layout-toolbox/" target="_blank" rel="noopener">Advanced Auto Layout Toolbox</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 离屏渲染</title>
      <link href="/2017/09/20/UI%20%E7%9B%B8%E5%85%B3/iOS-%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"/>
      <url>/2017/09/20/UI%20%E7%9B%B8%E5%85%B3/iOS-%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p>什么是离屏渲染？<br>他对性能有什么影响？<br>如何避免离屏渲染？</p><h2 id="ios-渲染"><a class="markdownIt-Anchor" href="#ios-渲染"></a> iOS 渲染</h2><p>如果想要了解离屏渲染，应该先知道iOS渲染框架是什么样的。</p><p><img src="/img/core-animation-pipline.jpg" alt="core animation pipeline"><br>让屏幕页面流畅应该保证页面刷新率为 60 帧/秒，1 帧的时间大概就是 16.67 ms了。<br>iOS 的渲染框架： Core Animation</p><ul><li>组合屏幕上的内容，追踪视图结构和内容的变化。</li><li>流程图中 Commit Transaction 前面的红框代表触发视图内容变化的事件，比如点击按钮</li><li>之后Core Animation 框架会捕获到屏幕内容的变化并提交给 Render Server（渲染服务器）</li><li>Render Server 里另外一个版本的 Core Animation 框架负责解码并绘制内容。</li><li>CPU 解码完成后将数据交给 GPU</li><li>GPU 渲染完成后显示</li></ul><p>离屏渲染是为了 缓存的<br>离屏渲染空间只有屏幕的 2.5倍<br>100ms 以后如果缓存没有使用就会被释放掉</p><p>圆角图片</p><p>由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染。但如果仅仅是实现一个简单的效果，直接使用 CPU 渲染的效率又可能比离屏渲染好，毕竟普通的离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。对一些简单的绘制过程来说，这个过程有可能用CoreGraphics，全部用CPU来完成反而会比GPU做得更好。</p><p>一个常见的 CPU 渲染的例子是：重写 drawRect 方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了 CPU 渲染。整个渲染过程由 CPU 在 App 内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。总之，具体使用 CPU 渲染还是使用 GPU 离屏渲染更多的时候需要进行性能上的具体比较才可以。</p><p>一个常见的性能优化的例子就是如何给 UIView/UIImageView 加圆角。</p><p>如下是三种加圆角的方式：</p><p>设置 cornerRadius<br>UIBezierPath<br>Core Graphics(为 UIView 加圆角)与直接截取图片(为 UIImageView 加圆角)<br>如下是这三种方法的比较：</p><p><a href="https://hit-alibaba.github.io/interview/iOS/Cocoa-Touch/Performance.html" target="_blank" rel="noopener">—</a></p><p>Advanced Graphics and Animations for iOS Apps（WWDC14 419)</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 性能 </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何使用 RunLoop</title>
      <link href="/2017/08/30/runloop/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-RunLoop/"/>
      <url>/2017/08/30/runloop/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-RunLoop/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><p><img src="/img/runLoop_class_struct.jpeg" alt="runloop结构"></p><p>本文主要以翻译为主，有翻译or理解错的地方请提出，3Q</p><h2 id="使用-runloop-对象"><a class="markdownIt-Anchor" href="#使用-runloop-对象"></a> 使用 RunLoop 对象</h2><p>Apple 框架中是如何描述 RunLoop 的:</p><table><thead><tr><th>框架</th><th>RunLoop</th><th>线程安全</th></tr></thead><tbody><tr><td>Cocoa</td><td>NSRunLoop 实例对象</td><td>不安全</td></tr><tr><td>Core Foundation</td><td>CFRunLoopRef指针</td><td>安全</td></tr></tbody></table><p>带着问题？</p><ol><li>runloop 使用需要注意什么？</li><li>什么时候使用 runloop</li><li>系统框架哪些地方使用了 runloop？</li><li>runloop 运行时的内部实体结构分析？</li></ol><h3 id="获得一个-runloop-对象"><a class="markdownIt-Anchor" href="#获得一个-runloop-对象"></a> 获得一个 runloop 对象</h3><p>swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="type">RunLoop</span>.current</span><br><span class="line"><span class="keyword">var</span> b = <span class="type">CFRunLoopGetCurrent</span>()</span><br></pre></td></tr></table></figure><p>oc</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> a = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"><span class="keyword">id</span> b = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br></pre></td></tr></table></figure><details><summary>__CFRunLoop 结构体</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">  CFRuntimeBase _base;</span><br><span class="line">  <span class="keyword">pthread_mutex_t</span> _lock;    <span class="comment">//* locked for accessing mode list */</span></span><br><span class="line">  __CFPort _wakeUpPort;     <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">  Boolean _unused;</span><br><span class="line">  <span class="keyword">volatile</span> _per_run_data *_perRunData;<span class="comment">// reset for runs of the run loop</span></span><br><span class="line">  <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">  <span class="keyword">uint32_t</span> _winthread;</span><br><span class="line">  CFMutableSetRef _commonModes;     <span class="comment">// 当前 runloop 要监听的 mode</span></span><br><span class="line">  CFMutableSetRef _commonModeItems; <span class="comment">// 所有模式下 要监听的 source0,source1,observer, timer</span></span><br><span class="line">  CFRunLoopModeRef _currentMode;</span><br><span class="line">  CFMutableSetRef _modes;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">  CFAbsoluteTime _runTime;</span><br><span class="line">  CFAbsoluteTime _sleepTime;</span><br><span class="line">  CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><details><summary>app 运行时 CFRunLoop 内部样子简版</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoop</span> &#123;</span><br><span class="line">  current mode = kCFRunLoopDefaultMode</span><br><span class="line">  common modes = &#123;</span><br><span class="line">  <span class="built_in">UITrackingRunLoopMode</span></span><br><span class="line">  kCFRunLoopDefaultMode</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  common mode items = &#123;</span><br><span class="line">  <span class="comment">// source0 (manual)</span></span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">    callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">    callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// source1 (mach port)</span></span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order =<span class="number">-1</span>, &#123;</span><br><span class="line">    callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</span><br><span class="line">    callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</span><br><span class="line">    callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>b03,</span><br><span class="line">    callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</span><br><span class="line">    callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Ovserver</span></span><br><span class="line">  <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></span><br><span class="line">    callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,    <span class="comment">// BeforeWaiting</span></span><br><span class="line">    callout = _UIGestureRecognizerUpdateObserver&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,  <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">    callout = _afterCACommitHandler&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,  <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">  <span class="built_in">CFRunLoopObserver</span> &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">    callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Timer</span></span><br><span class="line">  <span class="built_in">CFRunLoopTimer</span> &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</span><br><span class="line">    next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">    callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  modes ＝ &#123;</span><br><span class="line">  <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">    sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    timers =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">    sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    timers =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">    sources0 = &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">0</span>, &#123;</span><br><span class="line">      callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sources1 = (null),</span><br><span class="line">    observers = &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopObserver</span> &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</span><br><span class="line">      callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</span><br><span class="line">    )&#125;,</span><br><span class="line">    timers = (null),</span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">    sources0 = &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">      callout = PurpleEventSignalCallback&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    sources1 = &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopSource</span> &#123;order = <span class="number">-1</span>, &#123;</span><br><span class="line">      callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    observers = (null),</span><br><span class="line">    timers = (null),</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">CFRunLoopMode</span>  &#123;</span><br><span class="line">    sources0 = (null),</span><br><span class="line">    sources1 = (null),</span><br><span class="line">    observers = (null),</span><br><span class="line">    timers = (null),</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，系统默认注册了5个Mode:</p><ol><li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li><li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li><li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。</li><li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li><li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。<br></li></ol></pre></details><details><summary>app 运行时 CFRunLoop 内部样子，打印 runloop 对象</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br></pre></td><td class="code"><pre><span class="line">&lt;CFRunLoop <span class="number">0x6000008b0000</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">  wakeup port = <span class="number">0x2703</span>, </span><br><span class="line">  stopped = <span class="literal">false</span>, </span><br><span class="line">  ignoreWakeUps = <span class="literal">true</span>, </span><br><span class="line">  current mode = (none),</span><br><span class="line">  common modes = &lt;CFBasicHash <span class="number">0x600003afbb70</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">  type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">  count = <span class="number">2</span>,</span><br><span class="line">  entries =&gt;</span><br><span class="line">  <span class="number">0</span> : &lt;CFString <span class="number">0x7fff86743f40</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    contents = <span class="string">"UITrackingRunLoopMode"</span>&#125;</span><br><span class="line">  <span class="number">2</span> : &lt;CFString <span class="number">0x7fff80628740</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    contents = <span class="string">"kCFRunLoopDefaultMode"</span>&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  common mode items = &lt;CFBasicHash <span class="number">0x600003aa7690</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">  type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">  count = <span class="number">13</span>,</span><br><span class="line">  entries =&gt;</span><br><span class="line">  <span class="number">0</span> : &lt;CFRunLoopSource <span class="number">0x6000001bc180</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">-1</span>, </span><br><span class="line">    context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">0</span>, </span><br><span class="line">      info = <span class="number">0x0</span>, </span><br><span class="line">      callout = PurpleEventSignalCallback (<span class="number">0x7fff384399f5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">1</span> : &lt;CFRunLoopSource <span class="number">0x6000001b0240</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = Yes, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">0</span>, </span><br><span class="line">    context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">0</span>, </span><br><span class="line">      info = <span class="number">0x6000010b8e40</span>, </span><br><span class="line">      callout = FBSSerialQueueRunLoopSourceHandler (<span class="number">0x7fff365a092a</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">2</span> : &lt;CFRunLoopSource <span class="number">0x6000001b40c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">-1</span>, </span><br><span class="line">    context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">1</span>, </span><br><span class="line">      info = <span class="number">0x510b</span>, </span><br><span class="line">      callout = PurpleEventCallback (<span class="number">0x7fff38439a01</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">5</span> : &lt;CFRunLoopSource <span class="number">0x6000001b80c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">0</span>, </span><br><span class="line">    context = &lt;MSHRunLoopSource <span class="number">0x600003ae95f0</span>&gt; &#123;</span><br><span class="line">      port = <span class="number">430b</span>, callback = <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">7</span> : &lt;CFRunLoopObserver <span class="number">0x6000005b0820</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    valid = Yes, </span><br><span class="line">    activities = <span class="number">0xa0</span>, </span><br><span class="line">    repeats = Yes, </span><br><span class="line">    order = <span class="number">2147483647</span>, </span><br><span class="line">    callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="number">0x7fff47848c8c</span>), </span><br><span class="line">    context = &lt;CFArray <span class="number">0x600003ae9bf0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      type = <span class="keyword">mutable</span>-small, </span><br><span class="line">      count = <span class="number">0</span>, </span><br><span class="line">      values = ()</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">8</span> : &lt;CFRunLoopObserver <span class="number">0x6000005b0780</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    valid = Yes, </span><br><span class="line">    activities = <span class="number">0x1</span>,</span><br><span class="line">    repeats = Yes, </span><br><span class="line">    order = <span class="number">-2147483647</span>, </span><br><span class="line">    callout = _wrapRunLoopWithAutoreleasePoolHandler (<span class="number">0x7fff47848c8c</span>), </span><br><span class="line">    context = &lt;CFArray <span class="number">0x600003ae9bf0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      type = <span class="keyword">mutable</span>-small,</span><br><span class="line">      count = <span class="number">0</span>,</span><br><span class="line">      values = ()</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">9</span> : &lt;CFRunLoopObserver <span class="number">0x6000005b06e0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    valid = Yes,</span><br><span class="line">    activities = <span class="number">0xa0</span>,</span><br><span class="line">    repeats = Yes,</span><br><span class="line">    order = <span class="number">2001000</span>,</span><br><span class="line">    callout = _afterCACommitHandler (<span class="number">0x7fff47879310</span>),</span><br><span class="line">    context = &lt;CFRunLoopObserver context <span class="number">0x7fc5adc01e40</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">10</span> : &lt;CFRunLoopObserver <span class="number">0x6000005b0640</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    valid = Yes, </span><br><span class="line">    activities = <span class="number">0xa0</span>, </span><br><span class="line">    repeats = Yes, </span><br><span class="line">    order = <span class="number">1999000</span>, </span><br><span class="line">    callout = _beforeCACommitHandler (<span class="number">0x7fff478792a7</span>), </span><br><span class="line">    context = &lt;CFRunLoopObserver context <span class="number">0x7fc5adc01e40</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="number">12</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8b40</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">-1</span>, </span><br><span class="line">    context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">0</span>, </span><br><span class="line">      info = <span class="number">0x6000001b0180</span>, </span><br><span class="line">      callout = __handleEventQueue (<span class="number">0x7fff478e3efb</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">16</span> : &lt;CFRunLoopSource <span class="number">0x6000001b89c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">0</span>, </span><br><span class="line">    context = &lt;MSHRunLoopSource <span class="number">0x600003ae9650</span>&gt; &#123;</span><br><span class="line">      port = <span class="number">3f</span>0b, </span><br><span class="line">      callback = <span class="number">0x0</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">18</span> : &lt;CFRunLoopObserver <span class="number">0x6000005b0140</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    valid = Yes, </span><br><span class="line">    activities = <span class="number">0x20</span>, </span><br><span class="line">    repeats = Yes, </span><br><span class="line">    order = <span class="number">0</span>, </span><br><span class="line">    callout = _UIGestureRecognizerUpdateObserver (<span class="number">0x7fff473eda72</span>), context = &lt;CFRunLoopObserver context <span class="number">0x600001fb5180</span>&gt;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">21</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8a80</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">0</span>, </span><br><span class="line">    context = &lt;MSHRunLoopSource <span class="number">0x6000034a8160</span>&gt; &#123;</span><br><span class="line">      port = <span class="number">4207</span>, </span><br><span class="line">      callback = <span class="number">0x7fff2e3fdd33</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="number">22</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8cc0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    signalled = No, </span><br><span class="line">    valid = Yes, </span><br><span class="line">    order = <span class="number">-2</span>, </span><br><span class="line">    context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">0</span>, </span><br><span class="line">      info = <span class="number">0x600003a9fe70</span>, </span><br><span class="line">      callout = __handleHIDEventFetcherDrain (<span class="number">0x7fff478e3f07</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modes = &lt;CFBasicHash <span class="number">0x600003afbba0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">    count = <span class="number">3</span>,</span><br><span class="line">    entries =&gt;</span><br><span class="line">    <span class="number">0</span> : &lt;CFRunLoopMode <span class="number">0x600000fb8270</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      name = UITrackingRunLoopMode, </span><br><span class="line">      port <span class="built_in">set</span> = <span class="number">0x2c03</span>, </span><br><span class="line">      <span class="built_in">queue</span> = <span class="number">0x600001ab9180</span>, </span><br><span class="line">      source = <span class="number">0x600001ab9200</span> (<span class="keyword">not</span> fired), </span><br><span class="line">      timer port = <span class="number">0x5303</span>, </span><br><span class="line">    sources0 = &lt;CFBasicHash <span class="number">0x600003aa76f0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">      count = <span class="number">4</span>,</span><br><span class="line">      entries =&gt;</span><br><span class="line">      <span class="number">0</span> : &lt;CFRunLoopSource <span class="number">0x6000001bc180</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">-1</span>, </span><br><span class="line">        context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">        version = <span class="number">0</span>, </span><br><span class="line">        info = <span class="number">0x0</span>, </span><br><span class="line">        callout = PurpleEventSignalCallback (<span class="number">0x7fff384399f5</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">1</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8b40</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">-1</span>, </span><br><span class="line">        context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">        version = <span class="number">0</span>, </span><br><span class="line">        info = <span class="number">0x6000001b0180</span>, </span><br><span class="line">        callout = __handleEventQueue (<span class="number">0x7fff478e3efb</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">2</span> : &lt;CFRunLoopSource <span class="number">0x6000001b0240</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = Yes, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">0</span>, </span><br><span class="line">        context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">        version = <span class="number">0</span>, </span><br><span class="line">        info = <span class="number">0x6000010b8e40</span>, </span><br><span class="line">        callout = FBSSerialQueueRunLoopSourceHandler (<span class="number">0x7fff365a092a</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">3</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8cc0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">-2</span>, </span><br><span class="line">        context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">        version = <span class="number">0</span>, </span><br><span class="line">        info = <span class="number">0x600003a9fe70</span>, </span><br><span class="line">        callout = __handleHIDEventFetcherDrain (<span class="number">0x7fff478e3f07</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    sources1 = &lt;CFBasicHash <span class="number">0x600003aa7720</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">      count = <span class="number">4</span>,</span><br><span class="line">      entries =&gt;</span><br><span class="line">      <span class="number">0</span> : &lt;CFRunLoopSource <span class="number">0x6000001b40c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">-1</span>, </span><br><span class="line">        context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">        version = <span class="number">1</span>, </span><br><span class="line">        info = <span class="number">0x510b</span>, </span><br><span class="line">        callout = PurpleEventCallback (<span class="number">0x7fff38439a01</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">4</span> : &lt;CFRunLoopSource <span class="number">0x6000001b89c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">0</span>, </span><br><span class="line">        context = &lt;MSHRunLoopSource <span class="number">0x600003ae9650</span>&gt; &#123;</span><br><span class="line">        port = <span class="number">3f</span>0b, </span><br><span class="line">        callback = <span class="number">0x0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">5</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8a80</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">0</span>, </span><br><span class="line">        context = &lt;MSHRunLoopSource <span class="number">0x6000034a8160</span>&gt; &#123;</span><br><span class="line">        port = <span class="number">4207</span>, </span><br><span class="line">        callback = <span class="number">0x7fff2e3fdd33</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="number">6</span> : &lt;CFRunLoopSource <span class="number">0x6000001b80c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">        signalled = No, </span><br><span class="line">        valid = Yes, </span><br><span class="line">        order = <span class="number">0</span>, </span><br><span class="line">        context = &lt;MSHRunLoopSource <span class="number">0x600003ae95f0</span>&gt; &#123;</span><br><span class="line">        port = <span class="number">430b</span>, </span><br><span class="line">        callback = <span class="number">0x0</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      &#125; ,</span><br><span class="line">    observers = (</span><br><span class="line">      <span class="string">"&lt;CFRunLoopObserver 0x6000005b0780 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">      valid = Yes, </span></span><br><span class="line"><span class="string">      activities = 0x1, </span></span><br><span class="line"><span class="string">      repeats = Yes, </span></span><br><span class="line"><span class="string">      order = -2147483647, </span></span><br><span class="line"><span class="string">      callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), </span></span><br><span class="line"><span class="string">      context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;type = mutable-small, count = 0, values = ()</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      &#125;"</span>,</span><br><span class="line">      <span class="string">"&lt;CFRunLoopObserver 0x6000005b0140 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">      valid = Yes, </span></span><br><span class="line"><span class="string">      activities = 0x20, </span></span><br><span class="line"><span class="string">      repeats = Yes, </span></span><br><span class="line"><span class="string">      order = 0, </span></span><br><span class="line"><span class="string">      callout = _UIGestureRecognizerUpdateObserver (0x7fff473eda72), </span></span><br><span class="line"><span class="string">      context = &lt;CFRunLoopObserver context 0x600001fb5180&gt;</span></span><br><span class="line"><span class="string">      &#125;"</span>,</span><br><span class="line">      <span class="string">"&lt;CFRunLoopObserver 0x6000005b0640 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">      valid = Yes, </span></span><br><span class="line"><span class="string">      activities = 0xa0, </span></span><br><span class="line"><span class="string">      repeats = Yes, </span></span><br><span class="line"><span class="string">      order = 1999000, </span></span><br><span class="line"><span class="string">      callout = _beforeCACommitHandler (0x7fff478792a7), </span></span><br><span class="line"><span class="string">      context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt;</span></span><br><span class="line"><span class="string">      &#125;"</span>,</span><br><span class="line">      <span class="string">"&lt;CFRunLoopObserver 0x6000005b06e0 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">      valid = Yes, </span></span><br><span class="line"><span class="string">      activities = 0xa0, </span></span><br><span class="line"><span class="string">      repeats = Yes, </span></span><br><span class="line"><span class="string">      order = 2001000, </span></span><br><span class="line"><span class="string">      callout = _afterCACommitHandler (0x7fff47879310), </span></span><br><span class="line"><span class="string">      context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt;</span></span><br><span class="line"><span class="string">      &#125;"</span>,</span><br><span class="line">      <span class="string">"&lt;CFRunLoopObserver 0x6000005b0820 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">      valid = Yes, </span></span><br><span class="line"><span class="string">      activities = 0xa0, </span></span><br><span class="line"><span class="string">      repeats = Yes, </span></span><br><span class="line"><span class="string">      order = 2147483647, </span></span><br><span class="line"><span class="string">      callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), </span></span><br><span class="line"><span class="string">      context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">        type = mutable-small, </span></span><br><span class="line"><span class="string">        count = 0, </span></span><br><span class="line"><span class="string">        values = ()</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      &#125;"</span></span><br><span class="line">    ),</span><br><span class="line">    timers = (null),</span><br><span class="line">    currently <span class="number">600930818</span> (<span class="number">56642367633481</span>) / soft deadline in: <span class="number">1.84466874e+10</span> sec (@ <span class="number">-1</span>) / hard deadline in: <span class="number">1.84466874e+10</span> sec (@ <span class="number">-1</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  <span class="number">1</span> : &lt;CFRunLoopMode <span class="number">0x600000fb8340</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    name = GSEventReceiveRunLoopMode, </span><br><span class="line">    port <span class="built_in">set</span> = <span class="number">0x5203</span>, </span><br><span class="line">    <span class="built_in">queue</span> = <span class="number">0x600001ab9280</span>, </span><br><span class="line">    source = <span class="number">0x600001ab9380</span> (<span class="keyword">not</span> fired), </span><br><span class="line">    timer port = <span class="number">0x2e03</span>, </span><br><span class="line">  sources0 = &lt;CFBasicHash <span class="number">0x600003aa77b0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">    count = <span class="number">1</span>,</span><br><span class="line">    entries =&gt;</span><br><span class="line">    <span class="number">0</span> : &lt;CFRunLoopSource <span class="number">0x6000001bc180</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      signalled = No, </span><br><span class="line">      valid = Yes, </span><br><span class="line">      order = <span class="number">-1</span>, </span><br><span class="line">      context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">0</span>, </span><br><span class="line">      info = <span class="number">0x0</span>, </span><br><span class="line">      callout = PurpleEventSignalCallback (<span class="number">0x7fff384399f5</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">sources1 = &lt;CFBasicHash <span class="number">0x600003aa77e0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">    count = <span class="number">1</span>,</span><br><span class="line">    entries =&gt;</span><br><span class="line">    <span class="number">2</span> : &lt;CFRunLoopSource <span class="number">0x6000001b4180</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">      signalled = No, </span><br><span class="line">      valid = Yes, </span><br><span class="line">      order = <span class="number">-1</span>, </span><br><span class="line">      context = &lt;CFRunLoopSource context&gt;&#123;</span><br><span class="line">      version = <span class="number">1</span>, </span><br><span class="line">      info = <span class="number">0x510b</span>, </span><br><span class="line">      callout = PurpleEventCallback (<span class="number">0x7fff38439a01</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  observers = (null),</span><br><span class="line">  timers = (null),</span><br><span class="line">  currently <span class="number">600930818</span> (<span class="number">56642369572615</span>) / soft deadline in: <span class="number">1.84466874e+10</span> sec (@ <span class="number">-1</span>) / hard deadline in: <span class="number">1.84466874e+10</span> sec (@ <span class="number">-1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">2</span> : &lt;CFRunLoopMode <span class="number">0x600000fb01a0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    name = kCFRunLoopDefaultMode, </span><br><span class="line">    port <span class="built_in">set</span> = <span class="number">0x2603</span>, </span><br><span class="line">    <span class="built_in">queue</span> = <span class="number">0x600001ab0880</span>, </span><br><span class="line">    source = <span class="number">0x600001ab0980</span> (<span class="keyword">not</span> fired), </span><br><span class="line">    timer port = <span class="number">0x1f03</span>, </span><br><span class="line">  sources0 = &lt;CFBasicHash <span class="number">0x600003aa7750</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">    count = <span class="number">4</span>,</span><br><span class="line">    entries =&gt;</span><br><span class="line">    <span class="number">0</span> : &lt;CFRunLoopSource <span class="number">0x6000001bc180</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">-1</span>, context = &lt;CFRunLoopSource context&gt;&#123;version = <span class="number">0</span>, info = <span class="number">0x0</span>, callout = PurpleEventSignalCallback (<span class="number">0x7fff384399f5</span>)&#125;&#125;</span><br><span class="line">    <span class="number">1</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8b40</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">-1</span>, context = &lt;CFRunLoopSource context&gt;&#123;version = <span class="number">0</span>, info = <span class="number">0x6000001b0180</span>, callout = __handleEventQueue (<span class="number">0x7fff478e3efb</span>)&#125;&#125;</span><br><span class="line">    <span class="number">2</span> : &lt;CFRunLoopSource <span class="number">0x6000001b0240</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = Yes, valid = Yes, order = <span class="number">0</span>, context = &lt;CFRunLoopSource context&gt;&#123;version = <span class="number">0</span>, info = <span class="number">0x6000010b8e40</span>, callout = FBSSerialQueueRunLoopSourceHandler (<span class="number">0x7fff365a092a</span>)&#125;&#125;</span><br><span class="line">    <span class="number">3</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8cc0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">-2</span>, context = &lt;CFRunLoopSource context&gt;&#123;version = <span class="number">0</span>, info = <span class="number">0x600003a9fe70</span>, callout = __handleHIDEventFetcherDrain (<span class="number">0x7fff478e3f07</span>)&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  sources1 = &lt;CFBasicHash <span class="number">0x600003aa7780</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    type = <span class="keyword">mutable</span> <span class="built_in">set</span>, </span><br><span class="line">    count = <span class="number">4</span>,</span><br><span class="line">    entries =&gt;</span><br><span class="line">    <span class="number">0</span> : &lt;CFRunLoopSource <span class="number">0x6000001b40c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">-1</span>, context = &lt;CFRunLoopSource context&gt;&#123;version = <span class="number">1</span>, info = <span class="number">0x510b</span>, callout = PurpleEventCallback (<span class="number">0x7fff38439a01</span>)&#125;&#125;</span><br><span class="line">    <span class="number">4</span> : &lt;CFRunLoopSource <span class="number">0x6000001b89c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">0</span>, context = &lt;MSHRunLoopSource <span class="number">0x600003ae9650</span>&gt; &#123;port = <span class="number">3f</span>0b, callback = <span class="number">0x0</span>&#125;&#125;</span><br><span class="line">    <span class="number">5</span> : &lt;CFRunLoopSource <span class="number">0x6000001b8a80</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">0</span>, context = &lt;MSHRunLoopSource <span class="number">0x6000034a8160</span>&gt; &#123;port = <span class="number">4207</span>, callback = <span class="number">0x7fff2e3fdd33</span>&#125;&#125;</span><br><span class="line">    <span class="number">6</span> : &lt;CFRunLoopSource <span class="number">0x6000001b80c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;signalled = No, valid = Yes, order = <span class="number">0</span>, context = &lt;MSHRunLoopSource <span class="number">0x600003ae95f0</span>&gt; &#123;port = <span class="number">430b</span>, callback = <span class="number">0x0</span>&#125;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  observers = (</span><br><span class="line">    <span class="string">"&lt;CFRunLoopObserver 0x6000005b0780 [0x7fff80615350]&gt;&#123;</span></span><br><span class="line"><span class="string">    valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;"</span>,</span><br><span class="line">    <span class="string">"&lt;CFRunLoopObserver 0x6000005b0140 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x7fff473eda72), context = &lt;CFRunLoopObserver context 0x600001fb5180&gt;&#125;"</span>,</span><br><span class="line">    <span class="string">"&lt;CFRunLoopObserver 0x6000005b0640 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x7fff478792a7), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt;&#125;"</span>,</span><br><span class="line">    <span class="string">"&lt;CFRunLoopObserver 0x6000005b06e0 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x7fff47879310), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt;&#125;"</span>,</span><br><span class="line">    <span class="string">"&lt;CFRunLoopObserver 0x6000005b0820 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;"</span></span><br><span class="line">    ),</span><br><span class="line">  timers = &lt;CFArray <span class="number">0x6000010b6400</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;</span><br><span class="line">    type = <span class="keyword">mutable</span>-small, count = <span class="number">1</span>, values = (</span><br><span class="line">    <span class="number">0</span> : &lt;CFRunLoopTimer <span class="number">0x6000001b86c0</span> [<span class="number">0x7fff80615350</span>]&gt;&#123;valid = Yes, firing = No, interval = <span class="number">0</span>, tolerance = <span class="number">0</span>, next fire date = <span class="number">600930808</span> (<span class="number">-10.16959</span> @ <span class="number">56632202715119</span>), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (<span class="number">0x7fff2574c7d2</span> / <span class="number">0x7fff46da0bb6</span>) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore), context = &lt;CFRunLoopTimer context <span class="number">0x6000021ef300</span>&gt;&#125;</span><br><span class="line">    )</span><br><span class="line">    &#125;,</span><br><span class="line">  currently <span class="number">600930818</span> (<span class="number">56642369637217</span>) / soft deadline in: <span class="number">1.84467441e+10</span> sec (@ <span class="number">56632202715119</span>) / hard deadline in: <span class="number">1.84467441e+10</span> sec (@ <span class="number">56632202715119</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><p>NSRunLoop 是对CFRunLoopRef指针的封装，虽然两者之间类型转换不消耗性能，但是NSRunLoop class 定义一个得到 CFRunLoopRef 的方法 <code>getCFRunLoop</code></p><h3 id="配置-runloop"><a class="markdownIt-Anchor" href="#配置-runloop"></a> 配置 RunLoop</h3><p>在子线程上运行 RunLoop，你一定要向 runloop 中至少添加一个 input source 或者 timer，如果 runloop 中没有可监听的 sources，那么在 runloop 运行的时候他就会立刻退出。详情看下文 <a href="#2">配置 RunLoop 事件源(sources)</a></p><p>除了添加事件源 sources，你可能还要给 runloop 添加 observers（使用它来监听当前 runloop 的执行阶段）。</p><details><summary>创建 run loop observer</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)threadMain&#123;</span><br><span class="line">  <span class="comment">// The application uses garbage collection, so no autorelease pool is needed.</span></span><br><span class="line">  <span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Create a run loop observer and attach it to the run loop.</span></span><br><span class="line">  <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">  <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(</span><br><span class="line">  kCFAllocatorDefault,</span><br><span class="line">  kCFRunLoopAllActivities, </span><br><span class="line">  <span class="literal">YES</span>,</span><br><span class="line">  <span class="number">0</span>, </span><br><span class="line">  &amp;myRunLoopObserver, </span><br><span class="line">  &amp;context);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (observer)&#123;</span><br><span class="line">  <span class="built_in">CFRunLoopRef</span> cfLoop = [myRunLoop getCFRunLoop];</span><br><span class="line">  <span class="built_in">CFRunLoopAddObserver</span>(cfLoop, observer, kCFRunLoopDefaultMode);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Create and schedule the timer.</span></span><br><span class="line">  [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.1</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(doFireTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">NSInteger</span> loopCount = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">// Run the run loop 10 times to let the timer fire.</span></span><br><span class="line">  [myRunLoop runUntilDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1</span>]];</span><br><span class="line">  loopCount--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (loopCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><p>给 thread 配置 runloop 让处于保活状态，给runloop 添加一个 input sources来接受消息会比较好。虽然只有一个 timer sources 也可以进入 runloop，但是一旦 timer fires，timer 就会失效，导致 runloop 退出。添加一个 repeating timer 可以让 runloop 保活，可是反复调用 timer fire，会反复唤醒thread(这实际上是轮询的另一种形式)，相对来说，使用 input source 来等待 event 发生，没发生前thread 都处于睡眠状态。</p><h3 id="开启-runloop"><a class="markdownIt-Anchor" href="#开启-runloop"></a> 开启 RunLoop</h3><ul><li>只有子线程才需要开启 RunLoop</li><li>一个 RunLoop 实例至少有一个 input source or timer 来监听事件，如果没有可监听的sources，RunLoop开启后会立即退出。</li></ul><p>启动 RunLoop 的方法：</p><table><thead><tr><th>方式</th><th>方法名(NSRunLoop)</th><th>解释</th></tr></thead><tbody><tr><td>无条件</td><td>run</td><td>最简单但也<code>最不可取的方案</code>。会让线程进入无限循环，对 run loop 很难控制。可以添加和移除 input source 和 timer，但只能通过 kill 的方式停止 run loop。无法在自定义模式下运行 runloop。</td></tr><tr><td>设定时间限制</td><td>runUntilDate:</td><td>run loop 在收到事件或超时前会一直运行。run loop 结束后可以重启，并处理接下来的事情。比上一种方式更好，提供了时间限制。</td></tr><tr><td>处于特定模式</td><td>runMode:beforeDate:</td><td>相比上一种方式，增加了在特定模式下运行 run loop</td></tr></tbody></table><details><summary>Running a run loop</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)skeletonThreadMain &#123;</span><br><span class="line">  <span class="comment">// Set up an autorelease pool here if not using garbage collection.</span></span><br><span class="line">  <span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Add your sources or timers to the run loop and do any other setup.</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">// Start the run loop but return after each source is handled.</span></span><br><span class="line">    SInt32 result = <span class="built_in">CFRunLoopRunInMode</span>(kCFRunLoopDefaultMode, <span class="number">10</span>, <span class="literal">YES</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// If a source explicitly stopped the run loop, or if there are no</span></span><br><span class="line">    <span class="comment">// sources or timers, go ahead and exit.</span></span><br><span class="line">    <span class="keyword">if</span> ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished))</span><br><span class="line">    done = <span class="literal">YES</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Check for any other exit conditions here and set the</span></span><br><span class="line">    <span class="comment">// done variable as needed.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!done);</span><br><span class="line">  <span class="comment">// Clean up code here. Be sure to release any allocated autorelease pools.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><p>可以递归启动 run loop。也就是说可以在 input source 或 timer 的回调处理函数中调用 CFRunLoopRun, CFRunLoopRunInMode 或上面提到的 NSRunLoop 的三个方法，而且嵌套的 run loop 可以在任意 Mode 下运行。</p><h3 id="退出-runloop"><a class="markdownIt-Anchor" href="#退出-runloop"></a> 退出 RunLoop</h3><p>在处理事件之前，有两种方法可以让 RunLoop退出：</p><ul><li>给 run loop 配置 timeout 值</li><li>告诉 run loop 停止</li></ul><p>使用timeout的方式：RunLoop 退出之前会执行完所有正常情况下的处理，包括向 observers 发送通知。</p><p>使用 CFRunLoopStop()：和 timeout方式相似。RunLoop 会把剩下的所有状态发送给 observers，然后退出。不同的是：你只能使用 CFRunLoopStop 停止以 Unconditionally 方式开启的 RunLoop。</p><p>要注意的是 CFRunLoopStop 只会停止对 CFRunLoopRun 和 CFRunLoopRunInMode 的调用。对于 Cocoa 框架相当于只停止一次 runMode:beforeDate: 的调用，而不是退出 run loop。stop 一次运行和 exit 整个 run loop 是不一样的。</p><p>虽然移除 RunLoop 的 input source 和 timer 也会导致其退出，但这种方法不可靠。因为有些系统程序会向 RunLoop 中添加 input source，开发者根本不知道有这回事，移除的时候就会漏掉，自然就不会导致 RunLoop 退出。</p><h2 id="配置-runloop-事件源sources"><a class="markdownIt-Anchor" href="#配置-runloop-事件源sources"></a> 配置 RunLoop 事件源(sources)</h2><h3 id="定义-custom-input-source"><a class="markdownIt-Anchor" href="#定义-custom-input-source"></a> 定义 Custom Input Source</h3><p>创建自定义输入源涉及定义以下内容：</p><ul><li>你想让 input source 处理的信息</li><li>A scheduler routine：用于让外部 client 获知如何联系 input source</li><li>A handler routine：执行任何 client 发出请求的</li><li>A cancellation routine：使 input source 失效</li></ul><p>因为你使用 custom input source 来处理 custom information，配置的过程会相当灵活。The scheduler, handler, and cancellation routines，是你创建 custome input source 的关键。但是，input source 剩下的大部分行为都没有在这几个历程中，eg：</p><ul><li>向 input source 传递数据的方式需要你自己实现</li><li>让其他线程知道这个 input source 的存在</li></ul><p>下图给出了一个 custom input source 配置 demo。在这个例子中，<br>app 的主线程维护 ：</p><ul><li>引用 input source</li><li>引用 input source 自定义的 command buffer</li><li>引用 runloop[已经把input source 加到里面了]</li></ul><p>当 main thread 有一个task想要 worker thread 处理，main thread 会post 一个 command 到 command buffer 中，顺带把 worker thread 需要的信息发给它，然后 main thread 开启 task（因为main thread 和 worker thread 都有可以访问 command buffer，所以访问 command buffer 的过程要 sync）。一旦命令发布，main thread 向 input source 发送消息，唤起 worker thread 的runloop。worker thread 的 runloop 一旦接受到唤起命令，他就会调用 input source 的 handler 程序，handler 会处理 command buffer 中的命令。</p><p>操作 custom input source<br><img src="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Art/custominputsource.jpg" alt=" Operating a custom input source"></p><h4 id="定义-input-source"><a class="markdownIt-Anchor" href="#定义-input-source"></a> 定义 Input Source</h4><p>定义 custome input source 需要 Core Foundation，接口都是基于 C 的！</p><p>下面代码封装成 OC：RunLoopSource 封装了 CFRunLoopSourceRef，并管理一个 command buffer，并使用 buffer 接收其他线程的消息。RunLoopContext 封装了 CFRunLoopRef 和 RunLoopSource 指针，用于向应用主线程传递 source 对象和 run loop 引用。</p><details><summary>Custom Input Source 对象定义</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// These are the CFRunLoopSourceRef callback functions.</span></span><br><span class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info);</span><br><span class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopSource</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">  <span class="built_in">CFRunLoopSourceRef</span> runLoopSource;</span><br><span class="line">  <span class="built_in">NSMutableArray</span>* commands;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)init;</span><br><span class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop;</span><br><span class="line">- (<span class="keyword">void</span>)invalidate;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Handler method</span></span><br><span class="line">- (<span class="keyword">void</span>)sourceFired;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Client interface for registering commands to process</span></span><br><span class="line">- (<span class="keyword">void</span>)addCommand:(<span class="built_in">NSInteger</span>)command withData:(<span class="keyword">id</span>)data;</span><br><span class="line">- (<span class="keyword">void</span>)fireAllCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// RunLoopContext is a container object used during registration of the input source.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RunLoopContext</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">  <span class="built_in">CFRunLoopRef</span>  runLoop;</span><br><span class="line">  RunLoopSource*  source;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CFRunLoopRef</span> runLoop;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) RunLoopSource* source;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">id</span>)initWithSource:(RunLoopSource*)src andLoop:(<span class="built_in">CFRunLoopRef</span>)loop;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></pre></details><p>虽然 Objective-C 代码管理 input source 的自定义数据，但是把 input source 添加到 runloop 中需要基于 c 的方法。 第一个被调用的例程是 scheduler，当你把 source 添加到 runloop 时就会调用。 input source 只有一个 client，也就是主线程。这里 scheduler 做的事情就是用 application delegate 的 registerSource: 方法将 RunLoopContext 对象中的信息传递过去，以便之后 application delegate 与 input source 通信时使用。</p><p><span id="4">Scheduling a run loop source</span></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RunLoopSourceScheduleRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode)&#123;</span><br><span class="line">  RunLoopSource* obj = (RunLoopSource*)info;</span><br><span class="line">  AppDelegate*   del = [AppDelegate sharedAppDelegate];</span><br><span class="line">  RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"> </span><br><span class="line">  [del performSelectorOnMainThread:<span class="keyword">@selector</span>(registerSource:)</span><br><span class="line">        withObject:theContext waitUntilDone:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当向 input source 发送消息的时候，用于处理数据的 perform 函数会被调用，它是最重要的回调之一。下面的这个方法只是把请求转发给了 RunLoopSource 的 sourceFired 方法。后面会列出 sourceFired 处理 command buffer 的逻辑。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Performing work in the input source</span></span><br><span class="line"><span class="keyword">void</span> RunLoopSourcePerformRoutine (<span class="keyword">void</span> *info)&#123;</span><br><span class="line">  RunLoopSource*  obj = (__bridge RunLoopSource*)info;</span><br><span class="line">  [obj sourceFired];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你以前使用 CFRunLoopSourceInvalidate() 方法把 input source 从runloop中移除，系统会调用 input source 的 cancellation routine. 你可以使用这个 routine 通知 clients，你的input source 失效，需要移除他们对 input source 的引用。下面的 cancellation routine 体用系统传入的 RunLoopSource，runloop，runloopMode 创建一个新的 RunLoopContext，并传给 application delegate。</p><p><span id="5">Invalidating a run loop source:</span></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RunLoopSourceCancelRoutine (<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFStringRef</span> mode)&#123;</span><br><span class="line">  RunLoopSource* obj = (__bridge RunLoopSource*)info;</span><br><span class="line">  AppDelegate* del = [AppDelegate sharedAppDelegate];</span><br><span class="line">  RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl];</span><br><span class="line"> </span><br><span class="line">  [del performSelectorOnMainThread:<span class="keyword">@selector</span>(removeSource:)</span><br><span class="line">        withObject:theContext waitUntilDone:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 application delegate’s 的 registerSource: and removeSource: 方法在<a href="#3">下面</a>有</p><h4 id="把-input-source-添加到-run-loop"><a class="markdownIt-Anchor" href="#把-input-source-添加到-run-loop"></a> 把 Input Source 添加到 Run Loop</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)init&#123;</span><br><span class="line">  <span class="built_in">CFRunLoopSourceContext</span> context = &#123;<span class="number">0</span>, <span class="keyword">self</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">          &amp;RunLoopSourceScheduleRoutine,</span><br><span class="line">          RunLoopSourceCancelRoutine,</span><br><span class="line">          RunLoopSourcePerformRoutine&#125;;</span><br><span class="line"> </span><br><span class="line">  _runLoopSource = <span class="built_in">CFRunLoopSourceCreate</span>(<span class="literal">NULL</span>, <span class="number">0</span>, &amp;context);</span><br><span class="line">  commands = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addToCurrentRunLoop&#123;</span><br><span class="line">  <span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line">  <span class="built_in">CFRunLoopAddSource</span>(runLoop, _runLoopSource, kCFRunLoopDefaultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 worker 线程调用 addToCurrentRunLoop 方法时，才会将 input source 放到 runloop 中，并在此时调用 RunLoopSourceScheduleRoutine 。input source 加到 runloop 之后，thread 就可以跑起他的 runloop ，等待他派发 task 。</p><ul><li>CFRunLoopSourceContext 结构体描述了 custom input source（source0）的上下文</li><li>CFRunLoopSourceContext1 结构体描述了 port-based input source（source1）的上下文</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="built_in">CFIndex</span>version;</span><br><span class="line">  <span class="keyword">void</span> *info;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">retain</span>)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">  <span class="keyword">void</span>(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">  <span class="built_in">CFStringRef</span>(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">  Boolean(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">  <span class="built_in">CFHashCode</span>(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>(*schedule)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopMode</span> mode);</span><br><span class="line">  <span class="keyword">void</span>(*cancel)(<span class="keyword">void</span> *info, <span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopMode</span> mode);</span><br><span class="line">  <span class="keyword">void</span>(*perform)(<span class="keyword">void</span> *info);</span><br><span class="line"></span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="built_in">CFIndex</span>version;</span><br><span class="line">  <span class="keyword">void</span> *info;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">void</span> *(*<span class="keyword">retain</span>)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">  <span class="keyword">void</span>(*release)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">  <span class="built_in">CFStringRef</span>(*copyDescription)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line">  Boolean(*equal)(<span class="keyword">const</span> <span class="keyword">void</span> *info1, <span class="keyword">const</span> <span class="keyword">void</span> *info2);</span><br><span class="line">  <span class="built_in">CFHashCode</span>(*hash)(<span class="keyword">const</span> <span class="keyword">void</span> *info);</span><br><span class="line"><span class="meta">#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)</span></span><br><span class="line">  mach_port_t(*getPort)(<span class="keyword">void</span> *info);</span><br><span class="line">  <span class="keyword">void</span> *(*perform)(<span class="keyword">void</span> *msg, <span class="built_in">CFIndex</span> size, <span class="built_in">CFAllocatorRef</span> allocator, <span class="keyword">void</span> *info);</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">  <span class="keyword">void</span> *(*getPort)(<span class="keyword">void</span> *info);</span><br><span class="line">  <span class="keyword">void</span>(*perform)(<span class="keyword">void</span> *info);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125; <span class="built_in">CFRunLoopSourceContext1</span>;</span><br></pre></td></tr></table></figure><h4 id="input-source-与-client-的协作"><a class="markdownIt-Anchor" href="#input-source-与-client-的协作"></a> Input Source 与 Client 的协作</h4><p>想使用 input source，你需要从其他 thread 发送消息。input source 的全部目的是使其关联 thread 处于休眠状态，直到有事要做。这需要让你的应用程序中的其他线程知道输入源并有一种与之通信的方法。</p><p>当 input source 第一次装载到 run loop 的时候，可以向 client 发送注册 input source 的请求。可以将一个 input source 直接或间接注册到多个 client 中。下面的代码展示了 application delegate 提供的注册方法 registerSource:，之前提到过回调函数 RunLoopSourceScheduleRoutine 的实现会调用 registerSource:。也就是说执行流程是 install(addToCurrentRunLoop) -&gt; schedule(RunLoopSourceScheduleRoutine) -&gt; register(registerSource:)。对应地，当 input source 从 run loop 中被移除，回调函数 RunLoopSourceCancelRoutine 中会调用 removeSource: 方法。</p><p><a href="#4">scheduler an input source</a> 和 <a href="#5">Invalidating an input source</a><br><span id="3"></span></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerSource:(RunLoopContext*)sourceInfo;&#123;</span><br><span class="line">  [sourcesToPing addObject:sourceInfo];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)removeSource:(RunLoopContext*)sourceInfo&#123;</span><br><span class="line">  <span class="keyword">id</span> objToRemove = <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (RunLoopContext* context <span class="keyword">in</span> sourcesToPing) &#123;</span><br><span class="line">  <span class="keyword">if</span> ([context isEqual:sourceInfo]) &#123;</span><br><span class="line">    objToRemove = context;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (objToRemove)</span><br><span class="line">  [sourcesToPing removeObject:objToRemove];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="向-input-source-发送信号"><a class="markdownIt-Anchor" href="#向-input-source-发送信号"></a> 向 Input Source 发送信号</h4><p>在将数据交给 Input Source 后，客户端必须发信号通知源并唤醒其 runloop。消息传达 input source 以后，thread 可以处于休眠状态，你应该显示的唤起 runloop，如果处理完了可能会导致错误结果！</p><p>Waking up the run loop:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)fireCommandsOnRunLoop:(<span class="built_in">CFRunLoopRef</span>)runloop &#123;</span><br><span class="line">  <span class="built_in">CFRunLoopSourceSignal</span>(runLoopSource);</span><br><span class="line">  <span class="built_in">CFRunLoopWakeUp</span>(runloop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置-timer-sources"><a class="markdownIt-Anchor" href="#配置-timer-sources"></a> 配置 Timer Sources</h3><p>创建 Timer Sources：创建一个 timer 对象，然后在 runloop中调度它。<br>Cocoa 中使用 NSTimer，Core Foundation 中使用 CFRunLoopTimerRef 类型。虽然二者是 toll-free bridged 的，但是 NSTimer 提供的 API 更便捷：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:</span><br><span class="line">scheduledTimerWithTimeInterval:invocation:repeats:</span><br></pre></td></tr></table></figure><p>上面这2个方法会创建 timer 并添加到当前线程 runloop 的 DefaultMode 中。也可以手动创建一个 NSTimer 对象并用 NSRunLoop 的 addTimer:forMode: 方法将其添加到 runloop 的指定 Mode 中。</p><p>下面的代码展示了两种添加 timer 的方式：第一个 timer 延迟 1 秒触发并每隔 0.1 秒重复触发，第二个 timer 延迟 0.2 秒触发然后每隔 0.2 秒重复触发。</p><p>Creating and scheduling timers using NSTimer:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSRunLoop</span>* myRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create and schedule the first timer.</span></span><br><span class="line"><span class="built_in">NSDate</span>* futureDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">1.0</span>];</span><br><span class="line"><span class="built_in">NSTimer</span>* myTimer = [[<span class="built_in">NSTimer</span> alloc] initWithFireDate:futureDate</span><br><span class="line">            interval:<span class="number">0.1</span></span><br><span class="line">            target:<span class="keyword">self</span></span><br><span class="line">            selector:<span class="keyword">@selector</span>(myDoFireTimer1:)</span><br><span class="line">            userInfo:<span class="literal">nil</span></span><br><span class="line">             repeats:<span class="literal">YES</span>];</span><br><span class="line">[myRunLoop addTimer:myTimer forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Create and schedule the second timer.</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">0.2</span></span><br><span class="line">        target:<span class="keyword">self</span></span><br><span class="line">        selector:<span class="keyword">@selector</span>(myDoFireTimer2:)</span><br><span class="line">        userInfo:<span class="literal">nil</span></span><br><span class="line">         repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure><p>Creating and scheduling a timer using Core Foundation:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopRef</span> runLoop = <span class="built_in">CFRunLoopGetCurrent</span>();</span><br><span class="line"><span class="built_in">CFRunLoopTimerContext</span> context = &#123;<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line"><span class="built_in">CFRunLoopTimerRef</span> timer = <span class="built_in">CFRunLoopTimerCreate</span>(kCFAllocatorDefault, <span class="number">0.1</span>, <span class="number">0.3</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">          &amp;myCFTimerCallback, &amp;context);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(runLoop, timer, kCFRunLoopCommonModes);</span><br></pre></td></tr></table></figure><h3 id="配置-a-port-based-input-source"><a class="markdownIt-Anchor" href="#配置-a-port-based-input-source"></a> 配置 a Port-Based Input Source</h3><p>Cocoa and Core Foundation 都提供了 port-based 对象用于线程 or 进程间通讯，下面会使用不同类型的 ports 实现建立 port 通讯</p><h4 id="配置-nsmachport-object"><a class="markdownIt-Anchor" href="#配置-nsmachport-object"></a> 配置 NSMachPort Object</h4><p>使用 NSMachPort 对象建立本地连接：</p><ul><li>创建 NSMachPort 对象并添加到 primary 线程的 runloop 中。</li><li>当启动 secondary 线程时将这个 NSMachPort 对象传递给 secondary 线程的入口函数。</li><li>secondary 线程会用这个 NSMachPort 对象往 primary 线程发消息。</li></ul><h5 id="main-thread-代码实现"><a class="markdownIt-Anchor" href="#main-thread-代码实现"></a> main thread 代码实现</h5><p>下面的代码是启动 secondary worker 线程的主要代码。使用 Cocoa 框架的代码要比 Core Foundation 的少，效果几乎一样。有个不同点是 Cocoa 直接传递 NSPort 对象，而 Core Foundation 传递端口名字符串。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)launchThread&#123;</span><br><span class="line">  <span class="built_in">NSPort</span>* myPort = [<span class="built_in">NSMachPort</span> port];</span><br><span class="line">  <span class="keyword">if</span> (myPort) &#123;</span><br><span class="line">  <span class="comment">// This class handles incoming port messages.</span></span><br><span class="line">  [myPort setDelegate:<span class="keyword">self</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Install the port as an input source on the current run loop.</span></span><br><span class="line">  [[<span class="built_in">NSRunLoop</span> currentRunLoop] addPort:myPort forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Detach the thread. Let the worker release the port.</span></span><br><span class="line">  [<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(LaunchThreadWithPort:)</span><br><span class="line">     toTarget:[MyWorkerClass <span class="keyword">class</span>] withObject:myPort];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了建立好 threads 间的通讯，你可能想要得到 worker thread 将他的本地端口号发送给 main thread，把这个当做校验消息。main thread 得到 worker thread 的端口号，校验完毕，就知道启动 secondary thread 的过程一切进展顺利。主线程会将 worker thread 的 portID 保存起来。</p><p>下面的 handlePortMessage: 方法会在线程自己的本地端口收到数据后被调用。NSPortMessage 持有两个端口对象：发送端口和接收端口。handlePortMessage: 方法中使用 [portMessage sendPort] 获取到了发送端口对象，也就是 secondary thread 拥有的本地端口。也就是 secondary thread 启动后会给 primary thread 发消息，告知自己的端口对象，主线程会将其存下来以备日后使用。msgid 标记了消息的唯一 ID。</p><p>Handling Mach port messages:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define kCheckinMessage 100</span></span><br><span class="line"><span class="comment">// Handle responses from the worker thread.</span></span><br><span class="line">- (<span class="keyword">void</span>)handlePortMessage:(<span class="built_in">NSPortMessage</span> *)portMessage&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> message = [portMessage msgid];</span><br><span class="line">  <span class="built_in">NSPort</span>* distantPort = <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (message == kCheckinMessage) &#123;</span><br><span class="line">  <span class="comment">// Get the worker thread’s communications port.</span></span><br><span class="line">  distantPort = [portMessage sendPort];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Retain and save the worker port for later use.</span></span><br><span class="line">  [<span class="keyword">self</span> storeDistantPort:distantPort];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">// Handle other messages.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="secondary-thread-代码实现"><a class="markdownIt-Anchor" href="#secondary-thread-代码实现"></a> secondary thread 代码实现</h5><p>对于 secondary worker thread, 你一定要明确他的端口号！用它与 primary thread 通讯。</p><p>下面代码：如何配置 worker thread，worker thread 的入口函数会被传入 primary thread 的端口对象。下面代码中的 MyWorkerClass 是个辅助类，它的 sendCheckinMessage: 方法负责创建worker thread的本地端口，并发消息给 primary thread 。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)LaunchThreadWithPort:(<span class="keyword">id</span>)inData&#123;</span><br><span class="line">  <span class="built_in">NSAutoreleasePool</span>*  pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Set up the connection between this thread and the main thread.</span></span><br><span class="line">  <span class="built_in">NSPort</span>* distantPort = (<span class="built_in">NSPort</span>*)inData;</span><br><span class="line"> </span><br><span class="line">  MyWorkerClass*  workerObj = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  [workerObj sendCheckinMessage:distantPort];</span><br><span class="line">  [distantPort release];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Let the run loop process things.</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">  [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span></span><br><span class="line">         beforeDate:[<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">  &#125; <span class="keyword">while</span> (![workerObj shouldExit]);</span><br><span class="line"> </span><br><span class="line">  [workerObj release];</span><br><span class="line">  [pool release];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="配置-nsmessageport-object"><a class="markdownIt-Anchor" href="#配置-nsmessageport-object"></a> 配置 NSMessagePort Object</h4><h4 id="使用-core-foundation-配置-port-based-input-source"><a class="markdownIt-Anchor" href="#使用-core-foundation-配置-port-based-input-source"></a> 使用 Core Foundation 配置 Port-Based Input Source</h4><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW5" target="_blank" rel="noopener">Threading Programming Guide-RunLoop</a><br><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/#%E8%AF%A5%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-Run-Loop%EF%BC%9F" target="_blank" rel="noopener">Threading Programming Guide(2)</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> runloop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RunLoop 原理分析</title>
      <link href="/2017/08/27/runloop/RunLoop%E5%88%86%E6%9E%90/"/>
      <url>/2017/08/27/runloop/RunLoop%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><p><img src="/img/runloop_title.jpeg" alt="runloop_title"></p><h2 id="带着问题思考-questions"><a class="markdownIt-Anchor" href="#带着问题思考-questions"></a> 带着问题思考 Questions</h2><ol><li>RunLoop 他是什么？</li><li>RunLoop 结构是什么样的？</li><li>为什么要是这样的结构，其他的样子不可以吗？</li><li>RunLoop 内部分析？</li><li>系统中有哪些功能使用了 runloop？</li><li>开发中如何使用 RunLoop</li></ol><p>引用 CFRunLoopRef 源码：<a href="https://opensource.apple.com/tarballs/CF/CF-1153.18.tar.gz" target="_blank" rel="noopener">CF-1153.18.tar.gz</a></p><h2 id="runloop-来源"><a class="markdownIt-Anchor" href="#runloop-来源"></a> RunLoop 来源</h2><ul><li>一般来说，thread 只运行一次，然后终止. 像命令行驱动程序。但是这样的程序没有用户交互性</li><li>为了使程序增加用户交互性，就需要一个机制让程序不退出等待用户操作。使用<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event Loop</a>设计模式，让 thread 关联一个 event loop，监听 event，然后调用事件的 reactor 处理事件通常是交由 event loop 关联的 thread 处理。这样使 thread 保活</li></ul><figure class="highlight vb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> main</span><br><span class="line">    initialize()</span><br><span class="line">    <span class="keyword">while</span> message != quit</span><br><span class="line">        message := get_next_message()</span><br><span class="line">        process_message(message)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span></span><br><span class="line"><span class="keyword">end</span> <span class="keyword">function</span></span><br></pre></td></tr></table></figure><p>而对于没有 runloop 的thread</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task2</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(#function)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> thread = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"task1"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  thread.start()</span><br><span class="line">  perform(#selector(<span class="type">LongLiveViewController</span>.task2), on: thread, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果只会打印 task1，因为 thread 没有 runloop，所以执行完当前任务 task1 以后会自动退出</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withoutRunloop</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> thread = <span class="type">Thread</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"task 1"</span>)</span><br><span class="line">    <span class="type">RunLoop</span>.current.add(<span class="type">Port</span>(), forMode: .<span class="keyword">default</span>)</span><br><span class="line">    <span class="type">RunLoop</span>.current.run(mode: .<span class="keyword">default</span>, before: <span class="type">Date</span>.distantFuture)</span><br><span class="line">  &#125;</span><br><span class="line">  thread.start()</span><br><span class="line">  perform(#selector(<span class="type">LongLiveViewController</span>.task2), on: thread, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印 task1，task2()，只有当 Port 从 runloop 中移除这个线程就会退出，否则他的生命周期由 runloop 维护着，具体看下文</p><h2 id="event-loop-机制"><a class="markdownIt-Anchor" href="#event-loop-机制"></a> Event loop 机制</h2><p><img src="/img/event_loop.jpeg" alt="Event loop 机制"></p><p>Event Loop 在很多平台上都有，无论是 GUI，开始系统事件都需要 Event Loop 模式来处理交互程序</p><table><thead><tr><th style="text-align:left">环境</th><th style="text-align:left">Event_Loop对应名称</th></tr></thead><tbody><tr><td style="text-align:left">OSX/iOS</td><td style="text-align:left">RunLoop</td></tr><tr><td style="text-align:left">Windows</td><td style="text-align:left">消息队列</td></tr><tr><td style="text-align:left">Linux</td><td style="text-align:left">epoll，select</td></tr></tbody></table><p>消息队列使得调用方跟被调用方之间解耦</p><h2 id="osxios-中的-event-loop"><a class="markdownIt-Anchor" href="#osxios-中的-event-loop"></a> OSX/iOS 中的 Event Loop</h2><h3 id="runloop-特点"><a class="markdownIt-Anchor" href="#runloop-特点"></a> RunLoop 特点：</h3><ul><li>他是与线程相关的基础架构的一部分，充当着循环处理、调度事件/转发消息的角色，管理thread运行状态。<ul><li>它使得线程不会执行完单个任务后就立刻结束</li><li>让线程在没有任务时保持休眠状态</li><li>在需要处理消息时被立刻唤醒</li></ul></li><li>RunLoop 是个对象，每个线程都可以有对应的 runloop。runloop的管理机制并不完全是自动的，有时需要设计好 runloop 的运行时间和事件处理回调。<ul><li>除了主线程外，子线程需要开发者手动去配置并运行它的 runloop</li><li>主线程的 runloop 已经由系统自动配置并运行了。</li></ul></li><li>runloop 在 Cocoa 和 Core Foundation 有两个对应的类：NSRunLoop 和 CFRunLoop</li></ul><h2 id="run-loop-内部执行流程"><a class="markdownIt-Anchor" href="#run-loop-内部执行流程"></a> Run Loop 内部执行流程</h2><p>线程的 run loop 每次运行都会处理待决的事件，并为绑定的所有 observer 生成通知。次序如下：</p><p>如果mode里没有source/timer/observer, 直接返回。</p><ol><li>通知 <code>observer</code> 已经进入 run loop <font color="red">(kCFRunLoopEntry)</font></li><li>通知 <code>observer</code> 有 timer 将要触发 <font color="red">(kCFRunLoopBeforeTimers)</font></li><li>通知 <code>observer</code> 有非基于端口的 input source(source0) 将要触发 <font color="red">(kCFRunLoopBeforeSources)</font></li><li>触发所有已就绪的非基于端口的 input source(source0)</li><li>如果一个基于端口的 input source(source1, 系统触发) 已就绪并等待触发，立即处理事件，并转至第 9 步</li><li>通知 <code>observer</code> 线程即将休眠 <font color="red">(kCFRunLoopBeforeWaiting)</font></li><li>让线程休眠，直到被以下条件唤醒：<ol><li>有基于端口的 input source 事件到达</li><li>timer 触发</li><li>run loop 设定的超时时间到了</li><li>run loop 被手动唤醒</li></ol></li><li>通知 <code>observer</code> 线程刚刚被唤醒 <font color="red">(kCFRunLoopAfterWaiting)</font></li><li>处理待决事件<ol><li>如果用户定义的 timer 触发了，处理 timer 事件并重启 run loop，跳回到第 2 步</li><li>如果 input source 触发了，分发事件</li><li>如果 run loop 被唤醒且没有超时，重启 run loop，跳回到第 2 步</li></ol></li><li>通知 <code>observer</code> 已经退出 run loop <font color="red">(kCFRunLoopExit)</font></li></ol><details><summary>对应简化源码</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</span><br><span class="line">  CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">  <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 内部函数，进入loop</span></span><br><span class="line">  __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line">    Boolean sourceHandledThisLoop = NO;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123; </span><br><span class="line">      <span class="comment">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">      <span class="comment">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">      <span class="comment">// 执行被加入的block</span></span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">      sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">      <span class="comment">// 执行被加入的block</span></span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">      <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">        Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">        <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">      <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">        __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">      <span class="comment">// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">      <span class="comment">// • 一个 Timer 到时间了</span></span><br><span class="line">      <span class="comment">// • RunLoop 自身的超时时间到了</span></span><br><span class="line">      <span class="comment">// • 被其他什么调用者手动唤醒</span></span><br><span class="line">      __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">        mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">      __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 收到消息，处理消息。</span></span><br><span class="line">      handle_msg:</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">      <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">        __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">        __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">        sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">        <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">          mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 执行加入到Loop的block</span></span><br><span class="line">      __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">        <span class="comment">// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">        retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        <span class="comment">// 超出传入参数标记的超时时间了</span></span><br><span class="line">        retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">        <span class="comment">// 被外部调用者强制停止了</span></span><br><span class="line">        retVal = kCFRunLoopRunStopped;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">        <span class="comment">// source/timer/observer一个都没有了</span></span><br><span class="line">        retVal = kCFRunLoopRunFinished;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">  __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p></pre></details><img src="/img/runloop_main_routine.jpg" alt="runloop" style="width:500px;height:628px"><h2 id="runloop底层实现"><a class="markdownIt-Anchor" href="#runloop底层实现"></a> RunLoop底层实现</h2><p>核心是源码中的第 7 步：<br>7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒</p><ul><li>一个基于 port 的Source 的事件。</li><li>一个 Timer 到时间了</li><li>RunLoop 自身的超时时间到了</li><li>被其他什么调用者手动唤醒</li></ul><p>mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p><p><img src="/img/mach_msg.jpeg" alt="mach_msg"></p><p>使用 xcode，当程序不执行操作的时候，click debug 的暂停<br><img src="/img/main_thread_mach_msg.jpeg" alt="main_thread_mach_msg"></p><p>在没有事件处理时：<br>Thread 1 Queue : com.apple.main-thread (serial)<br>com.apple.uikit.eventfetch-thread (6)<br>这两个线程的runloop都停留在mach_msg_trap状态，等待事件发生。</p><p>其他线程都是 <a href="https://github.com/darlinghq/darling/blob/master/src/kernel/emulation/linux/bsdthread/workq_kernreturn.c" target="_blank" rel="noopener"><code>_workq_kernreturn：</code></a><br>等待 <code>spinlock</code> 技术，从而执行队列中的下一个 task（或者退出）</p><h2 id="runloop结构"><a class="markdownIt-Anchor" href="#runloop结构"></a> RunLoop结构</h2><h3 id="mode"><a class="markdownIt-Anchor" href="#mode"></a> Mode</h3><p>首先要知道 Mode 的作用：为了减少runloop监听的source/timer/observer 的个数</p><details><summary>RunLoop 和 Mode 简化源码</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> *<span class="title">CFRunLoopModeRef</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">  CFStringRef _name;      <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">  CFMutableSetRef _sources0;  <span class="comment">// Set 自定义的 input source，由其他 thread 发送消息</span></span><br><span class="line">  CFMutableSetRef _sources1;  <span class="comment">// Set 基于 port 包含了一个 mach_port 和一个回调（函数指针），用于通过内核和其他线程相互发送消息</span></span><br><span class="line">  CFMutableArrayRef _observers; <span class="comment">// Array</span></span><br><span class="line">  CFMutableArrayRef _timers;  <span class="comment">// Array</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> *<span class="title">CFRunLoopRef</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">  pthread thread;</span><br><span class="line">  CFMutableSetRef _commonModes;   <span class="comment">// Set 通用 modes集合，任何Source/Observer/Timer 加入其中以后，_commonModes 中的每个 mode 都会引用这些(Source/Observer/Timer ),并对其做相应处理</span></span><br><span class="line">  CFMutableSetRef _commonModeItems; <span class="comment">// Set 所有_commonModes中引用 &lt;Source/Observer/Timer&gt;</span></span><br><span class="line">  CFRunLoopModeRef _currentMode;  <span class="comment">// Current Runloop Mode CFRunLoopCopyAllModes方法会得到它</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><p><img src="/img/run_loop_structure.jpeg" alt="run_loop_structure"></p><p>Input Sources:</p><ul><li>Port-Based Sources：监听App的 Mach Port，由内核发出信号，输入源收到信号后，执行相关的例程。(sources1)</li><li>Custom Input Sources：监听自定义的输入源，需要在其它线程手动发送信号，输入源收到信号后，执行相关的例程。(sources0)</li><li>Cocoa Perform Selector Sources：Cocoa中自定义的输入源，目的是在不同线程中执行任务，同一线程中的任务是顺序执行的,当任务执行完成后系统会自动移除这个源。（注意：在目标线程中执行任务时，这个目标线程必须有活跃的RunLoop）(sources0)</li></ul><p><code>时间源 time sources</code><br>需要监听runloop的当前状态的：<br><code>监听者 observers</code></p><p>RunLoop 的每次运行都会在某个特定模式下，而且只有这个模式所包含的 item 集合才会参与发送事件(被监听)和接收通知。如果改 item 没有加入到指定模式下的runloop，那么该模式下就不会执通知or监听该 item，如果没有 item 那么会进入休眠状态。</p><ul><li>mode 中需要注意的 default 和 tracing 这两种，在实际开发中会经常使用</li></ul><span id="1"><table><thead><tr><th>Mode</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><font color="red">Default</font></td><td>NSDefaultRunLoopMode (Cocoa), kCFRunLoopDefaultMode (Core Foundation)</td><td>App的默认运行模式，通常主线程是在这个运行模式下运行</td></tr><tr><td>Connection</td><td>NSConnectionReplyMode (Cocoa)</td><td>Cocoa 中结合 NSConnection 使用，用于监听回复(Reply)，极少用到。(已弃用)</td></tr><tr><td>Modal</td><td>NSModalPanelRunLoopMode (Cocoa)</td><td>Cocoa 中 modal panel 使用它接收与之相关 Source 的事件</td></tr><tr><td><font color="red">Event tracking</font></td><td>NSEventTrackingRunLoopMode (Cocoa), UITrackingRunLoopMode (Cocoa Touch)</td><td>跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）</td></tr><tr><td><font color="red"><strong>Common modes</strong></font></td><td>NSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)</td><td>这是一组可配置的通用集合，如果将某个 input source 注册到该模式下，那么 input source 在通用模式集合中的每个 mode 中都会注册。Cocoa 框架中的 Common modes 默认包含 Default, Modal, Event tracking 三种 Mode；Core Foundation 只包含 Default，可以使用 <a href="https://developer.apple.com/documentation/corefoundation/1542137-cfrunloopaddcommonmode" target="_blank" rel="noopener">CFRunLoopAddCommonMode</a> 函数向集合中添加自定义 Mode。</td></tr></tbody></table><p><strong>Common modes</strong> 不是一个mode，而是一个 modes 集合！</p><p>eg: 在 Cocoa 框架中，如果 Sources, timers, observers 添加到 CommonModes中，那么 Sources, timers, observers 会被 CommonModes 结合中(Default, Modal, Event tracking)所有模式共享！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef rl, CFRunLoopMode mode)</span></span>;</span><br></pre></td></tr></table></figure><p>一旦 mode 添加到 runloop 的_commonModes以后就不可以被删除了！此时需要创建新的 runloop 对象，把旧 runloop 中需要的 mode copy 出来，放在新的 runloop 中</p><p><a href="https://developer.apple.com/documentation/corefoundation/1541775-cfrunloopcopycurrentmode?language=objc" target="_blank" rel="noopener">CFRunLoopCopyCurrentMode</a>/<a href="https://developer.apple.com/documentation/corefoundation/1542184-cfrunloopcopyallmodes?language=objc" target="_blank" rel="noopener">CFRunLoopCopyAllModes</a></p><h2 id="runloop-中的sources-和-observers"><a class="markdownIt-Anchor" href="#runloop-中的sources-和-observers"></a> RunLoop 中的sources 和 observers</h2><p><img src="/img/runloop_event.jpeg" alt="run_loop_structure"><br>在 RunLoop 对象结构中有个 Mode，是为了在某种模式下 RunLoop 才会处理，可以减少每次需要监听的事件源</p><h3 id="sources-事件源"><a class="markdownIt-Anchor" href="#sources-事件源"></a> Sources 事件源</h3><h4 id="input-sources"><a class="markdownIt-Anchor" href="#input-sources"></a> Input Sources</h4><p>source分为两类，source0和source1。</p><ol><li>source0只含有回调指针，处理如UIEvent，CFSocket这类事件。它只能手动唤醒。</li><li>source1则是有一个mach port和回调指针，能被Mach内核传递的信息唤醒。<ol><li>触摸事件其实是source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback</li><li>__IOHIDEventSystemClientQueueCallback() 内触发的 Source0</li><li>Source0 再触发的 _UIApplicationHandleEventQueue()</li></ol></li></ol><p>输入源：将事件以 <code>asynchronous</code> 的方式向 thread 发送 event</p><table><thead><tr><th style="text-align:left">输入源</th><th>Port-Based Sources</th><th>Custom Input Sources</th></tr></thead><tbody><tr><td style="text-align:left">对应 mode 结构体</td><td>source1</td><td>source0</td></tr><tr><td style="text-align:left">消息从何来(发送方)</td><td>kernel 线程</td><td>其他用户thread</td></tr><tr><td style="text-align:left">监听事件</td><td>Mach ports（内核 ports）event</td><td>用户自定义Input sources 的event</td></tr><tr><td style="text-align:left">添加方法</td><td>NSPort 对象</td><td>CFRunLoopSourceRef</td></tr></tbody></table><h4 id="timer-sources"><a class="markdownIt-Anchor" href="#timer-sources"></a> Timer Sources</h4><p>时间源：在预设时间后以同步的方式把 event 传递给 thread<br>Timer：是线程通知自己做某事的一种方式</p><h3 id="run-loop-observers-观察者"><a class="markdownIt-Anchor" href="#run-loop-observers-观察者"></a> Run Loop Observers 观察者</h3><p>不同于 source 在同步或异步事件发生时触发，observer 会在 runloop 运行期间的某些特殊地方触发。<br>CFRunLoopObserverRef是 runloop 状态的观察者，能够监听RunLoop所有的状态改变。</p><ul><li>进入 run loop</li><li>当 run loop 即将处理一个 timer</li><li>当 run loop 即将处理一个 input source</li><li>当 run loop 即将休眠</li><li>当 run loop 已经被唤醒，但在它处理唤醒它的事件之前</li><li>退出 run loop</li></ul><details><summary>对应 CFRunLoopActivity 枚举</summary><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 即将进入Loop</span></span><br><span class="line">  kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">  <span class="comment">// 即将处理Timer</span></span><br><span class="line">  kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">  <span class="comment">// 即将处理Source</span></span><br><span class="line">  kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">  <span class="comment">// 即将进入休眠</span></span><br><span class="line">  kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">  <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">  kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">  <span class="comment">// 即将退出Loop</span></span><br><span class="line">  kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">  <span class="comment">// 所有状态</span></span><br><span class="line">  kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><h2 id="runloop-核心对象的源码结构"><a class="markdownIt-Anchor" href="#runloop-核心对象的源码结构"></a> RunLoop 核心对象的源码结构</h2><details><summary>RunLoop</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></span><br><span class="line">  CFRuntimeBase _base;</span><br><span class="line">  __CFPort _wakeUpPort;  <span class="comment">// used for CFRunLoopWakeUp </span></span><br><span class="line">  Boolean _unused;</span><br><span class="line">  <span class="keyword">volatile</span> _per_run_data *_perRunData;  <span class="comment">// reset for runs of the run loop</span></span><br><span class="line">  <span class="keyword">pthread_t</span> _pthread;</span><br><span class="line">  CFMutableSetRef _commonModes;</span><br><span class="line">  CFMutableSetRef _commonModeItems;  </span><br><span class="line">  <span class="comment">//  CFSetAddValue(rl-&gt;_commonModeItems, rls); CFRunLoopSourceRef rlo</span></span><br><span class="line">  <span class="comment">//  CFSetAddValue(rl-&gt;_commonModeItems, rlo); CFRunLoopObserverRef rlo</span></span><br><span class="line">  CFRunLoopModeRef _currentMode;</span><br><span class="line">  CFMutableSetRef _modes;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></span><br><span class="line">  CFAbsoluteTime _runTime;</span><br><span class="line">  CFAbsoluteTime _sleepTime;</span><br><span class="line">  CFTypeRef _counterpart;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><details><summary>RunLoopMode</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></span><br><span class="line">  CFStringRef _name;</span><br><span class="line">  Boolean _stopped;</span><br><span class="line">  CFMutableSetRef _sources0;</span><br><span class="line">  CFMutableSetRef _sources1;</span><br><span class="line">  CFMutableArrayRef _observers;</span><br><span class="line">  CFMutableArrayRef _timers;</span><br><span class="line">  CFMutableDictionaryRef _portToV1SourceMap;</span><br><span class="line">  __CFPortSet _portSet;</span><br><span class="line">  CFIndex _observerMask;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_DISPATCH_SOURCE_FOR_TIMERS</span></span><br><span class="line">  <span class="keyword">dispatch_source_t</span> _timerSource;</span><br><span class="line">  <span class="keyword">dispatch_queue_t</span> _queue;</span><br><span class="line">  Boolean _timerFired; <span class="comment">// set to true by the source when a timer has fired</span></span><br><span class="line">  Boolean _dispatchTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_MK_TIMER_TOO</span></span><br><span class="line">  <span class="keyword">mach_port_t</span> _timerPort;</span><br><span class="line">  Boolean _mkTimerArmed;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><details><summary>RunLoopSource</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> &#123;</span></span><br><span class="line">  CFRuntimeBase _base;</span><br><span class="line">  <span class="keyword">uint32_t</span> _bits;</span><br><span class="line">  CFIndex _order;<span class="comment">/* immutable */</span></span><br><span class="line">  CFMutableBagRef _runLoops;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">  CFRunLoopSourceContext version0;<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">    CFRunLoopSourceContext1 version1;<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">  &#125; _context;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><details><summary>RunLoop Observers</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> &#123;</span></span><br><span class="line">  CFRuntimeBase _base;</span><br><span class="line">  CFRunLoopRef _runLoop;</span><br><span class="line">  CFIndex _rlCount;</span><br><span class="line">  CFOptionFlags _activities;<span class="comment">/* immutable */</span></span><br><span class="line">  CFIndex _order;<span class="comment">/* immutable */</span></span><br><span class="line">  CFRunLoopObserverCallBack _callout;<span class="comment">/* immutable */</span></span><br><span class="line">  CFRunLoopObserverContext _context;<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><details><summary>RunLoop Timer</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></span><br><span class="line">  CFRuntimeBase _base;</span><br><span class="line">  CFRunLoopRef _runLoop;</span><br><span class="line">  CFMutableSetRef _rlModes;</span><br><span class="line">  CFAbsoluteTime _nextFireDate;</span><br><span class="line">  CFTimeInterval _interval;<span class="comment">/* immutable */</span></span><br><span class="line">  CFTimeInterval _tolerance;      <span class="comment">/* mutable */</span></span><br><span class="line">  <span class="keyword">uint64_t</span> _fireTSR;<span class="comment">/* TSR units */</span></span><br><span class="line">  CFIndex _order;<span class="comment">/* immutable */</span></span><br><span class="line">  CFRunLoopTimerCallBack _callout;<span class="comment">/* immutable */</span></span><br><span class="line">  CFRunLoopTimerContext _context;<span class="comment">/* immutable, except invalidation */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><h2 id="使用到-runloop-的相关实践"><a class="markdownIt-Anchor" href="#使用到-runloop-的相关实践"></a> 使用到 RunLoop 的相关实践</h2><p>先分析下系统中都使用 runLoop 做了什么</p><h3 id="系统如何使用-runloop"><a class="markdownIt-Anchor" href="#系统如何使用-runloop"></a> 系统如何使用 RunLoop</h3><details><summary>app 运行时，打印CFRunLoop 内部样</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">CFRunLoop &#123;</span><br><span class="line">  current mode = kCFRunLoopDefaultMode</span><br><span class="line">  common modes = &#123;</span><br><span class="line">    UITrackingRunLoopMode,</span><br><span class="line">    kCFRunLoopDefaultMode</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  common mode items = &#123;</span><br><span class="line">  <span class="comment">// source0 (manual)</span></span><br><span class="line">    CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;callout = _UIApplicationHandleEventQueue&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;callout = PurpleEventSignalCallback &#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// source1 (mach port)</span></span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;callout = PurpleEventCallback&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</span><br><span class="line">    CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>, callout = __IOMIGMachPortPortCallback&#125;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Obvserver</span></span><br><span class="line">    <span class="comment">// Entry</span></span><br><span class="line">    CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; </span><br><span class="line">    <span class="comment">// BeforeWaiting</span></span><br><span class="line">    CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>, callout = _UIGestureRecognizerUpdateObserver&#125; </span><br><span class="line">    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">    CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>, callout = _afterCACommitHandler&#125; </span><br><span class="line">    <span class="comment">// BeforeWaiting | Exit</span></span><br><span class="line">    CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; </span><br><span class="line">    <span class="comment">// BeforeWaiting | Exit </span></span><br><span class="line">    CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Timer</span></span><br><span class="line">    CFRunLoopTimer &#123;</span><br><span class="line">      firing = No, </span><br><span class="line">      interval = <span class="number">3.1536e+09</span>, </span><br><span class="line">      tolerance = <span class="number">0</span>,</span><br><span class="line">      next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</span><br><span class="line">      callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</span><br><span class="line">  &#125;<span class="comment">// end commons,</span></span><br><span class="line"> </span><br><span class="line">  modes ＝ &#123;</span><br><span class="line">    CFRunLoopMode  &#123;</span><br><span class="line">      sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">      sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">      observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">      timers =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    CFRunLoopMode  &#123;</span><br><span class="line">      sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">      sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">      observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">      timers =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    CFRunLoopMode  &#123;</span><br><span class="line">      sources0 = &#123; CFRunLoopSource &#123;order = <span class="number">0</span>, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;,</span><br><span class="line">      sources1 = (null),</span><br><span class="line">      observers = &#123; CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;)&#125;,</span><br><span class="line">      timers = (null),</span><br><span class="line">    &#125;,</span><br><span class="line">    CFRunLoopMode  &#123;</span><br><span class="line">      sources0 = &#123;</span><br><span class="line">      CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;,</span><br><span class="line">      sources1 = &#123; CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123; callout = PurpleEventCallback&#125;&#125; &#125;,</span><br><span class="line">      observers = (null),</span><br><span class="line">      timers = (null),</span><br><span class="line">    &#125;,</span><br><span class="line">    CFRunLoopMode  &#123;</span><br><span class="line">      sources0 = (null),</span><br><span class="line">      sources1 = (null),</span><br><span class="line">      observers = (null),</span><br><span class="line">      timers = (null),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><p>打开上面代码可以看到，系统默认注册了<a href="#1">5个Mode</a>:</p><ol><li>Observer：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存管理相关：</span></span><br><span class="line">_wrapRunLoopWithAutoreleasePoolHandler： <span class="comment">//AutoReleasePool最高优先级处理 (observer)</span></span><br><span class="line">_wrapRunLoopWithAutoreleasePoolHandler： <span class="comment">//AutoReleasePool最低优先级处理 (observer)</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//界面刷新相关：</span></span><br><span class="line">afterCACommitHandler： <span class="comment">//监听CATransaction，刷新UI（observer）, 优先级很低</span></span><br><span class="line">_beforeCACommitHandler： <span class="comment">//监听CATransaction</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手势检测回调：手势变化时都会被这个观察者捕获。mach_msg_trap状态时也需要被RunLoop唤醒以后处理。</span></span><br><span class="line">_UIGestureRecognizerUpdateObserver： <span class="comment">//监听CATransaction，刷新UI（observer）</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Source：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_handleHIDEventFetcherDrain： <span class="comment">//释放IOHIDEvent对象的callback（source0)，所以有IOHIDEvent事件的位置（通常是唤醒RunLoop的位置）都会有这个回调方法。</span></span><br><span class="line">_handleEventQueue： <span class="comment">//用户事件回调(source0)，一般的addTarget: action: forControlEvents:方法都会加在source0，并由_handleEventQueue执行。</span></span><br></pre></td></tr></table></figure><span id="2"><h3 id="autoreleasepool"><a class="markdownIt-Anchor" href="#autoreleasepool"></a> AutoreleasePool</h3><p>根据上述分析，通过 RunLoop Observer，监听 RunLoop 状态来管理 AutoreleasePool的。<br>苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><ol><li>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</li><li>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</li></ol><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="事件响应"><a class="markdownIt-Anchor" href="#事件响应"></a> 事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p><p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p><p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p><h3 id="手势识别"><a class="markdownIt-Anchor" href="#手势识别"></a> 手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。<br>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。<br>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p><h3 id="界面更新"><a class="markdownIt-Anchor" href="#界面更新"></a> 界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</span><br><span class="line">    QuartzCore:CA::Transaction::observer_callback:</span><br><span class="line">        CA::Transaction::commit();</span><br><span class="line">            CA::Context::commit_transaction();</span><br><span class="line">                CA::Layer::layout_and_display_if_needed();</span><br><span class="line">                    CA::Layer::layout_if_needed();</span><br><span class="line">                        [CALayer layoutSublayers];</span><br><span class="line">                            [UIView layoutSubviews];</span><br><span class="line">                    CA::Layer::display_if_needed();</span><br><span class="line">                        [CALayer display];</span><br><span class="line">                            [UIView drawRect];</span><br></pre></td></tr></table></figure><h3 id="定时器"><a class="markdownIt-Anchor" href="#定时器"></a> 定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="performselecter"><a class="markdownIt-Anchor" href="#performselecter"></a> PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="关于gcd"><a class="markdownIt-Anchor" href="#关于gcd"></a> 关于GCD</h3><p>实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。</p><p>当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。</p><h3 id="关于网络请求"><a class="markdownIt-Anchor" href="#关于网络请求"></a> 关于网络请求</h3><p>iOS 中，关于网络请求的接口自下至上有如下几层:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CFSocket</span><br><span class="line">CFNetwork       -&gt;ASIHttpRequest</span><br><span class="line">NSURLConnection -&gt;AFNetworking</span><br><span class="line">NSURLSession    -&gt;AFNetworking2, Alamofire</span><br></pre></td></tr></table></figure><p>• CFSocket 是最底层的接口，只负责 socket 通信。<br>• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。<br>• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。<br>• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。</p><p>下面主要介绍下 NSURLConnection 的工作过程。</p><p>通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="RunLoop_network"></p><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html" target="_blank" rel="noopener">Threading Programming Guide – Run Loops</a><br><a href="https://developer.apple.com/documentation/corefoundation/1542137-cfrunloopaddcommonmode" target="_blank" rel="noopener">CFRunLoopAddCommonMode</a><br><a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a> 本文实例<a href="#2">使用到 RunLoop 的相关实践</a> 大量参考该文章，敬佩~<br><a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">Event loop</a><br><a href="https://github.com/robbie-cao/note/blob/master/eventloop.md" target="_blank" rel="noopener">后端eventloop</a><br><a href="https://en.wikipedia.org/wiki/Event-driven_programming" target="_blank" rel="noopener">Event-driven programming</a><br><a href="http://yulingtianxia.com/blog/2017/09/17/Threading-Programming-Guide-2/#Input-Sources" target="_blank" rel="noopener">Threading Programming Guide(2)</a></p></blockquote></span></span><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> runloop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOP 面向切面</title>
      <link href="/2017/08/16/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2/"/>
      <url>/2017/08/16/AOP-%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>概念：把一个个的横切关注点（某种业务的实现代码）放到某个模块中去，称之为切面。每个切面影响业务的一种功能，切面的目的就是为了功能增强，将需要增强的方法做成切面，实现对业务的增强，就是面向切面编程。</p><p>AOP实际是GoF设计模式的延续，设计模式追求的是调用者和被调用者之间的解耦，AOP可以说也是这种目标的一种实现。</p><h3 id="作用意图"><a class="markdownIt-Anchor" href="#作用意图"></a> 作用&amp;意图</h3><p>主要用于：日志记录，性能统计，安全控制，事务处理，异常处理等等。</p><p>主要意图：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改 变这些行为的时候不影响业务逻辑的代码。</p><p>目的：将与业务本身无关，却被业务模块所共同调用的功能代码封装成切面，以减少系统的重复代码，降低耦合，提高可扩展性。<br>优势：把多个方法前/后的共同代码抽离出来，使用动态代理机制来控制，先执行抽离出来的代码，再执行每一个真实方法.<br><img src="/img/aop0.png" alt="no aop"><br><img src="/img/aop.png" alt="aop"></p><h3 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h3><p>通过预编译方式，运行期动态代理，实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。<br>注意：AOP不是一种技术，实际上是编程思想。凡是符合AOP思想的技术，都可以看成是AOP的实现</p><h2 id="ios-中的-aop"><a class="markdownIt-Anchor" href="#ios-中的-aop"></a> iOS 中的 AOP</h2><p>利用 Runtime 特性 Method Swizzling 。<br>AOP也可以用来在 debug 模式做一些开发中的应用</p><h3 id="实际应用"><a class="markdownIt-Anchor" href="#实际应用"></a> 实际应用</h3><h4 id="事务拦截安全可变容器"><a class="markdownIt-Anchor" href="#事务拦截安全可变容器"></a> 事务拦截，安全可变容器</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果保证线程安全在每个方法中加锁</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSMutableArray</span> (<span class="title">safe</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="keyword">id</span> obj = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    [obj swizzleMethod:<span class="keyword">@selector</span>(addObject:) withMethod:<span class="keyword">@selector</span>(safeAddObject:)];</span><br><span class="line">    [obj swizzleMethod:<span class="keyword">@selector</span>(objectAtIndex:) withMethod:<span class="keyword">@selector</span>(safeObjectAtIndex:)];</span><br><span class="line">    [obj swizzleMethod:<span class="keyword">@selector</span>(insertObject:atIndex:) withMethod:<span class="keyword">@selector</span>(safeInsertObject:atIndex:)];</span><br><span class="line">    [obj swizzleMethod:<span class="keyword">@selector</span>(removeObjectAtIndex:) withMethod:<span class="keyword">@selector</span>(safeRemoveObjectAtIndex:)];</span><br><span class="line">    [obj swizzleMethod:<span class="keyword">@selector</span>(replaceObjectAtIndex:withObject:) withMethod:<span class="keyword">@selector</span>(safeReplaceObjectAtIndex:withObject:)];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)safeAddObject:(<span class="keyword">id</span>)anObject &#123;</span><br><span class="line">  <span class="keyword">if</span> (anObject) &#123;</span><br><span class="line">    [<span class="keyword">self</span> safeAddObject:anObject];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"obj is nil"</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)safeObjectAtIndex:(<span class="built_in">NSInteger</span>)index &#123;</span><br><span class="line">  <span class="keyword">if</span>(index&lt;[<span class="keyword">self</span> count])&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> safeObjectAtIndex:index];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"index is beyond bounds "</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)swizzleMethod:(SEL)origSelector withMethod:(SEL)newSelector&#123;</span><br><span class="line">  Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">  </span><br><span class="line">  Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, origSelector);</span><br><span class="line">  Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, newSelector);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                                      origSelector,</span><br><span class="line">                                      method_getImplementation(swizzledMethod),</span><br><span class="line">                                      method_getTypeEncoding(swizzledMethod));</span><br><span class="line">  <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    class_replaceMethod(<span class="keyword">class</span>, newSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>safeAddObject</code> 代码看起来很奇怪，像递归不是么。当然不会是递归，因为在 runtime 的时候，函数实现已经被交换了。调用 objectAtIndex: 会调用你实现的 safeObjectAtIndex:，而在 NSMutableArray: 里调用 safeObjectAtIndex: 实际上调用的是原来的 objectAtIndex: 。</p><h2 id="aspects-一个基于objective-c的aop开发框架"><a class="markdownIt-Anchor" href="#aspects-一个基于objective-c的aop开发框架"></a> Aspects 一个基于Objective-c的AOP开发框架</h2><ol><li>怎么 hook block</li><li>如何把hook 简化成了简单接口？</li></ol><p>主要接口：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主要接口</span></span><br><span class="line">+ (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(<span class="keyword">id</span>)block</span><br><span class="line">                                 error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;AspectToken&gt;)aspect_hookSelector:(SEL)selector</span><br><span class="line">                           withOptions:(AspectOptions)options</span><br><span class="line">                            usingBlock:(<span class="keyword">id</span>)block</span><br><span class="line">                                 error:(<span class="built_in">NSError</span> **)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">//业务埋点、日志打印分离</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)</span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">  [<span class="built_in">UIViewController</span> aspect_hookSelector:<span class="keyword">@selector</span>(viewDidAppear:)</span><br><span class="line">                            withOptions:AspectPositionAfter</span><br><span class="line">                             usingBlock:^(<span class="keyword">id</span>&lt;aspectinfo&gt; aspectInfo) &#123;</span><br><span class="line">                                <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>([[aspectInfo instance] <span class="keyword">class</span>]);</span><br><span class="line">                                [Logging logWithEventName:className];</span><br><span class="line">                              &#125; error:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="aspects-源码分析"><a class="markdownIt-Anchor" href="#aspects-源码分析"></a> Aspects 源码分析</h2><p>缕清框架在进行细节源码分析</p><p><img src="/img/Aspects_frame.jpg" alt="frame"></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 设计思想 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDWebImage 源码分析</title>
      <link href="/2017/08/14/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/SDWebImage-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2017/08/14/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/SDWebImage-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/SDWebImage/SDWebImage" target="_blank" rel="noopener">SDWebImage源码</a></p><p>框架架构的主要目的是为了将项目模块化，分层，把代码解耦从而提高代码的复用</p><p>而 <code>SDWebImage</code> 异步下载并支持缓存，图片编码解码的框架</p><p><img src="/img/SDWebImage_Frame.jpg" alt="frame"></p><details><summary>官方提供整体类图</summary><pre><p><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageHighLevelDiagram.jpeg" alt="顶层结构"></p><p><img src="https://raw.githubusercontent.com/SDWebImage/SDWebImage/master/Docs/Diagrams/SDWebImageClassDiagram.png" alt="整体类图"></p></pre></details><h2 id="协调器-manager"><a class="markdownIt-Anchor" href="#协调器-manager"></a> 协调器 Manager</h2><p><img src="/img/SDWebImage_ManagerClass_Diagram.png" alt="SDWebImageManagerClassDiagram"></p><ol><li>Manager 使用中介者模式，用于管理协调各个子模块之间交互</li><li>SDWebImageManager 依赖 SDWebImageOptions<enum>(配置信息)，各个子模块都是聚合关系<ol><li>子模块都是协议！使用协议作为隔离层用于解耦 Manager 跟子模块，Manager 不需要知道具体的子模块到底是什么</li><li>聚合的关系，说明子模块可以独立于 Manager 而独立使用</li></ol></enum></li><li><code>cacheKey(for url: URL?) -&gt; String?</code><ol><li>使用 url 作为cache key，用于读写 image</li></ol></li></ol><p>子模块分析，先分析 imageLoader和 imageCache</p><h2 id="子模块-sdimageloader"><a class="markdownIt-Anchor" href="#子模块-sdimageloader"></a> 子模块 SDImageLoader</h2><p><img src="/img/SDWebImage_LoaderClass_Diagram.png" alt="SDWebImageLoaderClassDiagram"></p><h3 id="sdimageloader-协议"><a class="markdownIt-Anchor" href="#sdimageloader-协议"></a> SDImageLoader 协议</h3><ol><li>SDImageLoader接口具体实现：<ol><li><code>SDImageLoadersManager</code> 组合模式，内部维护 <code>Array&lt;SDImageLoader&gt;</code></li><li><code>SDWebImageDownloader</code> 具体image 下载逻辑实现</li></ol></li><li>SDImageLoader接口依赖 <code>SDWebImageDownloaderOptions</code>，配置信息跟逻辑拆分，聚合配置信息，避免逻辑方法调用过程中配置参数零散</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">SDImageLoader</span> : <span class="title">NSObjectProtocol</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断 url 的有效性，如果无效会标记 image 加载失败，有效就会调用requestImageWithURL:options:context:progress:completed:</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">canRequestImage</span><span class="params">(<span class="keyword">for</span> url: URL?)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">根据 url 下载 image data </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">url：image url，有可能是 http url</span></span><br><span class="line"><span class="comment">options: 针对 request 的可选配置信息</span></span><br><span class="line"><span class="comment">context: SDWebImageContextOption，用于处理具体的changes or  precess</span></span><br><span class="line"><span class="comment">progressBlock: image 下载的回调，get进度信息。P.S. 后台队列</span></span><br><span class="line"><span class="comment">completedBlock: 下载完成回调</span></span><br><span class="line"><span class="comment">return: request 的 Operation，用户可以自己 cancel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">requestImage</span><span class="params">(with url: URL?,</span></span></span><br><span class="line"><span class="function"><span class="params">                    options: SDWebImageOptions = [],</span></span></span><br><span class="line"><span class="function"><span class="params">                    context: [SDWebImageContextOption : <span class="keyword">Any</span>]?,</span></span></span><br><span class="line"><span class="function"><span class="params">                    progress progressBlock: SDImageLoaderProgressBlock?,</span></span></span><br><span class="line"><span class="function"><span class="params">                    completed completedBlock: SDImageLoaderCompletedBlock? = <span class="literal">nil</span>)</span></span></span><br><span class="line">                    -&gt; <span class="type">SDWebImageOperation?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">来自图像加载器的错误是否应该标记为不可恢的。</span></span><br><span class="line"><span class="comment">如果返回 true，失败的 url放进黑名单 ，不使用`SDWebImageRetryFailed`</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">error: url 加载的 error，来自于`requestImageWithURL:options:context:progress:completed:` completedBlock's error.</span></span><br><span class="line"><span class="comment">return: 是否把url 放入黑名单</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">shouldBlockFailedURL</span><span class="params">(with url: URL, error: Error)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q:在想为什么协议只暴露三个接口？？</p><p>一些思考</p><ul><li>图片请求的并发量</li><li>请求超时策略</li><li>请求优先级</li></ul><h3 id="sdwebimagedownloaderoptions"><a class="markdownIt-Anchor" href="#sdwebimagedownloaderoptions"></a> SDWebImageDownloaderOptions</h3><p>位枚举，下载器功能自定义配置，用户可更改配置改变 Downloader 中的行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDWebImageDownloaderOptions</span> : <span class="title">OptionSet</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 下载任务的 priority (Put the download in the low queue priority and task priority.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> lowPriority: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 边下载边显示(This flag enables progressive download, the image is displayed progressively during download as a browser would do.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> progressiveLoad: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否使用 urlCache，默认是不使用 (By default, request prevent the use of NSURLCache. With this flag, NSURLCache is used with default policies.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> useNSURLCache: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果imageData 从 URLCache 中读取，complete block 会返回 nil，error code 是 `SDWebImageErrorCacheNotModified`, 这个标记应该跟  SDWebImageDownloaderUseNSURLCache 一起使用 (Call completion block with nil image/imageData if the image was read from NSURLCache And the error code is `SDWebImageErrorCacheNotModified` This flag should be combined with `SDWebImageDownloaderUseNSURLCache`.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> ignoreCachedResponse: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在 iOS 4+ 版本中，app 进入后台继续下载image，需要想系统请求而外的后台时间来让 Request 完成。如果请求时间耗尽，Operation 会被 cancel (In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for extra time in background to let the request finish. If the background task expires the operation will be cancelled.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> continueInBackground: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理村粗在 NSHTTPCookieStore 的 cookies (Handles cookies stored in NSHTTPCookieStore by setting NSMutableURLRequest.HTTPShouldHandleCookies = YES;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> handleCookies: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 允许不可信的 SSL 认证，主要用于测试(Enable to allow untrusted SSL certificates. Useful for testing purposes. Use with caution in production.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> allowInvalidSSLCertificates: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下载优先级，将下载 task 放在 高 priorty 队列中 (Put the download in the high queue priority and task priority.）</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> highPriority: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码下采样，默认情况，image解码应该跟原始尺寸一致，该 flag 在 iOS中根据设备内存来下采样 image size，如果设置 SDWebImageDownloaderAvoidDecodeImage这个 flag 会失效，如果设置了 SDWebImageDownloaderProgressiveLoad，这个 flag会被忽视(By default, images are decoded respecting their original size. On iOS, this flag will scale down the images to a size compatible with the constrained memory of devices. This flag take no effect if `SDWebImageDownloaderAvoidDecodeImage` is set. And it will be ignored if `SDWebImageDownloaderProgressiveLoad` is set.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> scaleDownLargeImages: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解码，默认情况，在查询 image cache or download from the network的时候，使用后台任务解码 image(在使用UIImage的时候 Core Animation是在 main thread 解码image的)。后台解码会增加内存，该flag 标记解码过程由用户自己处理 (By default, we will decode the image in the background during cache query and download from the network. This can help to improve performance because when rendering image on the screen, it need to be firstly decoded. But this happen on the main queue by Core Animation. However, this process may increase the memory usage as well. If you are experiencing a issue due to excessive memory consumption, This flag can prevent decode the image.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> avoidDecodeImage: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// gif image 解码，该 flag 标记框架只解码一帧 (By default, we decode the animated image. This flag can force decode the first frame only and produce the static image.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> decodeFirstFrameOnly: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//gif image 解码，该flag 标记框架解码所有帧 (By default, for `SDAnimatedImage`, we decode the animated image frame during rendering to reduce memory usage. This flag actually trigger `preloadAllAnimatedImageFrames = YES` after image load from network)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> preloadAllFrames: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//gif image 解码, 默认情况当你使用 `SDWebImageContextAnimatedImageClass` 的时候，我们依然使用 UIImage，当 cache 命中，或者image 解码器不可用，作为一个 fallback 方案，使用这个 option，可以确保使用你自己提供的 class来生成 image，如果失败会产生 `SDWebImageErrorBadImageData`，注意这个 flag 跟 `SDWebImageDownloaderDecodeFirstFrameOnly` 不兼容 (By default, when you use `SDWebImageContextAnimatedImageClass` context option (like using `SDAnimatedImageView` which designed to use `SDAnimatedImage`), we may still use `UIImage` when the memory cache hit, or image decoder is not available, to behave as a fallback solution. Using this option, can ensure we always produce image with your provided class. If failed, a error with code `SDWebImageErrorBadImageData` will been used. Note this options is not compatible with `SDWebImageDownloaderDecodeFirstFrameOnly`, which always produce a UIImage/NSImage.)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">var</span> matchAnimatedImageClass: <span class="type">SDWebImageDownloaderOptions</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="sdwebimagecontext"><a class="markdownIt-Anchor" href="#sdwebimagecontext"></a> SDWebImageContext</h3><p>根据字典拿到辅助功能对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSString</span> * SDWebImageContextOption <span class="built_in">NS_EXTENSIBLE_STRING_ENUM</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NSDictionary</span>&lt;SDWebImageContextOption, <span class="keyword">id</span>&gt; SDWebImageContext;</span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextSetImageOperationKey = <span class="string">@"setImageOperationKey"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextCustomManager = <span class="string">@"customManager"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImageCache = <span class="string">@"imageCache"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImageLoader = <span class="string">@"imageLoader"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImageCoder = <span class="string">@"imageCoder"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImageTransformer = <span class="string">@"imageTransformer"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImageScaleFactor = <span class="string">@"imageScaleFactor"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImagePreserveAspectRatio = <span class="string">@"imagePreserveAspectRatio"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextImageThumbnailPixelSize = <span class="string">@"imageThumbnailPixelSize"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextQueryCacheType = <span class="string">@"queryCacheType"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextStoreCacheType = <span class="string">@"storeCacheType"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextOriginalQueryCacheType = <span class="string">@"originalQueryCacheType"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextOriginalStoreCacheType = <span class="string">@"originalStoreCacheType"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextAnimatedImageClass = <span class="string">@"animatedImageClass"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextDownloadRequestModifier = <span class="string">@"downloadRequestModifier"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextDownloadResponseModifier = <span class="string">@"downloadResponseModifier"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextDownloadDecryptor = <span class="string">@"downloadDecryptor"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextCacheKeyFilter = <span class="string">@"cacheKeyFilter"</span>;</span><br><span class="line">SDWebImageContextOption <span class="keyword">const</span> SDWebImageContextCacheSerializer = <span class="string">@"cacheSerializer"</span>;</span><br></pre></td></tr></table></figure><p>为什么使用字典而不是在创建一个类呢？<br>可能这些类or配置信息都不重要，使用字典管理</p><h3 id="具体下载逻辑-sdwebimagedownloader"><a class="markdownIt-Anchor" href="#具体下载逻辑-sdwebimagedownloader"></a> 具体下载逻辑 SDWebImageDownloader</h3><p><img src="/img/SDWebImage_download.jpg" alt="downloader"></p><ol><li>依赖 <code>SDWebImageDownloadToken</code> (关联具体的 downloadOperation)</li><li>依赖 <code>SDWebImageDownloadOptions</code></li><li>依赖 <code>SDWebImageDownloaderOperation</code> (内部封装 downloadTask，coderQueue)</li><li>依赖 <code>SDWebImageDownloaderConfig</code> (下载配置信息)</li><li>聚合 <code>SDWebImageDownloaderRequestModifier</code> (在请求前修改 request)</li><li>聚合 <code>SDWebImageDownloaderResponsetModifier</code> (在响应后修改 response)</li><li>聚合 <code>SDWebImageDownloaderDecryptor</code></li><li>聚合 <code>NSURLSessionConfiguration</code> (下载operation 配置的 session 环境)</li></ol><p>私有属性，维护下载任务</p><ol><li>URLSession</li><li>OperationQueue，URLOperations</li></ol><p><img src="/img/SDWebImage_downloader_class.jpg" alt="downloader_class"></p><p>大致过程</p><ol><li>SDWebImageDownloader.init<ol><li>配置 downloader config</li><li>downloadQueue 并发 default 6 thread</li><li>配置 httpHeader</li><li>配置 urlSession</li></ol></li><li>url -&gt; SDWebImageDownloadToken -&gt; SDWebImageDownloaderOperation<ol><li>配置 request</li><li>根据 context 配置 SDWebImageDownloaderOperation<ol><li>operation.start 中封装 dataTask</li><li>配置 coderQueue(serial) SDWebImageDownloaderOperation taskDelegate receive data 回调中边下载data 边解码</li><li>dataTask 结束后调用 operation 的 completeBlock 将 imageData 交给用户</li></ol></li></ol></li></ol><h2 id="子模块-sdimagecache"><a class="markdownIt-Anchor" href="#子模块-sdimagecache"></a> 子模块 SDImageCache</h2><p>内存：当前程序运行空间，空间小，数据易丢失，读取快<br>程序运行后，内存分为 5 个区：栈区，堆区，全局区，常量区，代码区<br>内存缓存设计一般使用：栈区，堆区</p><p>磁盘：空间大、可持久、读取速度慢</p><p>iOS 主要提供4种磁盘存储方式：</p><ul><li>NSKeyedArchiver：归档的形式来保存数据，只能一次性归档保存以及一次性解压。所以只能针对小量数据，如果想改动数据的某一小部分，需要解压整个数据或者归档整个数据。</li><li>NSUserDefaults：用来保存应用程序设置和属性、用户保存的数据。存储的数据类型少，包括：NSData、NSString、NSNumber、NSDate、NSArray、 NSDictionary</li><li>plist：userDefault就是一个 plist</li><li>FileManager 相关 write 写入方式：永久保存在磁盘中</li><li>数据库</li></ul><p>App 的沙盒根目录结构：</p><ol><li>Documents</li><li>Library</li><li>temp</li></ol><p>大体结构，在网络层的 operation 中 coderQueue(serial) 负责解码 image</p><p><img src="/img/SDWebImage_cache_frame.jpg" alt="cache"></p><p>cache 读取方法：使用url的单向 hash值来读写<br><img src="/img/SDWebImage_cache_query.jpg" alt="cache"></p><ol><li>依赖 SDImageCacheOptions</li><li>聚合 SDMemoryCache</li><li>聚合 SDDiskCache</li><li>聚合 SDImageCacheConfig</li><li>使用组合模式 SDImageCachesManager 做分支节点，SDImageCache 做叶子节点</li><li>SDImageCacheManager 依赖 SDImageCachesManagerOperationPolicy(用于处理多个 cache)</li></ol><p><img src="/img/SDWebImage_CacheClass_Diagram.png" alt="SDWebImageCacheClassDiagram"></p><p>计算机组成原理：层级存储器设计思想</p><h3 id="sdmemorycache"><a class="markdownIt-Anchor" href="#sdmemorycache"></a> SDMemoryCache</h3><p>内存管理设计<br>内存空间(因为是内存，使用什么数据结构？)<br>3个队列：<br>50 * 10 kb<br>20 * 100 kb<br>10 * 100+kb</p><p>队列淘汰策略<br>FIFO 算法<br>LRU 算法（检查时机）</p><p>内部使用NSCache 实现缓存<br>NSMapTable 作为弱引用缓存</p><h3 id="sddiskcache"><a class="markdownIt-Anchor" href="#sddiskcache"></a> SDDiskCache</h3><p>磁盘管理设计<br>存储方式<br>空间大小限制<br>淘汰策略</p><p>根据文件属性删减文件</p><ul><li>(void)removeExpiredData</li></ul><h2 id="解码"><a class="markdownIt-Anchor" href="#解码"></a> 解码</h2><ul><li>使用策略模式针对不同图片解码</li><li>解码时机：<ul><li>图片数据下载完成</li><li>磁盘读取后</li></ul></li></ul><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> Net </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计思想 </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BlocksKit 源码阅读</title>
      <link href="/2017/08/06/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/BlocksKit-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
      <url>/2017/08/06/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/BlocksKit-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><p>Blocks 是 C 和 Objective-C 的魔法，它使得编码更快，更不用说在多线程开发中。<br>BlocksKit希望通过消除一些烦人的代码，通过 block 优化开发效率</p><ol><li>为集合类型添加 bk_each: 等方法对集合中元素快速遍历</li><li>block 对 NSObject 的封装<ol><li>AssociatedObject, block 封装关联对象</li><li>BlockExecution, 封装块执行</li><li>封装 KVO，使 NSObject 自动销毁</li></ol></li><li>为 UIView 对象添加 bk_whenTapped: 等方法快速添加手势</li><li>使用 block 替换 delegate，涉及到核心模块 DynamicDelegate</li></ol><p>自己想想如果是你，你会用什么方式实现上面几个问题</p><h2 id="block-封装集合操作"><a class="markdownIt-Anchor" href="#block-封装集合操作"></a> block 封装集合操作</h2><ol><li><code>bk_each:</code></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[@[@<span class="number">1</span>,@<span class="number">2</span>,@<span class="number">3</span>] bk_each:^(<span class="keyword">id</span> obj) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>，obj);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bk_each:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">  [<span class="keyword">self</span> enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj，<span class="built_in">NSUInteger</span> idx，<span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    block(obj);</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，对于集合函数式方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bk_each:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="keyword">void</span>)bk_apply:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="keyword">id</span>)bk_match:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)bk_select:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)bk_reject:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)bk_map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="keyword">id</span>)bk_reduce:(<span class="keyword">id</span>)initial withBlock:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> sum，<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)bk_reduceInteger:(<span class="built_in">NSInteger</span>)initial withBlock:(<span class="built_in">NSInteger</span>(^)(<span class="built_in">NSInteger</span> result，<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">CGFloat</span>)bk_reduceFloat:(<span class="built_in">CGFloat</span>)inital withBlock:(<span class="built_in">CGFloat</span>(^)(<span class="built_in">CGFloat</span> result，<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_any:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_none:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_all:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)bk_corresponds:(<span class="built_in">NSArray</span> *)list withBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> obj1，<span class="keyword">id</span> obj2))block;</span><br></pre></td></tr></table></figure><h2 id="nsobject-上的魔法封装"><a class="markdownIt-Anchor" href="#nsobject-上的魔法封装"></a> NSObject 上的魔法封装</h2><ol><li>AssociatedObject</li><li>BlockExecution</li><li>BlockObservation</li></ol><h3 id="associatedobject"><a class="markdownIt-Anchor" href="#associatedobject"></a> AssociatedObject</h3><p><code>NSObject+BKAssociatedObjects.h</code></p><p>在 runtime 时为对象添加 AssociatedObject 需要给对象</p><p>搞一个分类</p><ul><li>添加 getter setter 方法</li><li>添加 dynamic 属性</li></ul><p>使用 BlocksKit</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSObject</span> *test = [<span class="built_in">NSObject</span> new];</span><br><span class="line">[test bk_associateValue:<span class="string">@"Draveness"</span> withKey:<span class="string">@"name"</span>];<span class="comment">// 添加</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>，[test bk_associatedValueForKey:<span class="string">@"name"</span>]);<span class="comment">// 获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line">- (<span class="keyword">void</span>)bk_associateValue:(<span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key &#123;</span><br><span class="line">  objc_setAssociatedObject(<span class="keyword">self</span>，key，value，OBJC_ASSOCIATION_RETAIN_NONATOMIC);<span class="comment">// retain</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>associated object policy</summary><pre><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// associated object 的策略中没有 weak</span></span><br><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t，objc_AssociationPolicy) &#123;</span><br><span class="line">  OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>，      <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">  OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>，<span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is not made atomically. */</span></span><br><span class="line">  OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>，  <span class="comment">/**&lt; Specifies that the associated object is copied. The association is not made atomically. */</span></span><br><span class="line">  OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>，    <span class="comment">/**&lt; Specifies a strong reference to the associated object. The association is made atomically. */</span></span><br><span class="line">  OBJC_ASSOCIATION_COPY = <span class="number">01403</span>      <span class="comment">/**&lt; Specifies that the associated object is copied. The association is made atomically. */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></pre></details><p>BlocksKit 通过另一种方式实现了『弱属性』：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bk_weaklyAssociateValue:(__autoreleasing <span class="keyword">id</span>)value withKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key &#123;</span><br><span class="line">  _BKWeakAssociatedObject *assoc = objc_getAssociatedObject(<span class="keyword">self</span>，key);</span><br><span class="line">  <span class="keyword">if</span> (!assoc) &#123;</span><br><span class="line">    assoc = [_BKWeakAssociatedObject new];</span><br><span class="line">    [<span class="keyword">self</span> bk_associateValue:assoc withKey:key];</span><br><span class="line">  &#125;</span><br><span class="line">  assoc.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_BKWeakAssociatedObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">weak</span>) <span class="keyword">id</span> value;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_BKWeakAssociatedObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>添加属性的时候：<br><code>obj.key = weakObj</code> ==&gt; <code>weakObj.value = value</code><br><code>obj -/-&gt; weakObj ——&gt; value</code></p><p>在这里先获取了一个 <code>_BKWeakAssociatedObject</code> 对象 assoc，然后更新这个对象的属性 value。<br>因为直接使用 <code>AssociatedObject</code> 不能为对象添加弱属性，所以在这里添加了一个对象，然后让这个对象持有一个弱属性：</p><p>对于 getter 方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)bk_associatedValueForKey:(<span class="keyword">const</span> <span class="keyword">void</span> *)key &#123;</span><br><span class="line">  <span class="keyword">id</span> value = objc_getAssociatedObject(<span class="keyword">self</span>，key);</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; [value isKindOfClass:[_BKWeakAssociatedObject <span class="keyword">class</span>]]) &#123;</span><br><span class="line">    <span class="keyword">return</span> [(_BKWeakAssociatedObject *)value value];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>obj.weakObj.value</code></p><h3 id="blockexecution"><a class="markdownIt-Anchor" href="#blockexecution"></a> BlockExecution</h3><p><code>NSObject+BKBlockExecution.h</code></p><p>在任意对象上执行 block<br>通过这个类提供的一些接口，可以在任意对象上快速执行线程安全、异步的 block，而且这些 block 也可以在执行之前取消。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>，<span class="built_in">NSCopying</span>&gt;)bk_performOnQueue:(<span class="built_in">dispatch_queue_t</span>)queue afterDelay:(<span class="built_in">NSTimeInterval</span>)delay usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> obj))block &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line">  <span class="keyword">return</span> BKDispatchCancellableBlock(queue，delay，^&#123;</span><br><span class="line">    block(<span class="keyword">self</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中最关键的也就是它返回了一个可以取消的 <code>block</code>，而这个 <code>block</code> 就是用静态函数 BKDispatchCancellableBlock 生成的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>，<span class="built_in">NSCopying</span>&gt; BKDispatchCancellableBlock(<span class="built_in">dispatch_queue_t</span> queue，<span class="built_in">NSTimeInterval</span> delay，<span class="keyword">void</span>(^block)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">  dispatch_time_t time = BKTimeDelay(delay);</span><br><span class="line">  </span><br><span class="line"><span class="meta">#if DISPATCH_CANCELLATION_SUPPORTED</span></span><br><span class="line">  <span class="keyword">if</span> (BKSupportsDispatchCancellation()) &#123;</span><br><span class="line">    dispatch_block_t ret = dispatch_block_create(<span class="number">0</span>，block);</span><br><span class="line">    dispatch_after(time，queue，ret);</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  </span><br><span class="line">  __block <span class="built_in">BOOL</span> cancelled = <span class="literal">NO</span>;</span><br><span class="line">  <span class="keyword">void</span> (^wrapper)(<span class="built_in">BOOL</span>) = ^(<span class="built_in">BOOL</span> cancel) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cancel) &#123;</span><br><span class="line">      cancelled = <span class="literal">YES</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cancelled) block();</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  dispatch_after(time，queue，^&#123;</span><br><span class="line">    wrapper(<span class="literal">NO</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> wrapper; <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BKSupportsDispatchCancellation</code> 来判断当前平台和版本是否支持使用 GCD 取消 block，当然一般都是支持的：</p><ul><li>函数返回的是 YES，那么在 <code>block</code> 被派发到指定队列之后就会返回这个 <code>dispatch_block_t</code> 类型的 <code>block</code></li><li>函数返回的是 NO，那么就会就会手动包装一个可以取消的 <code>wrapper</code></li></ul><p>上面这部分代码就先创建一个 <code>wrapper</code> block，然后派发到指定队列，派发到指定队列的这个 block 是一定会执行的，但是怎么取消这个 block 呢？</p><p>如果当前 block 没有执行，我们在外面调用一次 <code>wrapper(YES)</code> 时，block 内部的 <code>cancelled</code> 变量就会被设置为 YES，所以 block 就不会执行。</p><ul><li><code>dispatch_after --- cancelled = NO</code></li><li><code>wrapper(YES) --- cancelled = YES</code></li><li><code>wrapper(NO) --- cancelled = YES</code> block 不会执行</li></ul><p>这是实现取消的关键部分：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)bk_cancelBlock:(<span class="keyword">id</span> &lt;<span class="built_in">NSObject</span>，<span class="built_in">NSCopying</span>&gt;)block &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if DISPATCH_CANCELLATION_SUPPORTED</span></span><br><span class="line">  <span class="keyword">if</span> (BKSupportsDispatchCancellation()) &#123;</span><br><span class="line">    dispatch_block_cancel((dispatch_block_t)block);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^wrapper)(<span class="built_in">BOOL</span>) = (<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span>))block;</span><br><span class="line">  wrapper(<span class="literal">YES</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GCD 支持取消 block，那么直接调用 dispatch_block_cancel 函数取消 block</li><li>GCD 不支持取消 block 那么调用一次 wrapper(YES)</li></ul><h3 id="blockobservation"><a class="markdownIt-Anchor" href="#blockobservation"></a> BlockObservation</h3><p>使用 block 封装 的Observation，在添加 observer以后会自动remove。</p><p><code>NSObject+BKBlockObservation.h</code></p><p><code>BlocksKit</code> 对 KVO 的封装由两部分组成：</p><ul><li><code>NSObject+BKBlockObservation</code> 的分类负责提供便利方法</li><li>私有类 <code>_BKObserver</code> 具体实现原生的 KVO 功能</li></ul><p>主要看点是，BlocksKit 是如何自动remove 掉observer的。<br><strong>核心技巧：使用method swizzle 替换 <code>dealloc</code> 方法</strong></p><p>在 <code>NSObject+BKBlockObservation</code> 分类中的主要接口:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bk_addObserverForKeyPaths:(<span class="built_in">NSArray</span> *)keyPaths identifier:(<span class="built_in">NSString</span> *)identifier options:(<span class="built_in">NSKeyValueObservingOptions</span>)options context:(BKObserverContext)context task:(<span class="keyword">id</span>)task &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 得到全局 swizzle dealloc 的class</span></span><br><span class="line">  Class classToSwizzle = <span class="keyword">self</span>.class;</span><br><span class="line">  <span class="built_in">NSMutableSet</span> *classes = <span class="keyword">self</span>.class.bk_observedClassesHash;</span><br><span class="line">  <span class="keyword">@synchronized</span> (classes) &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *className = <span class="built_in">NSStringFromClass</span>(classToSwizzle);</span><br><span class="line">    <span class="keyword">if</span> (![classes containsObject:className]) &#123;</span><br><span class="line">      SEL deallocSelector = sel_registerName(<span class="string">"dealloc"</span>);</span><br><span class="line"></span><br><span class="line">      __block <span class="keyword">void</span> (*originalDealloc)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>, SEL) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//1.1. 初始化新的 dealloc 方法</span></span><br><span class="line">      <span class="keyword">id</span> newDealloc = ^(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> objSelf) &#123;</span><br><span class="line">        <span class="comment">//在方法 dealloc 之前移除所有 observer</span></span><br><span class="line">        [objSelf bk_removeAllBlockObservers];</span><br><span class="line">        <span class="comment">// 如果子类没有 dealloc 就找父类的 dealloc 方法</span></span><br><span class="line">        <span class="keyword">if</span> (originalDealloc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="keyword">struct</span> objc_super superInfo = &#123;</span><br><span class="line">            .receiver = objSelf,</span><br><span class="line">            .super_class = class_getSuperclass(classToSwizzle)</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">void</span> (*msgSend)(<span class="keyword">struct</span> objc_super *, SEL) = (__typeof__(msgSend))objc_msgSendSuper;</span><br><span class="line">          msgSend(&amp;superInfo, deallocSelector);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          originalDealloc(objSelf, deallocSelector);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">//将 block 转成 imp</span></span><br><span class="line">      IMP newDeallocIMP = imp_implementationWithBlock(newDealloc);</span><br><span class="line">      <span class="comment">// 1.2. 方法替换</span></span><br><span class="line">      <span class="keyword">if</span> (!class_addMethod(classToSwizzle, deallocSelector, newDeallocIMP, <span class="string">"v@:"</span>)) &#123;</span><br><span class="line">        <span class="comment">// The class already contains a method implementation.</span></span><br><span class="line">        Method deallocMethod = class_getInstanceMethod(classToSwizzle, deallocSelector);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to store original implementation before setting new implementation</span></span><br><span class="line">        <span class="comment">// in case method is called at the time of setting.</span></span><br><span class="line">        originalDealloc = (<span class="keyword">void</span>(*)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>, SEL))method_getImplementation(deallocMethod);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We need to store original implementation again, in case it just changed.</span></span><br><span class="line">        originalDealloc = (<span class="keyword">void</span>(*)(__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span>, SEL))method_setImplementation(deallocMethod, newDeallocIMP);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 1.3替换过 dealloc 的类加到全局集合中</span></span><br><span class="line">      [classes addObject:className];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 封装observer 上下文</span></span><br><span class="line">  <span class="built_in">NSMutableDictionary</span> *dict;</span><br><span class="line">  _BKObserver *observer = [[_BKObserver alloc] initWithObservee:<span class="keyword">self</span> keyPaths:keyPaths context:context task:task];</span><br><span class="line">  [observer startObservingWithOptions:options];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">    dict = [<span class="keyword">self</span> bk_observerBlocks];<span class="comment">// 使用关联对象管理注册 observer</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dict == <span class="literal">nil</span>) &#123;</span><br><span class="line">      dict = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">      [<span class="keyword">self</span> bk_setObserverBlocks:dict];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  dict[identifier] = observer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NSObject 类方法，管理swizzled classes</span></span><br><span class="line">+ (<span class="built_in">NSMutableSet</span> *)bk_observedClassesHash&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">NSMutableSet</span> *swizzledClasses = <span class="literal">nil</span>;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    swizzledClasses = [[<span class="built_in">NSMutableSet</span> alloc] init];</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> swizzledClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述代码BlocksKit 主要做了两件事 <code>NSObject+BKBlockObservation.h：</code></p><ol><li>重写class 的 dealloc 方法<ol><li>NSObject 分类对象管理更换 dealloc 的 classes</li><li><code>newDealloc</code> 中处理 removeObserver</li></ol></li><li>管理 _observer（封装KVO 上下文）<ol><li>给 class 添加关联对象(一个 dict)，用于管理注册的 _observer</li><li><code>_BKObserver</code> 封装 KVO 上下文</li></ol></li></ol><h2 id="改造-uikit"><a class="markdownIt-Anchor" href="#改造-uikit"></a> 改造 UIKit</h2><ul><li>UIGestureRecongizer + UIBarButtonItem + UIControl</li><li>UIView</li></ul><h3 id="改造-uigesturerecongizeruibarbuttonitem-和-uicontrol"><a class="markdownIt-Anchor" href="#改造-uigesturerecongizeruibarbuttonitem-和-uicontrol"></a> 改造 UIGestureRecongizer，UIBarButtonItem 和 UIControl</h3><p>先来看一个 UITapGestureRecognizer 使用的例子</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UITapGestureRecognizer</span> *singleTap = [<span class="built_in">UITapGestureRecognizer</span> bk_recognizerWithHandler:^(<span class="keyword">id</span> sender) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Single tap."</span>);</span><br><span class="line">&#125; delay:<span class="number">0.18</span>];</span><br><span class="line">[<span class="keyword">self</span> addGestureRecognizer:singleTap];</span><br></pre></td></tr></table></figure><p>代码中的 <code>bk_recognizerWithHandler:delay:</code> 方法在最后都会调用初始化方法 <code>bk_initWithHandler:delay:</code> 生成一个 <code>UIGestureRecongizer</code> 的实例</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)bk_initWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIGestureRecognizer</span> *sender，<span class="built_in">UIGestureRecognizerState</span> state，<span class="built_in">CGPoint</span> location))block delay:(<span class="built_in">NSTimeInterval</span>)delay &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">self</span> initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(bk_handleAction:)];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.bk_handler = block;</span><br><span class="line">  <span class="keyword">self</span>.bk_handlerDelay = delay;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它会在这个方法中传入 target 和 selector。 其中 target 就是 self，而 selector 也会在这个分类中实现：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bk_handleAction:(<span class="built_in">UIGestureRecognizer</span> *)recognizer &#123;</span><br><span class="line">  <span class="keyword">void</span> (^handler)(<span class="built_in">UIGestureRecognizer</span> *sender，<span class="built_in">UIGestureRecognizerState</span> state，<span class="built_in">CGPoint</span> location) = recognizer.bk_handler;</span><br><span class="line">  <span class="keyword">if</span> (!handler) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">NSTimeInterval</span> delay = <span class="keyword">self</span>.bk_handlerDelay;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#1: 封装 block 并控制 block 是否可以执行</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.bk_shouldHandleAction = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">NSObject</span> bk_performAfterDelay:delay usingBlock:block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为在初始化方法 <code>bk_initWithHandler:delay:</code> 中保存了当前手势的 bk_handler，所以直接调用在 Block Execution 一节中提到过的 <code>bk_performAfterDelay:usingBlock:</code> 方法，将 block 派发到指定的队列中，最终完成对 block 的调用。</p><p>封装 block 并控制 block 是否可以执行<br>这部分代码和前面的部分有些相似，因为这里也用到了一个属性 <code>bk_shouldHandleAction</code> 来控制 block 是否会被执行：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span> location = [<span class="keyword">self</span> locationInView:<span class="keyword">self</span>.view];</span><br><span class="line"><span class="keyword">void</span> (^block)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>.bk_shouldHandleAction) <span class="keyword">return</span>;</span><br><span class="line">  handler(<span class="keyword">self</span>，<span class="keyword">self</span>.state，location);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样 <code>UIBarButtonItem</code> 和 <code>UIControl</code> 也是用了几乎相同的机制，把 target 设置为 self，让后在分类的方法中调用指定的 block。</p><h4 id="uicontrolwrapper"><a class="markdownIt-Anchor" href="#uicontrolwrapper"></a> UIControlWrapper</h4><p>稍微有些不同的是 UIControl。因为 <code>UIControl</code> 有多种 <code>UIControlEvents，所以使用另一个类</code> <code>BKControlWrapper</code> 来封装 <code>handler</code> 和 <code>controlEvents</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">UIControlEvents</span> controlEvents;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>) <span class="keyword">void</span> (^handler)(<span class="keyword">id</span> sender);</span><br></pre></td></tr></table></figure><p>其中 UIControlWrapper 对象以 {controlEvents，wrapper}的形式作为 UIControl 的属性存入字典。</p><h3 id="改造-uiview"><a class="markdownIt-Anchor" href="#改造-uiview"></a> 改造 UIView</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)bk_whenTouches:(<span class="built_in">NSUInteger</span>)numberOfTouches tapped:(<span class="built_in">NSUInteger</span>)numberOfTaps handler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">  <span class="keyword">if</span> (!block) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">UITapGestureRecognizer</span> *gesture = [<span class="built_in">UITapGestureRecognizer</span> bk_recognizerWithHandler:^(<span class="built_in">UIGestureRecognizer</span> *sender，<span class="built_in">UIGestureRecognizerState</span> state，<span class="built_in">CGPoint</span> location) &#123;</span><br><span class="line">    <span class="keyword">if</span> (state == <span class="built_in">UIGestureRecognizerStateRecognized</span>) block();</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  gesture.numberOfTouchesRequired = numberOfTouches;</span><br><span class="line">  gesture.numberOfTapsRequired = numberOfTaps;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span>.gestureRecognizers enumerateObjectsUsingBlock:^(<span class="keyword">id</span> obj，<span class="built_in">NSUInteger</span> idx，<span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> (![obj isKindOfClass:[<span class="built_in">UITapGestureRecognizer</span> <span class="keyword">class</span>]]) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">UITapGestureRecognizer</span> *tap = obj;</span><br><span class="line">    <span class="built_in">BOOL</span> rightTouches = (tap.numberOfTouchesRequired == numberOfTouches);</span><br><span class="line">    <span class="built_in">BOOL</span> rightTaps = (tap.numberOfTapsRequired == numberOfTaps);</span><br><span class="line">    <span class="keyword">if</span> (rightTouches &amp;&amp; rightTaps) &#123;</span><br><span class="line">      [gesture requireGestureRecognizerToFail:tap];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> addGestureRecognizer:gesture];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UIView 分类只有这一个核心方法，其它的方法都是向这个方法传入不同的参数，这里需要注意的就是。它会遍历所有的 <code>gestureRecognizers</code>，然后把对所有有冲突的手势调用 <code>requireGestureRecognizerToFail:</code> 方法，保证添加的手势能够正常的执行。</p><h2 id="动态代理"><a class="markdownIt-Anchor" href="#动态代理"></a> 动态代理</h2><p>思考代理模式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> -- <span class="title">protocol</span> <span class="title">DelegateA</span></span></span><br><span class="line"><span class="class"><span class="title">a</span>.<span class="title">delegate</span> = <span class="title">DelegateA</span>()</span></span><br></pre></td></tr></table></figure><p>实现 DelegateA 接口方法</p><p>BlocksKit 要改造成</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a.delegateBlock0 = ^&#123;</span><br><span class="line">&#125;</span><br><span class="line">a.delegateBlock1 = ^<span class="keyword">id</span>(<span class="keyword">int</span> a)&#123;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>block：</p><ol><li>不需要设置代理</li><li>不需要实现接口</li><li>让对象自己实现代理方法</li></ol><p>动态代理这部分可以说是 <code>BlocksKit</code> 的精华。<strong>它使用 <code>block</code> 属性替换 UIKit 中的所有能够通过代理完成的事件</strong>，</p><p><code>UIImagePickerController+BlocksKit.h</code> 代码量少, 分析如何给 UIKit 控件添加 BlocksKit的</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 自定义delegate class 继承 A2DynamicDelegate，并遵从 UIImagePickerControllerDelegate 方法</span></span><br><span class="line"><span class="meta">#pragma mark Custom delegate</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A2DynamicUIImagePickerControllerDelegate</span> : <span class="title">A2DynamicDelegate</span> &lt;<span class="title">UIImagePickerControllerDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A2DynamicUIImagePickerControllerDelegate</span></span></span><br><span class="line"><span class="comment">// 实现 UIImagePickerControllerDelegate 方法，内部调用 block</span></span><br><span class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info &#123;</span><br><span class="line">  <span class="keyword">id</span> realDelegate = <span class="keyword">self</span>.realDelegate;</span><br><span class="line">  <span class="keyword">if</span> (realDelegate &amp;&amp; [realDelegate respondsToSelector:<span class="keyword">@selector</span>(imagePickerController:didFinishPickingMediaWithInfo:)])</span><br><span class="line">    [realDelegate imagePickerController:picker didFinishPickingMediaWithInfo:info];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^block)(<span class="built_in">UIImagePickerController</span> *, <span class="built_in">NSDictionary</span> *) = [<span class="keyword">self</span> blockImplementationForMethod:_cmd];</span><br><span class="line">  <span class="keyword">if</span> (block) block(picker, info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)imagePickerControllerDidCancel:(<span class="built_in">UIImagePickerController</span> *)picker &#123;</span><br><span class="line">  <span class="keyword">id</span> realDelegate = <span class="keyword">self</span>.realDelegate;</span><br><span class="line">  <span class="keyword">if</span> (realDelegate &amp;&amp; [realDelegate respondsToSelector:<span class="keyword">@selector</span>(imagePickerControllerDidCancel:)])</span><br><span class="line">    [realDelegate imagePickerControllerDidCancel:picker];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^block)(<span class="built_in">UIImagePickerController</span> *) = [<span class="keyword">self</span> blockImplementationForMethod:_cmd];</span><br><span class="line">  <span class="keyword">if</span> (block) block(picker);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2. UIKit 分类</span></span><br><span class="line"><span class="comment">  2.1 添加回调block</span></span><br><span class="line"><span class="comment">  2.2 重写 load 方法，内部添加 &#123; block : delegateMethod &#125; 实现</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#pragma mark Category</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImagePickerController</span> (<span class="title">BlocksKit</span>) </span></span><br><span class="line"><span class="keyword">@dynamic</span> bk_didFinishPickingMediaBlock;</span><br><span class="line"><span class="keyword">@dynamic</span> bk_didCancelBlock;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> bk_registerDynamicDelegate];</span><br><span class="line">    [<span class="keyword">self</span> bk_linkDelegateMethods:@&#123;</span><br><span class="line">      <span class="string">@"bk_didFinishPickingMediaBlock"</span>: <span class="string">@"imagePickerController:didFinishPickingMediaWithInfo:"</span>,</span><br><span class="line">      <span class="string">@"bk_didCancelBlock"</span>: <span class="string">@"imagePickerControllerDidCancel:"</span> </span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>自己以后自定义的组件可以依赖 <code>BlocksKit</code> 通过 block 实现 delegate</p><ol><li>自定义 xxxDynamicDelegate class 继承 A2DynamicDelegate，并遵从 xxxDelegate 方法</li><li>Class 分类<br>2.1 添加实现 xxxDelegateMethod 的 block<br>2.2 重写 load 方法，内部添加 { block : xxxDelegateMethod } 实现</li></ol><h3 id="调用栈分析"><a class="markdownIt-Anchor" href="#调用栈分析"></a> 调用栈分析</h3><p>其实不是对象自己实现的代理方法，只是框架为我们提供的便捷方法，不需要构造其它对象就能完成代理方法的实现，具体我们会在后面详细地解释。</p><p>下面是这部分几个关键的类：</p><ul><li><code>A2BlockInvocation</code> 的主要作用是存储和转发 block</li><li><code>A2DynamicDelegate</code> 用来实现类的代理和数据源，它是 <code>NSProxy</code> 的子类</li><li><code>NSObject+A2DynamicDelegate</code> 负责为返回 <code>bk_dynamicDelegate</code> 和 <code>bk_dynamicDataSource</code> 等 <code>A2DynamicDelegate</code> 类型的实例，为 <code>NSObject</code> 提供主要的接口</li><li><code>NSObject+A2BlockDelegate</code> 提供了一系列接口将代理方法映射到 <code>block</code> 上</li><li>其他的 <code>UIKit</code> 的分类提供对应的属性，并在对应的 <code>A2DynamicDelegate</code> 子类中实现代理方法</li></ul><p>这里是我对这部分代码结构的理解：<br><img src="https://github.com/draveness/analyze/blob/master/contents/images/blockskit.png" alt="a"></p><p>这篇文成首先会从上到下对整个工作原理进行概述，然后再从底层到顶层详细地解释这个框架的机制和原理。</p><h3 id="动态代理工作概述"><a class="markdownIt-Anchor" href="#动态代理工作概述"></a> 动态代理工作概述</h3><p>在这里我们要对这部分的实现进行一个简单的概述，从上到下跟踪 <code>BlocksKit</code> 的调用过程。<br>以 <code>UIImagePickerController</code> 为例，因为这个文件中的代码较少，能省去很多不必要的实现细节。</p><p>在头文件中声明了两个属性，也就是 <code>UIImagePickerController</code> 代理方法的对应 block 属性：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>) <span class="keyword">void</span>(^bk_didFinishPickingMediaBlock)(<span class="built_in">UIImagePickerController</span> *，<span class="built_in">NSDictionary</span> *);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>) <span class="keyword">void</span>(^bk_didCancelBlock)(<span class="built_in">UIImagePickerController</span> *);</span><br></pre></td></tr></table></figure><p>然后在实现文件中动态生成这两个方法的存取方法</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@dynamic</span> bk_didFinishPickingMediaBlock;</span><br><span class="line"><span class="keyword">@dynamic</span> bk_didCancelBlock;</span><br></pre></td></tr></table></figure><p>你可以看到在这个名为 BlocksKit 的分类中只添加了一个方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    [<span class="keyword">self</span> bk_registerDynamicDelegate];</span><br><span class="line">    [<span class="keyword">self</span> bk_linkDelegateMethods:@&#123;<span class="string">@"bk_didFinishPickingMediaBlock"</span>: <span class="string">@"imagePickerController:didFinishPickingMediaWithInfo:"</span>,</span><br><span class="line">                      <span class="string">@"bk_didCancelBlock"</span>: <span class="string">@"imagePickerControllerDidCancel:"</span> &#125;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>load</code> 中实现这个方法，能够减少其中两个方法的调用次数，在 <code>autoreleasepool</code> 块中调用方法，使得其它地方的代码不会受到这里注册代理，链接代理方法中产生的对象的影响。</p><p><code>bk_registerDynamicDelegate</code> 方法是 <code>NSObject+A2BlockDelegate</code> 分类中添加的方法，用于修改原有属性 <code>delegate</code> 方法的实现（动态替换 delegate 方法实现）。在这里就是与 <code>UIImagePickerController+BlocksKit</code> 处于同一文件下的 <code>A2DynamicUIImagePickerControllerDelegate</code>，先不说这个文件的功能，会在之后介绍。</p><p>在 <code>NSObject+A2DynamicDelegate</code> 分类中的 <code>bk_registerDynamicDelegateNamed:forProtocol:</code> 修改 <code>@selector(delegate) 和 @selector(setDelegate:)</code> 的实现，使用 <code>A2DynamicUIImagePickerControllerDelegate</code> 替换原有的 <code>delegate</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMP setterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject，<span class="keyword">id</span> delegate) &#123;</span><br><span class="line">  A2DynamicDelegate *dynamicDelegate = getDynamicDelegate(delegatingObject，protocol，infoAsPtr，<span class="literal">YES</span>);</span><br><span class="line">  <span class="keyword">if</span> ([delegate isEqual:dynamicDelegate]) &#123;</span><br><span class="line">    delegate = <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dynamicDelegate.realDelegate = delegate;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">IMP getterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject) &#123;</span><br><span class="line">  <span class="keyword">return</span> [delegatingObject bk_dynamicDelegateForProtocol:a2_protocolForDelegatingObject(delegatingObject，protocol)];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在获取 delegate 属性时，就会获取 <code>A2DynamicUIImagePickerControllerDelegate</code>， <code>realDelegate</code> 相当于原有的 delegate 属性，会在下面的小节中具体分析。</p><p>在 load 方法中调用下一个方法是 <code>bk_linkDelegateMethods:</code> 这个方法会把代理方法和对应的 block 属性链接起来，这样可以通过代理方法的选择子查找对应的 block。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IMP getterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject) &#123;</span><br><span class="line">  A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，<span class="literal">NO</span>);</span><br><span class="line">  <span class="keyword">return</span> [delegate blockImplementationForMethod:selector];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">IMP setterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject，<span class="keyword">id</span> block) &#123;</span><br><span class="line">  A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，<span class="literal">YES</span>);</span><br><span class="line">  [delegate implementMethod:selector withBlock:block];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过调用 <code>A2DynamicDelegate</code> 的实例方法 <code>blockImplementationForMethod:</code> 和 <code>implementMethod:withBlock:</code> 动态实现 <code>block</code> 的存取方法。</p><p>当代理方法 <code>imagePickerController:didFinishPickingMediaWithInfo:</code> 被调用时，因为 <code>A2DynamicUIImagePickerControllerDelegate</code> 是 <code>UIImagePickerController</code> 的代理，所以会调用它的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span> *)info &#123;</span><br><span class="line">  <span class="keyword">id</span> realDelegate = <span class="keyword">self</span>.realDelegate;</span><br><span class="line">  <span class="keyword">if</span> (realDelegate &amp;&amp; [realDelegate respondsToSelector:<span class="keyword">@selector</span>(imagePickerController:didFinishPickingMediaWithInfo:)])</span><br><span class="line">    [realDelegate imagePickerController:picker didFinishPickingMediaWithInfo:info];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (^block)(<span class="built_in">UIImagePickerController</span> *，<span class="built_in">NSDictionary</span> *) = [<span class="keyword">self</span> blockImplementationForMethod:_cmd];</span><br><span class="line">  <span class="keyword">if</span> (block) block(picker，info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>blockImplementationForMethod:</code> 方法获取在上面存储的 block，然后传入参数执行该代码块。</p><ol><li>在 load 方法注册动态代理并链接代理方法</li><li>在运行时修改原有的 delegate 属性的存取方法，使用 A2DynamicDelegate 替换原有的 delegate，原有的 delegate 换为 realDelegate</li><li>为 block 属性动态实现存取方法，返回对应 A2DynamicDelegate 子类中存储的 block</li><li>在代理方法真正被调用时，查找 realDelegate 中是否对代理方法做出响应，无论是否响应，都通过选择子查找对应的 block，然后传入相应参数执行 block</li></ol><h3 id="自底向上分析动态代理的工作"><a class="markdownIt-Anchor" href="#自底向上分析动态代理的工作"></a> 自底向上分析动态代理的工作</h3><p>我们已经自顶向下分析了 <code>BlocksKit</code> 的工作过程，也对这个部分有一个基本的了解，接下来我们将从底层到顶层分析整个 BlocksKit，我们再来看一下整个框架的结构图：</p><p><img src="https://github.com/draveness/analyze/blob/master/contents/images/blockskit.png" alt="b"></p><p>我们将以下面的顺序来依次介绍这些模块，其中的 UITextField 可以换成其它的类：</p><ol><li>A2BlockInvocation</li><li>A2DynamicDelegate</li><li>NSObject+A2DynamicDelegate</li><li>A2DynamicUITextFieldDelegate</li><li>UITextField+BlocksKit</li></ol><h3 id="a2blockinvocation"><a class="markdownIt-Anchor" href="#a2blockinvocation"></a> A2BlockInvocation</h3><p><code>A2BlockInvocation</code> 使用来对闭包，也就是 <code>block</code> 进行存储和转发的类。</p><p>先介绍这个的是因为 <code>A2BlockInvocation</code> 的功能比较底层，涉及的内容也都比较奇葩，所以想先简单介绍一下，避免之后一个类分几部分介绍。</p><p>在 Objective-C 中，每一个方法甚至 block 都是有类型签名的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSMethodSignature</span> : <span class="title">NSObject</span> </span>&#123; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> numberOfArguments; </span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="keyword">const</span> <span class="keyword">char</span> *methodReturnType <span class="built_in">NS_RETURNS_INNER_POINTER</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它们有返回类型、参数数字和参数类型等等。</p><h4 id="block-结构体"><a class="markdownIt-Anchor" href="#block-结构体"></a> Block 结构体</h4><p>block 的签名没有哪个函数能够直接获取，它存储在 block 的结构体中，就像这样：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="keyword">int</span>，BKBlockFlags) &#123;</span><br><span class="line">  BKBlockFlagsHasCopyDisposeHelpers = (<span class="number">1</span> &lt;&lt; <span class="number">25</span>),</span><br><span class="line">  BKBlockFlagsHasSignature      = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _BKBlock &#123;</span><br><span class="line">  __unused Class isa;</span><br><span class="line">  BKBlockFlags flags;</span><br><span class="line">  __unused <span class="keyword">int</span> reserved;</span><br><span class="line">  <span class="keyword">void</span> (__unused *invoke)(<span class="keyword">struct</span> _BKBlock *block，...);</span><br><span class="line">  <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> size;</span><br><span class="line">  <span class="comment">// requires BKBlockFlagsHasCopyDisposeHelpers</span></span><br><span class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">void</span> *dst，<span class="keyword">const</span> <span class="keyword">void</span> *src);</span><br><span class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">const</span> <span class="keyword">void</span> *);</span><br><span class="line">  <span class="comment">// requires BKBlockFlagsHasSignature</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *signature;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *layout;</span><br><span class="line">  &#125;*descriptor;</span><br><span class="line">  <span class="comment">// imported variables</span></span><br><span class="line">&#125;*BKBlockRef;</span><br></pre></td></tr></table></figure><p>这部分其实就是 <code>block</code> 实际存储在内存中的数据接口，可以在 <code>runtime</code> 中的源代码中看到这里的代码。</p><h4 id="typesignatureforblock"><a class="markdownIt-Anchor" href="#typesignatureforblock"></a> typeSignatureForBlock</h4><p>上面的 signature 就是 block 的签名，下面实现方法来获取这个签名</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)typeSignatureForBlock:(<span class="keyword">id</span>)block __attribute__((pure，<span class="keyword">nonnull</span>(<span class="number">1</span>))) &#123;</span><br><span class="line">  BKBlockRef layout = (__bridge <span class="keyword">void</span> *)block;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果 block 没有签名直接返回空</span></span><br><span class="line">  <span class="keyword">if</span> (!(layout-&gt;flags &amp; BKBlockFlagsHasSignature))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *desc = layout-&gt;descriptor;</span><br><span class="line">  desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (layout-&gt;flags &amp; BKBlockFlagsHasCopyDisposeHelpers)</span><br><span class="line">    desc += <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">void</span> *);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!desc)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *signature = (*(<span class="keyword">const</span> <span class="keyword">char</span> **)desc);</span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了这个方法的作用再理解它的实现就非常简单了，根据flag 来移动指针，最终 signature 所在的内存空间。</p><p>Unlike a typical method signature，a block type signature has no self (’@’) or _cmd ( ‘:’ ) parameter，but instead just one parameter for the block itself (’@?’)。</p><p>在这里所涉及的 @、: 和@? 可以看这里的文档 类型编码</p><p>在一般的方法签名中 block 的类型签名是没有 self (’@’) 或者 _cmd ( ‘:’ ) 的，只有一个参数代表 block 自己 (’@?’).</p><ul><li>^(UIActionSheet *) {}<ul><li>参数类型：@?(@“UIActionSheet”)</li><li>返回类型：v</li></ul></li><li><ul><li>(void)willPresentActionSheet:(UIActionSheet *)actionSheet</li></ul><ul><li>参数类型：@: @</li><li>返回类型：v</li></ul></li></ul><p>为什么要把 @“UIActionSheet” 标记上括号？因为它们属于同一个参数。</p><p>同时因为 <code>UIActionSheet</code> 也是 id 类型，所以它的类型编码也是 @。</p><p>当调用 <code>initWithBlock:</code> 方法时，会先调用上面说的方法 <code>typeSignatureForBlock:</code> 获取 block 的类型签名：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">id</span>)block &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(block);</span><br><span class="line">  <span class="built_in">NSMethodSignature</span> *blockSignature = [[<span class="keyword">self</span> <span class="keyword">class</span>] typeSignatureForBlock:block];</span><br><span class="line">  <span class="built_in">NSMethodSignature</span> *methodSignature = [[<span class="keyword">self</span> <span class="keyword">class</span>] methodSignatureForBlockSignature:blockSignature];</span><br><span class="line">  <span class="built_in">NSAssert</span>(methodSignature，<span class="string">@"Incompatible block: %@"</span>，block);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> initWithBlock:block methodSignature:methodSignature blockSignature:blockSignature]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="methodsignatureforblocksignature"><a class="markdownIt-Anchor" href="#methodsignatureforblocksignature"></a> methodSignatureForBlockSignature</h4><p>然后调用 <code>methodSignatureForBlockSignature:</code> 方法构造一个可以兼容的方法签名：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForBlockSignature:(<span class="built_in">NSMethodSignature</span> *)original</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">#1: 检查方法签名的参数，省略</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">NSMutableString</span> *signature = [[<span class="built_in">NSMutableString</span> alloc] initWithCapacity:original.numberOfArguments + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *retTypeStr = original.methodReturnType;</span><br><span class="line">  <span class="comment">// 返回类型，id 类型(self @)，选择子类型(SEL :)</span></span><br><span class="line">  [signature appendFormat:<span class="string">@"%s%s%s"</span>，retTypeStr，<span class="keyword">@encode</span>(<span class="keyword">id</span>)，<span class="keyword">@encode</span>(SEL)];</span><br><span class="line">  <span class="comment">// signature = (返回类型)@:</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">1</span>;i &lt; original.numberOfArguments;i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *typeStr = [original getArgumentTypeAtIndex:i];</span><br><span class="line">    <span class="built_in">NSString</span> *type = [[<span class="built_in">NSString</span> alloc] initWithBytesNoCopy:(<span class="keyword">void</span> *)typeStr length:strlen(typeStr) encoding:<span class="built_in">NSUTF8StringEncoding</span> freeWhenDone:<span class="literal">NO</span>];</span><br><span class="line">    [signature appendString:type];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// signature = (返回类型)@:(参数类型) </span></span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:signature.UTF8String];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的实现细节我们就省略了，它的工作原理是把 @?(@“UIActionSheet”) 类型签名转换成 @: @，然后返回方法签名。</p><p>关于代码中的 @encode 可以看这里<a href="https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Function-Attributes.html" target="_blank" rel="noopener">声明方法的属性</a></p><h4 id="issignaturecompatiblewithsignature"><a class="markdownIt-Anchor" href="#issignaturecompatiblewithsignature"></a> isSignature:compatibleWithSignature:</h4><p>在这个类中最后一个重要的方法就是 <code>isSignature:compatibleWithSignature:</code>，这个方法是判断传入的 block 和方法的类型签名是否兼容。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)isSignature:(<span class="built_in">NSMethodSignature</span> *)signatureA compatibleWithSignature:(<span class="built_in">NSMethodSignature</span> *)signatureB __attribute__((pure)) &#123;</span><br><span class="line">  <span class="meta">#1: 参数检查，省略</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">#2: 判断返回值是否相同，省略</span></span><br><span class="line">  <span class="keyword">if</span> (signatureA.methodReturnType[<span class="number">0</span>] != signatureB.methodReturnType[<span class="number">0</span>]) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#3: 设置 methodSignature 和 blockSignature</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">#4: 比较 methodSignature 和 blockSignature</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 #3 部分设置 methodSignature 和 blockSignature。</p><p>因为方法签名会比 block 类型签名多一个默认参数，所以，这里会将参数多的设置为 methodSignature，如果把为 block 类型签名的设置给了 methodSignature 也不会有问题，在 #4 部分会判断出来并返回 NO。</p><p>方法默认参数：self，SEL，block 默认类型参数: block</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSMethodSignature</span> *methodSignature = <span class="literal">nil</span>，*blockSignature = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (signatureA.numberOfArguments &gt; signatureB.numberOfArguments) &#123;</span><br><span class="line">  methodSignature = signatureA;</span><br><span class="line">  blockSignature = signatureB;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (signatureB.numberOfArguments &gt; signatureA.numberOfArguments) &#123;</span><br><span class="line">  methodSignature = signatureB;</span><br><span class="line">  blockSignature = signatureA;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 #4 部分就是一次比较各个类型签名，也没什么复杂的，需要注意的就是选择正确的 index</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> numberOfArguments = methodSignature.numberOfArguments;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">2</span>;i &lt; numberOfArguments;i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> ([methodSignature getArgumentTypeAtIndex:i][<span class="number">0</span>] != [blockSignature getArgumentTypeAtIndex:i - <span class="number">1</span>][<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invokewithinvocationreturnvalueoutreturnvalue"><a class="markdownIt-Anchor" href="#invokewithinvocationreturnvalueoutreturnvalue"></a> invokeWithInvocation:returnValue:outReturnValue:</h4><p>这一节主要介绍的是，当 <code>A2BlockInvocation</code> 对象具体需要执行某一个 <code>NSInvocation</code> 时是如何工作的，其实这个方法还是很容易理解的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)invokeWithInvocation:(<span class="built_in">NSInvocation</span> *)outerInv returnValue:(<span class="keyword">out</span> <span class="built_in">NSValue</span> **)outReturnValue setOnInvocation:(<span class="built_in">BOOL</span>)setOnInvocation &#123;</span><br><span class="line">  <span class="meta">#1: 参数以及类型签名是否匹配的检查，省略 </span></span><br><span class="line">  <span class="built_in">NSInvocation</span> *innerInv = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:<span class="keyword">self</span>.blockSignature]; </span><br><span class="line">  <span class="meta">#2: 设置 innerInv 参数</span></span><br><span class="line">  ... </span><br><span class="line">  [innerInv invokeWithTarget:<span class="keyword">self</span>.block]; </span><br><span class="line">  <span class="meta">#3: 获取返回值 </span></span><br><span class="line">  free(argBuf); </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 #2、#3 部分的代码是为了设置 innerInv 的参数，获取返回值：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *argBuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">2</span>;i &lt; sig.numberOfArguments;i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *type = [sig getArgumentTypeAtIndex:i];</span><br><span class="line">  <span class="built_in">NSUInteger</span> argSize;</span><br><span class="line">  <span class="built_in">NSGetSizeAndAlignment</span>(type，&amp;argSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(argBuf = reallocf(argBuf，argSize))) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [outerInv getArgument:argBuf atIndex:i];</span><br><span class="line">  [innerInv setArgument:argBuf atIndex:i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 block</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSUInteger</span> retSize = sig.methodReturnLength;</span><br><span class="line"><span class="keyword">if</span> (retSize) &#123;</span><br><span class="line">  <span class="keyword">if</span> (outReturnValue || setOnInvocation) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(argBuf = reallocf(argBuf，retSize))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [innerInv getReturnValue:argBuf];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setOnInvocation) &#123;</span><br><span class="line">      [outerInv setReturnValue:argBuf];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outReturnValue) &#123;</span><br><span class="line">      *outReturnValue = [<span class="built_in">NSValue</span> valueWithBytes:argBuf objCType:sig.methodReturnType];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (outReturnValue) &#123;</span><br><span class="line">    *outReturnValue = <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>A2BlockInvocation</code> 这一节就到这里了，接下来要说一下 <code>A2DynamicDelegate。</code></p><h3 id="a2dynamicdelegate"><a class="markdownIt-Anchor" href="#a2dynamicdelegate"></a> A2DynamicDelegate</h3><p><code>A2DynamicDelegate</code> 可以说是 <code>BlocksKit</code> 实现动态代理的关键，是这个框架中很重要的类，它通过 block 实现了类的代理和数据源等协议。</p><p><code>A2DynamicDelegate</code> 它的父类是 <code>NSProxy</code>，而 <code>NSProxy</code> 出现的目的就是为了代理一个对象的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSProxy</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们不具体解释这里的 NSProxy，如果想要更详细的信息，请看<a href="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Reference/Foundation/Classes/NSProxy_Class/index.html" target="_blank" rel="noopener">这里</a>。</p><p><code>A2DynamicDelegate</code> 作为 NSProxy 的子类，必须实现 <code>forwardInvocation: methodSignatureForSelector:</code> 方法进行对象转发，这是在苹果官方文档中说明的。</p><h4 id="覆写必要的方法-methodsignatureforselector-和-forwardinvocation"><a class="markdownIt-Anchor" href="#覆写必要的方法-methodsignatureforselector-和-forwardinvocation"></a> 覆写必要的方法 methodSignatureForSelector: 和 forwardInvocation:</h4><p>我们首先来看一下 <code>methodSignatureForSelector:</code>，它为一个选择子返回合适的方法签名：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">  A2BlockInvocation *invocation = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">if</span> ((invocation = [<span class="keyword">self</span>.invocationsBySelectors bk_objectForSelector:aSelector]))</span><br><span class="line">    <span class="keyword">return</span> invocation.methodSignature;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.realDelegate methodSignatureForSelector:aSelector])</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.realDelegate methodSignatureForSelector:aSelector];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (class_respondsToSelector(object_getClass(<span class="keyword">self</span>)，aSelector))</span><br><span class="line">    <span class="keyword">return</span> [object_getClass(<span class="keyword">self</span>) methodSignatureForSelector:aSelector];</span><br><span class="line">  <span class="keyword">return</span> [[<span class="built_in">NSObject</span> <span class="keyword">class</span>] methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的逻辑如下：</p><ol><li><p>判断 <code>invocationsBySelectors</code> 属性中是否存储了该选择子对应的 A2BlockInvocation，直接返回这个 invocation 对象的类型签名，也就是说自己实现了该选择子对应的方法</p></li><li><p>在真正的 <code>realDelegate</code> 中查找原有的代理(不是当前的动态代理 A2DynamicDelegate)是否实现了该选择子，并返回方法签名</p><p><code>在这里的 realDelegate 是对象真正的代理，例如</code><br><code>self.tableView.delegate = [[UIViewController alloc] init];</code><br>其中 <code>realDelegate</code> 是视图控制器，但是在我们设置时，不需要这么设置<br><code>self.tableView.realDelegate = [[UIViewController alloc] init];</code><br>因为在 NSObject+A2BlockDelegate 中会进行方法调用，修改原有方法的实现，每次在设置 delegate 时，会将这个值设置传到 realDelegate 中。</p></li><li><p>在自己的类中查找该方法的选择子</p></li><li><p>如果上面三个步骤都没有得到相应，那么调用 NSObject 对象的 methodSignatureForSelector: 方法获取方法签名，当然可能返回空值</p></li></ol><p>====</p><p><code>forwardInvocation:</code> 的实现其实跟上面的方法的思路差不多</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)outerInv &#123;</span><br><span class="line">  SEL selector = outerInv.selector;</span><br><span class="line">  A2BlockInvocation *innerInv = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">if</span> ((innerInv = [<span class="keyword">self</span>.invocationsBySelectors bk_objectForSelector:selector])) &#123;</span><br><span class="line">    [innerInv invokeWithInvocation:outerInv];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span>.realDelegate respondsToSelector:selector]) &#123;</span><br><span class="line">    [outerInv invokeWithTarget:<span class="keyword">self</span>.realDelegate];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>判断 <code>invocationsBySelectors</code> 属性中是否存储了该选择子对应的 <code>A2BlockInvocation</code>，然后调用 <code>invokeWithInvocation:</code> 传入 outerInv 转发这个方法，最终会调用 <code>- [A2BlockInvocation invokeWithInvocation:returnValue:setOnInvocation:]</code></li><li>判断 <code>realDelegate</code> 是否实现了该方法，如果真正的代理能做出响应，将方法转发给 <code>realDelegate</code></li></ol><h4 id="block-实现方法-blockimplementationformethod-和-implementmethodwithblock"><a class="markdownIt-Anchor" href="#block-实现方法-blockimplementationformethod-和-implementmethodwithblock"></a> Block 实现方法 blockImplementationForMethod: 和 implementMethod:withBlock:</h4><p>这部分的代码其实相当于平时的 Getter/Setter</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)blockImplementationForMethod:(SEL)selector</span><br><span class="line">&#123;</span><br><span class="line">  A2BlockInvocation *invocation = <span class="literal">nil</span>;</span><br><span class="line">  <span class="keyword">if</span> ((invocation = [<span class="keyword">self</span>.invocationsBySelectors bk_objectForSelector:selector]))</span><br><span class="line">    <span class="keyword">return</span> invocation.block;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 block 都是在 <code>A2BlockInvocation</code> 中封装的，所以在通过选择子查找 block 的时候，实际上是查找对应的 <code>A2BlockInvocation</code>，然后返回它的 block。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)implementMethod:(SEL)selector withBlock:(<span class="keyword">id</span>)block &#123; </span><br><span class="line">  <span class="meta">#1: 参数检查，省略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">    [<span class="keyword">self</span>.invocationsBySelectors bk_removeObjectForSelector:selector];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">#2: 实例化 A2BlockInvocation</span></span><br><span class="line">  [<span class="keyword">self</span>.invocationsBySelectors bk_setObject:inv forSelector:selector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果能获取到方法的描述，那么就可以得到对应的方法签名，然后调用不同的初始化方法实例一个 <code>A2Blockinvocation</code> 对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_description methodDescription = protocol_getMethodDescription(<span class="keyword">self</span>.protocol，selector，<span class="literal">YES</span>，!isClassMethod);</span><br><span class="line"><span class="keyword">if</span> (!methodDescription.name) </span><br><span class="line">  methodDescription = protocol_getMethodDescription(<span class="keyword">self</span>.protocol，selector，<span class="literal">NO</span>，!isClassMethod);</span><br><span class="line"></span><br><span class="line">A2BlockInvocation *inv = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (methodDescription.name) &#123;</span><br><span class="line">  <span class="built_in">NSMethodSignature</span> *protoSig = [<span class="built_in">NSMethodSignature</span> signatureWithObjCTypes:methodDescription.types];</span><br><span class="line">  inv = [[A2BlockInvocation alloc] initWithBlock:block methodSignature:protoSig];</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  inv = [[A2BlockInvocation alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法的实现，主要目的是<code>为子类实现代理方法提供支持</code>。</p><h4 id="nsobjecta2dynamicdelegate-为对象添加动态代理"><a class="markdownIt-Anchor" href="#nsobjecta2dynamicdelegate-为对象添加动态代理"></a> NSObject+A2DynamicDelegate 为对象添加动态代理</h4><p>这个分类是为所有的对象提供简单快捷的接口找到对应的动态代理:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>，<span class="keyword">strong</span>) <span class="keyword">id</span> bk_dynamicDataSource;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>，<span class="keyword">strong</span>) <span class="keyword">id</span> bk_dynamicDelegate;</span><br><span class="line">- (<span class="keyword">id</span>)bk_dynamicDelegateForProtocol:(Protocol *)protocol;</span><br></pre></td></tr></table></figure><p>以 UITableView 为例:</p><ul><li>访问 tableView.bk_dynamicDataSource 那么它就会寻找 A2DynamicUITableViewDataSource 的对象</li><li>访问 tableView.bk_dynamicDelegate 那么它就会寻找 A2DynamicUITableViewDelegate 的对象</li></ul><p>这些对象都是在后台进程中惰性初始化的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)bk_dynamicDelegateWithClass:(Class)cls forProtocol:(Protocol *)protocol &#123;</span><br><span class="line">  __block A2DynamicDelegate *dynamicDelegate;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">dispatch_sync</span>(a2_backgroundQueue()，^&#123;</span><br><span class="line">    dynamicDelegate = objc_getAssociatedObject(<span class="keyword">self</span>，(__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)protocol);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dynamicDelegate) &#123;</span><br><span class="line">      dynamicDelegate = [[cls alloc] initWithProtocol:protocol];</span><br><span class="line">      objc_setAssociatedObject(<span class="keyword">self</span>，(__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)protocol，dynamicDelegate，OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dynamicDelegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nsobjecta2blockdelegate"><a class="markdownIt-Anchor" href="#nsobjecta2blockdelegate"></a> NSObject+A2BlockDelegate</h4><p>我们在概述的一部分实际上已经接触过这个分类里面的重要方法 <code>bk_linkProtocol:methods:</code>，它动态实现所有添加的 block 属性的存取方法，比如说 <code>bk_didFinishPickingMediaBlock</code> <code>bk_didCancelBlock</code></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IMP getterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject) &#123;</span><br><span class="line">  A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，<span class="literal">NO</span>);</span><br><span class="line">  <span class="keyword">return</span> [delegate blockImplementationForMethod:selector];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">IMP setterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject，<span class="keyword">id</span> block) &#123;</span><br><span class="line">  A2DynamicDelegate *delegate = getDynamicDelegate(delegatingObject，protocol，info，<span class="literal">YES</span>);</span><br><span class="line">  [delegate implementMethod:selector withBlock:block];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>方法调用之后的存取方法如下</p><p>getter: 以 selector 为键在动态代理中查找对应的 block<br>setter: 以 selector 也就是代理方法为键，通过 <code>implementMethod:withBlock:</code> 方法以 <code>A2BlockInvocation</code> 的形式存储 block<br>另一个方法 <code>bk_registerDynamicDelegateNamed:forProtocol:</code>，它主要功能就是修改 getter 和 setter 方法，将原有的 delegate 转发到 realDelegate，修改原有的 delegate 的实现，实现的方法就是喜闻乐见的方法调节：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">IMP setterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject，<span class="keyword">id</span> delegate) &#123;</span><br><span class="line">  A2DynamicDelegate *dynamicDelegate = getDynamicDelegate(delegatingObject，protocol，infoAsPtr，<span class="literal">YES</span>);</span><br><span class="line">  <span class="keyword">if</span> ([delegate isEqual:dynamicDelegate]) &#123;</span><br><span class="line">    delegate = <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dynamicDelegate.realDelegate = delegate;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">IMP getterImplementation = imp_implementationWithBlock(^(<span class="built_in">NSObject</span> *delegatingObject) &#123;</span><br><span class="line">  <span class="keyword">return</span> [delegatingObject bk_dynamicDelegateForProtocol:a2_protocolForDelegatingObject(delegatingObject，protocol)];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意，在这里省略了一些与脉络无关的实现细节，在调用过后 delegate 的存取方法如下：</p><ul><li>getter：返回一个动态代理对象</li><li>setter：设置代理并不会改变 delegate 中存储的动态代理，只会修改 realDelegate</li></ul><p>我们现在有了通过 runtime 实现 block 的 getter/setter，修改原有的 delegate 属性的方法将对象的代理设置为动态代理，接下来要在子类化动态代理，使用动态代理的子类实现所有的代理方法。</p><h4 id="a2dynamicuitextfielddelegate"><a class="markdownIt-Anchor" href="#a2dynamicuitextfielddelegate"></a> A2DynamicUITextFieldDelegate</h4><p><code>A2DynamicUITextFieldDelegate</code> 和 <code>UITextField+BlocksKit</code> 位于统一文件下，它是一个私有类，我们选取其中一个简单的代理方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)textFieldDidEndEditing:(<span class="built_in">UITextField</span> *)textField&#123;</span><br><span class="line">  <span class="keyword">id</span> realDelegate = <span class="keyword">self</span>.realDelegate;</span><br><span class="line">  <span class="keyword">if</span> (realDelegate &amp;&amp; [realDelegate respondsToSelector:<span class="keyword">@selector</span>(textFieldDidEndEditing:)])</span><br><span class="line">    [realDelegate textFieldDidEndEditing:textField];</span><br><span class="line">  <span class="keyword">void</span> (^block)(<span class="built_in">UITextField</span> *) = [<span class="keyword">self</span> blockImplementationForMethod:_cmd];</span><br><span class="line">  <span class="keyword">if</span> (block)</span><br><span class="line">    block(textField);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>当 <code>realDelegate</code> 实现了该代理方法时，首先调用代理的方法</li><li>当该代理方法对应的 <code>block</code> 存在的话，也会调用该 <code>block</code></li></ol><h4 id="uitextfieldblockskit-分类和-load-方法"><a class="markdownIt-Anchor" href="#uitextfieldblockskit-分类和-load-方法"></a> UITextField+BlocksKit 分类和 load 方法</h4><p>在最后就是对 <code>NSObject+A2BlockDelegate</code> 分类中方法的调用</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  [<span class="keyword">self</span> bk_registerDynamicDelegate];</span><br><span class="line">  [<span class="keyword">self</span> bk_linkDelegateMethods: @&#123;</span><br><span class="line">    <span class="string">@"bk_shouldBeginEditingBlock"</span>: <span class="string">@"textFieldShouldBeginEditing:"</span>,</span><br><span class="line">    <span class="string">@"bk_didBeginEditingBlock"</span>: <span class="string">@"textFieldDidBeginEditing:"</span>,</span><br><span class="line">    <span class="string">@"bk_shouldEndEditingBlock"</span>: <span class="string">@"textFieldShouldEndEditing:"</span>,</span><br><span class="line">    <span class="string">@"bk_didEndEditingBlock"</span> : <span class="string">@"textFieldDidEndEditing:"</span>,</span><br><span class="line">    <span class="string">@"bk_shouldChangeCharactersInRangeWithReplacementStringBlock"</span> : <span class="string">@"textField:shouldChangeCharactersInRange:replacementString:"</span>,</span><br><span class="line">    <span class="string">@"bk_shouldClearBlock"</span> : <span class="string">@"textFieldShouldClear:"</span>,</span><br><span class="line">    <span class="string">@"bk_shouldReturnBlock"</span> : <span class="string">@"textFieldShouldReturn:"</span>,</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么在 <code>load</code> 方法中调用这两个方法？原因有两个：</p><ul><li>每个文件中的该方法都只会调用一次，减少了调用的次数</li><li>该方法只会在文件被引入 ObjC 运行时 的时候调用</li></ul><p>其中的 <code>autoreleasepool</code> 的作用在上面已经介绍过了，它使得其它地方的代码不会受到这里注册代理，链接代理方法中产生的对象的影响。</p><p><code>UIKit+BlocksKit</code> 这些分类的另一作用就是提供 block 回调接口，声明属性，然后使用 @dynamic 表明属性是动态生成的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>，<span class="keyword">nullable</span>) <span class="built_in">BOOL</span>(^bk_shouldBeginEditingBlock)(<span class="built_in">UITextField</span> *textField);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>，<span class="keyword">copy</span>，<span class="keyword">nullable</span>) <span class="keyword">void</span>(^bk_didBeginEditingBlock)(<span class="built_in">UITextField</span> *textField);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@dynamic</span> bk_shouldBeginEditingBlock，bk_didBeginEditingBlock ...;</span><br></pre></td></tr></table></figure><h2 id="end"><a class="markdownIt-Anchor" href="#end"></a> End</h2><p>到这里对于 BlocksKit 的实现机制就基本上已经看完了。我们再来看一下 整个 BlocksKit 的结构图：</p><p><img src="https://github.com/draveness/analyze/blob/master/contents/images/blockskit.png" alt="c"></p><h2 id="reference"><a class="markdownIt-Anchor" href="#reference"></a> Reference</h2><blockquote><p><a href="https://github.com/draveness/analyze/blob/master/contents/BlocksKit/%E7%A5%9E%E5%A5%87%E7%9A%84%20BlocksKit%20%EF%BC%88%E4%B8%80%EF%BC%89.md" target="_blank" rel="noopener">神奇的 BlocksKit 一</a><br><a href="https://github.com/draveness/analyze/blob/master/contents/BlocksKit/%E7%A5%9E%E5%A5%87%E7%9A%84%20BlocksKit%20%EF%BC%88%E4%BA%8C%EF%BC%89.md" target="_blank" rel="noopener">神奇的 BlocksKit 二</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Method Swizzling</title>
      <link href="/2017/08/01/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/Method-Swizzling/"/>
      <url>/2017/08/01/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/Method-Swizzling/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:44 GMT+0800 (CST) --><a id="more"></a><h2 id="method-swizzling-的作用"><a class="markdownIt-Anchor" href="#method-swizzling-的作用"></a> Method swizzling 的作用</h2><p>他是一种 <a href="https://en.wikipedia.org/wiki/Pointer_swizzling" target="_blank" rel="noopener">交换指针指向</a> 的技术<br>Method swizzling 用于改变一个已经存在的 selector 的实现。<br>在运行时通过改变 selector 在类的消息分发列表中的映射从而改变原有方法。</p><p>例如：在 app 中追踪每一个视图控制器被用户呈现了几次：<br>通过在 viewDidAppear: 方法中添加追踪代码来实现，但会有大量重复代码。<br>继承是另一种可行的方式，但是这要求所有被继承的视图控制器如 UIViewController, UITableViewController, UINavigationController 都在 viewDidAppear：实现追踪代码，这同样会造成很多重复代码。这里有另外一种可行的方式：从 category 实现 method swizzling 。下面是实现方式：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line"><span class="comment">// 1. 得到方法名称 selector</span></span><br><span class="line">    SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">    SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line"><span class="comment">// 2. 得到方法类型（方法签名）</span></span><br><span class="line">    Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); </span><br><span class="line">    <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">    <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Method originalMethod = class_getClassMethod(class, originalSelector);</span></span><br><span class="line">    <span class="comment">// Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</span></span><br><span class="line"><span class="comment">// 3. 给 originalSelector 添加新method的实现和参数类，如果originSel在 cls 中没有实现体，那么会添加各一个实现体，并return YES，如果已经有实现体 return NO </span></span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod =</span><br><span class="line">    class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">                    originalSelector,</span><br><span class="line">                    method_getImplementation(swizzledMethod),</span><br><span class="line">                    method_getTypeEncoding(swizzledMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">      <span class="comment">// 4. 替换</span></span><br><span class="line">      class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                          swizzledSelector,</span><br><span class="line">                          method_getImplementation(originalMethod),</span><br><span class="line">                          method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">  [<span class="keyword">self</span> xxx_viewWillAppear:animated]; <span class="comment">// viewWillAppear</span></span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><strong>class_addMethod</strong> 。要先尝试添加 originSel 是为了做一层保护，因为如果这个类没有实现 originSel ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法。所以先尝试添加 originSel，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。</p><p>过程变化图<br><img src="/img/method_swizzle.jpg" alt="swizzle"></p><h2 id="应该在哪些地方使用-method-swizzling"><a class="markdownIt-Anchor" href="#应该在哪些地方使用-method-swizzling"></a> 应该在哪些地方使用 method swizzling</h2><h3 id="swizzling-应该只在-load-中"><a class="markdownIt-Anchor" href="#swizzling-应该只在-load-中"></a> swizzling 应该只在 +load 中</h3><p>在 Objective-C 的运行时中，每个类有两个方法都会自动调用。</p><ul><li>+load 是在一个类被初始装载时调用，[只会调用一次]</li><li>+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。[可能会被调用多次]</li></ul><p>两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。</p><h3 id="dispatch_once"><a class="markdownIt-Anchor" href="#dispatch_once"></a> dispatch_once</h3><p>swizzling 应该只在 dispatch_once 中完成。</p><ol><li>swizzling 改变了全局的状态</li><li>确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 提供原子性</li></ol><h3 id="selectors-methods-implementations"><a class="markdownIt-Anchor" href="#selectors-methods-implementations"></a> Selectors, Methods, &amp; Implementations</h3><p>在 Objective-C 的运行时中，selectors, methods, implementations 指代了不同概念，然而我们通常会说在消息发送过程中，这三个概念是可以相互转换的。 下面是苹果 Objective-C Runtime Reference中的描述：</p><ul><li><code>Selector（typedef struct objc_selector *SEL）</code>:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。</li><li><code>Method（typedef struct objc_method *Method）</code>:方法是一个不透明的用来代表一个方法的定义的类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Method 结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    MethodListIMP imp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>Implementation（typedef id (*IMP)(id, SEL,...)</code>）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象 metaclass ）。第二个参数是这个方法的名字 selector，该方法的真正参数紧随其后。</li></ul><p>理解 selector, method, implementation 这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。</p><h3 id="调用-_cmd"><a class="markdownIt-Anchor" href="#调用-_cmd"></a> 调用 _cmd</h3><p>下面代码在正常情况下会出现循环：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">  [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"viewWillAppear: %@"</span>, <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而在交换了方法实现后就不会出现循环了。好的程序员应该对这里出现的方法的递归调用有所警觉，这里我们应该理清在 method swizzling 后方法的实现究竟变成了什么。在交换了方法的实现后，xxx_viewWillAppear:方法的实现已经被替换为了 UIViewController -viewWillAppear：的原生实现，所以这里并不是在递归调用。由于 xxx_viewWillAppear: 这个方法的实现已经被替换为了 viewWillAppear: 的实现，所以，当我们在这个方法中再调用 viewWillAppear: 时便会造成递归循环。</p><p>记住给需要转换的所有方法加个前缀以区别原生方法。</p><h2 id="涉及-runtime-方法"><a class="markdownIt-Anchor" href="#涉及-runtime-方法"></a> 涉及 <code>runtime</code> 方法</h2><ol><li><p>通过 SEL 获取一个方法 Method<br>Method class_getInstanceMethod(Class cls, SEL name);</p></li><li><p>通过 Method 获取该方法的实现 IMP<br>IMP method_getImplementation(Method m);</p></li><li><p>返回一个字符串，描述了方法的参数和返回类型<br>const char * method_getTypeEncoding(Method m);</p></li><li><p>通过 SEL 以及 IMP 给一个类添加新的方法 Method，其中 types 就是 method_getTypeEncoding 的返回值。<br>BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types);</p><ol><li>当 cls 中有 name 方法实现，添加method return NO</li><li>当 cls 中没有 name 方法，则添加方法实现 return YES</li></ol></li><li><p>通过给定的 SEL 替换同一个类中的方法的实现 IMP，其中 SEL 是想要替换的 selector 名，IMP 是替换后的实现。<br>IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types);</p></li><li><p>交换两个方法的实现 IMP<br>void method_exchangeImplementations(Method m1, Method m2);</p></li></ol><h2 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h2><p>很多人认为交换方法实现会带来无法预料的结果。然而采取了以下预防措施后, method swizzling 会变得很可靠：</p><ul><li>在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。</li><li>避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。</li><li>理解实现原理：只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 &lt;obje/runtime.h&gt; 能够让你更好理解实现原理。</li><li>持续的预防：不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。</li></ul><h2 id="swift-中如何-swizzle"><a class="markdownIt-Anchor" href="#swift-中如何-swizzle"></a> swift 中如何 swizzle</h2><p>目前 swift 的版本已经不允许使用 <code>load</code> 和 <code>initialize</code> 方法<br>也没有了 <code>dispatch_once</code> 方法，那么如何确保 swizzle 只执行一次呢？</p><blockquote><p><a href="https://nshipster.cn/method-swizzling/" target="_blank" rel="noopener">引用 Method Swizzling</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> objc </category>
          
          <category> runtime </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> objc </tag>
            
            <tag> 底层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS app 沙盒目录结构</title>
      <link href="/2017/07/01/iOS-app-%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2017/07/01/iOS-app-%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><p><img src="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/art/ios_app_layout_2x.png" alt="sandbox"></p><p>iOS系统为了保证系统安全，通过重定向技术，把程序生成和修改的文件定向到自身文件夹中。在沙盒机制下，每个程序之间的文件夹不能互相访问。</p><ol><li>Documents</li><li>Library</li><li>tmp</li></ol><p><a href="https://www.jianshu.com/p/a06121bfec8c" target="_blank" rel="noopener">https://www.jianshu.com/p/a06121bfec8c</a></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CollectionView 使用</title>
      <link href="/2017/06/15/UI%20%E7%9B%B8%E5%85%B3/CollectionView-%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/06/15/UI%20%E7%9B%B8%E5%85%B3/CollectionView-%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><h2 id="基本实现注意点"><a class="markdownIt-Anchor" href="#基本实现注意点"></a> 基本实现注意点</h2><p>CollectionView 在呈现的数据和用于呈现该数据的视觉元素之间保持严格的区分（view + layout）。</p><p>基本使用的过程：</p><ol><li>自己的布局对象：子类化 layout</li><li>自定义 collectionView 中的 item（cell，supplementary views 和 decoration views）</li><li>在layout 的 <code>prepare</code> 方法中计算出所有 attribute（用来修饰 cell，supplementary views 和 decoration views）并缓存在 layout 对象中<ol><li>每个 attribute 的indexPath，frame，zIndex ……</li><li>根据 attribute 计算出 collectionViewContentSize</li><li>计算 attribute 的数据可以给 layout 自定义一个 delegate 协议，让他去向 collectionView 拿</li></ol></li><li><code>layoutAttributesForElementsInRect</code> 获取视图的可见矩形区域中的所有 UICollectionViewLayoutAttributes，类似实现 <code>layoutAttributesForItem:atIndexPath</code>， <code>layoutAttributesForSupplementaryViewOfKind:atIndexPath</code> ，<code>layoutAttributesForDecorationViewOfKind:atIndexPath</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以使用 binaryTree 算法，将复杂度降到 O(log(n))</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForElements</span><span class="params">(<span class="keyword">in</span> rect: CGRect)</span></span> -&gt; [<span class="type">UICollectionViewLayoutAttributes</span>]? &#123;</span><br><span class="line">  <span class="keyword">var</span> visibleLayoutAttributes: [<span class="type">UICollectionViewLayoutAttributes</span>] = []</span><br><span class="line">  <span class="keyword">for</span> attributes <span class="keyword">in</span> cache &#123;</span><br><span class="line">    <span class="keyword">if</span> attributes.frame.intersects(rect) &#123;</span><br><span class="line">      visibleLayoutAttributes.append(attributes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> visibleLayoutAttributes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutAttributesForItem</span><span class="params">(at indexPath: IndexPath)</span></span> -&gt; <span class="type">UICollectionViewLayoutAttributes?</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> cache[indexPath.item]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>是否刷新页面</li></ol><blockquote><p>当 collection view 的 bounds 改变时，布局需要告诉 collection view 是否需要重新计算布局。我的猜想是：当 collection view 改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个幼稚的实现可能只会简单的返回 YES。虽然实现功能很重要，但是 scroll view 的 bounds 在滚动时也会改变，这意味着你的布局每秒会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。<br>当 collection view 的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view 将它的新 bounds 传给 shouldInvalidateLayoutForBoundsChange: 方法。这样我们便能比较视图当前的bounds 和新的 bounds 来确定返回值：</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">shouldInvalidateLayout</span><span class="params">(forBoundsChange newBounds: CGRect)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> oldBounds = collectionView?.bounds</span><br><span class="line">  <span class="keyword">if</span> newBounds.width != oldBounds?.width &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析-uicollectionviewh-中的类结构"><a class="markdownIt-Anchor" href="#分析-uicollectionviewh-中的类结构"></a> 分析 UICollectionView.h 中的类结构</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">UICollectionView</span>, <span class="title">UICollectionReusableView</span>, <span class="title">UICollectionViewCell</span>, <span class="title">UICollectionViewLayout</span>, <span class="title">UICollectionViewTransitionLayout</span>, <span class="title">UICollectionViewLayoutAttributes</span>, <span class="title">UITouch</span>, <span class="title">UINib</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">UIDragItem</span>, <span class="title">UIDragPreviewParameters</span>, <span class="title">UIDragPreviewTarget</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">UICollectionViewDropProposal</span>, <span class="title">UICollectionViewPlaceholder</span>, <span class="title">UICollectionViewDropPlaceholder</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">UIContextMenuConfiguration</span>, <span class="title">UITargetedPreview</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIContextMenuInteractionCommitAnimating</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIDataSourceTranslating</span>, <span class="title">UISpringLoadedInteractionContext</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UIDragSession</span>, <span class="title">UIDropSession</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">UICollectionViewDragDelegate</span>, <span class="title">UICollectionViewDropDelegate</span>, <span class="title">UICollectionViewDropCoordinator</span>, <span class="title">UICollectionViewDropItem</span>, <span class="title">UICollectionViewDropPlaceholderContext</span>;</span></span><br></pre></td></tr></table></figure><p>引用：</p><blockquote><p><a href="https://objccn.io/issue-3-3/" target="_blank" rel="noopener">自定义 Collection View 布局</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c 可变参数宏整理</title>
      <link href="/2017/06/01/c-%E5%AE%8F%E6%95%B4%E7%90%86/"/>
      <url>/2017/06/01/c-%E5%AE%8F%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="__va_args__和__va_args__的作用"><a class="markdownIt-Anchor" href="#__va_args__和__va_args__的作用"></a> #、##、__VA_ARGS__和##__VA_ARGS__的作用</h2><h3 id="用来把参数转换成字符串"><a class="markdownIt-Anchor" href="#用来把参数转换成字符串"></a> <code>#</code>用来把参数转换成字符串</h3><p>实例1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P(A) printf(<span class="meta-string">"%s:%d\n"</span>,#A,A);</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123; </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>; </span><br><span class="line">  P(a); </span><br><span class="line">  P(b); </span><br><span class="line">  P(a+b); </span><br><span class="line">  system(<span class="string">"pause"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">1</span></span><br><span class="line">b:<span class="number">2</span></span><br><span class="line">a+b:<span class="number">3</span></span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SQUARE(x) printf(<span class="meta-string">"The square of "</span>#x<span class="meta-string">" is %d.\n"</span>, ((x)*(x)));</span></span><br><span class="line">SQUARE(<span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>输出的是：The square of 8 is 64</p><h3 id="运算符可以用于宏函数的替换部分"><a class="markdownIt-Anchor" href="#运算符可以用于宏函数的替换部分"></a> <code>##</code>运算符可以用于宏函数的替换部分</h3><p>这个运算符把两个语言符号组合成单个语言符号，为宏扩展提供了一种连接实际变元的手段</p><p>实例1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XNAME(n) x ## n</span></span><br></pre></td></tr></table></figure><p>如果这样使用宏：XNAME(8)</p><p>则会被展开成这样：x8</p><p><code>##</code>就是个粘合剂，将前后两部分粘合起来，也就是有“字符化”的意思。但是“##”不能随意粘合任意字符，必须是合法的C语言标示符。在单一的宏定义中，最多可以出现一次“#”或“##”预处理操作符。如果没有指定与“#”或“##”预处理操作符相关的计算次序，则会产生问题。为避免该问题，在单一的宏定义中只能使用其中一种操作符(即，一份“#”或一个“##”，或都不用)。除非非常有必要，否则尽量不要使用“#”和“##”。</p><h3 id="__va_args__-是一个可变参数的宏"><a class="markdownIt-Anchor" href="#__va_args__-是一个可变参数的宏"></a> <code>__VA_ARGS__</code> 是一个可变参数的宏</h3><p>这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。<br>实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。</p><h3 id="__va_args__"><a class="markdownIt-Anchor" href="#__va_args__"></a> <code>##__VA_ARGS__</code></h3><p>宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&quot;,&quot;去掉的作用,否则会编译出错</p><p>一般这个用在调试信息上多一点<br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> my_print1(...)  printf(\_\_VA_ARGS__)</span></span><br><span class="line">my_print1(<span class="string">"i=%d,j=%d\n"</span>,i,j)  正确打印</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> my_print2(fmt,...)  printf(fmt, \_\_VA_ARGS__)  </span></span><br><span class="line"></span><br><span class="line">my_print1(<span class="string">"i=%d,j=%d\n"</span>,i,j) 正确打印</span><br><span class="line"></span><br><span class="line">my_print1(<span class="string">"iiiiiii\n"</span>) 编译失败打印，因为扩展出来只有一个参数，至少要两个及以上参数</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">如果是<span class="meta">#<span class="meta-keyword">define</span> my_print2(fmt,...)  printf(fmt,##\_\_VA_ARGS__)  </span></span><br><span class="line"></span><br><span class="line">那么 my_print1 里面不管是几个参数都能正确打印</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MODULE_NAME <span class="meta-string">"MY_LIB"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> error_print(fmt, ...)  printf(<span class="meta-string">"[ERROR]["</span>MODULE_NAME<span class="meta-string">"](%s|%d)"</span> fmt, __func__, __LINE__, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h2 id="c-库宏-va_start"><a class="markdownIt-Anchor" href="#c-库宏-va_start"></a> C 库宏 - va_start()</h2><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 开发语言 </category>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Masonry 分析</title>
      <link href="/2017/06/01/source-code/Masonry-%E5%88%86%E6%9E%90/"/>
      <url>/2017/06/01/source-code/Masonry-%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>分析源码：</p><p>分析源码前想想怎么看源码：</p><ol><li>目的：这个第三方库，他是为了解决什么问题的？</li><li>技术起源：效果实现的核心技术是什么？</li><li>设计模式：整体结构是什么样的？</li><li>该怎么入手：由外而内逐层分析层次结构？</li></ol><h2 id="masonry-是什么"><a class="markdownIt-Anchor" href="#masonry-是什么"></a> Masonry 是什么</h2><p><a href="https://github.com/SnapKit/Masonry" target="_blank" rel="noopener">Masonry源码</a></p><ul><li>Masonry是一个轻量级的布局框架，它以更好的语法包装了AutoLayout</li><li>Masonry拥有自己的布局DSL，它提供了可链式语法来描述NSLayoutConstraints，从而使布局代码更简洁易读。<br>（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言）</li></ul><h2 id="为什么要设计-masonry"><a class="markdownIt-Anchor" href="#为什么要设计-masonry"></a> 为什么要设计 Masonry</h2><p>对比一下 AutoLayout 中使用 <code>NSLayoutConstraint</code> 是多么糟糕</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIView</span> *superview = <span class="keyword">self</span>.view;</span><br><span class="line"><span class="built_in">UIView</span> *view1 = [[<span class="built_in">UIView</span> alloc] init];</span><br><span class="line">view1.translatesAutoresizingMaskIntoConstraints = <span class="literal">NO</span>;</span><br><span class="line">view1.backgroundColor = [<span class="built_in">UIColor</span> greenColor];</span><br><span class="line">[superview addSubview:view1];</span><br><span class="line"></span><br><span class="line"><span class="built_in">UIEdgeInsets</span> padding = <span class="built_in">UIEdgeInsetsMake</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">[superview addConstraints:@[</span><br><span class="line">  <span class="comment">//view1 constraints</span></span><br><span class="line">  [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                    toItem:superview</span><br><span class="line">                 attribute:<span class="built_in">NSLayoutAttributeTop</span></span><br><span class="line">                multiplier:<span class="number">1.0</span></span><br><span class="line">                  constant:padding.top],</span><br><span class="line">  ... bottom, left</span><br><span class="line">  [<span class="built_in">NSLayoutConstraint</span> constraintWithItem:view1</span><br><span class="line">                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                 relatedBy:<span class="built_in">NSLayoutRelationEqual</span></span><br><span class="line">                    toItem:superview</span><br><span class="line">                 attribute:<span class="built_in">NSLayoutAttributeRight</span></span><br><span class="line">                multiplier:<span class="number">1</span></span><br><span class="line">                  constant:-padding.right],</span><br><span class="line"> ]];</span><br></pre></td></tr></table></figure><p>如果使用 Masonry<br><span id="code1"></span></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.edges.equalTo(superview).insets(padding);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>P.S. Masonry 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = NO;</p><p>Masonry 设计的目的，就是以链式编程手段封装 <code>NSLayoutConstraint</code> 冗余代码！<br><span id="questions"></span></p><ol><li>如何处理原来繁杂接口</li><li>如何实现链式</li><li>如何封装 <code>NSLayoutConstraint</code> 的</li><li>使用了何种编程手段整体架构设计，设计模式，语法技巧</li></ol><p>带着这些问题，根据源码结构分析出来</p><hr><h2 id="masonry-代码结构分析"><a class="markdownIt-Anchor" href="#masonry-代码结构分析"></a> Masonry 代码结构分析</h2><h3 id="从调用层次分析"><a class="markdownIt-Anchor" href="#从调用层次分析"></a> 从调用层次分析</h3><p>先根据函数调用一层一层的找</p><ol><li>最外层接口</li></ol><p><a href="#code1">根据这段代码分析</a><br>UIView category 中实现 View+MASAdditions.h (View+MASShorthandAdditions.h)</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define MAS_VIEW UIView</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MAS_VIEW</span> (<span class="title">MASAdditions</span>)</span></span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_makeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_updateConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;</span><br><span class="line">- (<span class="built_in">NSArray</span> *)mas_remakeConstraints:(<span class="keyword">void</span>(^)(MASConstraintMaker *make))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NSLayoutAttribute properties</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_left;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_top;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_right;</span><br><span class="line">...还有很多布局属性这里省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *(^mas_attribute)(<span class="built_in">NSLayoutAttribute</span> attr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_firstBaseline;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_lastBaseline;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a key to associate with this view</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> mas_key;</span><br></pre></td></tr></table></figure><ul><li>mas_left, mas_right …… 三个见名知意的方法</li><li>方法参数 <code>MASConstraintMaker</code> 这个就是 make</li><li>属性 <code>MASViewAttribute</code> 这个就是 make 后面的 make.edges</li><li><code>id mas_key</code> 这个是啥，目前不知道</li></ul><p>我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口<br>我还要找到下图的这些信息目前看不出来端倪<br><img src="/img/view_formula.jpeg" alt="view formula"></p><ol start="2"><li>接着往里面看</li></ol><ul><li>MASViewAttribute: 一个不可变元组，存着 receiver view, related view 和关联的 <code>NSLayoutAttribute</code> [根据文档注释]</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) MAS_VIEW *view;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> item;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSLayoutAttribute</span> layoutAttribute;</span><br></pre></td></tr></table></figure><p>目前理解为下图等式的相关信息</p><ul><li>MASConstraintMaker：<br>提供一个工厂方法来创建 <code>MASConstraints</code>, 这些 constraints 只有在被 installed 的时候才会被收集<code>根据文档注释</code></li></ul><p>MASConstraintMaker.h</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *firstBaseline;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *lastBaseline;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是干啥的？</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *(^attributes)(MASAttribute attrs);</span><br></pre></td></tr></table></figure><ul><li>MASConstraint？跟 <code>NSLayoutConstraint</code> 好像<ul><li>允许使用可链接的语法创建约束</li><li>约束可以表示单个 NSLayoutConstraint（MASViewConstraint）</li><li>或一组 NSLayoutConstraints（MASComposisteConstraint）</li></ul></li></ul><p>bingo，到这里下面这两个问题有眉目了, <a href="#questions">最开始的几个问题</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span> 如何实现链式</span><br><span class="line"><span class="number">3.</span> 如何封装 `NSLayoutConstraint` 的</span><br></pre></td></tr></table></figure><hr><h3 id="分析-masonry-链式封装"><a class="markdownIt-Anchor" href="#分析-masonry-链式封装"></a> 分析 <code>Masonry</code> 链式封装</h3><h4 id="主要组件结构"><a class="markdownIt-Anchor" href="#主要组件结构"></a> 主要组件结构</h4><ol><li>MASConstraintMaker</li><li>MASConstraint<ol><li>MASViewConstraint</li><li>MASComposisteConstraint</li></ol></li><li>MASConstraintDelegate</li></ol><p><img src="/img/masonry-frame.jpg" alt="masonry 主要组件"></p><hr><h4 id="使用函数调用栈分析"><a class="markdownIt-Anchor" href="#使用函数调用栈分析"></a> 使用函数调用栈分析</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">  make.top.equalTo(superview.mas_top).with.offset(padding); <span class="comment">//with with</span></span><br><span class="line">  make.left.equalTo(greenView.mas_right).offset(padding);   <span class="comment">//without with</span></span><br><span class="line">  make.bottom.equalTo(blueView.mas_top).offset(-padding);</span><br><span class="line">  make.right.equalTo(superview.mas_right).offset(-padding);</span><br><span class="line">  make.width.equalTo(greenView.mas_width);</span><br><span class="line">  make.height.equalTo(@[greenView, blueView]);              <span class="comment">//can pass array of views</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><details><summary>masonry call stack step1: 主流程</summary><pre><p><img src="/img/masonry-step1.jpeg" alt="step1"><br></p></pre><p></p></details><details><summary>masonry call stack step2：调用block 收集布局信息</summary><pre><p><img src="/img/masonry-step2.jpeg" alt="step2"><br></p></pre><p></p></details><details><summary>masonry call stack step3：install constraints</summary><pre><p><img src="/img/masonry-step3.jpeg" alt="step3"><br></p></pre><p></p></details><p>整体流程&amp;核心调用栈分析结束后，接下来再看细节技巧就容易多了</p><h3 id="代码组件分析"><a class="markdownIt-Anchor" href="#代码组件分析"></a> 代码组件分析</h3><ol><li>MASConstraintMaker</li><li>MASConstraint<ol><li>MASViewConstraint</li><li>MASComposisteConstraint</li></ol></li><li>MASConstraintDelegate</li><li>MASViewAttribute</li></ol><ul><li><p><code>NSLayoutConstraint</code> 的问题</p><ul><li>布局数据分散，使用命令式方法调用，接口参数就是布局属性，导致用户使用闹心</li></ul></li><li><p>Masonry 是如何解决这个问题的呢？</p><ol><li>需要创建对象保存 model 数据</li><li>创建链节点(把大量参数以链节点的方式逐一放在节点中（MASViewConstraint节点）)</li><li>调用系统 <code>NSLayoutConstraint</code> 方法</li></ol></li><li><p>整体步骤：</p><ol><li>node1: 创建 MASConstraint 节点，绑定第一个 item1 和 attr1</li><li>node2: 创建 MASViewAttribute(item2, attr2)，并添加等式的 relation (block 闭包调用)</li><li>node3: 添加 valueOffset，priority，divideBy …… 常量数据 （block 闭包低啊用）</li><li>block 结束，所有 constraint 配置完，进行 install 内部调用 <code>NSLayoutConstraint</code> 方法，把复杂的方法封装在内部</li></ol></li></ul><hr><h4 id="model-层数据"><a class="markdownIt-Anchor" href="#model-层数据"></a> model 层数据</h4><p>根据这个等式 等式信息：<br><img src="/img/view_formula.jpeg" alt="view formula"></p><p><strong>创建一个 constraint 需要：</strong></p><ol><li>两对（view, attr)</li><li>relation</li><li>mulity</li><li>constant</li><li>priority</li></ol><ul><li>MASViewAttribute 元组封装 (item, constraintAttr)</li><li>MASViewConstraint 在 MASViewAttribute 基础上封装 (mas_attr = 1.0 * mas_attr + constant)</li></ul><h5 id="生成-masviewattribute-的方式"><a class="markdownIt-Anchor" href="#生成-masviewattribute-的方式"></a> 生成 <strong>MASViewAttribute</strong> 的方式</h5><ol><li>UIView+MASAdditions</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算属性</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_left;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_top;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_right;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASViewAttribute *mas_bottom;</span><br><span class="line"></span><br><span class="line">- (MASViewAttribute *)mas_left &#123;</span><br><span class="line">  <span class="keyword">return</span> [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span> layoutAttribute:<span class="built_in">NSLayoutAttributeLeft</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>MASConstraintMaker</code> 生成链条节点 <code>MASConstraint</code> 时，使用工厂方法内部配置 <code>MASViewAttribute</code></li></ol><h5 id="masconstraint-配置过程"><a class="markdownIt-Anchor" href="#masconstraint-配置过程"></a> <strong>MASConstraint</strong> 配置过程</h5><p><code>make.bottom.equalTo(blueView.mas_top).offset(-padding);</code></p><ol><li>attr1: 由 MASConstraintMaker 中的计算属性方法创建 make.top.left</li><li>relation: 由 MASConstraint 中的方法 equalTo 添加</li><li>attr2: 由 UIView+MASAdditions 扩展方法得到</li><li>offset: 由 MASConstraint 中的方法 equalTo 添加</li><li>priority: 由 MASConstraint 中的方法 priority 添加</li></ol><p><img src="/img/masonry_frame2.jpg" alt=""></p><hr><h4 id="布局工厂-masconstraintmaker"><a class="markdownIt-Anchor" href="#布局工厂-masconstraintmaker"></a> 布局工厂 MASConstraintMaker</h4><p>他的 product 是 <code>MASConstraint</code></p><ol><li>他的工厂方法</li></ol><p><span id="anchor"></span></p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 计算属性，我理解为工厂方法</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *left;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *top;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *right;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) MASConstraint *bottom;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算属性的 get 方法</span></span><br><span class="line">- (MASConstraint *)top &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> addConstraintWithLayoutAttribute:<span class="built_in">NSLayoutAttributeTop</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (MASConstraint *)addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> constraint:<span class="literal">nil</span> addConstraintWithLayoutAttribute:layoutAttribute];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 真正的工厂方法，同时 他也是 给 constraint 添加 NSLayoutAttribute 的地方</span></span><br><span class="line">- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(<span class="built_in">NSLayoutAttribute</span>)layoutAttribute &#123;</span><br><span class="line"></span><br><span class="line">  MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:<span class="keyword">self</span>.view layoutAttribute:layoutAttribute];</span><br><span class="line">  MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.2 make.top.left.equalTo(superview).insets(padding); [left 节点的时候调用，产生第二个 节点以后所有节点的方法]</span></span><br><span class="line">  <span class="keyword">if</span> ([constraint isKindOfClass:MASViewConstraint.class]) &#123;</span><br><span class="line">    <span class="comment">//replace with composite constraint</span></span><br><span class="line">    <span class="built_in">NSArray</span> *children = @[constraint, newConstraint];</span><br><span class="line">    MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children];</span><br><span class="line">    compositeConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span> constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint];</span><br><span class="line">    <span class="keyword">return</span> compositeConstraint;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 make.top.left.equalTo(superview).insets(padding); [top 节点的时候调用，产生第一个 节点的方法]</span></span><br><span class="line">  <span class="keyword">if</span> (!constraint) &#123;</span><br><span class="line">    newConstraint.delegate = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.constraints addObject:newConstraint];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newConstraint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>得出结论：</strong></p><ol><li>根据上面代码中的 2.1，2.2 知道 make.left.right.top…… 会生产 3 个 MASViewConstraint，并组合到 MASCompositeConstraint 里面</li></ol><p>2333 这就知道了 为什么要有 MASCompositeConstraint，他的一个作用就是 实现链式兼容啊！（因为赤裸裸的 3个 MASViewConstraint，怎么变成一个 节点啊）<br>那么问题又来了，make.left.right.top(view)，是怎么实现 left = view.left, right = view.right …… 的呢？</p><ol start="2"><li>等式关系，使用函数表示，内部直接把对应 relation 配置给 constraint</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> attr))mas_equalTo;</span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> attr))mas_greaterThanOrEqualTo;</span><br><span class="line">- (MASConstraint * (^)(<span class="keyword">id</span> attr))mas_lessThanOrEqualTo;</span><br></pre></td></tr></table></figure><ol start="3"><li>接下来的链式都是用函数闭包的方式，把参数传给 constraint 的 [闭包格式 MASConstraint * (^)(parameter 参数)]</li><li>MASConstraintDelegate 是工厂方法协议, 从 <a href="#anchor">这段代码的 2 看</a>，他是让 constraint 生成 constraint 的方法过渡点。<ol><li>他是为了满足 make.top.left 中 top.left 通过 topConstraint 生成一个 leftConstraint的方法</li></ol></li><li>所以对于链式编程技巧：<ol><li>链条的开始，创建成链的起始节点对象</li><li>一条链上应该只有一个对象，后面的所有节点都是对于这个对象的属性配置添加</li><li>如果同一条链上有多个对象，那么使用组合模式，把多个节点对象封装成一个节点对象</li></ol></li></ol><p><img src="/img/masonry-call-stack.jpg" alt="从上面得到"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为什么要使用闭包传？使用方法消息传不好吗？</span><br><span class="line">好像就是为了不要 `[]` 这个符号吧……，使用 `.` 链式调用看着好看</span><br></pre></td></tr></table></figure><hr><h3 id="其他开发细节分析"><a class="markdownIt-Anchor" href="#其他开发细节分析"></a> 其他开发细节分析</h3><p>下面这些是啥？<br>都是一些 c 语言的宏，在其他文章里分析过了</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MASUtilities.h</span></span><br><span class="line"><span class="meta">#define MASAttachKeys(...)                                                        \</span></span><br><span class="line">  &#123;                                                                             \</span><br><span class="line">    <span class="built_in">NSDictionary</span> *keyPairs = <span class="built_in">NSDictionaryOfVariableBindings</span>(__VA_ARGS__);     \</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> keyPairs.allKeys) &#123;                                        \</span><br><span class="line">      <span class="keyword">id</span> obj = keyPairs[key];                                               \</span><br><span class="line">      <span class="built_in">NSAssert</span>([obj respondsToSelector:<span class="keyword">@selector</span>(setMas_key:)],             \</span><br><span class="line">               <span class="string">@"Cannot attach mas_key to %@"</span>, obj);                        \</span><br><span class="line">      [obj setMas_key:key];                                                 \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> _MASBoxValue(<span class="keyword">const</span> <span class="keyword">char</span> *type, ...)</span><br><span class="line"><span class="meta">#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//View+MASShorthandAdditions.h</span></span><br><span class="line"><span class="meta">#define MAS_ATTR_FORWARD(attr)  \</span></span><br><span class="line">- (MASViewAttribute *)attr &#123;    \</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mas_<span class="meta">##attr];   \</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define MAS_ATTR_FORWARD_AVAILABLE(attr, available)  \</span></span><br><span class="line">- (MASViewAttribute *)attr available &#123;    \</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> mas_<span class="meta">##attr];   \</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//MASConstraint.h</span></span><br><span class="line"><span class="meta">#define mas_equalTo(...)                 equalTo(MASBoxValue((__VA_ARGS__)))</span></span><br><span class="line"><span class="meta">#define mas_greaterThanOrEqualTo(...)    greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__)))</span></span><br><span class="line"><span class="meta">#define mas_lessThanOrEqualTo(...)       lessThanOrEqualTo(MASBoxValue((__VA_ARGS__)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define mas_offset(...)                  valueOffset(MASBoxValue((__VA_ARGS__)))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#ifdef MAS_SHORTHAND_GLOBALS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define equalTo(...)                     mas_equalTo(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define greaterThanOrEqualTo(...)        mas_greaterThanOrEqualTo(__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#define lessThanOrEqualTo(...)           mas_lessThanOrEqualTo(__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#define offset(...)                      mas_offset(__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h4 id="runtime-的运用"><a class="markdownIt-Anchor" href="#runtime-的运用"></a> runtime 的运用</h4><p>主要是给 view 添加关联对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MASViewConstraint.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MAS_VIEW</span> (<span class="title">MASConstraints</span>)</span></span><br><span class="line"><span class="comment">// 见名知意</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableSet</span> *mas_installedConstraints; </span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MAS_VIEW</span> (<span class="title">MASConstraints</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> kInstalledConstraintsKey; </span><br><span class="line">- (<span class="built_in">NSMutableSet</span> *)mas_installedConstraints &#123;</span><br><span class="line">  <span class="built_in">NSMutableSet</span> *constraints = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;kInstalledConstraintsKey);</span><br><span class="line">  <span class="keyword">if</span> (!constraints) &#123;</span><br><span class="line">    constraints = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;kInstalledConstraintsKey, constraints, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> constraints;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//View+MASAdditions.m</span></span><br><span class="line">- (<span class="keyword">id</span>)mas_key &#123;</span><br><span class="line">  <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(mas_key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setMas_key:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">  objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(mas_key), key, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mas_key 是为了调试布局用的</p><ul><li><a href="https://www.jianshu.com/p/710f742ca71a" target="_blank" rel="noopener">Masonry 布局冲突快速定位</a></li><li><a href="https://www.jianshu.com/p/e36db45b764a" target="_blank" rel="noopener">如何快速定位哪个 View 出现了约束警告？</a></li></ul><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="noopener">Auto Layout Guide</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> UI 布局 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS View 编程指南</title>
      <link href="/2017/05/15/UI%20%E7%9B%B8%E5%85%B3/iOS-View-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/"/>
      <url>/2017/05/15/UI%20%E7%9B%B8%E5%85%B3/iOS-View-%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="view-和-window-架构"><a class="markdownIt-Anchor" href="#view-和-window-架构"></a> View 和 Window 架构</h2><h3 id="view-结构基础"><a class="markdownIt-Anchor" href="#view-结构基础"></a> View 结构基础</h3><p>layer 管理 view 辅助存储器，处理view 相关的动画。</p><h4 id="view-层级和子view-管理"><a class="markdownIt-Anchor" href="#view-层级和子view-管理"></a> View 层级和子view 管理</h4><h4 id="view-绘制循环"><a class="markdownIt-Anchor" href="#view-绘制循环"></a> View 绘制循环</h4><p>UIView类使用按需绘制模型来呈现内容。当视图首次出现在屏幕上时，系统要求它绘制其内容。系统捕获该内容的快照并将该快照用作 view 的视觉表示。如果不更改视图的内容，则可能永远不会再次调用视图的绘图代码。快照图像可用于涉及视图的大多数操作。如果更改了内容，则会通知系统视图已更改。然后，视图重复绘制视图和捕获新结果快照的过程。当视图的内容更改时，您不会直接重绘这些更改。而是使用setNeedsDisplay或setNeedsDisplayInRect：方法使视图无效。这些方法告诉系统视图的内容已更改，并且需要在下一个机会重新绘制。在启动任何绘图操作之前，系统将一直等到当前运行循环结束。这种延迟使你有机会一次使多个视图无效，从层次结构中添加或删除视图，隐藏视图，调整视图大小以及重新放置视图。所做的所有更改都将同时反映出来。</p><p>问题：都有什么方式可以出发视图重新绘制？</p><h4 id="内容-modes"><a class="markdownIt-Anchor" href="#内容-modes"></a> 内容 Modes</h4><h4 id="可拉伸-views"><a class="markdownIt-Anchor" href="#可拉伸-views"></a> 可拉伸 Views</h4><h4 id="内建动画支持"><a class="markdownIt-Anchor" href="#内建动画支持"></a> 内建动画支持</h4><h3 id="view-几何和坐标系"><a class="markdownIt-Anchor" href="#view-几何和坐标系"></a> View 几何和坐标系</h3><h4 id="the-relationship-of-the-frame-bounds-and-center-properties"><a class="markdownIt-Anchor" href="#the-relationship-of-the-frame-bounds-and-center-properties"></a> The Relationship of the Frame, Bounds, and Center Properties</h4><h4 id="坐标系转换"><a class="markdownIt-Anchor" href="#坐标系转换"></a> 坐标系转换</h4><p>CGContextGetCTM<br>Returns the current transformation matrix.</p><h4 id="points-versus-pixels"><a class="markdownIt-Anchor" href="#points-versus-pixels"></a> Points Versus Pixels</h4><h3 id="the-runtime-interaction-model-for-views"><a class="markdownIt-Anchor" href="#the-runtime-interaction-model-for-views"></a> The Runtime Interaction Model for Views</h3><h3 id="tips-for-using-views-effectively"><a class="markdownIt-Anchor" href="#tips-for-using-views-effectively"></a> Tips for Using Views Effectively</h3><h4 id="views-do-not-always-have-a-corresponding-view-controller"><a class="markdownIt-Anchor" href="#views-do-not-always-have-a-corresponding-view-controller"></a> Views Do Not Always Have a Corresponding View Controller</h4><h4 id="minimize-custom-drawing"><a class="markdownIt-Anchor" href="#minimize-custom-drawing"></a> Minimize Custom Drawing</h4><h4 id="take-advantage-of-content-modes"><a class="markdownIt-Anchor" href="#take-advantage-of-content-modes"></a> Take Advantage of Content Modes</h4><h4 id="declare-views-as-opaque-whenever-possible"><a class="markdownIt-Anchor" href="#declare-views-as-opaque-whenever-possible"></a> Declare Views as Opaque Whenever Possible</h4><h4 id="adjust-your-views-drawing-behavior-when-scrolling"><a class="markdownIt-Anchor" href="#adjust-your-views-drawing-behavior-when-scrolling"></a> Adjust Your View’s Drawing Behavior When Scrolling</h4><h4 id="do-not-customize-controls-by-embedding-subviews"><a class="markdownIt-Anchor" href="#do-not-customize-controls-by-embedding-subviews"></a> Do Not Customize Controls by Embedding Subviews</h4><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> Guide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 面向协议编程</title>
      <link href="/2017/05/14/swift%20%E8%AF%AD%E6%B3%95/Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/"/>
      <url>/2017/05/14/swift%20%E8%AF%AD%E6%B3%95/Swift-%E9%9D%A2%E5%90%91%E5%8D%8F%E8%AE%AE%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><p>WWDC 2015<br>Developer Tools<br>Protocol-Oriented Programming in Swift<br>Session 408</p><h2 id="class"><a class="markdownIt-Anchor" href="#class"></a> Class</h2><p>面向对象的设计思想</p><ol><li>封装：把相关数据和操作进行分组</li><li>访问控制：构建一面墙把里面代码和外面代码分开</li><li>抽象接口：抽象接口表达类的作用和通讯功能</li><li>命名空间：避免代码名称冲突</li><li>Expressive syntax：表达式语法（下标扩展）</li><li>extension 扩展性：忘了给类加东西，可以使用 extension 给他加上</li></ol><p>但是，在 swift 里上面的这些都可以用 struct or enum 做</p><p>Building Better Apps with Value Types in Swift</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> WWDC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> WWDC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RAC-学习笔记01</title>
      <link href="/2017/04/06/RxSwfit+RAC/RAC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
      <url>/2017/04/06/RxSwfit+RAC/RAC-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="学习目的"><a class="markdownIt-Anchor" href="#学习目的"></a> 学习目的</h2><ol><li>知道 rac 都有什么</li><li>知道他们都怎么用</li><li>知道为什么有这些东西</li><li>根类归纳整理</li><li>如何自己扩展</li><li>适当分析源码</li></ol><h2 id="主要概念"><a class="markdownIt-Anchor" href="#主要概念"></a> 主要概念</h2><ol><li>信号</li><li>信号变换&amp;组合</li><li>订阅（绑定）</li><li>取消订阅</li></ol><p><img src="/img/RACStream.jpeg" alt="RACStream"></p><p>RACSignal : 基于时间的异步事件流</p><p>RACSequence : 惰性集合，同步（很少用），collection类型的封装，可以使用 Stream（monad）封装的函数式方式</p><h2 id="如何创建信号"><a class="markdownIt-Anchor" href="#如何创建信号"></a> 如何创建信号</h2><h3 id="单元信号"><a class="markdownIt-Anchor" href="#单元信号"></a> 单元信号</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *sig0 = [RACSignal error:<span class="built_in">NSError</span>.new];</span><br><span class="line">RACSignal *sig1 = [RACSignal <span class="keyword">return</span>:@<span class="number">0</span>];</span><br><span class="line">RACSignal *sig2 = [RACSignal empty];</span><br><span class="line">RACSignal *sig3 = [RACSignal never];</span><br></pre></td></tr></table></figure><h3 id="动态信号"><a class="markdownIt-Anchor" href="#动态信号"></a> 动态信号</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *s = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">  [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">  [subscriber sendCompleted];</span><br><span class="line">  <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"></span><br><span class="line">  &#125;];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="cocoa-桥接"><a class="markdownIt-Anchor" href="#cocoa-桥接"></a> Cocoa 桥接</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) bridge &#123;</span><br><span class="line">  RACSignal *sO = RACObserver(<span class="keyword">self</span>, button);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.sigSetFrame = [<span class="keyword">self</span>.button rac_signalForSelector:<span class="keyword">@selector</span>(setFrame:)];</span><br><span class="line">  [_sigSetFrame</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setFrame:%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">self</span>.sigClick = [<span class="keyword">self</span>.button rac_signalForControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">  [_sigClick</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"event: %@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line"></span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignals:_sigClick, <span class="literal">nil</span>]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalsFromArray:@[[_sigClick map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @[@<span class="number">3</span>];</span><br><span class="line">  &#125;]]]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@<span class="number">1</span>)]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) lift:(<span class="keyword">id</span>)value&#123;</span><br><span class="line">  printf(<span class="string">"lift: %s"</span>, __func__);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号变化内部是产生一个新信号的"><a class="markdownIt-Anchor" href="#信号变化内部是产生一个新信号的"></a> 信号变化(内部是产生一个新信号的)</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[_sigClick map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> @[@<span class="number">3</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="序列转换"><a class="markdownIt-Anchor" href="#序列转换"></a> 序列转换</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.sigSequence = [[RACSequence <span class="keyword">return</span>:@<span class="number">3</span>] concat:[RACSequence <span class="keyword">return</span>:@<span class="number">4</span>]].signal;</span><br></pre></td></tr></table></figure><h2 id="订阅绑定信号的方式"><a class="markdownIt-Anchor" href="#订阅绑定信号的方式"></a> 订阅（绑定）信号的方式</h2><h3 id="直接订阅方法"><a class="markdownIt-Anchor" href="#直接订阅方法"></a> 直接订阅方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.sigSample</span><br><span class="line"> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"sample: %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><h3 id="绑定"><a class="markdownIt-Anchor" href="#绑定"></a> 绑定</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RAC(<span class="keyword">self</span>, a) = Signal;</span><br></pre></td></tr></table></figure><h3 id="cocoa-桥接-2"><a class="markdownIt-Anchor" href="#cocoa-桥接-2"></a> Cocoa 桥接</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)signal &#123;</span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignals:_sigClick, <span class="literal">nil</span>]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [[<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalsFromArray:@[[_sigClick map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="keyword">return</span> @[@<span class="number">3</span>];</span><br><span class="line">  &#125;]]]</span><br><span class="line">   subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">  &#125;];</span><br><span class="line">  </span><br><span class="line">  [<span class="keyword">self</span> rac_liftSelector:<span class="keyword">@selector</span>(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@<span class="number">1</span>)]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>) lift:(<span class="keyword">id</span>)value&#123;</span><br><span class="line">  printf(<span class="string">"lift: %s"</span>, __func__);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号变化组合"><a class="markdownIt-Anchor" href="#信号变化组合"></a> 信号变化&amp;组合</h2><ol><li>单个信号的变化</li><li>多个信号的组合</li><li>高阶操作</li></ol><p><img src="/img/signal_transform.jpeg" alt="signal 变化"></p><h3 id="值操作"><a class="markdownIt-Anchor" href="#值操作"></a> 值操作</h3><p>问题：</p><ul><li>为什么会有这样的值操作方法？</li><li>自己如何扩展新的值方法</li></ul><hr><ul><li>transform 这些用的比较多<ol><li>map</li><li>MapReplace</li><li>ReduceEach tuple(a, b) -&gt; c</li></ol></li><li>值判断逻辑变换<ol><li>not</li><li>and</li><li>or</li></ol></li><li>用的比较少<ol><li>reduceApply 这个不太清楚为什么要这么设计，用combineLatest: reduceEach: 就可以做了，而且代码看起来更好。</li><li>materialize</li><li>dematerialize</li></ol></li></ul><h3 id="数量操作"><a class="markdownIt-Anchor" href="#数量操作"></a> 数量操作</h3><ol><li>repeat 一直会有值</li></ol><ul><li><p>条件过滤1</p><ol><li>ignore</li><li>ignoreValues</li><li>distinctUntilChanged</li></ol></li><li><p>条件过滤2</p><ol><li>takeUntilBlock:(BOOL (^)(id x))predicate</li><li>takeWhileBlock:(BOOL (^)(id x))predicate;</li><li>skipUntilBlock:(BOOL (^)(id x))predicate;</li><li>skipWhileBlock:(BOOL (^)(id x))predicate;</li></ol></li><li><p>数量判断，如果有值就发送</p><ol><li>any;</li><li>any:(BOOL (^)(id object))predicateBlock;</li><li>all:(BOOL (^)(id object))predicateBlock;</li></ol></li><li><p>重试</p><ol><li>retry</li><li>retry: Count</li><li>collect <code>汇聚</code> 信号必须有返回值</li></ol></li></ul><p>副作用：<br>– 对于信号值变化以外的一些操作</p><ul><li>doNext</li><li>doCompleted</li><li>doError</li></ul><p><code>折叠函数</code></p><p>不听对一个value 操作，使用折叠函数解决这个问题</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[sig10 aggregateWithStart:@<span class="number">0</span> reduce:^<span class="keyword">id</span>(<span class="keyword">id</span> running, <span class="keyword">id</span> next) &#123;</span><br><span class="line">  <span class="keyword">return</span> @([running intValue] + [next intValue]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><ol><li>(RACSignal *)aggregateWithStart:(id)start reduce:(id (^)(id running, id next))reduceBlock;</li><li>(RACSignal *)aggregateWithStart:(id)start reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock;</li><li>(RACSignal *)aggregateWithStartFactory:(id (^)(void))startFactory reduce:(id (^)(id running, id next))reduceBlock;</li><li>(instancetype)scanWithStart:(id)startingValue reduce:(id (^)(id running, id next))reduceBlock;</li><li>(instancetype)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock;</li></ol><h3 id="时间操作"><a class="markdownIt-Anchor" href="#时间操作"></a> 时间操作</h3><ol><li>+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler;</li><li>+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler withLeeway:(NSTimeInterval)leeway;</li><li>delay</li><li>throttle 阀门，在固定时间内没有新值发送的时候，会发送最后的值</li></ol><h3 id="多个信号组合"><a class="markdownIt-Anchor" href="#多个信号组合"></a> 多个信号组合</h3><p>问题：</p><ol><li>受哪个信号终止而终止？</li><li>错误传递？</li><li>各个信号何时开始开始订阅？</li><li>在哪个线程发出？</li></ol><ul><li>concat<ul><li>第一个结束后，订阅第二个</li><li>第一个error 后，就直接 error</li></ul></li><li>merge</li><li>zip</li><li>combineLatest</li><li>sample</li><li>takeUntil</li><li>takeUntilReplacement, 当 B 来了直接替换 A，开始订阅 B</li></ul><h3 id="信号的高阶操作升阶降阶"><a class="markdownIt-Anchor" href="#信号的高阶操作升阶降阶"></a> 信号的高阶操作（升阶降阶）</h3><ol><li>升阶 S(v) -&gt; S(s(v))</li><li>降阶 S(s(v)) -&gt; S(v)</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *signal = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>].rac_sequence.signal;</span><br><span class="line">RACSignal *signalB = [[signal map:^<span class="keyword">id</span>(<span class="keyword">id</span> value) &#123;</span><br><span class="line">  <span class="keyword">return</span> [[RACSignal <span class="keyword">return</span>:value] delay:<span class="number">1</span>];</span><br><span class="line">&#125;] concat];</span><br></pre></td></tr></table></figure><ul><li><p>降阶操作</p></li><li><p>switchToLatests</p></li></ul><p><img src="/img/switchToLatests.jpeg" alt="switchToLatests"></p><ul><li><p>if/then/else<br><img src="/img/if-then-else.jpeg" alt="if/then/else"></p></li><li><p>switch/cases/default</p></li><li><p>flatten</p></li></ul><p><img src="/img/flatten.jpeg" alt="flatten"></p><p>flatten 类似 merge 只不过一个是接收的 value是 signal，另一个接收的就是 value</p><ul><li>flatten:count 按个数展开信号，当信号个数 &gt; count 以后等待，如果有 sig completed，那么把等待中的sig 放入展开数组里面</li></ul><p><img src="/img/flatten-count.jpeg" alt="flatten-count"></p><p>flatten:1 == concat</p><ul><li>flattenMap</li></ul><p>满足 monad 的部分定义，绝大部分函数都可以使用 flattenMap 实现</p><ul><li>bind</li></ul><p>大部分函数都可以使用 bind 实现</p><h2 id="冷信号热信号"><a class="markdownIt-Anchor" href="#冷信号热信号"></a> 冷信号&amp;热信号</h2><h2 id="一些习题"><a class="markdownIt-Anchor" href="#一些习题"></a> 一些习题</h2><ol><li>如何获得无限递增的信号</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *increment(<span class="keyword">int</span> inc) &#123;</span><br><span class="line">  RACSignal *repeat = [[RACSignal <span class="keyword">return</span>:@(inc)] repeat];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> [[repeat scanWithStart:<span class="number">0</span> reduce:^<span class="keyword">id</span>(<span class="keyword">id</span> running, <span class="keyword">id</span> next) &#123;</span><br><span class="line">    <span class="keyword">return</span> @([running intValue] + [next intValue]);</span><br><span class="line">  &#125;]</span><br><span class="line">  delay:<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>fibonacci</li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *fibonacci() &#123;</span><br><span class="line">  RACSignal *repeat = [[RACSignal <span class="keyword">return</span>:<span class="literal">nil</span>] repeat];</span><br><span class="line">  <span class="keyword">return</span> [repeat scanWithStart:RACTuplePack(@<span class="number">1</span>, @<span class="number">1</span>) reduce:^<span class="keyword">id</span>(RACTuple *running, <span class="keyword">id</span> _) &#123;</span><br><span class="line">    <span class="keyword">int</span> next = [running.first intValue] + [running.second intValue];</span><br><span class="line">    <span class="keyword">return</span> RACTuplePack(running.second, @(next));</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 第三方框架 </category>
          
          <category> ReactiveCocoa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> RAC </tag>
            
            <tag> objc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程&amp;线程间通信</title>
      <link href="/2017/03/09/thread/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/2017/03/09/thread/%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:43 GMT+0800 (CST) --><a id="more"></a><h2 id="一-进程间的通信方式"><a class="markdownIt-Anchor" href="#一-进程间的通信方式"></a> 一、进程间的通信方式</h2><h3 id="管道-pipe"><a class="markdownIt-Anchor" href="#管道-pipe"></a> 管道( pipe )</h3><ul><li>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</li></ul><h3 id="有名管道-namedpipe"><a class="markdownIt-Anchor" href="#有名管道-namedpipe"></a> 有名管道 (namedpipe)</h3><ul><li>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</li></ul><h3 id="信号量semophore"><a class="markdownIt-Anchor" href="#信号量semophore"></a> 信号量(semophore )</h3><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p><h3 id="消息队列-messagequeue"><a class="markdownIt-Anchor" href="#消息队列-messagequeue"></a> 消息队列( messagequeue )</h3><ul><li>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li></ul><h3 id="信号-sinal"><a class="markdownIt-Anchor" href="#信号-sinal"></a> 信号 (sinal )</h3><ul><li>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</li></ul><h3 id="共享内存shared-memory"><a class="markdownIt-Anchor" href="#共享内存shared-memory"></a> 共享内存(shared memory )</h3><ul><li>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。</li></ul><h3 id="套接字socket"><a class="markdownIt-Anchor" href="#套接字socket"></a> 套接字(socket )</h3><ul><li>套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</li></ul><h2 id="二-线程间的通信方式"><a class="markdownIt-Anchor" href="#二-线程间的通信方式"></a> 二、线程间的通信方式</h2><ul><li>锁机制：包括互斥锁、条件变量、读写锁</li><li>互斥锁提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁允许多个线程同时读共享数据，而对写操作是互斥的。</li><li>条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li><li>信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量</li><li>信号机制(Signal)：类似进程间的信号处理</li></ul><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何读代码写代码</title>
      <link href="/2017/03/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%86%99%E4%BB%A3%E7%A0%81/"/>
      <url>/2017/03/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%86%99%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><a id="more"></a><h2 id="怎么读"><a class="markdownIt-Anchor" href="#怎么读"></a> 怎么读</h2><ol><li><p>这个库是用来干嘛？</p></li><li><p>子模块都有什么，子模块都干了什么？画出模块草图</p></li><li><p>核心类有哪些，把核心类的依赖关系用 UML图表示出来</p></li><li><p>分析每个子模块，想想使用了什么技术实现的？他是怎么利用这个技术的，你在开发中如何使用这个技术？</p></li><li><p>针对每个技术原理要清晰</p></li><li><p>看文件结构</p><ol><li>思考作者分了那些模块</li><li>每个模块都是干啥的</li><li>模块联系实际场景是啥，文件上用了哪些架构or设计模式（MVC，MVVM，ViewStateModel，Coordinate，Meditate……）</li><li>模块间是如何联系的——数据流</li><li>了解具体模块细节</li></ol></li><li><p>看具体协议&amp;类的接口</p><ol><li>作者想要给用户提供什么功能</li><li>类的数据出口&amp;入口是什么</li><li>类之间关系使用了什么设计模式，如何提高了复用性</li></ol></li><li><p>看数据流向</p><ol><li>对于文档少&amp;想更深入理解代码，借助 IDE 调试代码，跟踪数据输入输出，看函数调用栈</li><li>根据数据流向可以更清楚类之间的关系</li></ol></li><li><p>看具体实现</p><ol><li>想知道具体细节如何实现的时候，看文件，定位源码位置</li></ol></li></ol><h2 id="怎么写"><a class="markdownIt-Anchor" href="#怎么写"></a> 怎么写</h2><ol><li>确定功能</li><li>根据功能确定模块</li><li>中介者做 Manager 管理各个子模块</li><li>根据模块分文件夹<ol><li>思考模块之间关系，出口入口，相互依赖关系</li></ol></li><li>每个模块写接口——API<ol><li>API 层级关系，抽象层级，高层及实现通用功能</li><li>接口出口入口，依赖注入</li><li>接口之间依赖关系，思考使用何种设计模式</li></ol></li><li>根据模块，实现协议<ol><li>class 开发</li><li>class 之间关系，使用什么设计模式，提高复用效率</li><li>class 的出口入口，依赖注入</li><li>私有成员内部逻辑</li></ol></li></ol><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义控件[转载objccn]</title>
      <link href="/2017/01/13/UI%20%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/"/>
      <url>/2017/01/13/UI%20%E7%9B%B8%E5%85%B3/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><p>可以直接看 <a href="http://objccn.io" target="_blank" rel="noopener">objccn.io</a> 的这篇<a href="https://objccn.io/issue-3-4/" target="_blank" rel="noopener">自定义控件</a></p><ol><li>控件渲染方式</li><li>控件交互方式</li><li>optional 数据源</li></ol><h2 id="视图层次概览"><a class="markdownIt-Anchor" href="#视图层次概览"></a> 视图层次概览</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UIResponder</span><br><span class="line">    ↑</span><br><span class="line">  UIView</span><br><span class="line">    ↑</span><br><span class="line"> UIControl</span><br></pre></td></tr></table></figure><h3 id="uiresponder响应链"><a class="markdownIt-Anchor" href="#uiresponder响应链"></a> UIResponder(响应链)</h3><p>UIResponder 是 UIView 的父类。responder 能够处理触摸、手势、远程控制等事件。之所以它是一个单独的类而没有合并到 UIView 中，是因为 UIResponder 有更多的子类，最明显的就是 UIApplication 和 UIViewController。通过重写 UIResponder 的方法，可以决定一个类是否可以成为<font size="4" color="red">第一响应者 (first responder)</font>，例如当前输入焦点元素。</p><p>当 touches (触摸) 或 motion (指一系列运动传感器) 等交互行为发生时，它们被发送给第一响应者 (通常是一个视图)。如果第一响应者没有处理，则该行为沿着响应链到达视图控制器，如果行为仍然没有被处理，则继续传递给应用。如果想监测晃动手势，可以根据需要在这3层中的任意位置处理。</p><p>UIResponder 还允许自定义输入方法，从 inputAccessoryView 向键盘添加辅助视图到使用 inputView 提供一个完全自定义的键盘。</p><h3 id="uiview渲染layer宿主"><a class="markdownIt-Anchor" href="#uiview渲染layer宿主"></a> UIView(渲染layer宿主)</h3><p>UIView 子类处理所有跟内容绘制有关的事情以及触摸时间。<br>但我们重申一些技巧点:<br>一个普遍错误的概念：视图的区域是由它的 frame 定义的。实际上 <font color="red">frame 是一个派生属性，是由 center 和 bounds 合成而来</font>。不使用 Auto Layout 时，大多数人使用 frame 来改变视图的位置和大小。小心些，<a href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame" target="_blank" rel="noopener">官方文档</a>特别详细说明了一个注意事项:</p><blockquote><p>如果 transform 属性不是 identity transform 的话，那么这个属性的值是未定义的，因此应该将其忽略</p></blockquote><p>另一个允许向视图添加交互的方法是使用<font color="purple">手势识别。注意它们对 responders 并不起作用，而只对视图及其子类奏效</font>。</p><h3 id="uicontrol交互控件"><a class="markdownIt-Anchor" href="#uicontrol交互控件"></a> UIControl(交互控件)</h3><p>UIControl 建立在视图上，增加了更多的交互支持。最重要的是，<font color="purple">它增加了 target / action 模式</font>。看一下具体的子类，我们可以看一下按钮，日期选择器 (Date pickers)，文本框等等。创建交互控件时，你通常想要子类化一个 UIControl。一些常见的像 bar buttons (虽然也支持 target / action) 和 text view (这里需要你使用代理来获得通知) 的类其实并不是 UIControl。</p><h2 id="渲染"><a class="markdownIt-Anchor" href="#渲染"></a> 渲染</h2><p>现在，我们转向可见部分：自定义渲染。正如 Daniel 在他的<a href="http://www.objccn.io/issue-3-1/" target="_blank" rel="noopener">文章</a>中提到的，你可能想避免在 CPU 上做渲染而将其丢给 GPU。这里有一条经验：尽量避免 <code>drawRect:</code>，使用现有的视图构建自定义视图。</p><p><font color="purple">通常最快速的渲染方法是使用图片视图</font>。例如，假设你想画一个带有边框的圆形头像，像下面图片中这样:</p><div align="center"><img src="https://objccn.io/images/issues/issue-3/issue-3-rounded-corners@2x.png" alt="runloop" style="width:200px;height:376px"></div><p>为了实现这个，我们用以下的代码创建了一个图片视图的子类:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called from initializer</span></span><br><span class="line">- (<span class="keyword">void</span>)setupView &#123;</span><br><span class="line">  <span class="keyword">self</span>.clipsToBounds = <span class="literal">YES</span>;</span><br><span class="line">  <span class="keyword">self</span>.layer.cornerRadius = <span class="keyword">self</span>.bounds.size.width / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">self</span>.layer.borderWidth = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">self</span>.layer.borderColor = [<span class="built_in">UIColor</span> darkGrayColor].CGColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我鼓励各位读者<font color="red">深入了解 CALayer 及其属性，因为你用它能实现的大多数事情会比用 Core Graphics 自己画要快</font>。然而一如既往，监测自己的代码的性能是十分重要的。</p><p>把可拉伸的图片和图片视图一起使用也可以极大的提高效率。在 <a href="http://robots.thoughtbot.com/post/33427366406/designing-for-ios-taming-uibutton" target="_blank" rel="noopener">Taming UIButton</a> 这个帖子中，Reda Lemeden 探索了几种不同的绘图方法。在文章结尾处有一个很有价值的<a href="https://news.ycombinator.com/item?id=4645585" target="_blank" rel="noopener">来自 UIKit 团队的工程师 Andy Matuschak 的回复</a>，解释了可拉伸图片是这些技术中最快的。原因是可拉伸图片在 CPU 和 GPU 之间的数据转移量最小，并且这些图片的绘制是经过高度优化的。</p><p>处理图片时，你也可以让 GPU 为你工作来代替使用 Core Graphics。<font color="red">使用 Core Image，你不必用 CPU 做任何的工作就可以在图片上建立复杂的效果</font>。你可以直接在 OpenGL 上下文上直接渲染，所有的工作都在 GPU 上完成。</p><h3 id="自定义绘制"><a class="markdownIt-Anchor" href="#自定义绘制"></a> 自定义绘制</h3><p>如果决定了采用自定义绘制，有几种不同的选项可供选择。如果可能的话，看看是否可以生成一张图片并在内存和磁盘上缓存起来。如果内容是动态的，也许你可以使用 Core Animation，如果还是行不通，使用 Core Graphics。如果你真的想要接近底层，使用 GLKit 和原生 OpenGL 也不是那么难，但是需要做很多工作。</p><p>如果你真的选择了重写 <code>drawRect:</code>，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，这在当视图的 frame 改变时并不会重新绘制。</p><h2 id="自定义交互"><a class="markdownIt-Anchor" href="#自定义交互"></a> 自定义交互</h2><p>自定义控件的时候，你几乎一定会扩展一个 UIControl 的子类。在你的子类里，可以使用 target action 机制触发事件，如下面的例子:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> sendActionsForControlEvents:<span class="built_in">UIControlEventValueChanged</span>];</span><br></pre></td></tr></table></figure><p>为了响应触摸，你可能更倾向于使用手势识别。然而如果想要更接近底层，仍然可以重写 touchesBegan， touchesMoved 和 touchesEnded 方法来访问原始的触摸行为。<br>但虽说如此，<font color="purple">创建一个手势识别的子类来把手势处理相关的逻辑从你的视图或者视图控制器中分离出来，在很多情况下都是一种更合适的方式</font>。</p><p>创建自定义控件时所面对的<font color="red">一个普遍的设计问题是向拥有它们的类中回传返回值</font>。比如，假设你创建了一个绘制交互饼状图的自定义控件，想知道用户何时选择了其中一个部分。你可以用很多种不同的方法来解决这个问题，比如通过 target action 模式，代理，block 或者 KVO，甚至通知。</p><h3 id="使用-target-action"><a class="markdownIt-Anchor" href="#使用-target-action"></a> 使用 Target-Action</h3><p>通常也是最方便的做法是使用 target-action。在用户选择后你可以在自定义的视图中做类似这样的事情:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> sendActionsForControlEvents:<span class="built_in">UIControlEventValueChanged</span>];</span><br></pre></td></tr></table></figure><p>如果有一个视图控制器在管理这个视图，需要这样做:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupPieChart &#123;</span><br><span class="line">  [<span class="keyword">self</span>.pieChart addTarget:<span class="keyword">self</span> </span><br><span class="line">                action:<span class="keyword">@selector</span>(updateSelection:)</span><br><span class="line">      forControlEvents:<span class="built_in">UIControlEventValueChanged</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)updateSelection:(<span class="keyword">id</span>)sender&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="keyword">self</span>.pieChart.selectedSector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么做的好处是在自定义视图子类中需要做的事情很少，并且自动获得多目标支持</p><h3 id="使用代理"><a class="markdownIt-Anchor" href="#使用代理"></a> 使用代理</h3><p>如果你需要更多的控制从视图发送到视图控制器的消息，通常使用代理模式。在我们的饼状图中，代码看起来大概是这样:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.delegate pieChart:<span class="keyword">self</span> didSelectSector:<span class="keyword">self</span>.selectedSector];</span><br></pre></td></tr></table></figure><p>在视图控制器中，你要写如下代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyViewController</span> &lt;<span class="title">PieChartDelegate</span>&gt;</span></span><br><span class="line"> ...</span><br><span class="line">- (<span class="keyword">void</span>)setupPieChart&#123;</span><br><span class="line">  <span class="keyword">self</span>.pieChart.delegate = <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)pieChart:(PieChart*)pieChart didSelectSector:(PieChartSector*)sector&#123;</span><br><span class="line">  <span class="comment">// 处理区块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你想要做更多复杂的工作而不仅仅是通知所有者值发生了变化时，这么做显然更合适。不过虽然大多数开发人员可以非常快速的实现自定义代理，但这种方式仍然有一些缺点：你必须检查代理是否实现了你想要调用的方法 (使用 respondsToSelector:)，最重要的，通常你只有一个代理 (或者需要创建一个代理数组)。也就是说，一旦视图所有者和视图之间的通信变得稍微复杂，我们几乎总是会采取这种模式。</p><h3 id="使用-block"><a class="markdownIt-Anchor" href="#使用-block"></a> 使用 Block</h3><p>另一个选择是使用 block。再一次用饼状图举例，代码看起来大概是这样:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PieChart</span> : <span class="title">UIControl</span> </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">copy</span>) <span class="keyword">void</span>(^selectionHandler)(PieChartSection* selectedSection); </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在选取行为的代码中，你只需要执行它。在此之前检查一下block是否被赋值非常重要，因为执行一个未被赋值的 block 会使程序崩溃。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.selectionHandler != <span class="literal">NULL</span>) &#123;</span><br><span class="line">  <span class="keyword">self</span>.selectionHandler(<span class="keyword">self</span>.selectedSection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法的好处是可以把相关的代码整合在视图控制器中:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupPieChart &#123;</span><br><span class="line">  <span class="keyword">self</span>.pieChart.selectionHandler = ^(PieChartSection* section) &#123;</span><br><span class="line">      <span class="comment">// 处理区块</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就像代理，每个动作通常只有一个 block。另一个重要的限制是不要形成引用循环。如果你的视图控制器持有饼状图的强引用，饼状图持有 block，block 又持有视图控制器，就形成了一个引用循环。只要在 block 中引用 self 就会造成这个错误。所以通常代码会写成这个样子：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">id</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">self</span>.pieChart.selectionHandler = ^(PieChartSection* section) &#123;</span><br><span class="line">  MyViewController* strongSelf = weakSelf;</span><br><span class="line">  [strongSelf handleSectionChange:section];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦 block 中的代码要失去控制 (比如 block 中要处理的事情太多，导致 block 中的代码过多)，你还应该将它们抽离成独立的方法，这种情况的话可能用代理会更好一些。</p><h3 id="使用-kvo"><a class="markdownIt-Anchor" href="#使用-kvo"></a> 使用 KVO</h3><p>如果喜欢 KVO，你也可以用它来观察。这有一点神奇而且没那么直接，但当应用中已经使用，<font color="red">它是很好的解耦设计模式</font>。在饼状图类中，编写代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.selectedSegment = theNewSelectedSegment;</span><br></pre></td></tr></table></figure><p>当使用合成属性，KVO 会拦截到该变化并发出通知。在视图控制器中，编写类似的代码:</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupPieChart&#123;</span><br><span class="line">   [<span class="keyword">self</span>.pieChart addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"selectedSegment"</span> options:<span class="number">0</span> context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">  <span class="keyword">if</span>(object == <span class="keyword">self</span>.pieChart &amp;&amp; [keyPath isEqualToString:<span class="string">@"selectedSegment"</span>]) &#123;</span><br><span class="line">      <span class="comment">// 处理改变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据你的需要，在 viewWillDisappear: 或 dealloc 中，还需要移除观察者。对同一个对象设置多个观察者很容易造成混乱。有一些技术可以解决这个问题，比如 <a href="https://github.com/ReactiveCocoa/ReactiveCocoa" target="_blank" rel="noopener">ReactiveCocoa</a> 或者更轻量级的 THObserversAndBinders。</p><h3 id="使用通知"><a class="markdownIt-Anchor" href="#使用通知"></a> 使用通知</h3><p>作为最后一个选择，如果你想要一个非常松散的耦合，可以使用通知来使其他对象得知变化。对于饼状图来说你几乎肯定不想这样，不过为了讲解的完整，这里介绍如何去做。在饼状图的的头文件中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span>* <span class="keyword">const</span> SelectedSegmentChangedNotification;</span><br></pre></td></tr></table></figure><p>在实现文件中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span>* <span class="keyword">const</span> SelectedSegmentChangedNotification = <span class="string">@"selectedSegmentChangedNotification"</span>;</span><br><span class="line">...</span><br><span class="line">- (<span class="keyword">void</span>)notifyAboutChanges&#123;</span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SelectedSegmentChangedNotification object:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在订阅通知，在视图控制器中：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setupPieChart&#123;</span><br><span class="line">  [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> </span><br><span class="line">                                       selector:<span class="keyword">@selector</span>(segmentChanged:) </span><br><span class="line">                                           name:SelectedSegmentChangedNotification</span><br><span class="line">                                          object:<span class="keyword">self</span>.pieChart];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)segmentChanged:(<span class="built_in">NSNotification</span>*)note&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当添加了观察者，你可以不将饼状图作为参数 object，而是传递 nil，以接收所有饼状图对象发出的通知。就像 KVO 通知，你也需要在恰当的地方退订这些通知。</p><p><font color="red">这项技术的好处是完全的解耦。另一方面，你失去了类型安全，因为在回调中你得到的是一个通知对象，而不像代理，编译器无法检查通知发送者和接受者之间的类型是否匹配</font>。</p><h2 id="辅助功能-accessibility"><a class="markdownIt-Anchor" href="#辅助功能-accessibility"></a> 辅助功能 (Accessibility)</h2><p>苹果官方提供的标准 iOS 控件均有辅助功能。这也是推荐用标准控件创建自定义控件的另一个原因。</p><p>这或许可以作为一整期的主题，但是如果你想编写自定义视图，Accessibility Programming Guide 说明了如何创建辅助控制器。最为值得注意的是，如果有一个视图中有多个需要辅助功能的元素，但它们并不是该视图的子视图，你可以让视图实现 UIAccessibilityContainer 协议。对于每一个元素，返回一个描述它的 UIAccessibilityElement 对象。</p><h2 id="本地化"><a class="markdownIt-Anchor" href="#本地化"></a> 本地化</h2><p>创建自定义视图时，本地化也同样重要。像辅助功能一样，这个可以作为一整期的话题。本地化自定义视图的最直接工作就是字符串内容。如果使用 NSString，你不必担心编码问题。如果在自定义视图中展示日期或数字，使用日期和数字格式化类来展示它们。使用 NSLocalizedString 本地化字符串。</p><p>另一个本地化过程中很有用的工具是 Auto Layout。例如，有在英文中很短的词在德语中可能会很长。如果根据英文单词的长度对视图的尺寸做硬编码，那么当翻译成德文的时候几乎一定会遇上麻烦。通过使用 Auto Layout，让标签控件自动调整为内容的尺寸，并向依赖元素添加一些其他的限制以确保重新设置尺寸，使这项工作变得非常简单。苹果为此提供了一个很好的<a href="http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOS/chapters/InternationalizeYourApp/InternationalizeYourApp/InternationalizeYourApp.html" target="_blank" rel="noopener">介绍</a>。另外，对于类似希伯来语这种顺序从右到左的语言，如果你使用了 leading 和 trailing 属性，整个视图会自动按照从右到左的顺序展示，而不是硬编码的从左至右。</p><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>最后，让我们考虑测试视图的问题。对于单元测试，你可以使用 Xcode 自带的工具或者其它第三方框架。另外，可以使用 UIAutomation 或者其它基于它的工具。为此，你的视图完全支持辅助功能是必要的。UIAutomation 并未充分得到利用的一个功能是截图；你可以用它<a href="http://jeffkreeftmeijer.com/2011/comparing-images-and-creating-image-diffs/" target="_blank" rel="noopener">自动对比</a>视图和设计以确保两者每一个像素都分毫不差。(插一个无关的小提示：你还可以使用它来为应用上架 App Store <a href="http://www.smallte.ch/blog-read_en_29001.html" target="_blank" rel="noopener">自动生成截图</a>，这在你有多个多国语言的应用时会特别有用)。</p><p>引用</p><blockquote><p><a href="https://objccn.io/issue-3-4/" target="_blank" rel="noopener">自定义控件</a></p></blockquote><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
          <category> UI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 设备尺寸表</title>
      <link href="/2016/12/01/%E8%AE%BE%E5%A4%87%E5%B0%BA%E5%AF%B8/"/>
      <url>/2016/12/01/%E8%AE%BE%E5%A4%87%E5%B0%BA%E5%AF%B8/</url>
      
        <content type="html"><![CDATA[<!-- build time:Tue Aug 25 2020 13:50:42 GMT+0800 (CST) --><h2 id="尺寸要求"><a class="markdownIt-Anchor" href="#尺寸要求"></a> 尺寸要求</h2><p><a href="http://help.apple.com/itunes-connect/developer/#/devd274dd925" target="_blank" rel="noopener">Apple Doc</a></p><table><thead><tr><th style="text-align:center">屏幕尺寸</th><th style="text-align:center">横屏快照尺寸</th><th style="text-align:center">竖屏快照尺寸</th></tr></thead><tbody><tr><td style="text-align:center">3.5寸</td><td style="text-align:center">960 * 640</td><td style="text-align:center">640*960</td></tr><tr><td style="text-align:center">4寸</td><td style="text-align:center">1136*640</td><td style="text-align:center">640*1136</td></tr><tr><td style="text-align:center">4.7寸</td><td style="text-align:center">1334*750</td><td style="text-align:center">750*1334</td></tr><tr><td style="text-align:center">5.5寸</td><td style="text-align:center">2208*1242</td><td style="text-align:center">1242*2208</td></tr><tr><td style="text-align:center">5.8寸</td><td style="text-align:center">2436*1125</td><td style="text-align:center">1125*2436</td></tr><tr><td style="text-align:center">9.7寸(iPad)</td><td style="text-align:center">1024*768</td><td style="text-align:center">768*1024</td></tr><tr><td style="text-align:center">12.9寸(iPad)</td><td style="text-align:center">2732*2048</td><td style="text-align:center">2048*2732</td></tr></tbody></table><p>iTunesConnect 上架可使用 高尺寸代替低尺寸</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> iOS Programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
