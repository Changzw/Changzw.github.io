<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fri.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://changzw.github.io/"/>
  <updated>2020-06-10T13:21:08.069Z</updated>
  <id>https://changzw.github.io/</id>
  
  <author>
    <name>Fri.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SnapKit 分析</title>
    <link href="https://changzw.github.io/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/</id>
    <published>2020-04-10T07:24:23.000Z</published>
    <updated>2020-06-10T13:21:08.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><p>请看 <a href="https://changzw.github.io/2017/06/01/source-code/Masonry-%E5%88%86%E6%9E%90/">Masonry 源码分析</a></p><p>这篇文章是写给自己看的，初稿</p><p>（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言）</p><p>分析源码前想想怎么看源码：</p><ol><li>目的：这个第三方库，他是为了解决什么问题的？</li><li>技术起源：效果实现的核心技术是什么？</li><li>设计模式：整体结构是什么样的？</li><li>该怎么入手：由外而内逐层分析层次结构？</li></ol><h2 id="snapkit-是什么"><a class="markdownIt-Anchor" href="#snapkit-是什么"></a> <code>SnapKit</code> 是什么</h2><p><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">SnapKit 源码地址</a></p><h2 id="为什么要设计-snapkit"><a class="markdownIt-Anchor" href="#为什么要设计-snapkit"></a> 为什么要设计 <code>SnapKit</code></h2><p>为了解决 Apple 布局框架 AutoLayout 繁琐的 API</p><p>首先和系统提供接口对比下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> constraint1 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">150</span>);</span><br><span class="line">constraint1.isActive = <span class="literal">true</span></span><br><span class="line">... top, width</span><br><span class="line"><span class="keyword">let</span> constraint4 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .height,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .notAnAttribute,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">20</span>);</span><br><span class="line">constraint4.isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Anchor: 只支持 ios &gt;= 9</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">  label.leftAnchor.constraint(equalTo: view.leftAnchor, constant: <span class="number">150</span>),</span><br><span class="line">  label.topAnchor.constraint(equalTo: view.topAnchor, constant: <span class="number">200</span>),</span><br><span class="line">  label.widthAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">  label.heightAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><span id="code1"></span></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.top.equalToSuperview().offset(<span class="number">200</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. SnapKit 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = true</p><p>可以看出 SnapKit 接口更加简洁</p><p>那么他是如何实现的呢？</p><ol><li>如何处理原生 AutoLayout 繁杂接口</li><li>如何实现链式</li><li>如何封装 <code>NSLayoutConstraint</code> 的</li><li>如何把多个 <code>NSLayoutConstraint</code> 封装成简单的一句搞定的</li></ol><hr><h2 id="snapkit-代码结构分析"><a class="markdownIt-Anchor" href="#snapkit-代码结构分析"></a> <code>SnapKit</code> 代码结构分析</h2><h3 id="从调用层次分析"><a class="markdownIt-Anchor" href="#从调用层次分析"></a> 从调用层次分析</h3><p>像洋葱一样一层一层的看源码</p><ol><li>最外层接口<br>根据这段代码分析</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstraintMaker.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; [<span class="type">Constraint</span>]</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">remakeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">updateConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>make: ConstraintMaker</li><li>left, top，bottom，right……: ConstraintMakerExtendable</li><li>布局方法：make， remake， update</li></ol><p>我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口<br>还要找到下图的这些信息，目前的源码卡不出来<br><img src="/img/view_formula.jpeg" alt="view formula"></p><ol start="2"><li>接着往里面看</li></ol><ul><li><code>ConstraintMakerExtendable</code> 继承自 <code>ConstraintMakerRelatable</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerExtendable</span> : <span class="title">ConstraintMakerRelatable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">left</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .top</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .bottom</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">right</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><ul><li><p>问题&amp;猜测：</p><ul><li><code>description</code> 是啥？不知道</li><li>不过他有 <code>attributes</code> 属性，看样子对应 <code>NSLayoutConstraint.Attribute</code></li><li>left, top …… 这些都返回 <code>ConstraintMakerExtendable</code> ，猜测他是链式编程中链的节点对象</li></ul></li><li><p>继续看 <code>ConstraintMakerRelatable</code></p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerRelatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> description: <span class="type">ConstraintDescription</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(<span class="number">_</span> description: <span class="type">ConstraintDescription</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">relatedTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> related: <span class="type">ConstraintItem</span></span><br><span class="line">    <span class="keyword">let</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintItem</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> other.attributes == <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span> ||</span><br><span class="line">          other.attributes.layoutAttributes.<span class="built_in">count</span> &lt;= <span class="number">1</span> ||</span><br><span class="line">          other.attributes.layoutAttributes == <span class="keyword">self</span>.description.attributes.layoutAttributes ||</span><br><span class="line">          other.attributes == .edges &amp;&amp; <span class="keyword">self</span>.description.attributes == .margins ||</span><br><span class="line">          other.attributes == .margins &amp;&amp; <span class="keyword">self</span>.description.attributes == .edges ||</span><br><span class="line">          other.attributes == .directionalEdges &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalMargins ||</span><br><span class="line">          other.attributes == .directionalMargins &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalEdges <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Cannot constraint to multiple non identical attributes. (\(file), \(line))"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      related = other</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintView</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintConstantTarget</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: <span class="literal">nil</span>, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = other</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *), <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintLayoutGuide</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fatalError</span>(<span class="string">"Invalid constraint. (\(file), \(line))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> editable = <span class="type">ConstraintMakerEditable</span>(<span class="keyword">self</span>.description)</span><br><span class="line">    editable.description.sourceLocation = (file, line)</span><br><span class="line">    editable.description.relation = relation</span><br><span class="line">    editable.description.related = related</span><br><span class="line">    editable.description.constant = constant</span><br><span class="line">    <span class="keyword">return</span> editable</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">equalTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, <span class="number">_</span> file: String = #file, <span class="number">_</span> line: UInt = #line)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.relatedTo(other, relation: .<span class="built_in">equal</span>, file: file, line: line)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到了</p><ul><li>ConstraintConstantTarget(struct)</li><li>ConstraintRelation(struct)</li><li>ConstraintAttributes(struct)</li><li>ConstraintDescription(class)</li><li>ConstraintItem(class)</li><li>ConstraintMakerEditable(class)</li></ul><h3 id="model-层数据分析"><a class="markdownIt-Anchor" href="#model-层数据分析"></a> model 层数据分析</h3><h4 id="constraintconstanttarget"><a class="markdownIt-Anchor" href="#constraintconstanttarget"></a> ConstraintConstantTarget</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">LayoutAttribute</span> = <span class="type">NSLayoutConstraint</span>.<span class="type">Attribute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintInsets</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDirectionalEdgeInsets</span> : <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">constraintConstantTargetValueFor</span><span class="params">(layoutAttribute: LayoutAttribute)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码知道 <code>ConstraintConstantTarget</code> 是 autolayout 方程式中的 constant，他是这个 constant 扩展封装</p><h4 id="constraintrelation"><a class="markdownIt-Anchor" href="#constraintrelation"></a> ConstraintRelation</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConstraintRelation</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">  <span class="keyword">case</span> <span class="built_in">equal</span> </span><br><span class="line">  <span class="keyword">case</span> lessThanOrEqual </span><br><span class="line">  <span class="keyword">case</span> greaterThanOrEqual </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutRelation: <span class="type">LayoutRelation</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintRelation</code> 是 方程式中的 关系符号</p><h4 id="constraintattributes"><a class="markdownIt-Anchor" href="#constraintattributes"></a> ConstraintAttributes</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConstraintAttributes</span> : <span class="title">OptionSet</span>, <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">none</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> top: <span class="type">ConstraintAttributes</span> &#123;  <span class="keyword">return</span> <span class="number">2</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">8</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leading: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">16</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailing: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">32</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> width: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">64</span> &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutAttributes:[<span class="type">LayoutAttribute</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs = [<span class="type">LayoutAttribute</span>]()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.<span class="keyword">left</span>)) &#123;</span><br><span class="line">      attrs.append(.<span class="keyword">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.top)) &#123;</span><br><span class="line">      attrs.append(.top)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> -&gt; <span class="type">ConstraintAttributes</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">left</span>.union(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> &#123;</span><br><span class="line">  <span class="keyword">left</span>.formUnion(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ConstraintAttributes 使用了swift 的选择集(可选枚举)</li><li>重载了运算符</li><li>依然猜测 它对应 <code>NSLayoutConstraint.Attribute</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">AnyObject?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(target: <span class="type">AnyObject?</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutConstraintItem: <span class="type">LayoutConstraintItem?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target <span class="keyword">as</span>? <span class="type">LayoutConstraintItem</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: ConstraintItem, rhs: ConstraintItem)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LayoutConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">LayoutConstraintItem</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintLayoutGuide</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintView</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintLayoutGuide</span> = <span class="type">UILayoutGuide</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintView</span> = <span class="type">UIView</span></span><br></pre></td></tr></table></figure><p>nice~<br>ConstraintItem 就是 view 和 他对应布局属性的元组 (view, attr)</p><h4 id="constraintdescription"><a class="markdownIt-Anchor" href="#constraintdescription"></a> ConstraintDescription</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintDescription</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> item: <span class="type">LayoutConstraintItem</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> relation: <span class="type">ConstraintRelation?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> sourceLocation: (<span class="type">String</span>, <span class="type">UInt</span>)?</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> label: <span class="type">String?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> related: <span class="type">ConstraintItem?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> multiplier: <span class="type">ConstraintMultiplierTarget</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> priority: <span class="type">ConstraintPriorityTarget</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="built_in">lazy</span> <span class="keyword">var</span> constraint: <span class="type">SnapKit</span>.<span class="type">Constraint?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// main</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintDescription</code> 包含了 autolayout 布局方程式中所有信息，可是不知道为啥不在这里调用 NSLayoutConstraint 添加属性，非要搞一个 SnapKit.Constraint来做这些事</p><ul><li>ConstraintMakerEditable 是链式编程技巧里面的往后看</li></ul><h3 id="分析-snapkit-链式封装"><a class="markdownIt-Anchor" href="#分析-snapkit-链式封装"></a> 分析 <code>SnapKit</code> 链式封装</h3><h4 id="主要组件结"><a class="markdownIt-Anchor" href="#主要组件结"></a> 主要组件结</h4><ul><li>文件分组<br><img src="/img/snapkit_files.jpeg" alt="snapkit_files"></li></ul><h4 id="使用函数调用栈分析"><a class="markdownIt-Anchor" href="#使用函数调用栈分析"></a> 使用函数调用栈分析</h4><details><summary>SnapKit 主流程</summary><pres><p><img src="/img/snapKit_main_flow.jpeg" alt="snapKit main flow"><br></p></pres><p></p></details><details><summary>SnapKit 链式流程</summary><pres><p><img src="/img/snapKit_chain.jpeg" alt="snapKit chain"><br></p></pres><p></p></details><p>maker 创建一个其实节点 ContraintExtentable，他维护自己的 description<br>maker 保存 descriptions[] 数组</p><p>传递 description 来延续链节点</p><p>to be continued</p><h3 id="代码组件分析"><a class="markdownIt-Anchor" href="#代码组件分析"></a> 代码组件分析</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="noopener">Auto Layout Guide</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="UI 布局" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>使用 closures 代替 Gesture Recognizers 选择器</title>
    <link href="https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/"/>
    <id>https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/</id>
    <published>2020-03-08T01:56:45.000Z</published>
    <updated>2020-04-25T02:56:00.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/@sdrzn/adding-gesture-recognizers-with-closures-instead-of-selectors-9fb3e09a8f0b" target="_blank" rel="noopener">原文 Adding Gesture Recognizers with Closures Instead of Selectors<br></a></p><p>添加UITapGestureRecognizer或任何 recognizer/target action 的最糟糕的部分是仅针对选择器参数实现新功能。今天，我想分享一个巧妙的技巧，让你添加不带选择器的手势识别器。</p><p>假设我们在View Controller中有一个UIImageView，我们想向其中添加一个UITapGestureRecognizer，以便在点击它时打印出一条语句.</p><p>通常，我们会创建一个 UITapGestureRecognizer 的实例，并将其目标设置为视图控制器及其选择器，因为我们会快速将它们组合在一起(myImageViewTapped(sender：UITapGestureRecognizer))。</p><p>这可能会有点多余，并且可能导致要添加交互性的每个子视图的函数的代码混乱。</p><p>我以为我可以快速扩展一下，以便为我的图像视图添加敲击手势识别器，但是然后我必须为每个识别器创建一个新功能，对吗？错误！利用关联对象的功能，我们实际上可以将闭包存储为扩展中的计算属性！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In order to create computed properties for extensions, we need a key to </span></span><br><span class="line">  <span class="comment">// store and access the stored property</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociatedObjectKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tapGestureRecognizer = <span class="string">"MediaViewerAssociatedObjectKey_mediaViewer"</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">typealias</span> <span class="type">Action</span> = (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set our computed property type to a closure</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> tapGestureRecognizerAction: <span class="type">Action?</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newValue = newValue &#123;</span><br><span class="line">        <span class="comment">// Computed properties get stored as associated objects</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> tapGestureRecognizerActionInstance = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer) <span class="keyword">as</span>? <span class="type">Action</span></span><br><span class="line">      <span class="keyword">return</span> tapGestureRecognizerActionInstance</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// This is the meat of the sauce, here we create the tap gesture recognizer and</span></span><br><span class="line">  <span class="comment">// store the closure the user passed to us in the associated object we declared above</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addTapGestureRecognizer</span><span class="params">(action: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.tapGestureRecognizerAction = action</span><br><span class="line">    <span class="keyword">let</span> tapGestureRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleTapGesture))</span><br><span class="line">    <span class="keyword">self</span>.addGestureRecognizer(tapGestureRecognizer)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Every time the user taps on the UIImageView, this function gets called,</span></span><br><span class="line">  <span class="comment">// which triggers the closure we stored</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">handleTapGesture</span><span class="params">(sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.tapGestureRecognizerAction &#123;</span><br><span class="line">      action?()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"no action"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们要将UITapGestureRecognizer添加到UIView或UIView子类（如UIImageView）时，都可以这样做，而无需为选择器创建关联的功能！这是一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampleImageView.addTapGestureRecognizer &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"image tapped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有UITapGestureRecognizers实例，没有targets，没有selectors，没有不必要的functions！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Apple 系统界面渲染过程</title>
    <link href="https://changzw.github.io/2020/02/20/iOS%20%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/"/>
    <id>https://changzw.github.io/2020/02/20/iOS%20%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B/</id>
    <published>2020-02-20T06:39:27.000Z</published>
    <updated>2020-06-12T02:06:49.419Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><h2 id="苹果的渲染框架通俗的理解"><a class="markdownIt-Anchor" href="#苹果的渲染框架通俗的理解"></a> 苹果的渲染框架(通俗的理解)</h2><p><img src="/img/coreAnimation.jpeg" alt="coreAnimation"></p><p>根据日常开发和上图分析渲染流程</p><ol><li>UIKit: 开发中使用的用户交互组件都来自于 UIKit <strong><code>(理解为收集渲染信息+用户交互事件信息的框架)</code></strong><ol><li>提供各种 UI 组件</li><li>提供配置 UI 组件的样式接口(autoLayout, Frame, Color, Text ……)，交由 Core Animation 处理</li><li>封装用户事件接口</li></ol></li><li>Core Animation：字面翻译是核心动画，看下 CALayer，<code>CA</code> 表示的就是 Core Animation，<strong><code>Core Animation 理解为收集渲染信息，触底给底部然后得到一个渲染结果 contents</code></strong>（UIKit 上所有能看到的东西都是通过 <code>layer.contents</code> 呈现的）<ol><li>给 UIKit 提供 layer</li><li>管理动画</li><li>收集渲染数据交由渲染引擎处理</li><li>不负责用户事件相关处理！</li></ol></li><li>OpenGL ES &amp; Core Graphics 渲染引擎<ol><li>收集 Core Animation 提供的渲染数据</li><li>Core Graphics 是基于 Quartz(轻量级 2D 渲染) 高级绘图引擎</li></ol></li><li>Graphics Hardware 译为图形硬件，也就是我们经常提及的 GPU<ol><li>GPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效</li></ol></li></ol><p>用户操作的核心在 Core Animation，你要渲染的数据都要放在（<code>layer.contents</code>）上<br>当然用户也可以直接访问</p><ul><li>OpenGL ES(GLKView) 来处理渲染</li><li>Core Graphic (CG-- 相关接口) 来生成 bitmap 数据，然后将其放到 Core Animation 上<code>layer.contents</code></li></ul><ol><li>UIKit 中的组件都会关联到相应的 CALayer</li><li>渲染引擎 OpenGL ES &amp; Core Graphic 都会把渲染结果交给 layer.contents (CGImage)</li></ol><h3 id="用户使用渲染框架的数据流向"><a class="markdownIt-Anchor" href="#用户使用渲染框架的数据流向"></a> 用户使用渲染框架的数据流向</h3><p><img src="/img/user-render.jpg" alt="渲染的数据流向"></p><h2 id="官方渲染流程-core-animation-pipeline"><a class="markdownIt-Anchor" href="#官方渲染流程-core-animation-pipeline"></a> 官方渲染流程 Core Animation Pipeline</h2><p>在看完 wwdc2014 session419(Advanced Graphics and Animations for iOS Apps) 有了更深入的了解</p><p><img src="/img/core-animation-pipeline.jpg" alt="core animation pipeline"></p><p>上图需要注意：</p><ol><li>苹果的 UI 渲染频率是 60hz 16.67ms 一次（Vsync）</li><li>每个垂直的虚线表示一个 Vsync</li><li>水平虚线，表示一个硬件资源</li></ol><p>问题来了，根据上图一个渲染周期需要 3frame，那么真实的渲染频率只有 20hz<br>那么系统是怎么做到 60hz 的呢？答案： 流水线</p><p><img src="/img/core-animation-flow.jpeg" alt="core-animation-flow"></p><p>如果在每一帧上对应硬件操作都完成了，那么就会以 60hz 的速度渲染</p><p>接下来说一下渲染过程中的每个细节部分</p><p><span id="1"></span></p><h3 id="提交事务commit-transaction"><a class="markdownIt-Anchor" href="#提交事务commit-transaction"></a> 提交事务（commit transaction）</h3><p>主要是 4个阶段</p><ol><li>Layout：构建 Views<ol><li>调用 <code>layoutSubviews</code> 如果重载了</li><li>创建 view，addSubView:</li><li>填充内容，轻量级的数据查询（就是 string 赋值之类的）</li><li>通常是 CPU, I/O 负责</li></ol></li><li>Display：绘制 Views<ol><li><code>drawRect</code> 绘制内容，如果重载了（主要使用 Core Graphic，避免执行复杂操作）</li><li>String drawing</li><li>通常是 CPU / memory 负责</li></ol></li><li>Prepare：做些 Core Animation 相关操作<ol><li>image decoding（view hierachy 绘制的，jpeg，png）</li><li>image conversion（因为有些图片 GPU 不支持），通常是解码成 bitmap</li></ol></li><li>Commit：打包 layers，然后将他们发给 render server<ol><li>递归上述流程</li><li>如果 layer 树很复杂，那么会很耗性能。所以尽可能的让 layer tree 平一些（少几层）</li></ol></li></ol><h3 id="动画animation"><a class="markdownIt-Anchor" href="#动画animation"></a> 动画Animation</h3><p>主要是 3个阶段，有 2个阶段发生在 Application 进程中，1个在 Render Server 进程中</p><ol><li>创建动画接着更新视图层级 <code>animateWithDuration:animations:</code></li><li>准备动画，然后提交 <code>layoutSubviews</code>, <code>drawRect:</code> <a href="#1">就是<strong>提交事务</strong>这几步</a></li><li>使用进程间通信，render server 进程绘制出动画相关的每一帧，在交由 App 进程</li></ol><p><img src="/img/core-animation-animation.jpeg" alt="Animation 过程"></p><h3 id="渲染-render"><a class="markdownIt-Anchor" href="#渲染-render"></a> 渲染 render</h3><p>一个 view 的渲染过程</p><p><img src="/img/render-pass.jpeg" alt="render pass"></p><p>添加 masking 后的渲染过程</p><p><img src="/img/render-pass-mask.jpeg" alt="render-pass-mask"></p><p>GPU 的离屏渲染，就是对于一个 view 需要多次渲染组合，因为需要多个渲染层所以需要离屏渲染开辟缓存，绘制这些mask，radius，blend ……<br>如果需要组合的那些渲染过程在 CPU 中完成，然后CPU直接把一个绘制好的 image 交给 GPU 渲染就不会有这些问题了！不过 CPU 性能问题！drawRect 中如果绘制 image 太过复杂依然会出现掉帧问题</p><h2 id="runloop-core-animation"><a class="markdownIt-Anchor" href="#runloop-core-animation"></a> Runloop &amp; Core Animation</h2><p>RunLoop主要处理以下6类事件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> Observer</span><br><span class="line"><span class="number">2.</span> block</span><br><span class="line"><span class="number">3.</span> timer</span><br><span class="line"><span class="number">4.</span> main_dispatch_queue</span><br><span class="line"><span class="number">5.</span> source0</span><br><span class="line"><span class="number">6.</span> source1</span><br></pre></td></tr></table></figure><ol><li>Observer事件：runloop中状态变化时进行通知。Core Animation 监听 RunloopObserver 闲置的时候触发。</li><li>Block事件：</li><li>Main_Dispatch_Queue事件：GCD中dispatch到main queue的block 会在 main loop 中执行。</li><li>Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。</li><li>Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。(用户可以手动调用performSelector 方法触发 source0)</li><li>Source1事件：处理系统内核的mach_msg事件。（推测CADisplayLink也是这里触发）。</li></ol><p>App 进程的 Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件（就是不让 runloop 睡！）<br>。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。<br>当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。</p><h3 id="布局渲染"><a class="markdownIt-Anchor" href="#布局渲染"></a> 布局&amp;渲染</h3><p>渲染图片之前一定要先计算好尺寸位置，也就是 frame，AutoLayout 最终结果也是 frame，在 iOS12以后 AutoLayout 性能大幅提升</p><p><img src="/img/layout&amp;render.jpeg" alt="layout&amp;render"></p><p>更新布局限制的过程是：子–&gt;父(super.updateConstraints最后调用)<br>更新布局的过程是：父–&gt;子 (layoutSubview)</p><h3 id="布局渲染相关方法"><a class="markdownIt-Anchor" href="#布局渲染相关方法"></a> 布局渲染相关方法</h3><p><img src="/img/layout&amp;render-function.jpeg" alt="layout&amp;render-function"></p><ol><li>布局限制</li></ol><p>autulayout 的布局限制不要将布局 放到 <code>updateContraints</code> 方法中，这里是放大量布局更新的地方，通常布局代码放在 view 的 <code>init</code>, <code>awakeFromNib</code> or viewcontroller 的 <code>viewDidLoad，loadView</code> 方法中</p><p>setNeedXXXX 是标记脏布局，在下一次 RunLoop循环的时候就会调用 updateXXX 方法</p><ol start="2"><li>布局</li></ol><p><code>layoutSubViews</code> 被系统调用的时候，所有相关的子view的 frame 都已经被 AutoLayout 的布局引擎布局好了，都有了自己 frame，这个时候可以更改 他们的frame了</p><ol start="3"><li>显示（CPU）</li></ol><p>嗯以上的1~3都是 CPU的操作</p><ul><li>drawRect方法 通过 CoreGraphic库绘制 2D image，放在 layer.contents 编码交给 Render Server处理</li><li>同理 CALayer 的 drawLayer 方法</li><li>CALayer 的 delegate</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">CALayerDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* If defined, called by the default implementation of the -display</span></span><br><span class="line"><span class="comment"> * method, in which case it should implement the entire display</span></span><br><span class="line"><span class="comment"> * process (typically by setting the `contents' property). */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)displayLayer:(<span class="built_in">CALayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If defined, called by the default implementation of -drawInContext: */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)drawLayer:(<span class="built_in">CALayer</span> *)layer inContext:(<span class="built_in">CGContextRef</span>)ctx;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>默认情况 UIView 是 CALayer 的CALayerDelegate，drawRect 内部就是调用 CALayerDelegate的方法 给 Layer 绘制 contents</p><p>只要 layer.contents 的东西交由 Render Server，内部render 引擎渲染就是系统的事了<br>所以有了写异步渲染框架，只要程序员在子线程配置好了 contents然后在主线程交给 layer 就可以了</p><h2 id="离屏渲染"><a class="markdownIt-Anchor" href="#离屏渲染"></a> 离屏渲染</h2><p>离屏渲染是 GPU 为了缓存的已经渲染出来图形，等待跟其他图形组合<br>离屏渲染空间只有屏幕的 2.5倍</p><p>eg: 圆角图片<br>由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染。但如果仅仅是实现一个简单的效果，直接使用 CPU 渲染的效率又可能比离屏渲染好，毕竟普通的离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。对一些简单的绘制过程来说，这个过程有可能用CoreGraphics，全部用CPU来完成反而会比GPU做得更好。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="系统原理" scheme="https://changzw.github.io/categories/iOS-Programming/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="性能优化" scheme="https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>自定义 keyboard</title>
    <link href="https://changzw.github.io/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/"/>
    <id>https://changzw.github.io/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/</id>
    <published>2020-02-17T09:18:39.000Z</published>
    <updated>2020-04-25T02:44:20.510Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><p>原文：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html" target="_blank" rel="noopener">CustomKeyboard</a></p><h3 id="自定义键盘api"><a class="markdownIt-Anchor" href="#自定义键盘api"></a> 自定义键盘API</h3><p>开发自定义键盘的快速入门,如下图，它展示了键盘运行过程中一些重要的对象，以及它们在开发流程中的的位置：</p><p><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/keyboard_architecture_2x.png" alt="keyboard"></p><p>自定义键盘模板（在iOS“Application Extension”目标模板组）包含一个UIInputViewController的子类，它是你开发的键盘的主视图控制器。该模板包含</p><p>键盘所必需的“下一个键盘”按钮的实现，它调用了UIInputViewController类的advanceToNextInputMode方法。如上图所示，可以在输入视图控制器的主视图（在其inputView属性）中添加子视图、控制器以及手势识别器等。对于其它类型的扩展应用，在目标上并不存在窗体，因此也就没有根视图控制器了。</p><p>在模板的Info.plist文件中有预先配置好的键盘所需要的最基本的值。参见其中的NSExtensionAttributes字典关键字，配置一个键盘的关键字在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW18" target="_blank" rel="noopener">《配置自定义键盘的Info.plist文件》</a>中有介绍。</p><p>默认，键盘不能访问网络，不能和它的app共享容器。如果要具备这种能力，必须要将Info.plist文件中RequestsOpenAccess的值置为YES。这需要扩展键盘的沙盒，在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《设计用户信任》</a>中有介绍相关内容。</p><p>一个输入视图控制器遵从各种与文本输入对象内容交互的协议：</p><ul><li>响应触摸消息时如果要插入或删除文本，可以使用<a href="https://developer.apple.com/reference/uikit/uikeyinput" target="_blank" rel="noopener">UIKeyInput</a>协议的insertText:和deleteBackward方法。可以在视图控制器的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618193-textdocumentproxy" target="_blank" rel="noopener">textDocumentProxy</a>属性中调用这些方法，该属性代表当前文本输入对象，它遵从<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="noopener">UITextDocumentProxy</a>协议。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"hello "</span>]; <span class="comment">// Inserts the string "hello " at the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy deleteBackward];       <span class="comment">// Deletes the character to the left of the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"\n"</span>];     <span class="comment">// In a text view, inserts a newline character at the insertion point</span></span><br></pre></td></tr></table></figure><ul><li>在调用deleteBackward之前要先决定删除的字符数。可以通过textDocumentProxy的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618190-documentcontextbeforeinput" target="_blank" rel="noopener">documentContextBeforeInput</a>属性，来获得光标附近的文本上下文信息。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *precedingContext = <span class="keyword">self</span>.textDocumentProxy.documentContextBeforeInput;</span><br></pre></td></tr></table></figure><ul><li>为了控制光标所在位置的操作，比如支持向前删除文字，需要调用UITextDocumentProxy协议中的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618194-adjusttextposition" target="_blank" rel="noopener">adjustTextPositionByCharacterOffset:</a>方法。比如向前删除一个字符，代码如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) deleteForward &#123;</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy adjustTextPositionByCharacterOffset: <span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy deleteBackward];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现<a href="https://developer.apple.com/reference/uikit/uitextinputdelegate" target="_blank" rel="noopener">UITextInputDelegate</a>协议中的方法，可以响应当前输入文本对象的一些变化，比如内容变化以及用户触发的光标位置的变化。</li></ul><p>为了展现与当前文本输入对象适配的键盘布局，需要参照该对象的<a href="https://developer.apple.com/reference/uikit/uikeyboardtype" target="_blank" rel="noopener">UIKeyboardType</a>属性，根据每种你的键盘所能支持的属性，变化布局内容。</p><p><strong>在自定义键盘中，有两种方式来支持多语言：</strong></p><ul><li>为每个语言创建一个键盘，每个键盘都作为向容器app添加的独立的Target</li><li>创建一个多语言键盘，动态切换当前语言。可以使用UIInputViewController类的primaryLanguage属性来动态切换语言。</li></ul><p>根据你要支持的语言数量以及你想提供的用户体验，你可以从上面选择最合适的方案。</p><p>每种自定义键盘（需要RequestsOpenAccess）都可以通过UILexicon类访问自动纠错的词典。通过使用该类，并结合你自己的词典设计，可以在用户输入过程中为他提供输入建议和自动纠错。UILexicon对象包含来自如下源的单词：</p><ul><li>来自用户通讯录的人名和姓</li><li>在 设置 &gt; 通用 &gt; 键盘 &gt; 快捷方式（文本替换） 列表</li><li>通用词典</li></ul><p>你可以使用自动布局来调整你的自定义键盘主视图的高度。默认情况下，自定义键盘会根据屏幕尺寸以及设备方向，和系统键盘的尺寸保持一致。自定义键盘的宽度通常与屏幕当前宽度一致。修改自定义键盘主视图的高度约束即可修改其高度。</p><p>下面的代码展示如何定义和添加约束：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> _expandedHeight = <span class="number">500</span>;</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *_heightConstraint = </span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem: <span class="keyword">self</span>.view </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeHeight</span> </span><br><span class="line">                                 relatedBy: <span class="built_in">NSLayoutRelationEqual</span> </span><br><span class="line">                                    toItem: <span class="literal">nil</span> </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeNotAnAttribute</span></span><br><span class="line">                                multiplier: <span class="number">0.0</span> </span><br><span class="line">                                  constant: _expandedHeight];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint: _heightConstraint];</span><br></pre></td></tr></table></figure><h2 id="自定义键盘的开发关键"><a class="markdownIt-Anchor" href="#自定义键盘的开发关键"></a> 自定义键盘的开发关键</h2><p>自定义键盘开发有两个关键点：</p><ul><li>信任。 自定义键盘能访问用户输入的内容 ，因此在键盘和用户间建立信任非常关键。</li><li>“下一个键盘”键。 通过键盘界面必须能让用户能切换到下一个键盘。</li></ul><h3 id="为用户信任所做的设计"><a class="markdownIt-Anchor" href="#为用户信任所做的设计"></a> 为用户信任所做的设计</h3><p>作为自定义键盘的开发者，你首先应当考虑的是如何建立和维护用户信任。你要理解隐私策略的最佳实践并知道如何实现它才能很好地践行。</p><blockquote><p>注意<br>本节为你创建自定义键盘提供相关的开发手册，该手册要求尊重用户隐私。了解iOS编程要求，请阅读应用商店审核手册，iOS人机交互手册，iOS开发许可协议，请参见苹果的<a href="https://developer.apple.com/support/appstore/app-review/" target="_blank" rel="noopener">《应用审核支持》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/ExpectedAppBehaviors/ExpectedAppBehaviors.html#//apple_ref/doc/uid/TP40007072-CH3-SW6" target="_blank" rel="noopener">《支持用户隐私》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="noopener">《iOS应用编程指南》</a>。</p></blockquote><p>对于键盘，如下三个方面对于建立和维护用户信任至关重要：</p><ul><li>按键数据的安全。 用户希望他们的敲键会落在文档以及输入区域内，而不是上传到服务器或者用于其他不明目的。</li><li>最小化合理利用其它用户数据。 如果你的键盘还需要使用其他用户数据，例如定位服务或者通讯录，你有义务解释这给用户带来的好处是什么。</li><li>准确。 把输入事件转换成文本要求精准，这本身虽然不是一个隐私话题，但他会影响到信任：每次文字转换需要体现出你的代码的精准。</li></ul><p>在信任的开发设计过程中，首先考虑的是是否要获取open access权限。尽管开启了open access权限能给自定义键盘开发带来极大便利，但这也增加了你作为开发者的责任。下面是标准的open access的能力和隐私考虑：</p><table><thead><tr><th>Open Access</th><th>能力和限制</th><th>隐私考虑</th></tr></thead><tbody><tr><td>Off(default)</td><td>·键盘可以执行所有基本键盘的职责<br>·可以访问通用词典以支持自动纠错和输入建议<br>·访问设置里的快捷短语<br>·不与containing应用共享容器<br>·不访问键盘容器以外的文件系统<br>·不访问键盘容器以外的文件系统<br>·不能直接或间接访问iCloud或游戏中心或应用内购买</td><td>用户了解按键仅仅被发送到当前使用键盘的应用里</td></tr><tr><td>On</td><td>·具备非联网自定义键盘的所有能力<br>·在用户许可情况下可以访问位置服务和通讯录<br>·键盘和containing app可以访问共享容器<br>·键盘可以为服务器侧处理过程发送按键或其他输入事件<br>·containing app自动纠错字典提供编辑界面<br>·通过containing app键盘可以使用iCloud来保证自动纠错词典和设置的更新<br>·通过containing app，键盘可以参与到游戏中心和应用内购买<br>·如果键盘支持移动设备管理(MDM)，它可与被管理的应用共同工作</td><td>·用户了解键盘开发者会利用按键数据<br>·你必须遵守有联网能力的键盘开发手册和iOS开发许可协议，可参见《应用审核支持》</td></tr></tbody></table><p>如果你的自定义键盘不需要open access权限，系统确保敲键信息不会被发送给你的键盘以及别的地方。如果只想提供一般的键盘功能，请不要给键盘配备联网能力。由于有沙盒限制，不联网的键盘一定是满足苹果的数据隐私手册并能获得用户信任的。</p><p>开启open access权限（如上所述，可以在Info.plist文件中配置），能给你的开发带来更多可能性，同时也带来更多的责任。</p><blockquote><p>注意<br>向应用商店提交一个open-access的键盘必须遵守苹果《应用审核支持》中的相关条款。</p></blockquote><p>每一个与open access相关的功能都需要你履行相应的责任，应当最大限度地尊重用户数据，不得用于与用户输入无关的其他任何目的。下表列出了open access带来的好处以及开发者需承担的责任：</p><table><thead><tr><th>能力</th><th>用户利益示例</th><th>开发者责任</th></tr></thead><tbody><tr><td>与containing app共享容器</td><td>为键盘的自动纠错词典管理UI界面</td><td>要考虑到自动纠错数据属于用户隐私。不要把他发到你的服务器，用作与输入无关的用途。</td></tr><tr><td>把按键数据发到你的服务器</td><td>通过开发者的计算资源可以提供更好的按键处理结果和输入预测</td><td>只有为用户提供更好的输入体验之用时，才能保存按键和语音数据</td></tr><tr><td>基于云的自动纠错词典</td><td>把人名、地名、热点新闻加入到自动纠错词典中</td><td>不要把用户身份与输入数据关联起来，不得将用户信息用作与输入体验无关的其他目的</td></tr><tr><td>通讯录</td><td>把人名、地名、电话号码添加到自动纠错词典中</td><td>不得讲通讯录用作与输入体验无关的其他目的</td></tr><tr><td>位置服务</td><td>将附近的地名添加到自动纠错词典中</td><td>不要在后台使用位置服务，不得将位置信息发送到你的服务器并用于与输入体验无关的其他目的</td></tr></tbody></table><p>一个具有open-access权限的键盘和其containing app能将按键数据发送到服务器端，通过这些数据可以为用户提供更好的输入体验。如果你使用了这些能力，当不需要这些数据的时候，请及时在服务器端删除。参见上面的表格来履行你使用open-access权限中的义务。</p><h3 id="提供切换到其他键盘的方法"><a class="markdownIt-Anchor" href="#提供切换到其他键盘的方法"></a> 提供切换到其他键盘的方法</h3><p>系统键盘的小地球按键用于切换到其他键盘：<br><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/globe_key_2x.png" alt="The system keyboard’s Globe key"></p><p>你的自定义键盘必须提供类似的机制能切换到其他键盘。</p><p>调用UIInputViewController类的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618191-advancetonextinputmode" target="_blank" rel="noopener">advanceToNextInputMode</a>方法可以切换到其他键盘。系统会选择下一个键盘，没有能获得键盘列表的API，也没有切换到指定键盘的API。</p><p>Xcode自定义键盘模板中就已经在下一个键盘按钮上具备了advanceToNextInputMode的功能。为了提供最好的用户体验，应当把你的下一个键盘按键放在靠近系统键盘的小地球键的位置。</p><blockquote><p>注意<br>要通过应用审核，必须在你的键盘上提供明显允许用户切换键盘的UI标识。</p></blockquote><h2 id="开始自定义键盘的开发"><a class="markdownIt-Anchor" href="#开始自定义键盘的开发"></a> 开始自定义键盘的开发</h2><h3 id="使用xcode自定义键盘模板"><a class="markdownIt-Anchor" href="#使用xcode自定义键盘模板"></a> 使用Xcode自定义键盘模板</h3><p>创建键盘及其containing app与其他扩展应用略有不同。本节将带你领略基本键盘的开发和运行。</p><p><strong>在一个容器app中创建键盘，步骤如下</strong></p><ol><li>在Xcode中选择File &gt; New &gt; Project &gt; iOS &gt; Application选择Single View Application模板。</li><li>点击Next。</li><li>填写Project Name（如CKIme），点击Next。</li><li>选择要保存的位置，点击Create。这样，你就有了一个空app，该app只能完成一个简单的操作，接下来它将承载键盘。在你提交到应用商店之前，你需要完成一些有用的功能。请到应用审核支持参考应用商店审核指南。</li><li>选择File &gt; New &gt; Target &gt; iOS &gt; Application Extension选择Custom Keyboard Extension，点击Next。</li><li>填写Product Name（如CKbd），点击Finish。</li><li>确认Project和Embed in Application中都显示的是容器app的名字（CKIme），点击Finish。如果弹出Activate “CKbd” scheme提示让激活键盘工程，点击Activate。</li></ol><p><strong>定义键盘group name，步骤如下：</strong></p><ol><li>在Xcode工程导航视图中，选择容器app的Info.plist文件，</li><li>在右侧plist编辑器中，鼠标hover到Bundle name上，点“+”按钮创建一行空属性。</li><li>在Key中填写Bundle display name，回车</li><li>双击该行的Value，填写你要自定义的键盘group name。</li><li>选择File &gt; Save保存设置。</li></ol><p>下表汇总了在容器app和键盘app的Info.plist文件中你可以配置的UI字符串：</p><table><thead><tr><th>iOS UI字符串</th><th>Info.plist关键字</th></tr></thead><tbody><tr><td>· 在系统设置的已购键盘列表中的键盘group name</td><td>在容器app的Info.plist文件中的Bundle display name</td></tr><tr><td>· 系统设置中的键盘名称<br>· 键盘换列表中的键盘名称</td><td>在键盘app的Info.plist文件中的Bundle display name</td></tr></tbody></table><p><strong>运行自定义键盘并将Xcode调试器attach到它上面</strong></p><ol><li>在Xcode，你的view controller实现中设置一个断点（比如可以断在viewDidLoad上）。</li><li>在Xcode工具栏确保当前活动的项目为键盘项目，并对应iOS模拟器或设备。</li><li>选择菜单Project &gt; Run，或点击Build and then run the current scheme按钮（即播放按钮）。Xcode会提示选择host app。选择一个带有输入框的，比如通讯录或Safari。</li><li>点击Run。Xcode将运行起你指定的host app。如果这是你第一次使用键盘扩展应用，需要现在设置中添加并启用键盘：<ol><li>Settings &gt; General &gt; Keyboard &gt; Keyboards</li><li>点击Add New Keyboard…</li><li>在OTHER IPHONE KEYBOARDS中点击你刚刚创建的键盘</li></ol></li><li>在iOS模拟器或真机上，调出你的自定义键盘。<br>点击任意可输入区域，将显示出系统键盘。按住小地球，选择你的自定义键盘。<br>此时你将看到自定义键盘，但是调试器尚未attach上来。一个从模板构建而来的极简键盘仅有一个Next Keyboard按钮，点击后切换回前一个键盘。</li><li>取消你的键盘（以便在第8步中你可以再次调出键盘以命中viewDidLoad断点）</li><li>在Xcode中，选择Debug &gt; Attach to Process &gt; By Process Identifier(PID) or Name 在弹出对话框中，输入你的键盘扩展应用的名字（包含空格）.默认就是该扩展应用在工程导航窗口里的group name。</li><li>点击Attach。Xcode将显示出等待attach的调试器。</li><li>在任意能输入文字的app中调出键盘。<br>当你的键盘主视图开始加载时，Xcode调试器将attache到你的键盘，并命中断点。</li></ol><h3 id="为自定义键盘配置infoplist文件"><a class="markdownIt-Anchor" href="#为自定义键盘配置infoplist文件"></a> 为自定义键盘配置Info.plist文件</h3><p>自定义键盘的Info.plist文件允许静态定义键盘的现式特征，包括主要语言，以及是否需要open access权限。</p><p>打开Xcode并切换到自定义键盘的 target。在工程导航栏选择Info.plist文件，按文本格式呈现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtension<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionAttributes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>IsASCIICapable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrefersRightToLeft<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrimaryLanguage<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>en-US<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>RequestsOpenAccess<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPointIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.keyboard-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPrincipalClass<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>KeyboardViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个关键字在App Extension Keys中都有解释。可以使用字典NSExtensionAttributes中的关键字来描述你的自定义键盘的特征和需求，如下：</p><p><code>IsASCIICapable</code> - 默认为NO的布尔值。用户键盘是否可以向文档中插入ASCII字串。如果要为<code>UIKeyboardTypeASCIICapable</code>属性的输入对象展现单独类型的键盘，需要将该值置为YES。</p><p><code>PrefersRightToLeft</code> - 默认为NO的布尔值。是否为从右到左的语种设计的的自定义键盘。</p><p><code>PrimaryLanguage</code> - 默认为en-US的字串。以&lt;语种&gt;-&lt;区域&gt;的形式描述键盘的主语言。可以到http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c找到对应的语种和区域。</p><p><code>RequestsOpenAccess</code> - 默认为NO的布尔值。是否需要比基础键盘更大的沙盒范围。把该值置为YES将需要完全访问权限，你的键盘将获得如下能力，每个能力都伴随有相应的权限：</p><ul><li>访问定位服务，通讯录数据库，相机，每个都需要用户允许</li><li>与键盘的容器app共享容器数据，以便完成比如在容器app中管理用户词库的界面的功能</li><li>通过网络发送按键、输入事件之类的数据供云端处理</li><li>使用UIPasteboard类</li><li>播放音频，包括使用playInputClick方法播放按键音</li><li>访问iCloud，可以用来根据用户身份同步比如键盘设置、自定义自动纠错词典</li><li>通过容器app访问游戏中心和应用内购买</li><li>如果你的键盘支持移动设备管理（MDM），可以与被管理的app无缝合作</li></ul><p>当考虑是否将这些关键字设置为YES之前，一定要先阅读<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《用户信任设计》</a>，这里描述了如何尊重和保护用户数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="AppExtensions" scheme="https://changzw.github.io/categories/iOS-Programming/AppExtensions/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>runloop 实践相关</title>
    <link href="https://changzw.github.io/2019/12/29/runloop/runloop-%E5%AE%9E%E8%B7%B5%E7%9B%B8%E5%85%B3/"/>
    <id>https://changzw.github.io/2019/12/29/runloop/runloop-%E5%AE%9E%E8%B7%B5%E7%9B%B8%E5%85%B3/</id>
    <published>2019-12-29T11:00:54.000Z</published>
    <updated>2020-05-29T05:07:07.331Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><p>RunLoop 是系统层级上的设计，用来给管理系统消息队列派发，那我们都可以用 runLoop 做什么呢？<br>简单来说，RunLoop 是用来监听输入源，进行调度处理的。</p><p>RunLoop 输入源可以是：</p><ul><li>输入设备</li><li>网络</li><li>周期性或者延迟时间</li><li>异步回调</li></ul><p><img src="/img/runloop_core.jpeg" alt="runloop activities"></p><p>runloop 的 observer 可以监听的 7中状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">  kCFRunLoopEntry ,         <span class="comment">// 进入 loop</span></span><br><span class="line">  kCFRunLoopBeforeTimers ,  <span class="comment">// 触发 Timer 之前</span></span><br><span class="line">  kCFRunLoopBeforeSources , <span class="comment">// 触发 Source0 之前</span></span><br><span class="line">  kCFRunLoopBeforeWaiting , <span class="comment">// 等待 mach_port 消息（等待源Source和计时器Timer之前，进入睡眠）</span></span><br><span class="line">  <span class="comment">// 在这两个状态中真正处理事件</span></span><br><span class="line">  kCFRunLoopAfterWaiting ), <span class="comment">// 接收 mach_port 消息（等待源Source和计时器Timer后，同时在被唤醒之前）</span></span><br><span class="line">  kCFRunLoopExit , <span class="comment">// 退出 loop</span></span><br><span class="line">  kCFRunLoopAllActivities  <span class="comment">// loop 所有状态改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测-ios-app-卡顿"><a class="markdownIt-Anchor" href="#检测-ios-app-卡顿"></a> 检测 iOS App 卡顿</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h3><h4 id="卡顿如何造成的"><a class="markdownIt-Anchor" href="#卡顿如何造成的"></a> 卡顿如何造成的</h4><p>iOS系统页面刷新频率：60 FPS，60次/s, <code>let refresh_time_per = 1s/60 &lt; 0.02</code><br>如果在 <code>refresh_time_per</code> 时间内没有完成图片绘制，那么就会出现卡顿现象！<br>而系统页面刷新事件处理…… 事件几乎都是由 runloop 调用执行的。<br>那么如果 runloop 一次循环时间 &gt; <code>refresh_time_per</code> 就说明图片没有渲染完成，导致卡顿。</p><p>问题来了，如何判断 runloop 一次循环时间 &gt; <code>refresh_time_per</code> 呢？</p><p>RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p><p>所以要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。<br>RunLoop 的两个 loop 状态<br>在进入睡眠之前: kCFRunLoopBeforeSources<br>在进入唤醒之后: kCFRunLoopAfterWaiting<br>也就是要触发 Source0 回调和接收 mach_port 消息两个状态。</p><details><summary>runloop 核心源码</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="comment">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line"><span class="comment">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line"><span class="comment">// 执行被加入的block</span></span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line"><span class="comment">// 执行被加入的block</span></span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line"><span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">  Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">  <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line"><span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line"><span class="comment">// • 一个基于 port 的Source 的事件。</span></span><br><span class="line"><span class="comment">// • 一个 Timer 到时间了</span></span><br><span class="line"><span class="comment">// • RunLoop 自身的超时时间到了</span></span><br><span class="line"><span class="comment">// • 被其他什么调用者手动唤醒</span></span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">  mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到消息，处理消息。</span></span><br><span class="line">handle_msg:</span><br><span class="line">      <span class="comment">// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line"><span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">  __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">  __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">  sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">  <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  退出 runloop 逻辑 retVal != 0 exit</span></span><br><span class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">  <span class="comment">// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">  retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">  <span class="comment">// 超出传入参数标记的超时时间了</span></span><br><span class="line">  retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">  <span class="comment">// 被外部调用者强制停止了</span></span><br><span class="line">  retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">  <span class="comment">// source/timer/observer一个都没有了</span></span><br><span class="line">  retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h3 id="卡顿监听实践"><a class="markdownIt-Anchor" href="#卡顿监听实践"></a> 卡顿监听实践</h3><ol><li>创建 runloop 的observer对象:</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakSelf = <span class="type">Unmanaged</span>&lt;<span class="type">Monitor</span>&gt;.passUnretained(<span class="keyword">self</span>).toOpaque()</span><br><span class="line"><span class="keyword">var</span> ctx: <span class="type">CFRunLoopObserverContext</span> = <span class="type">CFRunLoopObserverContext</span>(version: <span class="number">0</span>, weakSelf: info, retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.runLoopObserver = <span class="type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.allActivities.rawValue, <span class="literal">true</span>, <span class="number">0</span>, runLoopCallBack(), &amp;ctx)</span><br></pre></td></tr></table></figure><ol start="2"><li>将 observer 添加到 runloop 的 commonModes 中</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFRunLoopAddObserver</span>(<span class="type">CFRunLoopGetCurrent</span>(), <span class="keyword">self</span>.runLoopObserver, <span class="type">CFRunLoopMode</span>.commonModes)</span><br></pre></td></tr></table></figure><ol start="3"><li>创建子线程，监听runloop的状态<ul><li>beforeSources: 进入睡眠前</li><li>afterWaiting: 唤醒后的状态</li><li>设置卡顿阀值</li><li>打印堆栈信息</li></ul></li></ol><p>为什么要监听 beforeSources 和 afterWaiting 这两个状态呢？<br>因为只有这两个状态 runloop 触发事件回调，如果runloop 长时间处于这两个状态中说明卡顿！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> sem = <span class="keyword">self</span>.dispatchSemaphore?.wait(timeout: <span class="type">DispatchTime</span>.now() + <span class="number">1</span> / <span class="number">50</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="type">DispatchTimeoutResult</span>.timedOut = sem &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.runLoopObserver <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dispatchSemaphore = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.runLoopActivity = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.runLoopActivity == <span class="type">CFRunLoopActivity</span>.beforeSources || <span class="keyword">self</span>.runLoopActivity == <span class="type">CFRunLoopActivity</span>.afterWaiting) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"symbo: \(Thread.callStackSymbols)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"打印卡顿堆栈..."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何获取卡顿的方法堆栈信息"><a class="markdownIt-Anchor" href="#如何获取卡顿的方法堆栈信息"></a> 如何获取卡顿的方法堆栈信息？</h3><h4 id="直接调用系统函数获取"><a class="markdownIt-Anchor" href="#直接调用系统函数获取"></a> 直接调用系统函数获取</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signals[] = &#123;</span><br><span class="line">  SIGABRT,</span><br><span class="line">  SIGBUS,</span><br><span class="line">  SIGFPE,</span><br><span class="line">  SIGILL,</span><br><span class="line">  SIGSEGV,</span><br><span class="line">  SIGTRAP,</span><br><span class="line">  SIGTERM,</span><br><span class="line">  SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signal_num = <span class="keyword">sizeof</span>(s_fatal_signals) / <span class="keyword">sizeof</span>(s_fatal_signals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">  <span class="built_in">NSArray</span> *exceptionArray = [exception callStackSymbols]; <span class="comment">// 得到当前调用栈信息</span></span><br><span class="line">  <span class="built_in">NSString</span> *exceptionReason = [exception reason];     <span class="comment">// 非常重要，就是崩溃的原因</span></span><br><span class="line">  <span class="built_in">NSString</span> *exceptionName = [exception name];       <span class="comment">// 异常类型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> SignalHandler(<span class="keyword">int</span> code) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"signal handler = %d"</span>,code);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> InitCrashReport() &#123;</span><br><span class="line">  <span class="comment">// 系统错误信号捕获</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">    signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//oc 未捕获异常的捕获</span></span><br><span class="line">  <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    InitCrashReport();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><h4 id="第三方库来获取堆栈信息"><a class="markdownIt-Anchor" href="#第三方库来获取堆栈信息"></a> 第三方库来获取堆栈信息</h4><p><a href="https://opensource.plausible.coop/src/projects/PLCR/repos/plcrashreporter/browse" target="_blank" rel="noopener">PLCrashReporter</a></p><h2 id="利用runloop空闲时间"><a class="markdownIt-Anchor" href="#利用runloop空闲时间"></a> 利用RunLoop空闲时间</h2><p>卡顿是因为 runloop 一次时间 &gt; 1/60s<br>那么如果 runloop 一次运行时间 &lt; 1/60s 呢？<br>譬如你把手机放在那看着 app，runloop 在那睡觉(<code>kCFRunLoopBeforeWaiting</code>)</p><p>这个时候往 runloop 里面放个 source or timer，runloop 就会醒来 进入 <code>kCFRunLoopAfterWaiting</code> 状态</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">BeforeWaitingDo</span> = () -&gt; ()</span><br><span class="line"><span class="keyword">var</span> tasks: [<span class="type">BeforeWaitingDo</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">self</span>.tasks.remove(at: <span class="number">0</span>)</span><br><span class="line">  t()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> rl = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">  <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.beforeWaiting.rawValue, <span class="literal">true</span>, <span class="number">0</span>) &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] (observer, actives) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span>,</span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.tasks.first <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">    <span class="comment">// 创建一个 source0 把 runloop 被叫醒</span></span><br><span class="line">    <span class="keyword">self</span>.perform(#selector(<span class="type">ChatEmojiViewController</span>.exec), on: <span class="type">Thread</span>.current, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">CFRunLoopAddObserver</span>(rl, observer, <span class="type">CFRunLoopMode</span>.commonModes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F161%3Fcode%3DQjb1JtJcvAPISj9QjxdKrAmeXmURMroQbkOcLNm0jeY%253D%26from%3Dsinglemessage%26isappinstalled%3D0" target="_blank" rel="noopener">《iOS开发高手课》</a><br><a href="https://www.jianshu.com/p/632d7a1526e9" target="_blank" rel="noopener">iOS 性能监控（二）—— 主线程卡顿监控</a><br><a href="https://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="runloop" scheme="https://changzw.github.io/categories/iOS-Programming/runloop/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="底层" scheme="https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>调试内存不足问题：使用运行时魔法捕获布局反馈循环</title>
    <link href="https://changzw.github.io/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/"/>
    <id>https://changzw.github.io/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/</id>
    <published>2019-11-30T23:25:43.000Z</published>
    <updated>2020-04-25T02:55:55.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><p>目标：<br>使用代码替代 <code>UIViewLayoutFeedbackLoopDebuggingThreshold</code> 符号调试，来捕获 Autolayout反馈循环所导致的内存不足问题。</p><h2 id="导致内存不足的原因"><a class="markdownIt-Anchor" href="#导致内存不足的原因"></a> 导致内存不足的原因</h2><p>如果 App，开始有大量日活用户并且崩溃率很低，但是过段时间，总会出现崩溃问题，检查 Fabric 也没啥用。</p><p>出现这种情况很可能是因为，内存不足，导致应用被系统终止。</p><p>导致内存不足的原因：</p><ul><li>循环引用;</li><li>竞争条件;</li><li>废弃的线程;</li><li>死锁;</li><li>布局反馈循环。</li></ul><p>Apple 提供了很多方法来解决这类问题：</p><ul><li>Instruments 里的 Allocations 和 Leaks 工具用于解决循环引用和 <a href="https://developer.apple.com/videos/play/wwdc2015/230/" target="_blank" rel="noopener">其他类型的泄漏</a></li><li>在 Xcode 8 中引入的 <a href="https://developer.apple.com/videos/play/wwdc2016/410/" target="_blank" rel="noopener">Memory Debugger</a> 代替了 Allocations 和 Leaks 的一部分功能</li><li><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">Thread Sanitizer</a> 帮助你找到竞争条件、废弃的线程或者死锁</li></ul><h2 id="布局反馈循环"><a class="markdownIt-Anchor" href="#布局反馈循环"></a> 布局反馈循环</h2><blockquote><p>当视图正在运行它们的布局代码，但某种方法导致它们再一次开始布局传递，此时布局反馈循环就会出现。这可能是因为某个视图正在改变某个父视图的大小，或者因为你有一个模棱两可的布局。无论哪种原因，这个问题的表现是你的 CPU 使用被占满和 RAM 使用量稳步上升，因为你的视图正在一次又一次地运行它们的布局代码，却没有返回。<br>-来自<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">HackingWithSwift 的 Paul Hudson</a></p></blockquote><p>在 WWDC 16 中 Apple 介绍了“布局反馈循环调试器”。这个调试器有助于识别在调试过程中发生循环的时间点。这就是一个符号断点，它的工作方式非常简单：它会计算在单个 run loop 迭代中调用每个视图上的 <font color="red">layoutSubviews()</font> 方法的次数。一旦这个计数值超过某个临界值（比如，100），这个应用程序将会停在这个断点并打印出日志。<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">这篇文章</a> 快速地介绍如何使用这个调试器。</p><p>这个方法在可以重现问题的情况下十分有效。但是在线上出现就不用容易调试。但是你可以尝试把 <font color="red">UIViewLayoutFeedbackLoopDebuggingThreshold</font> 的代码复制到生产代码中。</p><h3 id="如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"><a class="markdownIt-Anchor" href="#如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"></a> 如何用代码实现 UIViewLayoutFeedbackLoopDebuggingThreshold 的功能呢</h3><p>符号断点是如何工作的：它会计算 layoutSubviews() 的调用次数并在单个 run loop 迭代中超过某个临界值时发送一个事件。听起来很简单，对吧？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackableView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="type">YourAnalyticsFramework</span>.event(name: <span class="string">"loop"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于一个视图，这段代码运行正常。</li><li>但是现在你想要在另一个视图上实现它。当然，你可以创建一个 UIView 的子类，在这里实现它并使你项目中的所有视图都继承这个子类。</li><li>然后为 UITableView，UIScrollView，UIStackView 等做同样的事情。</li></ol><p>如果将此逻辑注入你想要的任何类，而无需编写大量重复的代码。这时候就可以 <code>借助运行时编程</code> 了。</p><h3 id="使用-runtime-实现子类"><a class="markdownIt-Anchor" href="#使用-runtime-实现子类"></a> 使用 runtime 实现子类</h3><p>我们会做同样的事情——创建一个子类，重写 layoutSubviews() 方法并计算其调用次数。唯一的区别是所有这些都使用 runtime 完成，而不是在项目中创建重复的类。</p><p><strong>创建自定义子类</strong>，并将原始视图的类更改为新的子类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>objc_allocateClassPair() 方法的文档告诉我们这个方法何时失败：</li></ol><blockquote><p>新类，或者如果无法创建类，则为 Nil （例如，所需名称已被使用）。</p></blockquote><p>这就意味着不能拥有两个同名的类。我们的策略是为单个视图类创建一个单独的运行时类。这就是我们在原始类名前加上前缀来形成新类的名称的原因。</p><ol start="2"><li>现在添加一个计数器到子类中。理论上，有两种方法可以做到这一点。</li><li>添加一个保存计数器的属性。</li><li>为这个类创建一个关联对象（Associated object）。</li></ol><p>但是目前，只有一个方法奏效。你可以想象属性是存储在分配给类的内存里的东西，然而关联对象则储存在一个完全不同的地方。因为分配给已存在对象的内存是固定的，所以我们<font color="red">在自定义类上新添加的属性将会从其他资源里“窃取”内存</font>。它可能导致意料之外的行为和难以调试的程序崩溃（点击 <a href="https://stackoverflow.com/questions/3346427/object-setclass-to-bigger-class" target="_blank" rel="noopener">这里</a> 查看更多信息）。但是在使用关联对象的情况下，它们将会存储在运行时创建的一个哈希表里，这是完全安全的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = <span class="string">"_counter"</span></span><br><span class="line">...</span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>当新的子类被创建时，计数器初值设置为 0。</p><p><strong>实现这个新的layoutSubviews() 方法，并将它添加到我们的类中</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">      onLoop()</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>为了理解上面这段代码实际上在干什么，让我们看一下这个来自 &lt;objc/runtime.h&gt; 的结构体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> </span>&#123;</span><br><span class="line">  <span class="type">SEL</span> method_name;</span><br><span class="line">  char *method_types;</span><br><span class="line">  <span class="type">IMP</span> method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实际上是由什么组成的：</p><ul><li>方法的实现 method_imp，这是调用方法时要执行的实际函数。它的前两个形参总是方法接收者和消息选择器。</li><li>包含方法签名的方法类型字符串 method_types。你可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">这里</a> 详细了解其格式。但是在现在的情况下，需要明确说明的字符串是 “v@:”。作为返回类型，v 代表 void，而 @ 和 : 分别代表接收者和消息选择器。</li><li>选择器 method_name 作为键，用于在运行时查找方法的实现。</li></ul><p>你可以把 Witness Table（在其他编程语言中，它也被称作方法派发表）想象成一个简单的字典数据结构。那么选择器为键，且实现部分则为对应的值。<br>在下面这行代码中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(trackableClass,#selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>我们所做的是给 layoutSubviews() 方法对应的键分配新值。</p><p>这个方法直截了当。我们获得这个计数器，使它的计数值加一。如果计数值超过临界值，我们会发送分析事件，其中包含类名和想要的任何数据体。</p><p>让我们回顾一下如何对关联对象实现和使用键：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>为什么我们使用 var 来修饰计数器的键这个静态属性并在传递到其他地方时使用引用？答案隐藏在 Swift 语言基础——字符串之中。字符串像其他所有的值类型一样，是按值传递的。那么，当你把它传入这个闭包时，这个字符串将会被复制到一个不同的地址，这会导致在关联对象表中产生一个完全不同的键。&amp; 符号总是保证将相同的地址作为键参数的值。你可以尝试以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAddress</span><span class="params">(<span class="number">_</span> string: UnsafeRawPointer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(string)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">printAddress(str)</span><br><span class="line">printAddress(str)</span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  printAddress(str)</span><br><span class="line">  printAddress(str)</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 最后两个函数调用的地址将始终不同</span></span><br></pre></td></tr></table></figure><p>用引用的方式来传递键的主意总是好的，因为有时，即使你没有使用闭包，变量的地址仍可能因内存管理而更改。在我们例子中，如果你把上面的代码运行多次，即使是前两个 printAddress() 的调用也可能会输出不同的地址。</p><p>让我们回到运行时的魔法里来。在新 layoutSubviews() 的实现里，还有一件很重要的事情没有完成。这件事是每次重写父类的方法时通常都会做的事情——调用父类实现。layoutSubviews() 的文档里提到：</p><blockquote><p>在 iOS 5.1 及更早版本中，这个方法的默认实现不执行任何操作。而之后的默认实现会使用你设置的任何约束来确定任何子视图的大小和位置。</p></blockquote><p>为了避免发生一些难以预料的布局行为，我们得调用父类的实现，但这不像平常那样简单明了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line"><span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line"><span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line"><span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">originalLayoutSubviews(view, selector)</span><br></pre></td></tr></table></figure><p>这里实际发生的是：我们检索方法所需的实现部分，并直接从代码中调用它，而不是用常见的方式来调用方法（即执行一个会在 Witness Table 中寻找对应实现的选择器）。</p><p>目前为止，让我们看看实现部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">  <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称</span></span><br><span class="line">  <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">  <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在当前运行时会话期间尚未创建此类</span></span><br><span class="line">    <span class="comment">// 注册这个类并将其与原始视图的类交换</span></span><br><span class="line">    objc_registerClassPair(trackableClass)</span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">    objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">    <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">      <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">      <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">      <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">      <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">      <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">      originalLayoutSubviews(view, selector)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">          onLoop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">    class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">    <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类</span></span><br><span class="line">    <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换</span></span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为视图创建模拟布局循环，并为其设置计数器来进行测试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">    <span class="type">LayoutLoopHunter</span>.setUp(<span class="keyword">for</span>: view) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Hello, world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line">    view.setNeedsLayout() <span class="comment">// loop creation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是忘记了什么事情？让我们再次回顾一下 UIViewLayoutFeedbackLoopDebuggingThreshold 断点的工作原理：</p><blockquote><p>在确认为反馈循环之前，定义某个视图的子视图在单个 run loop 里必须布局的次数</p></blockquote><p>我们从未把“单个 run loop ”这一条件考虑进来。如果视图在屏幕上停留了相当长的时间，并经常被反复布局，计数器迟早会超过临界值。但这可不是因为内存的问题。</p><p>我们该怎么解决这个问题呢？只需在每次 run loop 迭代时重置计数器。为了做到这一点，我们可以创建一个 <a href="https://www.appcoda.com/grand-central-dispatch/" target="_blank" rel="noopener">DispatchWorkItem</a>，它重置计数器，并在主队列上异步传递它。通过这种方式，它会在 run loop 下一次进入主线程时被调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">  previousResetWorkItem.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> currentResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async(execute: currentResetWorkItem)</span><br><span class="line">objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, currentResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>最终的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Associated objects keys</span></span><br><span class="line">    <span class="comment">// 关联对象键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">      objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">      <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">        <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">        <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">        <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">        <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">        originalLayoutSubviews(view, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">            onLoop()</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 为重置计数器，在每个新的 run loop 遍历中分发 work item</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">          previousResetWorkItem.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> counterResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">          objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async(execute: counterResetWorkItem)</span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, counterResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">      class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>是的！现在你可以为所有可疑的视图设置分析事件了，发布应用程序，并找到这个问题的确切出处。你可以把这个问题的范围缩小到某个特定的视图，并在用户不知情的情况下借助于他们来解决这个问题。</p><p>最后要提到的一件事是：能力越大责任越大。运行时编程非常容易出错，因此很容易在不知情的情况下为应用程序引入另一个严重的问题。这就是为什么总是建议将应用程序中的所有危险代码包装在某种可停止开关中，因为你可以在发现代码导致问题时从后端触发开关禁用该功能。这有一篇介绍 Firebase 的 Feature Flags 的 <a href="https://medium.com/@rwbutler/feature-flags-a-b-testing-mvt-on-ios-718339ac7aa1" target="_blank" rel="noopener">(好文章</a></p><p>完整代码可以从这个 <a href="https://github.com/rsrbk/LayoutLoopHunter" target="_blank" rel="noopener">GitHub 仓库</a> 里获取，并且也将会发布到 CocoPods 上，以跟踪项目中的布局循环。</p><blockquote><p><a href="https://swift.gg/2019/11/11/layout-feedback-loop/" target="_blank" rel="noopener">大量引用</a><br>原文读起来费劲，只是想让自己读的容易写的这篇文章</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AlamoFire 分析</title>
    <link href="https://changzw.github.io/2019/08/23/source-code/AlamoFire-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2019/08/23/source-code/AlamoFire-%E5%88%86%E6%9E%90/</id>
    <published>2019-08-23T02:24:19.000Z</published>
    <updated>2020-05-20T03:01:51.578Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><p>分析源码：</p><ol><li>这个第三方库，他设计的目标是什么？</li><li>需要哪些基础知识</li><li>整体结构是什么样的</li><li>由外而内逐层分析层次结构</li><li>每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点</li><li>为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？</li></ol><p>为什么要分析 AlamoFire</p><ul><li>分析它的接口设计</li><li>分析他是如何封装 URL Loading System 的</li><li>分析网络层次思考数据传输过程</li></ul><p>AlamoFire 都做了什么？</p><ul><li>Chainable Request / Response Methods</li><li>URL / JSON Parameter Encoding</li><li>Upload File / Data / Stream / MultipartFormData</li><li>Download File using Request or Resume Data</li><li>Authentication with URLCredential</li><li>HTTP Response Validation</li><li>Upload and Download Progress Closures with Progress</li><li>cURL Command Output</li><li>Dynamically Adapt and Retry Requests</li><li>TLS Certificate and Public Key Pinning</li><li>Network Reachability</li></ul><h2 id="foundation-中提供的网络相关接口"><a class="markdownIt-Anchor" href="#foundation-中提供的网络相关接口"></a> Foundation 中提供的网络相关接口</h2><p><code>AlamoFire</code> 是一个网络请求库，底层封装的事 Apple 提供的 <code>URL Loading System</code></p><h3 id="后台-session下载流程注意事项"><a class="markdownIt-Anchor" href="#后台-session下载流程注意事项"></a> 后台 session下载流程&amp;注意事项</h3><p>后台 sessionConfiguration 下载文件保存 到本地沙盒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启后台 请求 task</span></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> session = <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.downloadTask(with: <span class="type">URL</span>(string: urlDownloadStr)!).resume()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">URLSessionDownloadDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">// 下载完成后代理回调方法，将文件移动到沙盒指定位置</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载完成 - \(location)"</span>)</span><br><span class="line">    <span class="keyword">let</span> locationPath = location.path</span><br><span class="line">    <span class="keyword">let</span> documnets = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/xxxx"</span> + <span class="string">".zip"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"移动地址:\(documnets)"</span>)</span><br><span class="line">    <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">try</span>! fileManager.moveItem(atPath: locationPath, toPath: documnets)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// http 分段传输，会不断调用这个方法直到，全部下载完成</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台请求，需要申请后台权限，这样 app 进入 background 的时候才可以继续下载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存后台下载的completionHandler</span></span><br><span class="line"><span class="keyword">var</span> backgroundSessionCompletionHandler: (() -&gt; <span class="type">Void</span>)? </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"background: \(identifier)"</span>)</span><br><span class="line">  <span class="keyword">self</span>.backgroundSessionCompletionHandler = completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-alamofire"><a class="markdownIt-Anchor" href="#使用-alamofire"></a> 使用 AlamoFire</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(urlString)</span><br><span class="line">  .responseJSON &#123; (data) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面对比[原生的方法(#code1), 思考 <code>AlamoFire</code> 都封装了什么，如何实现链式调用的，内部如何使用 oop，pop 的, 思考 <code>AlamoFire</code> 接口设计</p><p>下面这些都是怎么实现的？</p><ul><li>链式语法</li><li>直接传 string</li><li>封装调用 session，resume</li><li>Response 回调的返回的是 json 数据</li><li><code>Alamofire</code> 模块导入调用</li></ul><p>调用的第一层：<br>Alamofire.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Alamofire Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">  method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  headers: HTTPHeaders? = <span class="literal">nil</span>)</span></span></span><br><span class="line">  -&gt; <span class="type">DataRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>.<span class="keyword">default</span>.request(</span><br><span class="line">    url,</span><br><span class="line">    method: method,</span><br><span class="line">    parameters: parameters,</span><br><span class="line">    encoding: encoding,</span><br><span class="line">    headers: headers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionManager.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SessionManager</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A default instance of `SessionManager`, used by top-level Alamofire request methods, and suitable for use</span></span><br><span class="line"><span class="comment">/// directly for any ad hoc requests.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `<span class="keyword">default</span>`: <span class="type">SessionManager</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.httpAdditionalHeaders = <span class="type">SessionManager</span>.defaultHTTPHeaders </span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>(configuration: configuration)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">  configuration: <span class="type">URLSessionConfiguration</span> = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span> = <span class="type">SessionDelegate</span>(),</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = <span class="type">URLSession</span>(configuration: configuration, delegate: delegate, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>?(</span><br><span class="line">  session: <span class="type">URLSession</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span>,</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> delegate === session.delegate <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = session</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SessionDelegate()</code> 代理移交 <code>SessionDelegate</code> 是个 class, 处理 <code>URLSession</code> 的事件回调代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionTaskDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionStreamDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>为什么 Manager 不处理 <code>URLSession</code> 的代理回调方法，要搞一个 <code>SessionDelegate</code> 处理，因为 Manager 是一个中介者，用于管理各个 class 之间的联系，处理回调的那些方法应该归属于 xxxClass 来处理</p><p><img src="/img/AlamoFire-Manager.jpg" alt="AlamoFire 基本核心框架"></p><p>使用 Manager 主要作用是把代码模块之间的 频繁调用关系化简。划分业务层，管理层<br>Manager 统一管理调度<br>各个模块处理完成后，回调给 Manager</p><h3 id="处理后台下载"><a class="markdownIt-Anchor" href="#处理后台下载"></a> 处理后台下载</h3><h2 id="request"><a class="markdownIt-Anchor" href="#request"></a> request</h2><h3 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h3><p><img src="/img/requst_encode.jpeg" alt="提供的3种编码方式"></p><ul><li>url</li><li>json</li><li>propertyList</li></ul><p>url 是ASCII码编码的，他不是 Unicode，ASCII 码中的外文无法识别，所以要百分号编码——将 ACSII -&gt; Unicode 这样可以被识别</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> urlRequest: URLRequestConvertible, with parameters: Parameters?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> urlRequest = <span class="keyword">try</span> urlRequest.asURLRequest()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> parameters = parameters <span class="keyword">else</span> &#123; <span class="keyword">return</span> urlRequest &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// header</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> method = <span class="type">HTTPMethod</span>(rawValue: urlRequest.httpMethod ?? <span class="string">"GET"</span>), encodesParametersInURL(with: method) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = urlRequest.url <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">AFError</span>.parameterEncodingFailed(reason: .missingURL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">var</span> urlComponents = <span class="type">URLComponents</span>(url: url, resolvingAgainstBaseURL: <span class="literal">false</span>), !parameters.isEmpty &#123;</span><br><span class="line">      <span class="keyword">let</span> percentEncodedQuery = (urlComponents.percentEncodedQuery.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"&amp;"</span> &#125; ?? <span class="string">""</span>) + query(parameters)</span><br><span class="line">      urlComponents.percentEncodedQuery = percentEncodedQuery</span><br><span class="line">      urlRequest.url = urlComponents.url</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> urlRequest.value(forHTTPHeaderField: <span class="string">"Content-Type"</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">      urlRequest.setValue(<span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// body</span></span><br><span class="line">    urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> urlRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p.s. 传输组的时候一定要传 json 字符串！</p><p><a href="https://github.com/Alamofire/Alamofire/issues/1920" target="_blank" rel="noopener">iOS 10: Background Session won’t inform when downloads have failed #1920</a></p><blockquote><p><a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">URL Loading System</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Net" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Net/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>URL Loading System</title>
    <link href="https://changzw.github.io/2019/08/19/URL-Loading-System/"/>
    <id>https://changzw.github.io/2019/08/19/URL-Loading-System/</id>
    <published>2019-08-19T01:52:28.000Z</published>
    <updated>2020-05-20T07:28:52.914Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>在 Foundation 框架中</li><li>支持协议：<ul><li>FTP协议（ftp://）</li><li>超文本传输协议（http://）</li><li>加密超文本传输协议(https://)</li><li>本地资源(file://)</li><li>数据URLs(data://)</li></ul></li><li>关键类：URLSession，URL，URLRequest，Tasks，Data</li><li>支持：Authorization credentials，cache 和cookies， 配置管理</li><li>使用 closure 和 delegate 处理 Response</li></ul><p><img src="/img/url_loading_system.jpg" alt="url_loading_system 核心类 分 6 个部分"></p><h2 id="核心-urlsession-urlsessiontask"><a class="markdownIt-Anchor" href="#核心-urlsession-urlsessiontask"></a> 核心 URLSession &amp; URLSessionTask</h2><p>一个 session 请求网络数据需要的核心内容</p><p><img src="/img/urlsession.jpg" alt="urlsession"></p><h3 id="session-configuration"><a class="markdownIt-Anchor" href="#session-configuration"></a> Session Configuration</h3><p>每个配置属性都值得研究<br><img src="/img/urlsession_configuration.jpg" alt="configuration"><br><a href="https://juejin.im/post/5d5f5bcbe51d4561c02a2547" target="_blank" rel="noopener">这篇文章有各个参数翻译</a></p><p>总共有三种 configuration</p><ul><li><code>Default</code>: 使用本地沙盒缓存，用户credential保存在 keychain 中</li><li><code>Ephemeral</code>: 不使用沙盒，所有缓存credential 等数据存在 与 session 绑定的 RAM 中，session 失效后内存自动清理</li><li><code>Background</code>: 跟 default session 相似，但是使用的是另外一个 进程(process) 处理数据传输，因为是跨进程，所以 background session 有些限制操作。（嗯后台session 使用了进程间通信）</li></ul><p>为什么要有 configuration？<br>session 相当一个 manager，用来管理组织 task，网络事件处理的枢纽，configuration是这个枢纽的参数信息！相当于 一个 app 他都有 自己 preference</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration1 = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span><span class="comment">// 允许用户拥有沙盒缓存器，当session 释放的时候，数据依然存在</span></span><br><span class="line"><span class="keyword">let</span> configuration2 = <span class="type">URLSessionConfiguration</span>.ephemeral<span class="comment">// session 无效时，东西就会消失</span></span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration).dataTask(with: <span class="type">URL</span>(string: urlDownloadStr)!)</span><br><span class="line">  .resume()<span class="comment">// 后台 sessionConfiguration 不能设置 completeHandler，需要自己设置代理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"background-内存大小：\(String(describing: configuration.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"background-沙盒大小：\(String(describing: configuration.urlCache.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-内存大小：\(String(describing: configuration1.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-沙盒大小：\(String(describing: configuration1.urlCache.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-内存大小：\(String(describing: configuration2.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-沙盒大小：\(String(describing: configuration2.urlCache.diskCapacity))"</span>)</span><br></pre></td></tr></table></figure><p>打印结果：<br>background-内存大小：nil<br>background-沙盒大小：nil<br>default-内存大小：512000<br>default-沙盒大小：10000000<br>ephemeral-内存大小：512000<br>ephemeral-沙盒大小：0</p><p>就像文档说的，当session 失效以后 ephemeral 的 cache 会消失，因为他没有沙盒空间</p><h3 id="session-网络请求"><a class="markdownIt-Anchor" href="#session-网络请求"></a> session 网络请求</h3><p><img src="/img/urlsession_flow.jpg" alt="urlsession request flow"></p><p>我们要做的</p><ol><li>配置需要的 session configuration，</li><li>配置 session<ol><li>系统提供的 shared 单例，系统自己配置 configuration，sessionDelegate，delegateQueue</li><li>自定义 session，自己设置 configuration，sessionDelegate，delegateQueue(是 serial queue)</li></ol></li><li>提供 request &amp; url 给 session</li><li>生成 task<ol><li>URLSessionTask<ul><li>URLSessionDataTask</li><li>URLSessionUploadTask</li><li>URLSessionDownloadTask</li><li>URLSessionStreamTask</li><li>URLSessionWebSocketTask（iOS 13.0）</li></ul></li></ol></li><li>配置SessionDelegate, SessionTaskDelegate 对网络事件处理 (URLSessionTaskDelegate: URLSessionDelegate<ul><li>URLSessionDataDelegate</li><li>URLSessionDownloadDelegate</li><li>URLSessionStreamDelegate</li><li>URLSessionWebSocketDelegate（iOS 13.0）</li></ul></li></ol><p>SessionDelegate 只有3个接口</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, didBecomeInvalidWithError error: Error?)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping <span class="params">(URLSession.AuthChallengeDisposition, URLCredential?)</span></span></span> -&gt; <span class="type">Void</span>) </span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSessionDidFinishEvents</span><span class="params">(forBackgroundURLSession session: URLSession)</span></span></span><br></pre></td></tr></table></figure><p>至于各个 taskDelegate，对应不同的task 类型有个字不同协议接口<br>这里主要看 SessionTaskDelegate</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">URLSessionTaskDelegate</span> : <span class="title">URLSessionDelegate</span> </span>&#123; </span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest, completionHandler: @escaping <span class="params">(URLSession.DelayedRequestDisposition, URLRequest?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping <span class="params">(URLRequest?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping <span class="params">(URLSession.AuthChallengeDisposition, URLCredential?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping <span class="params">(InputStream?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的是 dataTask，downloadTask，uploadTask</p><h2 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h2><h3 id="从网站获取数据到内存"><a class="markdownIt-Anchor" href="#从网站获取数据到内存"></a> 从网站获取数据到内存</h3><h4 id="使用回调处理接受结果使用closure-回调得到-data"><a class="markdownIt-Anchor" href="#使用回调处理接受结果使用closure-回调得到-data"></a> 使用回调处理接受结果：使用closure 回调得到 data</h4><p><img src="https://docs-assets.developer.apple.com/published/c7124fb5d7/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task 的状态</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSessionTask</span> </span>&#123; </span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> running </span><br><span class="line">    <span class="keyword">case</span> suspended <span class="comment">// 初试状态</span></span><br><span class="line">    <span class="keyword">case</span> canceling </span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/"</span>)!</span><br><span class="line">  <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">      <span class="keyword">self</span>.handleClientError(error)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>,</span><br><span class="line">      (<span class="number">200</span>...<span class="number">299</span>).<span class="built_in">contains</span>(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.handleServerError(response)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mimeType = httpResponse.mimeType, mimeType == <span class="string">"text/html"</span>,</span><br><span class="line">      <span class="keyword">let</span> data = data,</span><br><span class="line">      <span class="keyword">let</span> string = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: url)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session create 出来的 task 是 suspend 的状态</span></span><br><span class="line">  task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>session create 出来的 task 初始状态是 suspend</li><li>回调处理是在 serial queue 任务放到子线程处理的，通知 UI 变化应切换主线程</li></ol><h4 id="接受请求详情结果使用-delegate"><a class="markdownIt-Anchor" href="#接受请求详情结果使用-delegate"></a> 接受请求详情&amp;结果：使用 Delegate</h4><p><img src="https://docs-assets.developer.apple.com/published/8b22355c7f/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png" alt=""></p><p>这个时候 session 不应该使用 <code>shared</code>，而是要自己配置</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> session: <span class="type">URLSession</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.waitsForConnectivity = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: configuration,</span><br><span class="line">                    delegate: <span class="keyword">self</span>,</span><br><span class="line">                    delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receivedData: <span class="type">Data?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  loadButton.isEnabled = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/"</span>)!</span><br><span class="line">  receivedData = <span class="type">Data</span>()</span><br><span class="line">  <span class="keyword">let</span> task = session.dataTask(with: url)</span><br><span class="line">  task.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate methods</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: @escaping <span class="params">(URLSession.ResponseDisposition)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>,</span><br><span class="line">    (<span class="number">200</span>...<span class="number">299</span>).<span class="built_in">contains</span>(response.statusCode),</span><br><span class="line">    <span class="keyword">let</span> mimeType = response.mimeType,</span><br><span class="line">    mimeType == <span class="string">"text/html"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.cancel)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  completionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.receivedData?.append(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span> &#123;</span><br><span class="line">  <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">self</span>.loadButton.isEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">      handleClientError(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> receivedData = <span class="keyword">self</span>.receivedData,</span><br><span class="line">      <span class="keyword">let</span> string = <span class="type">String</span>(data: receivedData, encoding: .utf8) &#123;</span><br><span class="line">      <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理的方式，可以处理很多特殊的情况：</p><ul><li>authentication challenges</li><li>following redirects</li></ul><blockquote><p><a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">URL Loading System</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="Guide" scheme="https://changzw.github.io/categories/iOS-Programming/Guide/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>好文章</title>
    <link href="https://changzw.github.io/2019/06/03/%E5%A5%BD%E6%96%87%E7%AB%A0/"/>
    <id>https://changzw.github.io/2019/06/03/%E5%A5%BD%E6%96%87%E7%AB%A0/</id>
    <published>2019-06-03T02:58:25.000Z</published>
    <updated>2020-06-08T03:25:02.785Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><p><a href="https://juejin.im/post/5bd5a546f265da0af033cee6" target="_blank" rel="noopener">深入理解 Autolayout 与列表性能 – 背锅的 Cassowary 和偷懒的 CPU</a><br><a href="https://juejin.im/post/5c22eaf1f265da611b5863b2" target="_blank" rel="noopener">深入浅出iOS编译</a><br><a href="https://zhuanlan.zhihu.com/p/57907139" target="_blank" rel="noopener">不了解GIF的加载原理？看我就够了！</a><br><a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a><br><a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="noopener">iOS应用架构谈 组件化方案</a><br><a href="https://blog.csdn.net/zhangao0086/article/details/45622875" target="_blank" rel="noopener">如何设计一个 iOS 控件?(iOS 控件完全解析)</a><br><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">RxSwift + MVVM: how to feed ViewModels</a><br><a href="https://swift.gg/2019/11/11/layout-feedback-loop/" target="_blank" rel="noopener">调试内存不足问题：使用运行时魔法捕获布局反馈循环</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="favorite" scheme="https://changzw.github.io/categories/favorite/"/>
    
    
      <category term="readings" scheme="https://changzw.github.io/tags/readings/"/>
    
  </entry>
  
  <entry>
    <title>读代码 Me</title>
    <link href="https://changzw.github.io/2019/05/17/source-code/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/"/>
    <id>https://changzw.github.io/2019/05/17/source-code/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/</id>
    <published>2019-05-16T16:47:30.000Z</published>
    <updated>2020-05-18T12:08:33.197Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><h2 id="为什么看"><a class="markdownIt-Anchor" href="#为什么看"></a> 为什么看</h2><p>抽空晚上睡不着看 <a href="https://github.com/vsouza/awesome-ios#gcd" target="_blank" rel="noopener">awesome-ios</a> 提供的优秀代码库<br>[Me](<a href="https://github.com/pascalbros/Me" target="_blank" rel="noopener">https://github.com/pascalbros/Me</a> 源码</p><h2 id="他是做什么的"><a class="markdownIt-Anchor" href="#他是做什么的"></a> 他是做什么的</h2><p>Me 是解决嵌套异步问题的一个轻量级库——就一个文件</p><h2 id="使用他以后的效果"><a class="markdownIt-Anchor" href="#使用他以后的效果"></a> 使用他以后的效果</h2><p>before</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyAPI</span>.login &#123;</span><br><span class="line">  <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">    <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">    <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">      <span class="comment">//We are done here</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Me</span>.start &#123; (me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.login &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">   <span class="comment">//We are done here</span></span><br><span class="line">   me.end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.run()</span><br></pre></td></tr></table></figure><p>看效果：</p><ol><li>Me 把异步嵌套代码–&gt; 链式代码（想想他是怎么做的？）</li><li>Me 是链条型的，start，next，next(name:)，jump(toName:)，end<ol><li>他是如何做异步通知的？</li><li>如何开始，如何结束？</li><li>支持实现多链条并发执行吗？</li></ol></li><li>从提供的接口上可以看出<ol><li>Me开启结束要由用户控制</li><li>节点驱动需要用户触发</li><li>支持指定节点跳转</li></ol></li></ol><p>ok 使用demo&amp;基本特性分析完了，接下来看源码</p><hr><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><h3 id="先看接口"><a class="markdownIt-Anchor" href="#先看接口"></a> 先看接口</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeInitClosure</span> = ((<span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeClosure</span> = ((<span class="number">_</span> previous: <span class="type">Me?</span>, <span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Me</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> index: <span class="type">UInt</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> parameters: [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式节点函数，static 是起点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(name: String = <span class="string">""</span>, this: @escaping MeInitClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(this: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">(name: String = <span class="string">""</span>, next: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNextOnMain</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toName jump: String)</span></span></span><br></pre></td></tr></table></figure><ol><li>提供 Me 节点 index，name，代码库内部维护</li><li>只提供其实节点 first</li><li>提供线程队列调度接口</li><li>parameters 是干什么的？像是 [name: MeClouse] 字典，每个 me 节点都有一个clouse</li></ol><h3 id="看代码实现"><a class="markdownIt-Anchor" href="#看代码实现"></a> 看代码实现</h3><ol><li>核心代码，这个地方封装了 GCD</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> next = <span class="keyword">self</span>.next &#123;</span><br><span class="line">    <span class="comment">//self.nextObj!.parameters = self.parameters //enable to pass parameters to the next object</span></span><br><span class="line">    queue.async &#123;</span><br><span class="line">      next(<span class="keyword">self</span>, <span class="keyword">self</span>.nextObj!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> to = me(at: jump) &#123;</span><br><span class="line">    to.this(<span class="keyword">self</span>, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个问题是：<code>jump</code> 的queue 没有用……（这个库的使用价值不大）只有 <code>runNext</code> 相关方法可以调度线程<br>parameters: 是 me 节点保存数据，用于用户自己传递数据使用</p><ol start="2"><li>内部数据结构使用的是链表</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> nextObj: <span class="type">Me?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _first: <span class="type">Me?</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="读源码" scheme="https://changzw.github.io/categories/%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift + MVVM:如何提供ViewModels</title>
    <link href="https://changzw.github.io/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/"/>
    <id>https://changzw.github.io/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/</id>
    <published>2019-04-16T12:58:40.000Z</published>
    <updated>2020-04-25T02:21:37.289Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">原文：RxSwift + MVVM: how to feed ViewModels</a></p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>自从我们开始在BlaBlaCar的Model-View-ViewModel（MVVM）架构中使用RxSwift以来，已经快一年了。我们对结果感到兴奋。我们使用这种方法编写的代码更容易理解，维护，测试和扩展。但是，最初的几周并不是小菜一碟。我们必须在MVVM + RxSwift架构的某些方面进行迭代，以使事情变得正确。其中一个方式——给 ViewModels 提供 Inputs。</p><p>让我们通过两种不同方式给ViewModels 提供 Inputs（Rx Event）</p><p>但是首先，让我们简单谈一下 ViewModels</p><h2 id="viewmodels"><a class="markdownIt-Anchor" href="#viewmodels"></a> ViewModels</h2><p>ViewModel的职责，你必须正确理解它（不止一个）：</p><ul><li>它应该是可以插入到任何View上的。比如，不是先造一个View再去定义一个ViewModel。注意，是View拥有ViewModel。View知道ViewModel，而不是反过来。</li><li>它是可测试的。最终，MVVM架构最大的好处就是让业务逻辑可测。</li><li>MVVM使用绑定机制更加牛逼，所以让使用 RxSwift 来更好地利用 ViewModel</li></ul><p>to be continued…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>iOS 响应链</title>
    <link href="https://changzw.github.io/2019/02/11/iOS-%E5%93%8D%E5%BA%94%E9%93%BE/"/>
    <id>https://changzw.github.io/2019/02/11/iOS-%E5%93%8D%E5%BA%94%E9%93%BE/</id>
    <published>2019-02-11T09:20:22.000Z</published>
    <updated>2020-06-11T16:04:58.533Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><p>响应链就是 UIRespondser 对象的组成链</p><h2 id="什么可以作为响应对象"><a class="markdownIt-Anchor" href="#什么可以作为响应对象"></a> 什么可以作为响应对象</h2><ol><li>响应者链通常是由视图（UIView）构成的</li><li>一个视图的下一个响应者是它视图控制器（UIViewController）（如果有的话），然后再转给它的父视图（Super View）</li><li>视图控制器（如果有的话）的下一个响应者为其管理的视图的父视图</li><li>单例的窗口（UIWindow）的内容视图将指向窗口本身作为它的下一个响应者</li><li>单例的应用（UIApplication）是一个响应者链的终点，它的下一个响应者指向nil，以结束整个循环</li></ol><p>当事件触发，UIKit 会把事件分发给响应链来处理 event</p><h2 id="事件分发"><a class="markdownIt-Anchor" href="#事件分发"></a> 事件分发</h2><p>第一响应者（First responder）指的是当前接受触摸的响应者对象（通常是一个UIView对象），即表示当前该对象正在与用户交互，它是响应者链的开端。<br>整个响应者链和事件分发的使命都是找出第一响应者。</p><p>UIWindow对象以消息的形式将事件发送给第一响应者，使其有机会首先处理事件。如果第一响应者没有进行处理，系统就将事件（通过消息）传递给响应者链中的下一个响应者，看看它是否可以进行处理。</p><p>iOS系统检测到手指触摸(Touch)操作时会将其打包成一个UIEvent对象，并放入当前活动Application的事件队列，单例的 UIApplication 会从事件队列中取出触摸事件并传递给单例的UIWindow来处理，UIWindow对象首先会使用hitTest:withEvent:方法寻找此次Touch操作初始点所在的视图(View)，即需要将触摸事件传递给其处理的视图，这个过程称之为hit-test view。</p><p>UIWindow实例对象会首先在它的内容视图上调用hitTest:withEvent:，此方法会在其视图层级结构中的每个视图上调用pointInside:withEvent:（该方法用来判断点击事件发生的位置是否处于当前视图范围内，以确定用户是不是点击了当前视图），如果pointInside:withEvent:返回YES，则继续逐级调用，直到找到touch操作发生的位置，这个视图也就是要找的hit-test view。<br>hitTest:withEvent:方法的处理流程如下:</p><p>首先调用当前视图的pointInside:withEvent:方法判断触摸点是否在当前视图内；<br>若返回NO,则hitTest:withEvent:返回nil;</p><p>若返回YES,则向当前视图的所有子视图(subviews)发送hitTest:withEvent:消息，所有子视图的遍历顺序是从最顶层视图一直到到最底层视图，即从subviews数组的末尾向前遍历，直到有子视图返回非空对象或者全部子视图遍历完毕；</p><p>若第一次有子视图返回非空对象，则hitTest:withEvent:方法返回此对象，处理结束；<br>如所有子视图都返回非，则hitTest:withEvent:方法返回自身(self)。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="UI" scheme="https://changzw.github.io/categories/iOS-Programming/UI/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>雪球速读法--迭代树--整体&amp;细节</title>
    <link href="https://changzw.github.io/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/"/>
    <id>https://changzw.github.io/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/</id>
    <published>2019-02-05T11:01:50.000Z</published>
    <updated>2020-04-25T03:03:03.779Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><h2 id="雪球速读法浅析"><a class="markdownIt-Anchor" href="#雪球速读法浅析"></a> 雪球速读法–浅析</h2><p>《雪球速读法》中说：</p><blockquote><p>速读的方式是：<br>速度技巧 * 资料库(大小) = 速读</p><ul><li>反复读 n 变</li><li>每次快速阅读，要求1.不求甚解，2.脑子里不要有读的声音</li></ul><p>具体：</p><ul><li>先话读目录，前言，后记 用 15~30，思考书的整体结构，作者写作意图</li><li>从框架的外层一层层向知识细节挖，每次处理一层，理解一层，构建自己对这本书的资料库（滚雪球的过程）</li></ul></blockquote><p>这样做的好处是：</p><ol><li>强调先掌握知识的框架！从整体的角度一层层学习知识。</li><li>有了框架就知道森林大概的样子！</li><li>如果单纯的按照目录一点点学习书本上的知识，会陷在局部细节中出不来浪费大量时间，读书时间过长，前面的知识会忘，后面不一定会认真读完，最后整本书都很难理解。</li><li>作者是以什么样的方式写书的呢？类似于《雪球速读法》先有中心思想，目录，段落，然后落实到细节，《雪球速读法》就是按照作者的写作的方式理解知识的过程。</li><li>速读不发出声音，更有利于读者跟作者产生共鸣！这个也是读书的一个目的</li></ol><h2 id="目标-vs-任务"><a class="markdownIt-Anchor" href="#目标-vs-任务"></a> 目标 vs 任务</h2><p>目标：一个你想要看见的好结果<br>任务：为实现目标你要做的事</p><p>在缺少动力的时候多思考目标带来那些美好的愿景，用 Deadline 给自己施加压力，对比人的承诺。</p><p>在执行的时候多看细节，任务，因为总是关注目标，会无从下手，很多细节上的困难乐观对待！导致目标最终搁浅。</p><h2 id="树状结构知识"><a class="markdownIt-Anchor" href="#树状结构知识"></a> 树状结构知识</h2><p>有关树状结构，知识迭代过程都是一层层包裹的知识，有历史气息的知识都是树状结构<br>这样的知识可以像《雪球速读法》一样层层学习</p><h2 id="计算机知识"><a class="markdownIt-Anchor" href="#计算机知识"></a> 计算机知识</h2><p>计算机知识就是一个大大的树，找到一个大树枝，然后一层层分解这个知识点<br><img src="/img/knowledge_tree.jpg" alt="-"></p><p>程序开发的时候也是，现有结构，然后再是细节！</p><p>有时间补充</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>iOS 渲染过程性能优化</title>
    <link href="https://changzw.github.io/2019/02/05/iOS-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://changzw.github.io/2019/02/05/iOS-%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2019-02-05T07:13:29.000Z</published>
    <updated>2020-06-10T02:33:07.994Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><p>此文整理<a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a></p><h2 id="屏幕显示原理"><a class="markdownIt-Anchor" href="#屏幕显示原理"></a> 屏幕显示原理</h2><h3 id="crt-显示器原理"><a class="markdownIt-Anchor" href="#crt-显示器原理"></a> CRT 显示器原理</h3><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_scan.png" alt="CRT 显示器原理"></p><ul><li>一帧画面：CRT 的电子枪从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。</li><li>为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。<ul><li>HSync: 当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization）</li><li>VSync: 而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization）。</li></ul></li><li>显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变</li></ul><h3 id="cpu-gpu-将数据交给显示器"><a class="markdownIt-Anchor" href="#cpu-gpu-将数据交给显示器"></a> CPU, GPU 将数据交给显示器</h3><p><a href="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_screen_display.png" target="_blank" rel="noopener">CPU, GPU 将数据交给显示器</a></p><ol><li>CPU 计算好显示内容提交到 GPU</li><li>GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。</li></ol><p>在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。<br>在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。</p><p>双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_vsync_off.jpg" alt="资源竞争冲突"></p><p>为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。</p><h2 id="卡顿产生的原因和解决方案"><a class="markdownIt-Anchor" href="#卡顿产生的原因和解决方案"></a> 卡顿产生的原因和解决方案</h2><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/11/ios_frame_drop.png" alt="卡顿产生的原因和解决方案"></p><ol><li>在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App</li><li>App <code>主线程</code> 开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。</li><li>随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，</li><li>等待下一次 VSync 信号到来时显示到屏幕上。</li></ol><h3 id="卡顿原因"><a class="markdownIt-Anchor" href="#卡顿原因"></a> 卡顿原因</h3><ul><li>如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，</li><li>则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。</li></ul><p>这就是界面卡顿的原因。</p><p>从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。</p><h3 id="cpu-资源消耗原因和解决方案"><a class="markdownIt-Anchor" href="#cpu-资源消耗原因和解决方案"></a> CPU 资源消耗原因和解决方案</h3><h4 id="对象创建"><a class="markdownIt-Anchor" href="#对象创建"></a> 对象创建</h4><p>对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。<br>尽量用轻量的对象代替重量的对象，可以对性能有所优化。</p><p>eg:</p><ul><li>CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。</li><li>如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。</li><li>通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。</li><li>尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。</li><li>如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。</li></ul><h4 id="对象调整"><a class="markdownIt-Anchor" href="#对象调整"></a> 对象调整</h4><p>对象的调整也经常是消耗 CPU 资源的地方。</p><ul><li>这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。</li><li>UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。</li></ul><p>当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。</p><h4 id="对象销毁"><a class="markdownIt-Anchor" href="#对象销毁"></a> 对象销毁</h4><p>对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。</p><ul><li>如果对象可以放到后台线程去释放，那就挪到后台线程去。</li><li>这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *tmp = <span class="keyword">self</span>.array;</span><br><span class="line"><span class="keyword">self</span>.array = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">  [tmp <span class="keyword">class</span>];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><details><summary>在异步线程中让引用计数变为 0，达到异步回收，swift版本，</summary><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncReleaseObjc</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"AsyncReleaseObjc:"</span> + #function + <span class="string">"\(Thread.current)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncReleaseObjcViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mainReleaseData: <span class="type">AsyncReleaseObjc?</span></span><br><span class="line">  <span class="keyword">var</span> threadReleaseData: <span class="type">AsyncReleaseObjc?</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    view.backgroundColor = .white</span><br><span class="line">    mainReleaseData = <span class="type">AsyncReleaseObjc</span>()</span><br><span class="line">    threadReleaseData = <span class="type">AsyncReleaseObjc</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesEnded</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">    mainReleaseData = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> tmp = threadReleaseData</span><br><span class="line">    threadReleaseData = <span class="literal">nil</span></span><br><span class="line">    <span class="type">DispatchQueue</span>.global().async &#123;<span class="comment">// 捕获 threadReleaseData，当async 结束时，释放</span></span><br><span class="line">      tmp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">deinit</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"AsyncReleaseObjcController:"</span> + #function)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h4 id="布局计算"><a class="markdownIt-Anchor" href="#布局计算"></a> 布局计算</h4><p>视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。</p><ul><li>如果能在后台线程提前计算好视图布局</li><li>并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。</li></ul><p>不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。<br>上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。</p><p>Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。(iOS12 性能改善，几乎跟 frame 差不多)</p><p>具体数据可以看这个文章：<a href="http://pilky.me/36/%E3%80%82" target="_blank" rel="noopener">http://pilky.me/36/。</a> 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。</p><h4 id="文本计算"><a class="markdownIt-Anchor" href="#文本计算"></a> 文本计算</h4><p>如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。<br>如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：</p><ul><li>用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，</li><li>用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。</li></ul><p>尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。</p><p>如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。</p><h4 id="文本渲染"><a class="markdownIt-Anchor" href="#文本渲染"></a> 文本渲染</h4><p>屏幕上能看到的所有文本内容控件在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。</p><ul><li>UIWebView，UILabel、UITextView 等</li><li>其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。</li><li>对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。</li><li>尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）</li><li>CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</li></ul><h4 id="图片的解码"><a class="markdownIt-Anchor" href="#图片的解码"></a> 图片的解码</h4><ol><li>当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。</li><li>图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。</li><li>这一步是发生在主线程的，并且不可避免。</li><li>如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。</li></ol><h4 id="图像的绘制"><a class="markdownIt-Anchor" href="#图像的绘制"></a> 图像的绘制</h4><p>图像的绘制通常是指用那些以 CG(CoreGraphic) 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。<br>这个最常见的地方就是 [UIView drawRect:] 里面了。<br>由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(backgroundQueue, ^&#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">CGBitmapContextCreate</span>(...);</span><br><span class="line">        <span class="comment">// draw in context...</span></span><br><span class="line">        <span class="built_in">CGImageRef</span> img = <span class="built_in">CGBitmapContextCreateImage</span>(ctx);</span><br><span class="line">        <span class="built_in">CFRelease</span>(ctx);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(mainQueue, ^&#123;</span><br><span class="line">            layer.contents = img;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gpu-资源消耗原因和解决方案"><a class="markdownIt-Anchor" href="#gpu-资源消耗原因和解决方案"></a> GPU 资源消耗原因和解决方案</h3><p>相对于 CPU 来说，GPU 能干的事情比较单一：</p><ul><li>接收提交的纹理（Texture）和顶点描述（三角形）</li><li>应用变换（transform）、混合并渲染，然后输出到屏幕上。</li><li>通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。</li></ul><h4 id="纹理的渲染"><a class="markdownIt-Anchor" href="#纹理的渲染"></a> 纹理的渲染</h4><ul><li>所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。</li><li>不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。</li><li>当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。</li><li>避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。</li></ul><p>当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：<a href="http://iosres.com" target="_blank" rel="noopener">iosres.com</a>。所以，尽量不要让图片和视图的大小超过这个值。</p><h4 id="视图的混合-composing"><a class="markdownIt-Anchor" href="#视图的混合-composing"></a> 视图的混合 (Composing)</h4><p>当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。</p><p>为了减轻这种情况的 GPU 消耗</p><ul><li>应用应当尽量减少视图数量和层次</li><li>并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。</li><li>当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。</li></ul><h4 id="图形的生成"><a class="markdownIt-Anchor" href="#图形的生成"></a> 图形的生成</h4><p>离屏渲染通常发生在 GPU 中:</p><ol><li>CALayer 的 border、圆角、阴影、遮罩（mask）</li><li>CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering）。</li><li>当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。</li><li>这时界面仍然能正常滑动，但平均帧数会降到很低。</li><li>为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。</li><li>最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="系统原理" scheme="https://changzw.github.io/categories/iOS-Programming/%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="性能优化" scheme="https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift 5.RxDataSources</title>
    <link href="https://changzw.github.io/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/"/>
    <id>https://changzw.github.io/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/</id>
    <published>2019-01-31T05:58:32.000Z</published>
    <updated>2020-04-25T02:21:27.338Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/RxSwiftCommunity/RxDataSources/issues?q=is%3Aissue+is%3Aclosed" target="_blank" rel="noopener">原文: RxDataSources</a></p><h2 id="table-和-collection-view-data-sources"><a class="markdownIt-Anchor" href="#table-和-collection-view-data-sources"></a> Table 和 Collection View data sources</h2><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li>[x] O(N)计算差异的算法<ul><li>该算法假设所有 sections 和 items 都是唯一的，因此没有二义性</li><li>如果有歧义，在非动画刷新时自动回退</li></ul></li><li>[x] 他使用其他启发式方法以将最少数量的命令发送到分段视图<ul><li>即使运行时间是线性的，发送命令的首选数量通常也比线性少</li><li>最好（并且有可能）将更改数量限制为较小的数量，并且如果更改数量朝线性方向增长，则只需进行正常的reload即可</li></ul></li><li>[x] 支持扩展你的 item 和 section 结构<ul><li>只需使用 <code>IdentifiableType</code> 和 <code>Equatable</code> 扩展你的 item，并使用 <code>AnimatableSectionModelType</code> 扩展 section</li></ul></li><li>[x] 支持 section 和 item 的两级分层动画的所有组合<ul><li>Section 动画: Insert, Delete, Mov</li><li>Item 动画: Insert, Delete, Move, Reload (如果旧值不等于新值)</li></ul></li><li>[x] 可配置动画类型对于 Insert, Reload and Delete (Automatic, Fade, …)</li><li>[x] 示例 app</li><li>[x] 随机压力测试（eg app）</li><li>[x] 支持开箱即用的编辑（eg app）</li><li>[x] 同 UITableView 和 UICollectionView 一起工作</li></ul><h2 id="为什么"><a class="markdownIt-Anchor" href="#为什么"></a> 为什么</h2><p>编写 table 和 collection View 数据源很繁琐。对于最简单的情况，需要实现大量的委托方法。</p><p>RxSwift 通过简单的数据绑定机制有助于减轻一些负担：</p><ol><li>把你的数据转化成可见听序列 Observable</li><li>使用下面方法把数据绑定到 tableView/collectionView 上<ul><li>rx.items(dataSource:protocol&lt;RxTableViewDataSourceType, UITableViewDataSource&gt;)</li><li>rx.items(cellIdentifier:String)</li><li>rx.items(cellIdentifier:String:Cell.Type:_: )</li><li>rx.items(<em>:</em>: )</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">Observable</span>&lt;[<span class="type">String</span>]&gt;.just([<span class="string">"first element"</span>, <span class="string">"second element"</span>, <span class="string">"third element"</span>])</span><br><span class="line"></span><br><span class="line">data.bind(to: tableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; index, model, cell <span class="keyword">in</span></span><br><span class="line">  cell.textLabel?.text = model</span><br><span class="line">&#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这适用于简单数据集，但不适用于需要将复杂数据集与多个section 绑定或在添加/修改/删除item 时需要执行动画的情况。</p><p>这些正是RxDataSources帮助解决的用例。</p><p>使用RxDataSources，写起来非常容易</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">SectionModel</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;&gt;(configureCell: configureCell)</span><br><span class="line"><span class="type">Observable</span>.just([<span class="type">SectionModel</span>(model: <span class="string">"title"</span>, items: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])])</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/rxdatasources/RxDataSources.gif" alt="-"></p><h2 id="怎么用"><a class="markdownIt-Anchor" href="#怎么用"></a> 怎么用</h2><p>给定以下自定义数据结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anInt: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> aString: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> aCGPoint: <span class="type">CGPoint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先使用遵循 SectionModelType 协议的结构定义你的section：<ul><li>定义 item 类型别名：等于该 section 将包含的 item 类型</li><li>声明一个 items 属性：Item 类型数组</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOfCustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> header: <span class="type">String</span>    </span><br><span class="line">  <span class="keyword">var</span> items: [<span class="type">Item</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SectionOfCustomData</span>: <span class="title">SectionModelType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Item</span> = <span class="type">CustomData</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(original: <span class="type">SectionOfCustomData</span>, items: [<span class="type">Item</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span> = original</span><br><span class="line">    <span class="keyword">self</span>.items = items</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个dataSource对象，并将其传递给 SectionOfCustomData 类型：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedAnimatedDataSource</span>&lt;<span class="type">MySection</span>&gt;(</span><br><span class="line">    configureCell: &#123; ds, tv, <span class="number">_</span>, item <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> cell = tv.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>) ?? <span class="type">UITableViewCell</span>(style: .<span class="keyword">default</span>, reuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"Item \(item)"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;,</span><br><span class="line">    titleForHeaderInSection: &#123; ds, index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> ds.sectionModels[index].header</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>根据需要在dataSource上自定义闭包：<ul><li>titleForHeaderInSection</li><li>titleForFooterInSection</li><li>etc</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataSource.titleForHeaderInSection = &#123; dataSource, index <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.titleForFooterInSection = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].footer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canEditRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canMoveRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将实际数据定义为 CustomData 对象的 Observable序列，并将其绑定到tableView</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sections = [</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"First section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">0</span>, aString: <span class="string">"zero"</span>, aCGPoint: <span class="type">CGPoint</span>.zero), <span class="type">CustomData</span>(anInt: <span class="number">1</span>, aString: <span class="string">"one"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)) ]),</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"Second section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">2</span>, aString: <span class="string">"two"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)), <span class="type">CustomData</span>(anInt: <span class="number">3</span>, aString: <span class="string">"three"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">3</span>, y: <span class="number">3</span>)) ])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.just(sections)</span><br><span class="line">  .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="数据源动画"><a class="markdownIt-Anchor" href="#数据源动画"></a> 数据源动画</h2><p>RxDataSources 提供了两种特殊的数据源类型，它们可以自动处理绑定数据源中的动画变化：<code>RxTableViewSectionedAnimatedDataSource</code> 和 <code>RxCollectionViewSectionedAnimatedDataSource</code> 。</p><p>要使用两个动画数据源之一，你必须在上述概述的基础上采取一些额外的步骤：</p><ul><li>SectionOfCustomData需要遵守 AnimatableSectionModelType 协议</li><li>数据模型必须符合<ul><li>IdentifiableType：IdentifiableType 协议提供的 <code>identity</code> 必须是表示模型实例的不可变标识符(identifier)。例如，对于 Car 模型，你可能要使用 Car 的plateNumber 作为其标识。</li><li>Equatable：遵从 Equatable 协议 有助于RxDataSources确定哪些 cell 已更改，因此它只能为这些特定 cell 设置动画。这意味着，更改Car模型的任何属性都会触发该 cell 的动画重新加载。</li></ul></li></ul><h2 id="需要"><a class="markdownIt-Anchor" href="#需要"></a> 需要</h2><p>Xcode 10.2</p><p>Swift 5.0</p><p>For Swift 4.x version please use versions 3.0.0 … 3.1.0 For Swift 3.x version please use versions 1.0 … 2.0.2 For Swift 2.3 version please use versions 0.1 … 0.9</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="cocoapods"><a class="markdownIt-Anchor" href="#cocoapods"></a> CocoaPods</h3><p>Podfile</p><blockquote><p>pod ‘RxDataSources’, ‘~&gt; 4.0’</p></blockquote><h3 id="carthage"><a class="markdownIt-Anchor" href="#carthage"></a> Carthage</h3><p>Cartfile</p><blockquote><p>github “RxSwiftCommunity/RxDataSources” ~&gt; 4.0</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>load和initialize</title>
    <link href="https://changzw.github.io/2019/01/12/load%E5%92%8Cinitialize/"/>
    <id>https://changzw.github.io/2019/01/12/load%E5%92%8Cinitialize/</id>
    <published>2019-01-12T03:58:04.000Z</published>
    <updated>2020-06-10T13:06:08.368Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><h2 id="load"><a class="markdownIt-Anchor" href="#load"></a> + load</h2><ol><li>load 是通过 c 函数调用的</li><li>load 调用在 main 函数之前，动态链接器通知调用 load_images，执行load 方法</li><li>load 加载顺序：父类-&gt; 类-&gt; 分类</li><li>load 方法中最常用的就是方法交换 method swizzling</li></ol><h3 id="load-方法的调用栈"><a class="markdownIt-Anchor" href="#load-方法的调用栈"></a> load 方法的调用栈</h3><p>在 <code>+ load</code> 方法出打断点，查看 load 调用栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>  +[XXObject load]</span><br><span class="line"><span class="number">1</span>  call_class_loads()</span><br><span class="line"><span class="number">2</span>  call_load_methods</span><br><span class="line"><span class="number">3</span>  load_images</span><br><span class="line"><span class="number">4</span>  dyld::notifySingle(dyld_image_states, ImageLoader <span class="keyword">const</span>*)</span><br><span class="line"><span class="number">11</span> _dyld_start</span><br></pre></td></tr></table></figure><blockquote><p>dyld(dynamic link editor)，它是苹果的动态链接器。<br>在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作</p></blockquote><p>在 runtime 时调用 <code>load_images</code> 方法,那么就看下他的源码(objc4-756.2)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* load_images</span></span><br><span class="line"><span class="comment">* Process +load in the given images which are being mapped in by dyld.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: write-locks runtimeLock and loadMethodLock</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">hasLoadMethods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">load_images</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path __unused, <span class="keyword">const</span> struct mach_header *mh)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasLoadMethods((<span class="keyword">const</span> headerType *)mh)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">recursive_mutex_locker_t</span> lock(loadMethodLock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Discover load methods</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">mutex_locker_t</span> lock2(runtimeLock);</span><br><span class="line">    prepare_load_methods((<span class="keyword">const</span> headerType *)mh);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Call +load methods (without runtimeLock - re-entrant)</span></span><br><span class="line">  call_load_methods();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare_load_methods</span><span class="params">(<span class="keyword">const</span> headerType *mhdr)</span></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> count, i;</span><br><span class="line"></span><br><span class="line">  runtimeLock.assertLocked();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">classref_t</span> *classlist = </span><br><span class="line">    _getObjc2NonlazyClassList(mhdr, &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    schedule_class_load(remapClass(classlist[i]));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">category_t</span> **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    <span class="keyword">category_t</span> *cat = categorylist[i];</span><br><span class="line">    Class cls = remapClass(cat-&gt;cls);</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">continue</span>;  <span class="comment">// category for ignored weak-linked class</span></span><br><span class="line">    <span class="keyword">if</span> (cls-&gt;isSwiftStable()) &#123;</span><br><span class="line">      _objc_fatal(<span class="string">"Swift class extensions and categories on Swift "</span></span><br><span class="line">            <span class="string">"classes are not allowed to have +load methods"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    realizeClassWithoutSwift(cls);</span><br><span class="line">    assert(cls-&gt;ISA()-&gt;isRealized());</span><br><span class="line">    add_category_to_loadable_list(cat);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* prepare_load_methods</span></span><br><span class="line"><span class="comment">* Schedule +load for classes in this image, any un-+load-ed </span></span><br><span class="line"><span class="comment">* superclasses in other images, and any categories in this image.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="comment">// Recursively schedule +load for cls and any un-+load-ed superclasses.</span></span><br><span class="line"><span class="comment">// cls must already be connected.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule_class_load</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cls) <span class="keyword">return</span>;</span><br><span class="line">  assert(cls-&gt;isRealized());  <span class="comment">// _read_images should realize</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cls-&gt;data()-&gt;flags &amp; RW_LOADED) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ensure superclass-first ordering</span></span><br><span class="line">  schedule_class_load(cls-&gt;superclass); </span><br><span class="line">  add_class_to_loadable_list(cls);</span><br><span class="line">  cls-&gt;setInfo(RW_LOADED); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* add_class_to_loadable_list</span></span><br><span class="line"><span class="comment">* Class cls has just become connected. Schedule it for +load if</span></span><br><span class="line"><span class="comment">* it implements a +load method.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_class_to_loadable_list</span><span class="params">(Class cls)</span> </span>&#123;</span><br><span class="line">  IMP method;</span><br><span class="line"></span><br><span class="line">  method = cls-&gt;getLoadMethod();</span><br><span class="line">  <span class="keyword">if</span> (!method) <span class="keyword">return</span>;  <span class="comment">// Don't bother if cls has no +load method</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (loadable_classes_used == loadable_classes_allocated) &#123;</span><br><span class="line">    loadable_classes_allocated = loadable_classes_allocated*<span class="number">2</span> + <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 分配类对象空间，加载类</span></span><br><span class="line">    loadable_classes = (struct loadable_class *)</span><br><span class="line">      <span class="built_in">realloc</span>(loadable_classes,</span><br><span class="line">                loadable_classes_allocated *</span><br><span class="line">                <span class="keyword">sizeof</span>(struct loadable_class));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  loadable_classes[loadable_classes_used].cls = cls;</span><br><span class="line">  loadable_classes[loadable_classes_used].method = method;</span><br><span class="line">  loadable_classes_used++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">* call_load_methods</span></span><br><span class="line"><span class="comment">* Call all pending class and category +load methods.</span></span><br><span class="line"><span class="comment">* Class +load methods are called superclass-first. </span></span><br><span class="line"><span class="comment">* Category +load methods are not called until after the parent class's +load.</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* This method must be RE-ENTRANT, because a +load could trigger </span></span><br><span class="line"><span class="comment">* more image mapping. In addition, the superclass-first ordering </span></span><br><span class="line"><span class="comment">* must be preserved in the face of re-entrant calls. Therefore, </span></span><br><span class="line"><span class="comment">* only the OUTERMOST call of this function will do anything, and </span></span><br><span class="line"><span class="comment">* that call will handle all loadable classes, even those generated </span></span><br><span class="line"><span class="comment">* while it was running.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The sequence below preserves +load ordering in the face of </span></span><br><span class="line"><span class="comment">* image loading during a +load, and make sure that no </span></span><br><span class="line"><span class="comment">* +load method is forgotten because it was added during </span></span><br><span class="line"><span class="comment">* a +load call.</span></span><br><span class="line"><span class="comment">* Sequence:</span></span><br><span class="line"><span class="comment">* 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line"><span class="comment">* 2. Call category +loads ONCE.</span></span><br><span class="line"><span class="comment">* 3. Run more +loads if:</span></span><br><span class="line"><span class="comment">*  (a) there are more classes to load, OR</span></span><br><span class="line"><span class="comment">*  (b) there are some potential category +loads that have </span></span><br><span class="line"><span class="comment">*    still never been attempted.</span></span><br><span class="line"><span class="comment">* Category +loads are only run once to ensure "parent class first" </span></span><br><span class="line"><span class="comment">* ordering, even if a category +load triggers a new loadable class </span></span><br><span class="line"><span class="comment">* and a new loadable category attached to that class. </span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Locking: loadMethodLock must be held by the caller </span></span><br><span class="line"><span class="comment">*   All other locks must not be held.</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_load_methods</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">bool</span> loading = NO;</span><br><span class="line">  <span class="keyword">bool</span> more_categories; </span><br><span class="line"><span class="comment">// Re-entrant calls do nothing; the outermost call will finish the job.</span></span><br><span class="line">  <span class="keyword">if</span> (loading) <span class="keyword">return</span>;</span><br><span class="line">  loading = YES; </span><br><span class="line">  <span class="keyword">void</span> *pool = objc_autoreleasePoolPush();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 1. Repeatedly call class +loads until there aren't any more</span></span><br><span class="line">    <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      call_class_loads();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 2. Call category +loads ONCE</span></span><br><span class="line">    more_categories = call_category_loads();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. Run more +loads if there are classes OR more untried categories</span></span><br><span class="line">  &#125; <span class="keyword">while</span> (loadable_classes_used &gt; <span class="number">0</span>  ||  more_categories); </span><br><span class="line">  objc_autoreleasePoolPop(pool); </span><br><span class="line">  loading = NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="initialize"><a class="markdownIt-Anchor" href="#initialize"></a> initialize</h2><ol><li>惰性方法，第一次初始化实例对象的时候会调用这个方法</li><li>正常情况，只会调用一次</li><li>不正常情况，调用多次，多个子类没有实现 initialize，那么会多次调用父类的 initialize</li></ol><h3 id="分析-initialize"><a class="markdownIt-Anchor" href="#分析-initialize"></a> 分析 initialize</h3><p>调用栈分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> +[XXObject initialize]</span><br><span class="line"><span class="number">1</span> _class_initialize</span><br><span class="line"><span class="number">2</span> lookUpImpOrForward</span><br><span class="line"><span class="number">3</span> _class_lookupMethodAndLoadCache3</span><br><span class="line"><span class="number">4</span> objc_msgSend</span><br><span class="line"><span class="number">5</span> main</span><br><span class="line"><span class="number">6</span> start</span><br></pre></td></tr></table></figure><ol><li>使用 oc 消息机制发送的</li><li>父类的initialize方法会比子类先执行</li><li>当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. <code>cls.isInitialized</code> 判断该类是否被实例化过</li><li>当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个</li></ol><blockquote><p><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%20load%20%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F.md" target="_blank" rel="noopener">你真的了解 load 方法么？</a><br><a href="https://github.com/draveness/analyze/blob/master/contents/objc/%E6%87%92%E6%83%B0%E7%9A%84%20initialize%20%E6%96%B9%E6%B3%95.md" target="_blank" rel="noopener">懒惰的 initialize 方法</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="底层" scheme="https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
      <category term="objc" scheme="https://changzw.github.io/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>从GCD 到 Operation</title>
    <link href="https://changzw.github.io/2018/12/25/%E4%BB%8EGCD-%E5%88%B0-Operation/"/>
    <id>https://changzw.github.io/2018/12/25/%E4%BB%8EGCD-%E5%88%B0-Operation/</id>
    <published>2018-12-25T03:00:22.000Z</published>
    <updated>2020-06-13T03:36:25.609Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><h2 id="operation-的优势"><a class="markdownIt-Anchor" href="#operation-的优势"></a> Operation 的优势</h2><p>Operation 底层是由 GCD 实现的，他的最大的优点是 复用性</p><p>向GCD 中的 queue 中放 task 的方式有两种</p><ol><li>添加 block(闭包)</li><li>添加 WorkItem(对象类型)</li></ol><p>虽然 workItem 也拥有复用性，但是用户可控性没有 Operation 好</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatchWorkItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(qos: <span class="type">DispatchQoS</span> = .unspecified, flags: <span class="type">DispatchWorkItemFlags</span> = [], block: @escaping <span class="meta">@convention</span>(block) () -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(timeout: DispatchTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(wallTimeout: DispatchWallTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], queue: DispatchQueue, execute: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="comment">// 制定 workItem 的依赖关系</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(queue: DispatchQueue, execute: DispatchWorkItem)</span></span></span><br><span class="line"><span class="comment">// 取消 work，如果没有开始，那么删除这个 work</span></span><br><span class="line"><span class="comment">// 如果 work 执行中，那么isCancel 会被设置为 true</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> isCancelled: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 item 的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">DispatchWorkItemFlags</span> : <span class="title">OptionSet</span>, <span class="title">RawRepresentable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> barrier: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> detached: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> assignCurrentContext: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> noQoS: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> inheritQoS: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> enforceQoS: <span class="type">DispatchWorkItemFlags</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"xyz"</span>) </span><br><span class="line"><span class="keyword">let</span> backgroundWorkItem = <span class="type">DispatchWorkItem</span> &#123; &#125; </span><br><span class="line"><span class="keyword">let</span> updateUIWorkItem = <span class="type">DispatchWorkItem</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">backgroundWorkItem.notify(queue: <span class="type">DispatchQueue</span>.main,execute: updateUIWorkItem) </span><br><span class="line">queue.async(execute: backgroundWorkItem)</span><br></pre></td></tr></table></figure><p>对于每个 Operation 都有自己的 state</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span> : <span class="title">NSObject</span> </span>&#123; </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">()</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isCancelled: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">cancel</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isReady: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isExecuting: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isFinished: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isConcurrent: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isAsynchronous: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addDependency</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">removeDependency</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> dependencies: [<span class="type">Operation</span>] &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> queuePriority: <span class="type">Operation</span>.<span class="type">QueuePriority</span> </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> qualityOfService: <span class="type">QualityOfService</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> completionBlock: (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：不像 gcd 你要把task block or workItem 放在 queue 里才能执行<br>Operation 自己可以执行，不过默认情况是 sync 的 eg:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> op = <span class="type">SubOperation</span>()</span><br><span class="line">op.start()<span class="comment">// 在当前 thread，sync 执行 Operation.main</span></span><br></pre></td></tr></table></figure><p>如果想要 Operation 异步操作，需要做额外操作，eg 使用OperationQueue</p><h2 id="blockoperation"><a class="markdownIt-Anchor" href="#blockoperation"></a> BlockOperation</h2><p>如果不想使用 OperationQueue 异步并发调度 Operation<br>可以使用 BlockOperation: Operation，执行在 default global queue.</p><p>BlockOperation 的效果跟 GCD 中的 Group 相同<br>不过内部执行是 异步并发的，<code>NSInvocationOperation</code> 在swift 中没有 <code>invocation</code> 相关方法在 swift 中都没有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果 oc 想要使用 invocation 调用 swift 的方法，那么 swift 中 该方法应该 是 @objc的，响应类也要继承 NSObject</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence = <span class="string">"Ray's courses are the best!"</span></span><br><span class="line"><span class="keyword">let</span> wordOperation = <span class="type">BlockOperation</span>()</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sentence.<span class="built_in">split</span>(separator: <span class="string">" "</span>) &#123;</span><br><span class="line">  wordOperation.addExecutionBlock &#123;</span><br><span class="line">    <span class="built_in">print</span>(word)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wordOperation.completionBlock = &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Thank you for your patronage!"</span>)</span><br><span class="line">&#125;</span><br><span class="line">duration &#123;</span><br><span class="line">  wordOperation.start()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 打印结果</span></span><br><span class="line"><span class="comment">the</span></span><br><span class="line"><span class="comment">are</span></span><br><span class="line"><span class="comment">courses</span></span><br><span class="line"><span class="comment">Ray's</span></span><br><span class="line"><span class="comment">best!</span></span><br><span class="line"><span class="comment">Thank you for your patronage!*/</span></span><br></pre></td></tr></table></figure><h2 id="operationqueue"><a class="markdownIt-Anchor" href="#operationqueue"></a> OperationQueue</h2><p>Operation 当你使用 Queue 来管理 Operation 的时候，才能体现他真正的强大的地方，将 Operation 放到 Queue，你不需要自己调用 start，当Queue Scheduler 分配好 thread 给 Operation 的时候，就会 start</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationQueue</span> : <span class="title">NSObject</span>, <span class="title">ProgressReporting</span> </span>&#123;</span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">13.0</span>, *)</span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> progress: <span class="type">Progress</span> &#123; <span class="keyword">get</span> &#125; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="number">_</span> op: Operation)</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperations</span><span class="params">(<span class="number">_</span> ops: [Operation], waitUntilFinished wait: Bool)</span></span></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addOperation</span><span class="params">(<span class="number">_</span> block: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">13.0</span>, *)</span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">addBarrierBlock</span><span class="params">(<span class="number">_</span> barrier: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> maxConcurrentOperationCount: <span class="type">Int</span> <span class="comment">// is 1, 表示串行</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> isSuspended: <span class="type">Bool</span></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> name: <span class="type">String?</span></span><br><span class="line">  <span class="keyword">open</span> <span class="keyword">var</span> qualityOfService: <span class="type">QualityOfService</span> </span><br><span class="line">  <span class="keyword">unowned</span>(unsafe) <span class="keyword">open</span> <span class="keyword">var</span> underlyingQueue: <span class="type">DispatchQueue?</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">cancelAllOperations</span><span class="params">()</span></span> </span><br><span class="line">  <span class="keyword">open</span> <span class="function"><span class="keyword">func</span> <span class="title">waitUntilAllOperationsAreFinished</span><span class="params">()</span></span> </span><br><span class="line"></span><br><span class="line">  <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">current</span>: <span class="title">OperationQueue</span>? </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">main</span>: <span class="title">OperationQueue</span> </span>&#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="thread" scheme="https://changzw.github.io/categories/iOS-Programming/thread/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>GCD 原理+API 分析</title>
    <link href="https://changzw.github.io/2018/12/21/GCD-%E5%8E%9F%E7%90%86-API-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2018/12/21/GCD-%E5%8E%9F%E7%90%86-API-%E5%88%86%E6%9E%90/</id>
    <published>2018-12-21T02:39:22.000Z</published>
    <updated>2020-06-13T03:01:57.625Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><p>GCD 是操作系统层级的概念，他给用户提供了操作线程的 API<br>任务派发中心，内部实现原理是有了 FIFO 分发队列,<a href="http://libdispatch.macosforge.org/" target="_blank" rel="noopener">GCD 源码</a><br>使用 GCD 用户不需要直接操作繁琐的 thread，线程池由系统管理，用户只需要维护分发队列，向分发队列中放 task 就可以了。<br>直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长，每个线程都会消耗一些内存和内核资源。</p><h2 id="主要原理"><a class="markdownIt-Anchor" href="#主要原理"></a> 主要原理</h2><p>主要理解三个概念</p><ol><li>queue: 管理任务的队列，确定任务派发方式</li><li>task: 用户自定义需要执行的 task (代码段)</li><li>thread: GCD 根据 queue 定义的方式，将 task 派发给线程池中的指定线程（thread 不需要自己创建）</li></ol><p><img src="/img/GCD-thread-mode.jpg" alt="GCD Queue task thread"></p><ul><li>queue<ul><li>串行队列，所有任务都在同一个 thread 上一个接着一个的执行<ul><li>特例：主队列 main_queue，所有 task 在 mainThread 中执行</li></ul></li><li>并发队列，任务可以在多个 thread 中执行没有固定执行顺序<ul><li>特例：global 队列</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">concurrent</span><br><span class="line">adj. adj. 并发的；一致的；同时发生的；并存的</span><br><span class="line">n. [数] 共点；同时发生的事件</span><br><span class="line"></span><br><span class="line">对于并行跟并发</span><br><span class="line">并发：值得是程序上多thread并发执行，其实是多线程抢占资源 -- cpu 执行（任务是以在单核 CPU 上分时（时间共享））</span><br><span class="line">并行：是硬件上，多个thread在多个 cpu 上同事执行着</span><br></pre></td></tr></table></figure><ul><li><p>同步异步执行任务</p><ul><li>sync 所有任务要在一个 thread 中执行，一个接着一个</li><li>async 具备开启线程的能力，可以在多个thread 中并发执行任务</li></ul></li><li><p>thread</p><ul><li>使用 GCD，不用再直接跟线程打交道了，只需要向队列中添加代码块(task)即可，GCD 在后端管理着一个线程池。</li><li>作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。</li><li>根据👆图 task 真正的并发只有 右下角的才能出现，并发队列中异步执行任务<br>P.S.：async 执行 task的时候 thread 的个数跟 task 的个数没有关系（现在 iOS系统是开辟 6个 thread，以前低版本的是 3个，thread 开辟太多，会用掉大量内存）</li></ul></li></ul><p>接下来说一些 GCD 接口，根据接口分析原理</p><h2 id="分发队列"><a class="markdownIt-Anchor" href="#分发队列"></a> 分发队列</h2><h3 id="队列的创建"><a class="markdownIt-Anchor" href="#队列的创建"></a> 队列的创建</h3><ol><li>GCD 公开有 5 个不同的全局队列：<ul><li>运行在主线程中的 main queue（串行队列）</li><li>global 队列，3 个不同优先级的后台队列（并发队列）</li><li>以及一个优先级更低的后台队列（用于 I/O）（并发队列）</li></ul></li></ol><p>得到系统的全局队列</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_main_t mainDispatchQueue = dispatch_get_main_queue();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_HIGH 2</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_LOW (-2)</span></span><br><span class="line"><span class="comment">#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_queue_global_t globalDispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>自定义队列：串行或者并行队列。自定义队列非常强大，<strong>在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。</strong></li></ol><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue</span><br><span class="line">concurrentQueue = dispatch_queue_create(<span class="string">"concurrent"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serialQueue = dispatch_queue_create(<span class="string">"serial"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure><p><img src="https://objccn.io/images/issues/issue-2/gcd-queues.png" alt=""></p><h3 id="创建队列并设置优先级"><a class="markdownIt-Anchor" href="#创建队列并设置优先级"></a> 创建队列并设置优先级</h3><ol><li>获取全局 global 系统队列时传递优先级</li><li>dipatch_queue_attr_make_with_qos_class</li><li>dispatch_set_target_queue</li></ol><p>使用 <code>dispatch_queue_attr_t</code> 属性设置优先级</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>;</span><br><span class="line"><span class="keyword">dispatch_queue_attr_t</span> attr;</span><br><span class="line">attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"com.example.myqueue"</span>, attr);</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>DISPATCH_QUEUE_PRIORITY_HIGH</td><td>QOS_CLASS_USER_INITIATED</td></tr><tr><td>DISPATCH_QUEUE_PRIORITY_DEFAULT</td><td>QOS_CLASS_DEFAULT</td></tr><tr><td>DISPATCH_QUEUE_PRIORITY_LOW</td><td>QOS_CLASS_UTILITY</td></tr><tr><td>DISPATCH_QUEUE_PRIORITY_BACKGROUND</td><td>QOS_CLASS_BACKGROUND</td></tr></tbody></table><ul><li>QOS_CLASS_USER_INTERACTIVE 指定为该QOS class的队列负责执行与用户交互相关的任务，比如动画、事件处理、更新UI等，所以有最高优先级。该优先级的队列应该只限于做与用户交互相关的任务，所以在上面优先级的宏定义中并没有将其暴露出来。(推测主队列优先级是这个)</li><li>QOS_CLASS_USER_INITIATED 指定为该QOS class的队列用来执行那些会阻碍用户使用你的App的任务，所以优先级也很高。</li><li>QOS_CLASS_DEFAULT 默认优先级。</li><li>QOS_CLASS_UTILITY 指定为该QOS class的队列用于执行那些用户不需要立即得到结果的任务，所以优先级相对较低。(long-running computations, I/O, networking or continuous data feeds.)</li><li>QOS_CLASS_BACKGROUND 指定为该QOS class的队列用于执行维护或清理等任务，用户不需要关心其结果。</li></ul><p>设置目标队列</p><details><summary>dispatch_set_target_queue 相关注释说明</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* When no quality of service <span class="class"><span class="keyword">class</span> <span class="title">and</span> <span class="title">relative</span> <span class="title">priority</span> <span class="title">is</span> <span class="title">specified</span> <span class="title">for</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">* <span class="title">dispatch</span> <span class="title">queue</span> <span class="title">at</span> <span class="title">the</span> <span class="title">time</span> <span class="title">of</span> <span class="title">creation</span>, <span class="title">a</span> <span class="title">dispatch</span> <span class="title">queue</span>'<span class="title">s</span> <span class="title">quality</span> <span class="title">of</span> <span class="title">service</span></span></span><br><span class="line"><span class="class">* <span class="title">class</span> <span class="title">is</span> <span class="title">inherited</span> <span class="title">from</span> <span class="title">its</span> <span class="title">target</span> <span class="title">queue</span>. <span class="title">The</span> <span class="title">dispatch_get_global_queue</span>()</span></span><br><span class="line"><span class="class">* <span class="title">function</span> <span class="title">may</span> <span class="title">be</span> <span class="title">used</span> <span class="title">to</span> <span class="title">obtain</span> <span class="title">a</span> <span class="title">target</span> <span class="title">queue</span> <span class="title">of</span> <span class="title">a</span> <span class="title">specific</span> <span class="title">quality</span> <span class="title">of</span></span></span><br><span class="line"><span class="class">* <span class="title">service</span> <span class="title">class</span>, <span class="title">however</span> <span class="title">the</span> <span class="title">use</span> <span class="title">of</span> <span class="title">dispatch_queue_attr_make_with_qos_class</span>()</span></span><br><span class="line"><span class="class">* <span class="title">is</span> <span class="title">recommended</span> <span class="title">instead</span>.</span></span><br></pre></td></tr></table></figure></pre></details><ol><li>将自定义 queue 中的 task 都将被放入到系统的全局队列和线程池中：默认情况下会把开发者创建的队列放入到<strong>默认优先级</strong>的全局队列中。但是也可以给自定义的队列设置一个目标队列</li><li>改变自定义 queue 的优先级：让其执行优先级与该目标队列的执行优先级一致。</li><li>改变 queue 中 task 执行的方式：不仅能改变优先级，如果一个队列是并行的，但是其目标队列是串行的，那么实际上这个队列也会转换为串行队列。再者，不同串行队列中的任务是可以同时执行的，如果把这些串行队列的目标队列都设置为同一个串行队列，那这些串行队列中的任务将不会并行执行。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> * @param object</span><br><span class="line"> * The object to modify.</span><br><span class="line"> * The result of passing <span class="literal">NULL</span> in <span class="keyword">this</span> parameter is undefined.</span><br><span class="line"> *</span><br><span class="line"> * @param <span class="built_in">queue</span></span><br><span class="line"> * The <span class="keyword">new</span> target <span class="built_in">queue</span> <span class="keyword">for</span> the object. The <span class="built_in">queue</span> is retained, <span class="keyword">and</span> the</span><br><span class="line"> * previous target <span class="built_in">queue</span>, <span class="keyword">if</span> any, is released.</span><br><span class="line"> * If <span class="built_in">queue</span> is DISPATCH_TARGET_QUEUE_DEFAULT, <span class="built_in">set</span> the object<span class="number">'</span>s target <span class="built_in">queue</span></span><br><span class="line"> * to the <span class="keyword">default</span> target <span class="built_in">queue</span> <span class="keyword">for</span> the given object type.</span><br><span class="line"> */</span><br><span class="line">DISPATCH_EXPORT DISPATCH_NOTHROW</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_set_target_queue(<span class="keyword">dispatch_object_t</span> object, <span class="keyword">dispatch_queue_t</span> _Nullable <span class="built_in">queue</span>);</span><br></pre></td></tr></table></figure><p>dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行</p><details><summary>dispatch_set_target_queue使用后的效果</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setTarget</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> serialQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"serialQueue"</span>)</span><br><span class="line">  <span class="keyword">let</span> aQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.0"</span>, attributes: .concurrent, target: serialQueue)</span><br><span class="line">  <span class="keyword">let</span> bQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.1"</span>, attributes: .concurrent, target: serialQueue)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> alabel = aQueue.label</span><br><span class="line">  <span class="keyword">let</span> blabel = bQueue.label</span><br><span class="line">  aQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(alabel): 1"</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 2"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 3"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">concurrent.queue.0: 1</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 2</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nosetTarget</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> aQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.0"</span>, attributes: .concurrent)</span><br><span class="line">  <span class="keyword">let</span> bQueue = <span class="type">DispatchQueue</span>(label: <span class="string">"concurrent.queue.1"</span>, attributes: .concurrent)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> alabel = aQueue.label</span><br><span class="line">  <span class="keyword">let</span> blabel = bQueue.label</span><br><span class="line">  aQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(alabel): 1"</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 2"</span>)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bQueue.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(blabel): 3"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">concurrent.queue.0: 1</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 3</span></span><br><span class="line"><span class="comment">concurrent.queue.1: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></pre></details><h2 id="gcd-任务调度"><a class="markdownIt-Anchor" href="#gcd-任务调度"></a> GCD 任务调度</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sync</span><span class="params">(execute workItem: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(execute workItem: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(group: DispatchGroup, execute workItem: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">async</span><span class="params">(group: DispatchGroup? = <span class="literal">nil</span>, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sync</span>&lt;T&gt;<span class="params">(execute work: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">sync</span>&lt;T&gt;<span class="params">(flags: DispatchWorkItemFlags, execute work: <span class="params">()</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">T</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(deadline: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(wallDeadline: DispatchWallTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(deadline: DispatchTime, execute: DispatchWorkItem)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">asyncAfter</span><span class="params">(wallDeadline: DispatchWallTime, execute: DispatchWorkItem)</span></span></span><br></pre></td></tr></table></figure><h3 id="只执行一次-task"><a class="markdownIt-Anchor" href="#只执行一次-task"></a> 只执行一次 task</h3><p>dispatch_once 只执行一次指定的block。它的性能要比@synchronized要好。@synchronized每一次都要先获取锁，而dispatch_once使用一个token标识代码是否执行过。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在Swift 3.0中这个函数被废弃了，但是可以使用懒加载的全局变量或静态变量，也能保证线程安全。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onceTask: <span class="type">String</span> = &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"onceTask"</span></span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h3 id="添加栅栏函数"><a class="markdownIt-Anchor" href="#添加栅栏函数"></a> 添加栅栏函数</h3><p><img src="/img/barrier.jpeg" alt=""></p><p>Dispatch Barrier解决多线程多读单写同一个资源发生死锁问题<br>同步队列中不会出现这个问题<br>在并发队列中，如果添加了 <code>.barrier</code> task 那么在 <code>.barrier</code> task 之前添加的任务所有任务执行之前都会有任务执行，在全局并发队列和串行队列上，效果和dispatch_sync一样</p><p><img src="/img/GCD_barrier.jpg" alt="barrier"></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">barrier</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"barrier"</span>, attributes: .concurrent)</span><br><span class="line">  q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  q.async(flags: .barrier) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sleep 2s----"</span>)</span><br><span class="line">    sleep(<span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  q.async &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">4</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><details><summary>一个 barrier 功能的 PhotoManager</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">PhotoManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> concurrentPhotoQueue =</span><br><span class="line">    <span class="type">DispatchQueue</span>(</span><br><span class="line">      label: <span class="string">"com.raywenderlich.GooglyPuff.photoQueue"</span>,</span><br><span class="line">      attributes: .concurrent)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> unsafePhotos: [<span class="type">Photo</span>] = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> photos: [<span class="type">Photo</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> photosCopy: [<span class="type">Photo</span>] = []</span><br><span class="line">    concurrentPhotoQueue.sync &#123;</span><br><span class="line">      photosCopy = <span class="keyword">self</span>.unsafePhotos</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> photosCopy</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(<span class="number">_</span> photo: Photo)</span></span> &#123;</span><br><span class="line">    concurrentPhotoQueue.async(flags: .barrier) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">self</span>.unsafePhotos.append(photo)</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.postContentAddedNotification()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">downloadPhotos</span><span class="params">(withCompletion completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> storedError: <span class="type">NSError?</span></span><br><span class="line">    <span class="keyword">for</span> address <span class="keyword">in</span> [<span class="type">PhotoURLString</span>.overlyAttachedGirlfriend,</span><br><span class="line">                    <span class="type">PhotoURLString</span>.successKid,</span><br><span class="line">                    <span class="type">PhotoURLString</span>.lotsOfFaces] &#123;</span><br><span class="line">                      <span class="keyword">let</span> url = <span class="type">URL</span>(string: address)</span><br><span class="line">                      <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123; <span class="number">_</span>, error <span class="keyword">in</span></span><br><span class="line">                        <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">                          storedError = error</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      <span class="type">PhotoManager</span>.shared.addPhoto(photo)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    completion?(storedError)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">postContentAddedNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">PhotoManagerNotification</span>.contentAdded, object: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h3 id="添加-group-通知"><a class="markdownIt-Anchor" href="#添加-group-通知"></a> 添加 group 通知</h3><p>dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。</p><p>当group里所有事件都完成GCD API有两种方式发送通知<br>第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时<br>第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// notify 任务组完成后，执行 notify 要做的事，notify不阻塞线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], queue: DispatchQueue, execute work: @escaping @convention<span class="params">(block)</span></span></span> () -&gt; <span class="type">Void</span>)</span><br><span class="line"><span class="meta">@available</span>(<span class="type">OSX</span> <span class="number">10.10</span>, iOS <span class="number">8.0</span>, *)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">notify</span><span class="params">(queue: DispatchQueue, work: DispatchWorkItem)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待直到完成or超时</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(timeout: DispatchTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">wait</span><span class="params">(wallTimeout timeout: DispatchWallTime)</span></span> -&gt; <span class="type">DispatchTimeoutResult</span></span><br></pre></td></tr></table></figure><p>如果放入组里面的任务内部没有嵌套任务，那么一切正常<br>可是如果组里面的 task 内部异步任务呢？eg task0{ async(task1) }<br>这个时候我想，task1 异步回调执行完，才算task0 这个组任务完成该怎么做？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">enter</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">leave</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这篇例子很棒–<a href="https://www.jianshu.com/p/92eed31b7421" target="_blank" rel="noopener">iOS 使用GCD控制网络请求顺序</a></p><details><summary>一个很棒的 使用 group 做同步的例子</summary><pre><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhotoManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> shared = <span class="type">PhotoManager</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">let</span> concurrentPhotoQueue =</span><br><span class="line">    <span class="type">DispatchQueue</span>(</span><br><span class="line">      label: <span class="string">"com.raywenderlich.GooglyPuff.photoQueue"</span>,</span><br><span class="line">      attributes: .concurrent)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> unsafePhotos: [<span class="type">Photo</span>] = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> photos: [<span class="type">Photo</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> photosCopy: [<span class="type">Photo</span>]!</span><br><span class="line">    concurrentPhotoQueue.sync &#123;</span><br><span class="line">      photosCopy = <span class="keyword">self</span>.unsafePhotos</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> photosCopy</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">addPhoto</span><span class="params">(<span class="number">_</span> photo: Photo)</span></span> &#123;</span><br><span class="line">    concurrentPhotoQueue.async(flags: .barrier) &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">self</span>.unsafePhotos.append(photo)</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">self</span>?.postContentAddedNotification()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">downloadPhotos</span><span class="params">(withCompletion completion: BatchPhotoDownloadingCompletionClosure?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> storedError: <span class="type">NSError?</span></span><br><span class="line">    <span class="keyword">let</span> downloadGroup = <span class="type">DispatchGroup</span>()</span><br><span class="line">    <span class="keyword">var</span> addresses = [<span class="type">PhotoURLString</span>.overlyAttachedGirlfriend,</span><br><span class="line">                     <span class="type">PhotoURLString</span>.successKid,</span><br><span class="line">                     <span class="type">PhotoURLString</span>.lotsOfFaces]</span><br><span class="line">    addresses += addresses + addresses</span><br><span class="line">    <span class="keyword">var</span> blocks: [<span class="type">DispatchWorkItem</span>] = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;addresses.<span class="built_in">count</span> &#123;</span><br><span class="line">      downloadGroup.enter()</span><br><span class="line">      <span class="keyword">let</span> block = <span class="type">DispatchWorkItem</span>(flags: .inheritQoS) &#123;</span><br><span class="line">        <span class="keyword">let</span> address = addresses[index]</span><br><span class="line">        <span class="keyword">let</span> url = <span class="type">URL</span>(string: address)</span><br><span class="line">        <span class="keyword">let</span> photo = <span class="type">DownloadPhoto</span>(url: url!) &#123; <span class="number">_</span>, error <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">if</span> error != <span class="literal">nil</span> &#123;</span><br><span class="line">            storedError = error</span><br><span class="line">          &#125;</span><br><span class="line">          downloadGroup.leave()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">PhotoManager</span>.shared.addPhoto(photo)</span><br><span class="line">      &#125;</span><br><span class="line">      blocks.append(block)</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async(execute: block)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> blocks[<span class="number">3</span>..&lt;blocks.<span class="built_in">count</span>] &#123;</span><br><span class="line">      <span class="keyword">let</span> cancel = <span class="type">Bool</span>.random()</span><br><span class="line">      <span class="keyword">if</span> cancel &#123;</span><br><span class="line">        block.cancel()</span><br><span class="line">        downloadGroup.leave()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    downloadGroup.notify(queue: <span class="type">DispatchQueue</span>.main) &#123;</span><br><span class="line">      completion?(storedError)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">postContentAddedNotification</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">PhotoManagerNotification</span>.contentAdded, object: <span class="literal">nil</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h3 id="挂起恢复队列"><a class="markdownIt-Anchor" href="#挂起恢复队列"></a> 挂起/恢复队列</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue.suspend()</span><br><span class="line">queue.resume()</span><br></pre></td></tr></table></figure><p>这里挂起不会暂停正在执行的block</p><h3 id="dispatch_apply进行快速迭代"><a class="markdownIt-Anchor" href="#dispatch_apply进行快速迭代"></a> dispatch_apply进行快速迭代</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> q = <span class="type">DispatchQueue</span>(label: <span class="string">"apply"</span>, attributes: .concurrent)</span><br><span class="line">  __dispatch_apply(<span class="number">5</span>, q)&#123; idx <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(idx)<span class="comment">// 异步并发</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"apply end"</span>)<span class="comment">// 同步等待</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">apply end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>dispatch_apply</p><ul><li>在并发队列中使用</li><li>将 task 追加到队列中</li><li>所有 task 并发执行完以后同步执行后面的打印</li><li>dispatch_apply 添加的 task 是异步并发执行，外部是同步执行</li></ul><p><img src="/img/GCD_apply.jpg" alt="apply"></p><p>用dispatch_apply替代对数组等的for循环，把这些block放到并行队列中可以提高执行效率。</p><h3 id="dispatch-semaphore"><a class="markdownIt-Anchor" href="#dispatch-semaphore"></a> Dispatch Semaphore</h3><p>使用变量管理多线程的同步方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> dispatch_semaphore_create(<span class="keyword">long</span> value);</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://objccn.io/issue-2-1/" target="_blank" rel="noopener">并发编程：API 及挑战</a><br><a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8" target="_blank" rel="noopener">细说GCD（Grand Central Dispatch）如何用</a><br>raywenderlich 这两篇实例很棒！<br><a href="https://www.raywenderlich.com/5370-grand-central-dispatch-tutorial-for-swift-4-part-1-2" target="_blank" rel="noopener">Grand Central Dispatch Tutorial for Swift 4: Part 1/2</a><br><a href="http://www.raywenderlich.com/79150/grand-central-dispatch-tutorial-swift-part-2" target="_blank" rel="noopener">Grand Central Dispatch Tutorial for Swift 4: Part 2/2<br></a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="thread" scheme="https://changzw.github.io/categories/iOS-Programming/thread/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="底层" scheme="https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>简化设计 App 的过程</title>
    <link href="https://changzw.github.io/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://changzw.github.io/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2018-12-06T09:31:17.000Z</published>
    <updated>2020-05-06T10:18:58.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>一个 app 原型&amp;需求来了以后，如何实现呢？<br>本来一个完成的东西如何把需求翻译成程序呢？</p><h2 id="正常节奏"><a class="markdownIt-Anchor" href="#正常节奏"></a> 正常节奏：</h2><ol><li>分析需求<ol><li>原型分析</li><li>需求分析</li></ol></li><li>技术点调研分析<ol><li>架构方式</li><li>使用什么框架（框架对比）</li><li>View 层使用什么渲染方式，Model层使用什么组件，中间层使用什么工具</li></ol></li><li>时间预估<ol><li>新技术学习时间</li><li>开发时间</li><li>调试时间</li></ol></li></ol><h2 id="遇到问题"><a class="markdownIt-Anchor" href="#遇到问题"></a> 遇到问题</h2><ol><li>需求量大，强调代码的复用性！思考时间过长</li><li>需求理解错误，理解不深，差异性问题没有解决</li><li>新技术，熟练度问题，错误使用</li><li>沟通问题！</li></ol><h2 id="简单思考"><a class="markdownIt-Anchor" href="#简单思考"></a> 简单思考</h2><ol><li>简化开发流程！</li><li>App 编码过程<ol><li>照着画 UI</li><li>确定数据渲染方式！</li><li>简化让 model 层数据传到 UI 层渲染的过程，让水流通（我喜欢的方式是函数响应式 rx）</li><li>数据流连接完成以后，添加各种逻辑<ol><li>单链逻辑</li><li>一条条加</li><li>复用的地方在复用</li></ol></li></ol></li><li>代码不是一下子完美的！<ol><li>开始的时候不要太复杂</li><li>不要用太高端自己又不熟悉的技巧</li><li>重构优化使用更好地技术手段都是迭代的过程</li></ol></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:05 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>viewController transitions</title>
    <link href="https://changzw.github.io/2018/11/06/UI%20%E7%9B%B8%E5%85%B3/viewController-transitions/"/>
    <id>https://changzw.github.io/2018/11/06/UI%20%E7%9B%B8%E5%85%B3/viewController-transitions/</id>
    <published>2018-11-06T09:21:48.000Z</published>
    <updated>2020-06-10T02:39:47.854Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>iOS 系统提供了像 <code>push, pop, cover vertically</code> 这样的 <code>ViewController</code> 过渡，该篇分析如何自定义自己的 ViewController transitions。为啥要写这个因为“看着很麻烦”，比起 push，pop，present 来说……</p><p>思考：</p><ol><li>ViewController 的 过渡流程步骤是什么样的</li><li>都有什么组成，他们之间的逻辑是什么样的</li><li>用户如何使用</li></ol><p>过渡的过程，应该有：</p><ol><li>负责触发事件</li><li>负责管理过渡动画</li><li>负责过渡相关的ViewControllers，Views</li></ol><h2 id="transitions-结构"><a class="markdownIt-Anchor" href="#transitions-结构"></a> transitions 结构</h2><p>transitioning API 一组 protocols 结合，允许我们自定义化，使用一个现有的 transition 对象 or 自己定义一个新的。<br><img src="/img/Transition-Frame.jpeg" alt="transitioning API"></p><p>Q: 每个协议的责任是什么？<br>Q: 执行步骤是什么</p><h3 id="transitioning-delegate"><a class="markdownIt-Anchor" href="#transitioning-delegate"></a> Transitioning Delegate</h3><p>每个 ViewController 都有对象—— <code>transitioningDelegate: UIViewControllerTransitioningDelegate</code> 用来得到 Animation controller 对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CardViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlipPresentAnimationController</span>(originFrame: cardView.frame)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你 present or dismiss <code>ViewController</code> 的时候，UIKit 会向 <code>transitioningDelegate</code> 要你自定义的 <code>Animation controller</code> 来替代默认动画。你要做的是实现 <code>UIViewControllerTransitioningDelegate</code> 代理方法返回 <code>Animation controller</code></p><h3 id="animation-controller"><a class="markdownIt-Anchor" href="#animation-controller"></a> Animation Controller</h3><p>用来做过渡动画，他实现自 <code>UIViewControllerAnimatedTransitioning</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipPresentAnimationController</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置动画时间</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 从UIViewControllerContextTransitioning 中得到 toVc &amp; fromVc，对其制作动画</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1 通过 transitionContext 得到 fromVC 是触发 present的VC，toVC 是要被呈现的 VC，snapShot，是toVC 呈现以后的view 截图用于做动画</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: .from),</span><br><span class="line">      <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: .to),</span><br><span class="line">      <span class="keyword">let</span> snapshot = toVC.view.snapshotView(afterScreenUpdates: <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//containerView 是过渡过程中的容器 view</span></span><br><span class="line">    <span class="keyword">let</span> containerView = transitionContext.containerView</span><br><span class="line">    <span class="keyword">let</span> finalFrame = transitionContext.finalFrame(<span class="keyword">for</span>: toVC)</span><br><span class="line"></span><br><span class="line">    snapshot.frame = originFrame</span><br><span class="line">    snapshot.layer.cornerRadius = <span class="type">CardViewController</span>.cardCornerRadius</span><br><span class="line">    snapshot.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    containerView.addSubview(toVC.view)</span><br><span class="line">    containerView.addSubview(snapshot)</span><br><span class="line">    toVC.view.isHidden = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnimationHelper</span>.perspectiveTransform(<span class="keyword">for</span>: containerView)</span><br><span class="line">    snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(.pi / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 view 做动画处理</span></span><br><span class="line">    <span class="type">UIView</span>.animateKeyframes(</span><br><span class="line">      withDuration: duration,</span><br><span class="line">      delay: <span class="number">0</span>,</span><br><span class="line">      options: .calculationModeCubic,</span><br><span class="line">      animations: &#123;</span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">0.0</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          fromVC.view.layer.transform = <span class="type">AnimationHelper</span>.yRotation(-.pi / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">1</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(<span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">2</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.frame = finalFrame</span><br><span class="line">          snapshot.layer.cornerRadius = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">      completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        toVC.view.isHidden = <span class="literal">false</span></span><br><span class="line">        snapshot.removeFromSuperview()</span><br><span class="line">        fromVC.view.layer.transform = <span class="type">CATransform3DIdentity</span></span><br><span class="line">        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><p>对于需要自定义的 transitioning 的 ViewController，CustomViewController</p><ol><li>CustomViewController: UIViewControllerTransitioningDelegate 实现协议</li><li>实现协议的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animationController(presented:, presenting:, source:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br><span class="line">animationController(dismiss:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 Animation Controller（CustomeAnimationController: UIViewControllerAnimatedTransitioning)</li><li>实现 UIViewControllerAnimatedTransitioning 中的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transitionDuration(using transitionContext: <span class="type">UIViewControllerContextTransitioning?</span>) -&gt; <span class="type">TimeInterval</span></span><br><span class="line">animateTransition(transitionContext:)</span><br></pre></td></tr></table></figure><h2 id="给-dismiss-添加手势交互"><a class="markdownIt-Anchor" href="#给-dismiss-添加手势交互"></a> 给 dismiss 添加手势交互</h2><p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/settings.gif" alt=""></p><blockquote><p><a href="https://www.raywenderlich.com/322-custom-uiviewcontroller-transitions-getting-started#toc-anchor-011" target="_blank" rel="noopener">Custom UIViewController Transitions: Getting Started</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sat Jun 13 2020 11:39:06 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="UI" scheme="https://changzw.github.io/categories/iOS-Programming/UI/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
