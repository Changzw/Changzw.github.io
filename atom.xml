<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fri.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://changzw.github.io/"/>
  <updated>2020-05-10T15:53:49.232Z</updated>
  <id>https://changzw.github.io/</id>
  
  <author>
    <name>Fri.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flutter 学习02 </title>
    <link href="https://changzw.github.io/2020/05/10/flutter-%E5%AD%A6%E4%B9%A002/"/>
    <id>https://changzw.github.io/2020/05/10/flutter-%E5%AD%A6%E4%B9%A002/</id>
    <published>2020-05-10T09:37:37.000Z</published>
    <updated>2020-05-10T15:53:49.232Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><p>学习–&gt; 精通</p><p>学习的目的不是为了精通，而是为了解决实际问题，一门编程语言并不是为了成为语言专家，而是为了解决实际问题。</p><h2 id="dart-特性"><a class="markdownIt-Anchor" href="#dart-特性"></a> DART 特性</h2><h3 id="编译支持jit与aot"><a class="markdownIt-Anchor" href="#编译支持jit与aot"></a> （编译）支持JIT与AOT</h3><ul><li>JIT（Just In Time，即时编译）: 在开发周期中使用，可以动态下发和执行代码，开发测试效率高，但运行速度和 执行性能则会因为运行时即时编译受到影响。</li><li>AOT（Ahead of Time，运行前编译）: 可以生成被直接执行的二进制代码，运行速度快、执行性能表现好，但每次执行前都需 要提前编译，开发测试效率低。</li></ul><p>如何区分一门语言究竟是AOT还是JIT呢？通常来说，看代码在执行前是否需要编译即可。如果需要编 译，通常属于AOT；如果不需要，则属于JIT。</p><p>AOT的典型代表是C/C++，它们必须在执行前编译成机器码；而JIT的代表，则包括了如JavaScript、Python 等几乎所有的脚本语言。</p><h3 id="内存管理内存分配与垃圾回收"><a class="markdownIt-Anchor" href="#内存管理内存分配与垃圾回收"></a> （内存管理）内存分配与垃圾回收</h3><p>Dart VM的内存分配策略比较简单，创建对象时只需要在堆上移动指针，内存增长始终是线性的，省去了查 找可用内存的过程。</p><p>在Dart中，并发是通过Isolate实现的。Isolate是类似于线程但不共享内存，独立运行的worker。这样的机制，就可以让Dart实现无锁的快速分配。</p><p>Dart的垃圾回收，则是采用了多生代算法。新生代在回收内存时采用“半空间”机制，触发垃圾回收时， Dart会将当前半空间中的“活跃”对象拷贝到备用空间，然后整体释放当前空间的所有内存。回收过程中， Dart只需要操作少量的“活跃”对象，没有引用的大量“死亡”对象则被忽略，这样的回收机制很适合 Flutter框架中大量Widget销毁重建的场景。</p><h3 id="线程线程模型单线程模型"><a class="markdownIt-Anchor" href="#线程线程模型单线程模型"></a> （线程）线程模型–单线程模型</h3><p>支持并发执行线程，大都以抢占式的方式切换线程，即：每个线程都会被分配一个固定的时间片来执行，超过了时间片后线程上下文将被抢占后切换。如果这时正在更新线程间的共享资源，抢占后就可能导致数据不同步的问题。</p><p>解决这一问题的典型方法是，使用锁来保护共享资源，但锁本身又可能会带来性能损耗，甚至出现死锁等更严重的问题。</p><p>Dart是单线程模型的优势就体现出来了，因为它天然不存在资源竞争和状态同步的问题。这就意味 着，一旦某个函数开始执行，就将执行到这个函数结束，而不会被其他Dart代码打断。</p><p><strong>Dart中并没有线程，只有Isolate（隔离区）</strong>。Isolates之间不会共享内存，就像几个运行在不同进程 中的worker，通过事件循环（Event Looper）在事件队列（Event Queue）上传递消息通信。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;&lt;p&gt;学习–&amp;gt; 精通&lt;/p&gt;&lt;p&gt;学习的目的不是为了精通，而是为了解决实际问题，一门编程语言并不是为了成为语言专家，而是为了解决实际问题。&lt;/p&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="flutter" scheme="https://changzw.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://changzw.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>flutter 学习01</title>
    <link href="https://changzw.github.io/2020/05/10/flutter-%E5%AD%A6%E4%B9%A001/"/>
    <id>https://changzw.github.io/2020/05/10/flutter-%E5%AD%A6%E4%B9%A001/</id>
    <published>2020-05-10T09:09:03.000Z</published>
    <updated>2020-05-10T09:37:04.116Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><ol><li>明确学习 flutter 要干什么！应用到实际中<ul><li>过一遍流程，可以做出一个 app</li><li>跟 iOS 各个框架比较思考</li><li>以后跨端实践</li></ul></li></ol><h2 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h2><ol><li>安装Android Studio<ul><li>配置完成后，我们打开AVD Manager，点击“Create Virtual Device”按钮创建一台Nexus 6P模拟器，至此 Android Studio的安装配置工作就完成了。</li></ul></li><li>安装Xcode</li><li>安装Flutter<ul><li>建议使用VPN</li></ul></li></ol><p>或者配置镜像站点的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn </span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><ul><li>去<a href="https://flutter.dev/docs/development/tools/sdk/releases?tab=macos" target="_blank" rel="noopener">Flutter官网</a>，选择并下载最新的稳定版</li><li>对于macOS与Linux系统，我们编辑~/.bash_profile文件，把以下代码添加至文件最后，将flutter命令的执行 路径追加到环境变量PATH中：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=~/Documents/flutter/bin:$PATH</span><br></pre></td></tr></table></figure><ul><li>执行 flutter doctor 看看还有什么配置问题</li></ul><ol start="4"><li>执行 flutter emulators 查看当前可用的模拟器：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="built_in">available</span> emulators:</span><br><span class="line"></span><br><span class="line">Pixel_XL_API_22     • Pixel XL API <span class="number">22</span> • Google • android</span><br><span class="line">apple_ios_simulator • iOS Simulator   • Apple  • ios</span><br><span class="line"></span><br><span class="line">To run an emulator, run 'flutter emulators --launch &lt;emulator id&gt;'.</span><br><span class="line">To create a new emulator, run 'flutter emulators --create [--name xyz]'.</span><br><span class="line"></span><br><span class="line">You can <span class="built_in">find</span> more information on managing emulators at the links below:</span><br><span class="line">  https:<span class="comment">//developer.android.com/studio/run/managing-avds</span></span><br><span class="line">  https:<span class="comment">//developer.android.com/studio/command-line/avdmanager</span></span><br></pre></td></tr></table></figure><p>如果出现这个问题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Waiting for another flutter command to release the startup lock...</span><br></pre></td></tr></table></figure><p>那么 <code>./flutter/bin/cache/lockfile</code></p><ol start="5"><li>启动 iOS模拟器，运行Flutter项目：flutter emulators --launch apple_ios_simulator</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;&lt;ol&gt;&lt;li&gt;明确学习 flutter 要干什么！应用到实际中&lt;ul&gt;&lt;li&gt;过一遍流程，可以做出一个 app&lt;/li&gt;&lt;li&gt;跟 iOS 各个框架比较思考&lt;/
      
    
    </summary>
    
    
      <category term="flutter" scheme="https://changzw.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://changzw.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>SnapKit 分析</title>
    <link href="https://changzw.github.io/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/</id>
    <published>2020-04-10T07:24:23.000Z</published>
    <updated>2020-04-25T07:00:42.842Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p>对应 <a href="https://changzw.github.io/2017/06/01/source-code/Masonry-%E5%88%86%E6%9E%90/">Masonry 源码分析</a>, 看这篇文章前最好先看看这篇</p><p>（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言）</p><p>分析源码：</p><ol><li>这个第三方库，他设计的目标是什么？</li><li>需要哪些基础知识</li><li>整体结构是什么样的</li><li>由外而内逐层分析层次结构</li><li>每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点</li><li>为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？</li></ol><h2 id="snapkit-是什么"><a class="markdownIt-Anchor" href="#snapkit-是什么"></a> <code>SnapKit</code> 是什么</h2><p><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">SnapKit 源码地址</a></p><h2 id="为什么要设计-snapkit"><a class="markdownIt-Anchor" href="#为什么要设计-snapkit"></a> 为什么要设计 <code>SnapKit</code></h2><p>首先和系统提供接口对比下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> constraint1 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">150</span>);</span><br><span class="line">constraint1.isActive = <span class="literal">true</span></span><br><span class="line">... top, width</span><br><span class="line"><span class="keyword">let</span> constraint4 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .height,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .notAnAttribute,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">20</span>);</span><br><span class="line">constraint4.isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Anchor: 只支持 ios &gt;= 9</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">  label.leftAnchor.constraint(equalTo: view.leftAnchor, constant: <span class="number">150</span>),</span><br><span class="line">  label.topAnchor.constraint(equalTo: view.topAnchor, constant: <span class="number">200</span>),</span><br><span class="line">  label.widthAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">  label.heightAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><span id="code1"></span></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.top.equalToSuperview().offset(<span class="number">200</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. SnapKit 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = true</p><p>SnapKit 设计的目的，就是以链式编程手段封装 <code>NSLayoutConstraint</code> 冗余代码！</p><ol><li>如何处理原来繁杂接口</li><li>如何实现链式</li><li>如何封装 <code>NSLayoutConstraint</code> 的</li><li>如何把多个 <code>NSLayoutConstraint</code> 封装成简单的一句搞定的</li><li>使用了何种编程手段</li></ol><hr><h2 id="snapkit-代码结构分析"><a class="markdownIt-Anchor" href="#snapkit-代码结构分析"></a> <code>SnapKit</code> 代码结构分析</h2><h3 id="从调用层次分析"><a class="markdownIt-Anchor" href="#从调用层次分析"></a> 从调用层次分析</h3><p>这里我要像洋葱一样一层一层的拨开</p><ol><li>最外层接口<br>根据这段代码分析</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstraintMaker.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; [<span class="type">Constraint</span>]</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">remakeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">updateConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从👆源码可以看到</p><ul><li>三个见名知意的方法</li><li>方法参数 <code>ConstraintMaker</code> 这个就是 make</li><li>属性 <code>ConstraintMakerExtendable</code> 这个就是 make 后面的 make.left</li></ul><p>我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口<br>我还要找到 下图的这些信息<br><img src="/img/view_formula.jpeg" alt="view formula"></p><ol start="2"><li>接着往里面看</li></ol><ul><li><code>ConstraintMakerExtendable</code> 继承自 <code>ConstraintMakerRelatable</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerExtendable</span> : <span class="title">ConstraintMakerRelatable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">left</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .top</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .bottom</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">right</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><ul><li><p>问题&amp;猜测：</p><ul><li><code>description</code> 是啥？不知道</li><li>不过他有 <code>attributes</code> 属性，看样子对应 <code>NSLayoutConstraint.Attribute</code></li><li>left, top …… 这些都返回 <code>ConstraintMakerExtendable</code> ，猜测他是链的节点对象</li></ul></li><li><p>继续看 <code>ConstraintMakerRelatable</code></p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerRelatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> description: <span class="type">ConstraintDescription</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(<span class="number">_</span> description: <span class="type">ConstraintDescription</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">relatedTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> related: <span class="type">ConstraintItem</span></span><br><span class="line">    <span class="keyword">let</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintItem</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> other.attributes == <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span> ||</span><br><span class="line">          other.attributes.layoutAttributes.<span class="built_in">count</span> &lt;= <span class="number">1</span> ||</span><br><span class="line">          other.attributes.layoutAttributes == <span class="keyword">self</span>.description.attributes.layoutAttributes ||</span><br><span class="line">          other.attributes == .edges &amp;&amp; <span class="keyword">self</span>.description.attributes == .margins ||</span><br><span class="line">          other.attributes == .margins &amp;&amp; <span class="keyword">self</span>.description.attributes == .edges ||</span><br><span class="line">          other.attributes == .directionalEdges &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalMargins ||</span><br><span class="line">          other.attributes == .directionalMargins &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalEdges <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Cannot constraint to multiple non identical attributes. (\(file), \(line))"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      related = other</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintView</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintConstantTarget</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: <span class="literal">nil</span>, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = other</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *), <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintLayoutGuide</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fatalError</span>(<span class="string">"Invalid constraint. (\(file), \(line))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> editable = <span class="type">ConstraintMakerEditable</span>(<span class="keyword">self</span>.description)</span><br><span class="line">    editable.description.sourceLocation = (file, line)</span><br><span class="line">    editable.description.relation = relation</span><br><span class="line">    editable.description.related = related</span><br><span class="line">    editable.description.constant = constant</span><br><span class="line">    <span class="keyword">return</span> editable</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">equalTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, <span class="number">_</span> file: String = #file, <span class="number">_</span> line: UInt = #line)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.relatedTo(other, relation: .<span class="built_in">equal</span>, file: file, line: line)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到了</p><ul><li>ConstraintConstantTarget(struct)</li><li>ConstraintRelation(struct)</li><li>ConstraintAttributes(struct)</li><li>ConstraintDescription(class)</li><li>ConstraintItem(class)</li><li>ConstraintMakerEditable(class)</li></ul><h3 id="model-层数据分析"><a class="markdownIt-Anchor" href="#model-层数据分析"></a> model 层数据分析</h3><h4 id="constraintconstanttarget"><a class="markdownIt-Anchor" href="#constraintconstanttarget"></a> ConstraintConstantTarget</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">LayoutAttribute</span> = <span class="type">NSLayoutConstraint</span>.<span class="type">Attribute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintInsets</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDirectionalEdgeInsets</span> : <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">constraintConstantTargetValueFor</span><span class="params">(layoutAttribute: LayoutAttribute)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码知道 <code>ConstraintConstantTarget</code> 是 autolayout 方程式中的 constant，他是这个 constant 扩展封装</p><h4 id="constraintrelation"><a class="markdownIt-Anchor" href="#constraintrelation"></a> ConstraintRelation</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConstraintRelation</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">  <span class="keyword">case</span> <span class="built_in">equal</span> </span><br><span class="line">  <span class="keyword">case</span> lessThanOrEqual </span><br><span class="line">  <span class="keyword">case</span> greaterThanOrEqual </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutRelation: <span class="type">LayoutRelation</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintRelation</code> 是 方程式中的 关系符号</p><h4 id="constraintattributes"><a class="markdownIt-Anchor" href="#constraintattributes"></a> ConstraintAttributes</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConstraintAttributes</span> : <span class="title">OptionSet</span>, <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">none</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> top: <span class="type">ConstraintAttributes</span> &#123;  <span class="keyword">return</span> <span class="number">2</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">8</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leading: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">16</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailing: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">32</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> width: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">64</span> &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutAttributes:[<span class="type">LayoutAttribute</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs = [<span class="type">LayoutAttribute</span>]()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.<span class="keyword">left</span>)) &#123;</span><br><span class="line">      attrs.append(.<span class="keyword">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.top)) &#123;</span><br><span class="line">      attrs.append(.top)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> -&gt; <span class="type">ConstraintAttributes</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">left</span>.union(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> &#123;</span><br><span class="line">  <span class="keyword">left</span>.formUnion(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ConstraintAttributes 使用了swift 的选择集(可选枚举)</li><li>重载了运算符</li><li>依然猜测 它对应 <code>NSLayoutConstraint.Attribute</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">AnyObject?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(target: <span class="type">AnyObject?</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutConstraintItem: <span class="type">LayoutConstraintItem?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target <span class="keyword">as</span>? <span class="type">LayoutConstraintItem</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: ConstraintItem, rhs: ConstraintItem)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LayoutConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">LayoutConstraintItem</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintLayoutGuide</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintView</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintLayoutGuide</span> = <span class="type">UILayoutGuide</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintView</span> = <span class="type">UIView</span></span><br></pre></td></tr></table></figure><p>nice~<br>ConstraintItem 就是 view 和 他对应布局属性的元组 (view, attr)</p><h4 id="constraintdescription"><a class="markdownIt-Anchor" href="#constraintdescription"></a> ConstraintDescription</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintDescription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> item: <span class="type">LayoutConstraintItem</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> relation: <span class="type">ConstraintRelation?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sourceLocation: (<span class="type">String</span>, <span class="type">UInt</span>)?</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> label: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> related: <span class="type">ConstraintItem?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> multiplier: <span class="type">ConstraintMultiplierTarget</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> priority: <span class="type">ConstraintPriorityTarget</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">lazy</span> <span class="keyword">var</span> constraint: <span class="type">SnapKit</span>.<span class="type">Constraint?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// main</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintDescription</code> 包含了 autolayout 布局方程式中所有信息，可是不知道为啥不在这里调用 NSLayoutConstraint 添加属性，非要搞一个 SnapKit.Constraint来做这些事</p><ul><li>ConstraintMakerEditable 是链式编程技巧里面的往后看</li></ul><h3 id="分析-snapkit-链式封装"><a class="markdownIt-Anchor" href="#分析-snapkit-链式封装"></a> 分析 <code>SnapKit</code> 链式封装</h3><h4 id="主要组件结"><a class="markdownIt-Anchor" href="#主要组件结"></a> 主要组件结</h4><ul><li>文件分组<br><img src="/img/snapkit_files.jpeg" alt="snapkit_files"></li></ul><h4 id="使用函数调用栈分析"><a class="markdownIt-Anchor" href="#使用函数调用栈分析"></a> 使用函数调用栈分析</h4><details><summary>SnapKit 主流程</summary><pres><p><img src="/img/snapKit_main_flow.jpeg" alt="snapKit main flow"><br></p></pres><p></p></details><details><summary>SnapKit 链式流程</summary><pres><p><img src="/img/snapKit_chain.jpeg" alt="snapKit chain"><br></p></pres><p></p></details><p>maker 创建一个其实节点 ContraintExtentable，他维护自己的 description<br>maker 保存 descriptions[] 数组</p><p>传递 description 来延续链节点</p><p>to be continued</p><h3 id="代码组件分析"><a class="markdownIt-Anchor" href="#代码组件分析"></a> 代码组件分析</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="noopener">Auto Layout Guide</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="UI 布局" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>使用 closures 代替 Gesture Recognizers 选择器</title>
    <link href="https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/"/>
    <id>https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/</id>
    <published>2020-03-08T01:56:45.000Z</published>
    <updated>2020-04-25T02:56:00.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/@sdrzn/adding-gesture-recognizers-with-closures-instead-of-selectors-9fb3e09a8f0b" target="_blank" rel="noopener">原文 Adding Gesture Recognizers with Closures Instead of Selectors<br></a></p><p>添加UITapGestureRecognizer或任何 recognizer/target action 的最糟糕的部分是仅针对选择器参数实现新功能。今天，我想分享一个巧妙的技巧，让你添加不带选择器的手势识别器。</p><p>假设我们在View Controller中有一个UIImageView，我们想向其中添加一个UITapGestureRecognizer，以便在点击它时打印出一条语句.</p><p>通常，我们会创建一个 UITapGestureRecognizer 的实例，并将其目标设置为视图控制器及其选择器，因为我们会快速将它们组合在一起(myImageViewTapped(sender：UITapGestureRecognizer))。</p><p>这可能会有点多余，并且可能导致要添加交互性的每个子视图的函数的代码混乱。</p><p>我以为我可以快速扩展一下，以便为我的图像视图添加敲击手势识别器，但是然后我必须为每个识别器创建一个新功能，对吗？错误！利用关联对象的功能，我们实际上可以将闭包存储为扩展中的计算属性！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In order to create computed properties for extensions, we need a key to </span></span><br><span class="line">  <span class="comment">// store and access the stored property</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociatedObjectKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tapGestureRecognizer = <span class="string">"MediaViewerAssociatedObjectKey_mediaViewer"</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">typealias</span> <span class="type">Action</span> = (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set our computed property type to a closure</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> tapGestureRecognizerAction: <span class="type">Action?</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newValue = newValue &#123;</span><br><span class="line">        <span class="comment">// Computed properties get stored as associated objects</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> tapGestureRecognizerActionInstance = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer) <span class="keyword">as</span>? <span class="type">Action</span></span><br><span class="line">      <span class="keyword">return</span> tapGestureRecognizerActionInstance</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// This is the meat of the sauce, here we create the tap gesture recognizer and</span></span><br><span class="line">  <span class="comment">// store the closure the user passed to us in the associated object we declared above</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addTapGestureRecognizer</span><span class="params">(action: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.tapGestureRecognizerAction = action</span><br><span class="line">    <span class="keyword">let</span> tapGestureRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleTapGesture))</span><br><span class="line">    <span class="keyword">self</span>.addGestureRecognizer(tapGestureRecognizer)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Every time the user taps on the UIImageView, this function gets called,</span></span><br><span class="line">  <span class="comment">// which triggers the closure we stored</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">handleTapGesture</span><span class="params">(sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.tapGestureRecognizerAction &#123;</span><br><span class="line">      action?()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"no action"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们要将UITapGestureRecognizer添加到UIView或UIView子类（如UIImageView）时，都可以这样做，而无需为选择器创建关联的功能！这是一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampleImageView.addTapGestureRecognizer &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"image tapped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有UITapGestureRecognizers实例，没有targets，没有selectors，没有不必要的functions！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>KeyboardKit 源码分析</title>
    <link href="https://changzw.github.io/2020/03/03/source-code/KeyboardKit-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2020/03/03/source-code/KeyboardKit-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-03-03T13:01:50.000Z</published>
    <updated>2020-04-25T02:51:15.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><p>KeyboardKit是一个Swift库，用来创建iOS键盘扩展</p><a id="more"></a><p>使用KeyboardKit，继承KeyboardInputViewController而不是UIInputViewController。KeyboardKit提供了一个可以处理点击，长按等操作的keyboardActionHandler以及一个可以向其中添加工具栏，按钮行和集合视图之类的组件的keyboardStackView。</p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念：</h2><h3 id="keyboard-actions"><a class="markdownIt-Anchor" href="#keyboard-actions"></a> Keyboard Actions</h3><p><strong><code>Actions</code></strong><br>KeyboardKit带有一组可应用于键盘按钮的操作<br>characters, backspace, newline, space, keyboard switchers etc.</p><p><strong><code>ActionHander</code></strong><br>KeyboardInputViewController具有keyboardActionHandler，应该将所有 <code>action</code> 委托给KeyboardActionHandler。默认情况下，它使用StandardKeyboardActionHandler，但你可以用任何实现代替</p><p>大多数 action 没有标准行为，因为他们行为依赖于你的 app。eg. <code>image</code> 只是描述一个 image button，但是你必须决定 image 的 tap 和 long press 事件</p><h3 id="keyboard-types"><a class="markdownIt-Anchor" href="#keyboard-types"></a> Keyboard Types</h3><p>KeyboardKit带有以下内置键盘类型:</p><ul><li>alphabetic(uppercase/lowercase)</li><li>numeric</li><li>symbolic</li><li>email</li><li>emojis</li><li>custom(name)</li></ul><p>这些类型只是键盘表示形式，没有任何逻辑。可以将它们绑定到键盘操作，以添加可以在各种键盘类型之间切换的按钮，但是你必须自己实现键盘类型。</p><h3 id="components"><a class="markdownIt-Anchor" href="#components"></a> Components</h3><p>KeyboardKit带有一组 Components 协议，可以将其组合成完整的键盘，例如vertical and horizontal components, buttons, button rows等</p><h3 id="views"><a class="markdownIt-Anchor" href="#views"></a> Views</h3><p>KeyboardKit带有一组实现上述一个或多个组件协议的 view. eg: vertical and horizontal components, buttons, button rows etc.</p><h2 id="附加功能"><a class="markdownIt-Anchor" href="#附加功能"></a> 附加功能</h2><h3 id="autocomplete"><a class="markdownIt-Anchor" href="#autocomplete"></a> Autocomplete</h3><h3 id="alerts"><a class="markdownIt-Anchor" href="#alerts"></a> Alerts</h3><h3 id="haptic-feedback"><a class="markdownIt-Anchor" href="#haptic-feedback"></a> Haptic Feedback</h3><h3 id="audio-feedback"><a class="markdownIt-Anchor" href="#audio-feedback"></a> Audio Feedback</h3><h3 id="extensions"><a class="markdownIt-Anchor" href="#extensions"></a> Extensions</h3><h2 id="demo-application"><a class="markdownIt-Anchor" href="#demo-application"></a> Demo Application</h2><h2 id="源码解析"><a class="markdownIt-Anchor" href="#源码解析"></a> 源码解析</h2><p>文件结构</p><p><img src="/img/KeyboardKit.jpeg" width="160px" height="120px"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;&lt;p&gt;KeyboardKit是一个Swift库，用来创建iOS键盘扩展&lt;/p&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="KeyboardKit" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/KeyboardKit/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>自定义 keyboard</title>
    <link href="https://changzw.github.io/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/"/>
    <id>https://changzw.github.io/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/</id>
    <published>2020-02-17T09:18:39.000Z</published>
    <updated>2020-04-25T02:44:20.510Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p>原文：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html" target="_blank" rel="noopener">CustomKeyboard</a></p><h3 id="自定义键盘api"><a class="markdownIt-Anchor" href="#自定义键盘api"></a> 自定义键盘API</h3><p>开发自定义键盘的快速入门,如下图，它展示了键盘运行过程中一些重要的对象，以及它们在开发流程中的的位置：</p><p><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/keyboard_architecture_2x.png" alt="keyboard"></p><p>自定义键盘模板（在iOS“Application Extension”目标模板组）包含一个UIInputViewController的子类，它是你开发的键盘的主视图控制器。该模板包含</p><p>键盘所必需的“下一个键盘”按钮的实现，它调用了UIInputViewController类的advanceToNextInputMode方法。如上图所示，可以在输入视图控制器的主视图（在其inputView属性）中添加子视图、控制器以及手势识别器等。对于其它类型的扩展应用，在目标上并不存在窗体，因此也就没有根视图控制器了。</p><p>在模板的Info.plist文件中有预先配置好的键盘所需要的最基本的值。参见其中的NSExtensionAttributes字典关键字，配置一个键盘的关键字在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW18" target="_blank" rel="noopener">《配置自定义键盘的Info.plist文件》</a>中有介绍。</p><p>默认，键盘不能访问网络，不能和它的app共享容器。如果要具备这种能力，必须要将Info.plist文件中RequestsOpenAccess的值置为YES。这需要扩展键盘的沙盒，在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《设计用户信任》</a>中有介绍相关内容。</p><p>一个输入视图控制器遵从各种与文本输入对象内容交互的协议：</p><ul><li>响应触摸消息时如果要插入或删除文本，可以使用<a href="https://developer.apple.com/reference/uikit/uikeyinput" target="_blank" rel="noopener">UIKeyInput</a>协议的insertText:和deleteBackward方法。可以在视图控制器的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618193-textdocumentproxy" target="_blank" rel="noopener">textDocumentProxy</a>属性中调用这些方法，该属性代表当前文本输入对象，它遵从<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="noopener">UITextDocumentProxy</a>协议。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"hello "</span>]; <span class="comment">// Inserts the string "hello " at the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy deleteBackward];       <span class="comment">// Deletes the character to the left of the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"\n"</span>];     <span class="comment">// In a text view, inserts a newline character at the insertion point</span></span><br></pre></td></tr></table></figure><ul><li>在调用deleteBackward之前要先决定删除的字符数。可以通过textDocumentProxy的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618190-documentcontextbeforeinput" target="_blank" rel="noopener">documentContextBeforeInput</a>属性，来获得光标附近的文本上下文信息。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *precedingContext = <span class="keyword">self</span>.textDocumentProxy.documentContextBeforeInput;</span><br></pre></td></tr></table></figure><ul><li>为了控制光标所在位置的操作，比如支持向前删除文字，需要调用UITextDocumentProxy协议中的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618194-adjusttextposition" target="_blank" rel="noopener">adjustTextPositionByCharacterOffset:</a>方法。比如向前删除一个字符，代码如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) deleteForward &#123;</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy adjustTextPositionByCharacterOffset: <span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy deleteBackward];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现<a href="https://developer.apple.com/reference/uikit/uitextinputdelegate" target="_blank" rel="noopener">UITextInputDelegate</a>协议中的方法，可以响应当前输入文本对象的一些变化，比如内容变化以及用户触发的光标位置的变化。</li></ul><p>为了展现与当前文本输入对象适配的键盘布局，需要参照该对象的<a href="https://developer.apple.com/reference/uikit/uikeyboardtype" target="_blank" rel="noopener">UIKeyboardType</a>属性，根据每种你的键盘所能支持的属性，变化布局内容。</p><p><strong>在自定义键盘中，有两种方式来支持多语言：</strong></p><ul><li>为每个语言创建一个键盘，每个键盘都作为向容器app添加的独立的Target</li><li>创建一个多语言键盘，动态切换当前语言。可以使用UIInputViewController类的primaryLanguage属性来动态切换语言。</li></ul><p>根据你要支持的语言数量以及你想提供的用户体验，你可以从上面选择最合适的方案。</p><p>每种自定义键盘（需要RequestsOpenAccess）都可以通过UILexicon类访问自动纠错的词典。通过使用该类，并结合你自己的词典设计，可以在用户输入过程中为他提供输入建议和自动纠错。UILexicon对象包含来自如下源的单词：</p><ul><li>来自用户通讯录的人名和姓</li><li>在 设置 &gt; 通用 &gt; 键盘 &gt; 快捷方式（文本替换） 列表</li><li>通用词典</li></ul><p>你可以使用自动布局来调整你的自定义键盘主视图的高度。默认情况下，自定义键盘会根据屏幕尺寸以及设备方向，和系统键盘的尺寸保持一致。自定义键盘的宽度通常与屏幕当前宽度一致。修改自定义键盘主视图的高度约束即可修改其高度。</p><p>下面的代码展示如何定义和添加约束：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> _expandedHeight = <span class="number">500</span>;</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *_heightConstraint = </span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem: <span class="keyword">self</span>.view </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeHeight</span> </span><br><span class="line">                                 relatedBy: <span class="built_in">NSLayoutRelationEqual</span> </span><br><span class="line">                                    toItem: <span class="literal">nil</span> </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeNotAnAttribute</span></span><br><span class="line">                                multiplier: <span class="number">0.0</span> </span><br><span class="line">                                  constant: _expandedHeight];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint: _heightConstraint];</span><br></pre></td></tr></table></figure><h2 id="自定义键盘的开发关键"><a class="markdownIt-Anchor" href="#自定义键盘的开发关键"></a> 自定义键盘的开发关键</h2><p>自定义键盘开发有两个关键点：</p><ul><li>信任。 自定义键盘能访问用户输入的内容 ，因此在键盘和用户间建立信任非常关键。</li><li>“下一个键盘”键。 通过键盘界面必须能让用户能切换到下一个键盘。</li></ul><h3 id="为用户信任所做的设计"><a class="markdownIt-Anchor" href="#为用户信任所做的设计"></a> 为用户信任所做的设计</h3><p>作为自定义键盘的开发者，你首先应当考虑的是如何建立和维护用户信任。你要理解隐私策略的最佳实践并知道如何实现它才能很好地践行。</p><blockquote><p>注意<br>本节为你创建自定义键盘提供相关的开发手册，该手册要求尊重用户隐私。了解iOS编程要求，请阅读应用商店审核手册，iOS人机交互手册，iOS开发许可协议，请参见苹果的<a href="https://developer.apple.com/support/appstore/app-review/" target="_blank" rel="noopener">《应用审核支持》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/ExpectedAppBehaviors/ExpectedAppBehaviors.html#//apple_ref/doc/uid/TP40007072-CH3-SW6" target="_blank" rel="noopener">《支持用户隐私》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="noopener">《iOS应用编程指南》</a>。</p></blockquote><p>对于键盘，如下三个方面对于建立和维护用户信任至关重要：</p><ul><li>按键数据的安全。 用户希望他们的敲键会落在文档以及输入区域内，而不是上传到服务器或者用于其他不明目的。</li><li>最小化合理利用其它用户数据。 如果你的键盘还需要使用其他用户数据，例如定位服务或者通讯录，你有义务解释这给用户带来的好处是什么。</li><li>准确。 把输入事件转换成文本要求精准，这本身虽然不是一个隐私话题，但他会影响到信任：每次文字转换需要体现出你的代码的精准。</li></ul><p>在信任的开发设计过程中，首先考虑的是是否要获取open access权限。尽管开启了open access权限能给自定义键盘开发带来极大便利，但这也增加了你作为开发者的责任。下面是标准的open access的能力和隐私考虑：</p><table><thead><tr><th>Open Access</th><th>能力和限制</th><th>隐私考虑</th></tr></thead><tbody><tr><td>Off(default)</td><td>·键盘可以执行所有基本键盘的职责<br>·可以访问通用词典以支持自动纠错和输入建议<br>·访问设置里的快捷短语<br>·不与containing应用共享容器<br>·不访问键盘容器以外的文件系统<br>·不访问键盘容器以外的文件系统<br>·不能直接或间接访问iCloud或游戏中心或应用内购买</td><td>用户了解按键仅仅被发送到当前使用键盘的应用里</td></tr><tr><td>On</td><td>·具备非联网自定义键盘的所有能力<br>·在用户许可情况下可以访问位置服务和通讯录<br>·键盘和containing app可以访问共享容器<br>·键盘可以为服务器侧处理过程发送按键或其他输入事件<br>·containing app自动纠错字典提供编辑界面<br>·通过containing app键盘可以使用iCloud来保证自动纠错词典和设置的更新<br>·通过containing app，键盘可以参与到游戏中心和应用内购买<br>·如果键盘支持移动设备管理(MDM)，它可与被管理的应用共同工作</td><td>·用户了解键盘开发者会利用按键数据<br>·你必须遵守有联网能力的键盘开发手册和iOS开发许可协议，可参见《应用审核支持》</td></tr></tbody></table><p>如果你的自定义键盘不需要open access权限，系统确保敲键信息不会被发送给你的键盘以及别的地方。如果只想提供一般的键盘功能，请不要给键盘配备联网能力。由于有沙盒限制，不联网的键盘一定是满足苹果的数据隐私手册并能获得用户信任的。</p><p>开启open access权限（如上所述，可以在Info.plist文件中配置），能给你的开发带来更多可能性，同时也带来更多的责任。</p><blockquote><p>注意<br>向应用商店提交一个open-access的键盘必须遵守苹果《应用审核支持》中的相关条款。</p></blockquote><p>每一个与open access相关的功能都需要你履行相应的责任，应当最大限度地尊重用户数据，不得用于与用户输入无关的其他任何目的。下表列出了open access带来的好处以及开发者需承担的责任：</p><table><thead><tr><th>能力</th><th>用户利益示例</th><th>开发者责任</th></tr></thead><tbody><tr><td>与containing app共享容器</td><td>为键盘的自动纠错词典管理UI界面</td><td>要考虑到自动纠错数据属于用户隐私。不要把他发到你的服务器，用作与输入无关的用途。</td></tr><tr><td>把按键数据发到你的服务器</td><td>通过开发者的计算资源可以提供更好的按键处理结果和输入预测</td><td>只有为用户提供更好的输入体验之用时，才能保存按键和语音数据</td></tr><tr><td>基于云的自动纠错词典</td><td>把人名、地名、热点新闻加入到自动纠错词典中</td><td>不要把用户身份与输入数据关联起来，不得将用户信息用作与输入体验无关的其他目的</td></tr><tr><td>通讯录</td><td>把人名、地名、电话号码添加到自动纠错词典中</td><td>不得讲通讯录用作与输入体验无关的其他目的</td></tr><tr><td>位置服务</td><td>将附近的地名添加到自动纠错词典中</td><td>不要在后台使用位置服务，不得将位置信息发送到你的服务器并用于与输入体验无关的其他目的</td></tr></tbody></table><p>一个具有open-access权限的键盘和其containing app能将按键数据发送到服务器端，通过这些数据可以为用户提供更好的输入体验。如果你使用了这些能力，当不需要这些数据的时候，请及时在服务器端删除。参见上面的表格来履行你使用open-access权限中的义务。</p><h3 id="提供切换到其他键盘的方法"><a class="markdownIt-Anchor" href="#提供切换到其他键盘的方法"></a> 提供切换到其他键盘的方法</h3><p>系统键盘的小地球按键用于切换到其他键盘：<br><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/globe_key_2x.png" alt="The system keyboard’s Globe key"></p><p>你的自定义键盘必须提供类似的机制能切换到其他键盘。</p><p>调用UIInputViewController类的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618191-advancetonextinputmode" target="_blank" rel="noopener">advanceToNextInputMode</a>方法可以切换到其他键盘。系统会选择下一个键盘，没有能获得键盘列表的API，也没有切换到指定键盘的API。</p><p>Xcode自定义键盘模板中就已经在下一个键盘按钮上具备了advanceToNextInputMode的功能。为了提供最好的用户体验，应当把你的下一个键盘按键放在靠近系统键盘的小地球键的位置。</p><blockquote><p>注意<br>要通过应用审核，必须在你的键盘上提供明显允许用户切换键盘的UI标识。</p></blockquote><h2 id="开始自定义键盘的开发"><a class="markdownIt-Anchor" href="#开始自定义键盘的开发"></a> 开始自定义键盘的开发</h2><h3 id="使用xcode自定义键盘模板"><a class="markdownIt-Anchor" href="#使用xcode自定义键盘模板"></a> 使用Xcode自定义键盘模板</h3><p>创建键盘及其containing app与其他扩展应用略有不同。本节将带你领略基本键盘的开发和运行。</p><p><strong>在一个容器app中创建键盘，步骤如下</strong></p><ol><li>在Xcode中选择File &gt; New &gt; Project &gt; iOS &gt; Application选择Single View Application模板。</li><li>点击Next。</li><li>填写Project Name（如CKIme），点击Next。</li><li>选择要保存的位置，点击Create。这样，你就有了一个空app，该app只能完成一个简单的操作，接下来它将承载键盘。在你提交到应用商店之前，你需要完成一些有用的功能。请到应用审核支持参考应用商店审核指南。</li><li>选择File &gt; New &gt; Target &gt; iOS &gt; Application Extension选择Custom Keyboard Extension，点击Next。</li><li>填写Product Name（如CKbd），点击Finish。</li><li>确认Project和Embed in Application中都显示的是容器app的名字（CKIme），点击Finish。如果弹出Activate “CKbd” scheme提示让激活键盘工程，点击Activate。</li></ol><p><strong>定义键盘group name，步骤如下：</strong></p><ol><li>在Xcode工程导航视图中，选择容器app的Info.plist文件，</li><li>在右侧plist编辑器中，鼠标hover到Bundle name上，点“+”按钮创建一行空属性。</li><li>在Key中填写Bundle display name，回车</li><li>双击该行的Value，填写你要自定义的键盘group name。</li><li>选择File &gt; Save保存设置。</li></ol><p>下表汇总了在容器app和键盘app的Info.plist文件中你可以配置的UI字符串：</p><table><thead><tr><th>iOS UI字符串</th><th>Info.plist关键字</th></tr></thead><tbody><tr><td>· 在系统设置的已购键盘列表中的键盘group name</td><td>在容器app的Info.plist文件中的Bundle display name</td></tr><tr><td>· 系统设置中的键盘名称<br>· 键盘换列表中的键盘名称</td><td>在键盘app的Info.plist文件中的Bundle display name</td></tr></tbody></table><p><strong>运行自定义键盘并将Xcode调试器attach到它上面</strong></p><ol><li>在Xcode，你的view controller实现中设置一个断点（比如可以断在viewDidLoad上）。</li><li>在Xcode工具栏确保当前活动的项目为键盘项目，并对应iOS模拟器或设备。</li><li>选择菜单Project &gt; Run，或点击Build and then run the current scheme按钮（即播放按钮）。Xcode会提示选择host app。选择一个带有输入框的，比如通讯录或Safari。</li><li>点击Run。Xcode将运行起你指定的host app。如果这是你第一次使用键盘扩展应用，需要现在设置中添加并启用键盘：<ol><li>Settings &gt; General &gt; Keyboard &gt; Keyboards</li><li>点击Add New Keyboard…</li><li>在OTHER IPHONE KEYBOARDS中点击你刚刚创建的键盘</li></ol></li><li>在iOS模拟器或真机上，调出你的自定义键盘。<br>点击任意可输入区域，将显示出系统键盘。按住小地球，选择你的自定义键盘。<br>此时你将看到自定义键盘，但是调试器尚未attach上来。一个从模板构建而来的极简键盘仅有一个Next Keyboard按钮，点击后切换回前一个键盘。</li><li>取消你的键盘（以便在第8步中你可以再次调出键盘以命中viewDidLoad断点）</li><li>在Xcode中，选择Debug &gt; Attach to Process &gt; By Process Identifier(PID) or Name 在弹出对话框中，输入你的键盘扩展应用的名字（包含空格）.默认就是该扩展应用在工程导航窗口里的group name。</li><li>点击Attach。Xcode将显示出等待attach的调试器。</li><li>在任意能输入文字的app中调出键盘。<br>当你的键盘主视图开始加载时，Xcode调试器将attache到你的键盘，并命中断点。</li></ol><h3 id="为自定义键盘配置infoplist文件"><a class="markdownIt-Anchor" href="#为自定义键盘配置infoplist文件"></a> 为自定义键盘配置Info.plist文件</h3><p>自定义键盘的Info.plist文件允许静态定义键盘的现式特征，包括主要语言，以及是否需要open access权限。</p><p>打开Xcode并切换到自定义键盘的 target。在工程导航栏选择Info.plist文件，按文本格式呈现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtension<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionAttributes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>IsASCIICapable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrefersRightToLeft<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrimaryLanguage<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>en-US<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>RequestsOpenAccess<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPointIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.keyboard-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPrincipalClass<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>KeyboardViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个关键字在App Extension Keys中都有解释。可以使用字典NSExtensionAttributes中的关键字来描述你的自定义键盘的特征和需求，如下：</p><p><code>IsASCIICapable</code> - 默认为NO的布尔值。用户键盘是否可以向文档中插入ASCII字串。如果要为<code>UIKeyboardTypeASCIICapable</code>属性的输入对象展现单独类型的键盘，需要将该值置为YES。</p><p><code>PrefersRightToLeft</code> - 默认为NO的布尔值。是否为从右到左的语种设计的的自定义键盘。</p><p><code>PrimaryLanguage</code> - 默认为en-US的字串。以&lt;语种&gt;-&lt;区域&gt;的形式描述键盘的主语言。可以到http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c找到对应的语种和区域。</p><p><code>RequestsOpenAccess</code> - 默认为NO的布尔值。是否需要比基础键盘更大的沙盒范围。把该值置为YES将需要完全访问权限，你的键盘将获得如下能力，每个能力都伴随有相应的权限：</p><ul><li>访问定位服务，通讯录数据库，相机，每个都需要用户允许</li><li>与键盘的容器app共享容器数据，以便完成比如在容器app中管理用户词库的界面的功能</li><li>通过网络发送按键、输入事件之类的数据供云端处理</li><li>使用UIPasteboard类</li><li>播放音频，包括使用playInputClick方法播放按键音</li><li>访问iCloud，可以用来根据用户身份同步比如键盘设置、自定义自动纠错词典</li><li>通过容器app访问游戏中心和应用内购买</li><li>如果你的键盘支持移动设备管理（MDM），可以与被管理的app无缝合作</li></ul><p>当考虑是否将这些关键字设置为YES之前，一定要先阅读<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《用户信任设计》</a>，这里描述了如何尊重和保护用户数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="AppExtensions" scheme="https://changzw.github.io/categories/iOS-Programming/AppExtensions/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>调试内存不足问题：使用运行时魔法捕获布局反馈循环</title>
    <link href="https://changzw.github.io/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/"/>
    <id>https://changzw.github.io/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/</id>
    <published>2019-11-30T23:25:43.000Z</published>
    <updated>2020-04-25T02:55:55.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p>目标：<br>使用代码替代 <code>UIViewLayoutFeedbackLoopDebuggingThreshold</code> 符号调试，来捕获 Autolayout反馈循环所导致的内存不足问题。</p><h2 id="导致内存不足的原因"><a class="markdownIt-Anchor" href="#导致内存不足的原因"></a> 导致内存不足的原因</h2><p>如果 App，开始有大量日活用户并且崩溃率很低，但是过段时间，总会出现崩溃问题，检查 Fabric 也没啥用。</p><p>出现这种情况很可能是因为，内存不足，导致应用被系统终止。</p><p>导致内存不足的原因：</p><ul><li>循环引用;</li><li>竞争条件;</li><li>废弃的线程;</li><li>死锁;</li><li>布局反馈循环。</li></ul><p>Apple 提供了很多方法来解决这类问题：</p><ul><li>Instruments 里的 Allocations 和 Leaks 工具用于解决循环引用和 <a href="https://developer.apple.com/videos/play/wwdc2015/230/" target="_blank" rel="noopener">其他类型的泄漏</a></li><li>在 Xcode 8 中引入的 <a href="https://developer.apple.com/videos/play/wwdc2016/410/" target="_blank" rel="noopener">Memory Debugger</a> 代替了 Allocations 和 Leaks 的一部分功能</li><li><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">Thread Sanitizer</a> 帮助你找到竞争条件、废弃的线程或者死锁</li></ul><h2 id="布局反馈循环"><a class="markdownIt-Anchor" href="#布局反馈循环"></a> 布局反馈循环</h2><blockquote><p>当视图正在运行它们的布局代码，但某种方法导致它们再一次开始布局传递，此时布局反馈循环就会出现。这可能是因为某个视图正在改变某个父视图的大小，或者因为你有一个模棱两可的布局。无论哪种原因，这个问题的表现是你的 CPU 使用被占满和 RAM 使用量稳步上升，因为你的视图正在一次又一次地运行它们的布局代码，却没有返回。<br>-来自<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">HackingWithSwift 的 Paul Hudson</a></p></blockquote><p>在 WWDC 16 中 Apple 介绍了“布局反馈循环调试器”。这个调试器有助于识别在调试过程中发生循环的时间点。这就是一个符号断点，它的工作方式非常简单：它会计算在单个 run loop 迭代中调用每个视图上的 <font color="red">layoutSubviews()</font> 方法的次数。一旦这个计数值超过某个临界值（比如，100），这个应用程序将会停在这个断点并打印出日志。<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">这篇文章</a> 快速地介绍如何使用这个调试器。</p><p>这个方法在可以重现问题的情况下十分有效。但是在线上出现就不用容易调试。但是你可以尝试把 <font color="red">UIViewLayoutFeedbackLoopDebuggingThreshold</font> 的代码复制到生产代码中。</p><h3 id="如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"><a class="markdownIt-Anchor" href="#如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"></a> 如何用代码实现 UIViewLayoutFeedbackLoopDebuggingThreshold 的功能呢</h3><p>符号断点是如何工作的：它会计算 layoutSubviews() 的调用次数并在单个 run loop 迭代中超过某个临界值时发送一个事件。听起来很简单，对吧？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackableView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="type">YourAnalyticsFramework</span>.event(name: <span class="string">"loop"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于一个视图，这段代码运行正常。</li><li>但是现在你想要在另一个视图上实现它。当然，你可以创建一个 UIView 的子类，在这里实现它并使你项目中的所有视图都继承这个子类。</li><li>然后为 UITableView，UIScrollView，UIStackView 等做同样的事情。</li></ol><p>如果将此逻辑注入你想要的任何类，而无需编写大量重复的代码。这时候就可以 <code>借助运行时编程</code> 了。</p><h3 id="使用-runtime-实现子类"><a class="markdownIt-Anchor" href="#使用-runtime-实现子类"></a> 使用 runtime 实现子类</h3><p>我们会做同样的事情——创建一个子类，重写 layoutSubviews() 方法并计算其调用次数。唯一的区别是所有这些都使用 runtime 完成，而不是在项目中创建重复的类。</p><p><strong>创建自定义子类</strong>，并将原始视图的类更改为新的子类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>objc_allocateClassPair() 方法的文档告诉我们这个方法何时失败：</li></ol><blockquote><p>新类，或者如果无法创建类，则为 Nil （例如，所需名称已被使用）。</p></blockquote><p>这就意味着不能拥有两个同名的类。我们的策略是为单个视图类创建一个单独的运行时类。这就是我们在原始类名前加上前缀来形成新类的名称的原因。</p><ol start="2"><li>现在添加一个计数器到子类中。理论上，有两种方法可以做到这一点。</li><li>添加一个保存计数器的属性。</li><li>为这个类创建一个关联对象（Associated object）。</li></ol><p>但是目前，只有一个方法奏效。你可以想象属性是存储在分配给类的内存里的东西，然而关联对象则储存在一个完全不同的地方。因为分配给已存在对象的内存是固定的，所以我们<font color="red">在自定义类上新添加的属性将会从其他资源里“窃取”内存</font>。它可能导致意料之外的行为和难以调试的程序崩溃（点击 <a href="https://stackoverflow.com/questions/3346427/object-setclass-to-bigger-class" target="_blank" rel="noopener">这里</a> 查看更多信息）。但是在使用关联对象的情况下，它们将会存储在运行时创建的一个哈希表里，这是完全安全的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = <span class="string">"_counter"</span></span><br><span class="line">...</span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>当新的子类被创建时，计数器初值设置为 0。</p><p><strong>实现这个新的layoutSubviews() 方法，并将它添加到我们的类中</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">      onLoop()</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>为了理解上面这段代码实际上在干什么，让我们看一下这个来自 &lt;objc/runtime.h&gt; 的结构体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> </span>&#123;</span><br><span class="line">  <span class="type">SEL</span> method_name;</span><br><span class="line">  char *method_types;</span><br><span class="line">  <span class="type">IMP</span> method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实际上是由什么组成的：</p><ul><li>方法的实现 method_imp，这是调用方法时要执行的实际函数。它的前两个形参总是方法接收者和消息选择器。</li><li>包含方法签名的方法类型字符串 method_types。你可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">这里</a> 详细了解其格式。但是在现在的情况下，需要明确说明的字符串是 “v@:”。作为返回类型，v 代表 void，而 @ 和 : 分别代表接收者和消息选择器。</li><li>选择器 method_name 作为键，用于在运行时查找方法的实现。</li></ul><p>你可以把 Witness Table（在其他编程语言中，它也被称作方法派发表）想象成一个简单的字典数据结构。那么选择器为键，且实现部分则为对应的值。<br>在下面这行代码中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(trackableClass,#selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>我们所做的是给 layoutSubviews() 方法对应的键分配新值。</p><p>这个方法直截了当。我们获得这个计数器，使它的计数值加一。如果计数值超过临界值，我们会发送分析事件，其中包含类名和想要的任何数据体。</p><p>让我们回顾一下如何对关联对象实现和使用键：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>为什么我们使用 var 来修饰计数器的键这个静态属性并在传递到其他地方时使用引用？答案隐藏在 Swift 语言基础——字符串之中。字符串像其他所有的值类型一样，是按值传递的。那么，当你把它传入这个闭包时，这个字符串将会被复制到一个不同的地址，这会导致在关联对象表中产生一个完全不同的键。&amp; 符号总是保证将相同的地址作为键参数的值。你可以尝试以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAddress</span><span class="params">(<span class="number">_</span> string: UnsafeRawPointer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(string)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">printAddress(str)</span><br><span class="line">printAddress(str)</span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  printAddress(str)</span><br><span class="line">  printAddress(str)</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 最后两个函数调用的地址将始终不同</span></span><br></pre></td></tr></table></figure><p>用引用的方式来传递键的主意总是好的，因为有时，即使你没有使用闭包，变量的地址仍可能因内存管理而更改。在我们例子中，如果你把上面的代码运行多次，即使是前两个 printAddress() 的调用也可能会输出不同的地址。</p><p>让我们回到运行时的魔法里来。在新 layoutSubviews() 的实现里，还有一件很重要的事情没有完成。这件事是每次重写父类的方法时通常都会做的事情——调用父类实现。layoutSubviews() 的文档里提到：</p><blockquote><p>在 iOS 5.1 及更早版本中，这个方法的默认实现不执行任何操作。而之后的默认实现会使用你设置的任何约束来确定任何子视图的大小和位置。</p></blockquote><p>为了避免发生一些难以预料的布局行为，我们得调用父类的实现，但这不像平常那样简单明了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line"><span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line"><span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line"><span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">originalLayoutSubviews(view, selector)</span><br></pre></td></tr></table></figure><p>这里实际发生的是：我们检索方法所需的实现部分，并直接从代码中调用它，而不是用常见的方式来调用方法（即执行一个会在 Witness Table 中寻找对应实现的选择器）。</p><p>目前为止，让我们看看实现部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">  <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称</span></span><br><span class="line">  <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">  <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在当前运行时会话期间尚未创建此类</span></span><br><span class="line">    <span class="comment">// 注册这个类并将其与原始视图的类交换</span></span><br><span class="line">    objc_registerClassPair(trackableClass)</span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">    objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">    <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">      <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">      <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">      <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">      <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">      <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">      originalLayoutSubviews(view, selector)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">          onLoop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">    class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">    <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类</span></span><br><span class="line">    <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换</span></span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为视图创建模拟布局循环，并为其设置计数器来进行测试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">    <span class="type">LayoutLoopHunter</span>.setUp(<span class="keyword">for</span>: view) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Hello, world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line">    view.setNeedsLayout() <span class="comment">// loop creation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是忘记了什么事情？让我们再次回顾一下 UIViewLayoutFeedbackLoopDebuggingThreshold 断点的工作原理：</p><blockquote><p>在确认为反馈循环之前，定义某个视图的子视图在单个 run loop 里必须布局的次数</p></blockquote><p>我们从未把“单个 run loop ”这一条件考虑进来。如果视图在屏幕上停留了相当长的时间，并经常被反复布局，计数器迟早会超过临界值。但这可不是因为内存的问题。</p><p>我们该怎么解决这个问题呢？只需在每次 run loop 迭代时重置计数器。为了做到这一点，我们可以创建一个 <a href="https://www.appcoda.com/grand-central-dispatch/" target="_blank" rel="noopener">DispatchWorkItem</a>，它重置计数器，并在主队列上异步传递它。通过这种方式，它会在 run loop 下一次进入主线程时被调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">  previousResetWorkItem.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> currentResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async(execute: currentResetWorkItem)</span><br><span class="line">objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, currentResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>最终的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Associated objects keys</span></span><br><span class="line">    <span class="comment">// 关联对象键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">      objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">      <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">        <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">        <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">        <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">        <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">        originalLayoutSubviews(view, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">            onLoop()</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 为重置计数器，在每个新的 run loop 遍历中分发 work item</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">          previousResetWorkItem.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> counterResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">          objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async(execute: counterResetWorkItem)</span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, counterResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">      class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>是的！现在你可以为所有可疑的视图设置分析事件了，发布应用程序，并找到这个问题的确切出处。你可以把这个问题的范围缩小到某个特定的视图，并在用户不知情的情况下借助于他们来解决这个问题。</p><p>最后要提到的一件事是：能力越大责任越大。运行时编程非常容易出错，因此很容易在不知情的情况下为应用程序引入另一个严重的问题。这就是为什么总是建议将应用程序中的所有危险代码包装在某种可停止开关中，因为你可以在发现代码导致问题时从后端触发开关禁用该功能。这有一篇介绍 Firebase 的 Feature Flags 的 <a href="https://medium.com/@rwbutler/feature-flags-a-b-testing-mvt-on-ios-718339ac7aa1" target="_blank" rel="noopener">(好文章</a></p><p>完整代码可以从这个 <a href="https://github.com/rsrbk/LayoutLoopHunter" target="_blank" rel="noopener">GitHub 仓库</a> 里获取，并且也将会发布到 CocoPods 上，以跟踪项目中的布局循环。</p><blockquote><p><a href="https://swift.gg/2019/11/11/layout-feedback-loop/" target="_blank" rel="noopener">大量引用</a><br>原文读起来费劲，只是想让自己读的容易写的这篇文章</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AlamoFire 分析</title>
    <link href="https://changzw.github.io/2019/06/10/source-code/AlamoFire-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2019/06/10/source-code/AlamoFire-%E5%88%86%E6%9E%90/</id>
    <published>2019-06-10T02:24:19.000Z</published>
    <updated>2020-05-18T15:31:35.775Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p>分析源码：</p><ol><li>这个第三方库，他设计的目标是什么？</li><li>需要哪些基础知识</li><li>整体结构是什么样的</li><li>由外而内逐层分析层次结构</li><li>每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点</li><li>为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？</li></ol><p>为什么要分析 AlamoFire</p><ul><li>分析它的接口设计</li><li>分析他是如何封装 URL Loading System 的</li><li>分析网络层次思考数据传输过程</li></ul><p>AlamoFire 都做了什么？</p><ul><li>Chainable Request / Response Methods</li><li>URL / JSON Parameter Encoding</li><li>Upload File / Data / Stream / MultipartFormData</li><li>Download File using Request or Resume Data</li><li>Authentication with URLCredential</li><li>HTTP Response Validation</li><li>Upload and Download Progress Closures with Progress</li><li>cURL Command Output</li><li>Dynamically Adapt and Retry Requests</li><li>TLS Certificate and Public Key Pinning</li><li>Network Reachability</li></ul><h2 id="建立网络请求"><a class="markdownIt-Anchor" href="#建立网络请求"></a> 建立网络请求</h2><p>一个 session 请求网络数据</p><p><span id="code1"></span></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 创建一个 session</span></span><br><span class="line"><span class="comment">2. 创建一个 task-&gt; url</span></span><br><span class="line"><span class="comment">3. 唤醒这个 task</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">let</span> urlString = <span class="string">"http://www.douban.com/j/app/radio/channels"</span></span><br><span class="line">  <span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: urlDownloadStr)!, completionHandler: &#123;data,response,error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"response:\(response!)"</span>)</span><br><span class="line">  &#125;) <span class="comment">// task 挂起状态</span></span><br><span class="line">  .resume()<span class="comment">// 唤醒 task</span></span><br></pre></td></tr></table></figure><h3 id="session-配置"><a class="markdownIt-Anchor" href="#session-配置"></a> session 配置</h3><p>加入配置,在不同配置环境下 进行网络请求</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration1 = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span><span class="comment">// 允许用户拥有沙盒缓存器，当session 释放的时候，数据依然存在</span></span><br><span class="line"><span class="keyword">let</span> configuration2 = <span class="type">URLSessionConfiguration</span>.ephemeral<span class="comment">// session 无效时，东西就会消失</span></span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration).dataTask(with: <span class="type">URL</span>(string: urlDownloadStr)!)</span><br><span class="line">  .resume()<span class="comment">// 后台 sessionConfiguration 不能设置 completeHandler，需要自己设置代理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-内存大小：\(String(describing: configuration1.urlCache?.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-沙盒大小：\(String(describing: configuration1.urlCache?.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-内存大小：\(String(describing: configuration2.urlCache?.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-沙盒大小：\(String(describing: configuration2.urlCache?.diskCapacity))"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.shared.dataTask(with: <span class="type">URL</span>(string: urlDownloadStr)!, completionHandler: &#123;data,response,error <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"normal finish========"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"response:\(response!)"</span>)</span><br><span class="line">&#125;).resume()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration1 = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span><span class="comment">// 允许用户拥有沙盒缓存器，当session 释放的时候，数据依然存在</span></span><br><span class="line"><span class="keyword">let</span> configuration2 = <span class="type">URLSessionConfiguration</span>.ephemeral<span class="comment">// session 无效时，东西就会消失</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>-内存大小：<span class="type">Optional</span>(<span class="number">512000</span>)</span><br><span class="line"><span class="keyword">default</span>-沙盒大小：<span class="type">Optional</span>(<span class="number">10000000</span>)</span><br><span class="line">ephemeral-内存大小：<span class="type">Optional</span>(<span class="number">512000</span>)</span><br><span class="line">ephemeral-沙盒大小：<span class="type">Optional</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="后台-session下载流程注意事项"><a class="markdownIt-Anchor" href="#后台-session下载流程注意事项"></a> 后台 session下载流程&amp;注意事项</h3><p>后台 sessionConfiguration 下载文件保存 到本地沙盒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启后台 请求 task</span></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> session = <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.downloadTask(with: <span class="type">URL</span>(string: urlDownloadStr)!).resume()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">URLSessionDownloadDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">// 下载完成后代理回调方法，将文件移动到沙盒指定位置</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载完成 - \(location)"</span>)</span><br><span class="line">    <span class="keyword">let</span> locationPath = location.path</span><br><span class="line">    <span class="keyword">let</span> documnets = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/xxxx"</span> + <span class="string">".zip"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"移动地址:\(documnets)"</span>)</span><br><span class="line">    <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">try</span>! fileManager.moveItem(atPath: locationPath, toPath: documnets)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// http 分段传输，会不断调用这个方法直到，全部下载完成</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台请求，需要申请后台权限，这样 app 进入 background 的时候才可以继续下载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存后台下载的completionHandler</span></span><br><span class="line"><span class="keyword">var</span> backgroundSessionCompletionHandler: (() -&gt; <span class="type">Void</span>)? </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"background: \(identifier)"</span>)</span><br><span class="line">  <span class="keyword">self</span>.backgroundSessionCompletionHandler = completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-alamofire"><a class="markdownIt-Anchor" href="#使用-alamofire"></a> 使用 AlamoFire</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(urlString)</span><br><span class="line">  .responseJSON &#123; (data) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面对比[原生的方法(#code1), 思考 <code>AlamoFire</code> 都封装了什么，如何实现链式调用的，内部如何使用 oop，pop 的, 思考 <code>AlamoFire</code> 接口设计</p><p>下面这些都是怎么实现的？</p><ul><li>链式语法</li><li>直接传 string</li><li>封装调用 session，resume</li><li>Response 回调的返回的是 json 数据</li><li><code>Alamofire</code> 模块导入调用</li></ul><p>调用的第一层：<br>Alamofire.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Alamofire Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">  method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  headers: HTTPHeaders? = <span class="literal">nil</span>)</span></span></span><br><span class="line">  -&gt; <span class="type">DataRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>.<span class="keyword">default</span>.request(</span><br><span class="line">    url,</span><br><span class="line">    method: method,</span><br><span class="line">    parameters: parameters,</span><br><span class="line">    encoding: encoding,</span><br><span class="line">    headers: headers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionManager.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SessionManager</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A default instance of `SessionManager`, used by top-level Alamofire request methods, and suitable for use</span></span><br><span class="line"><span class="comment">/// directly for any ad hoc requests.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `<span class="keyword">default</span>`: <span class="type">SessionManager</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.httpAdditionalHeaders = <span class="type">SessionManager</span>.defaultHTTPHeaders </span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>(configuration: configuration)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">  configuration: <span class="type">URLSessionConfiguration</span> = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span> = <span class="type">SessionDelegate</span>(),</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = <span class="type">URLSession</span>(configuration: configuration, delegate: delegate, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>?(</span><br><span class="line">  session: <span class="type">URLSession</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span>,</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> delegate === session.delegate <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = session</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SessionDelegate()</code> 代理移交 <code>SessionDelegate</code> 是个 class, 处理 <code>URLSession</code> 的事件回调代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionTaskDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionStreamDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>为什么 Manager 不处理 <code>URLSession</code> 的代理回调方法，要搞一个 <code>SessionDelegate</code> 处理，因为 Manager 是一个中介者，用于管理各个 class 之间的联系，处理回调的那些方法应该归属于 xxxClass 来处理</p><p><img src="/img/AlamoFire-Manager.jpg" alt="AlamoFire 基本核心框架"></p><p>使用 Manager 主要作用是把代码模块之间的 频繁调用关系化简。划分业务层，管理层<br>Manager 统一管理调度<br>各个模块处理完成后，回调给 Manager</p><h3 id="处理后台下载"><a class="markdownIt-Anchor" href="#处理后台下载"></a> 处理后台下载</h3><p><a href="https://github.com/Alamofire/Alamofire/issues/1920" target="_blank" rel="noopener">iOS 10: Background Session won’t inform when downloads have failed #1920</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Net" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Net/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>读代码 Me</title>
    <link href="https://changzw.github.io/2019/05/17/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/"/>
    <id>https://changzw.github.io/2019/05/17/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/</id>
    <published>2019-05-16T16:47:30.000Z</published>
    <updated>2020-05-18T12:08:33.197Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="为什么看"><a class="markdownIt-Anchor" href="#为什么看"></a> 为什么看</h2><p>抽空晚上睡不着看 <a href="https://github.com/vsouza/awesome-ios#gcd" target="_blank" rel="noopener">awesome-ios</a> 提供的优秀代码库<br>[Me](<a href="https://github.com/pascalbros/Me" target="_blank" rel="noopener">https://github.com/pascalbros/Me</a> 源码</p><h2 id="他是做什么的"><a class="markdownIt-Anchor" href="#他是做什么的"></a> 他是做什么的</h2><p>Me 是解决嵌套异步问题的一个轻量级库——就一个文件</p><h2 id="使用他以后的效果"><a class="markdownIt-Anchor" href="#使用他以后的效果"></a> 使用他以后的效果</h2><p>before</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyAPI</span>.login &#123;</span><br><span class="line">  <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">    <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">    <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">      <span class="comment">//We are done here</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Me</span>.start &#123; (me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.login &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">   <span class="comment">//We are done here</span></span><br><span class="line">   me.end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.run()</span><br></pre></td></tr></table></figure><p>看效果：</p><ol><li>Me 把异步嵌套代码–&gt; 链式代码（想想他是怎么做的？）</li><li>Me 是链条型的，start，next，next(name:)，jump(toName:)，end<ol><li>他是如何做异步通知的？</li><li>如何开始，如何结束？</li><li>支持实现多链条并发执行吗？</li></ol></li><li>从提供的接口上可以看出<ol><li>Me开启结束要由用户控制</li><li>节点驱动需要用户触发</li><li>支持指定节点跳转</li></ol></li></ol><p>ok 使用demo&amp;基本特性分析完了，接下来看源码</p><hr><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><h3 id="先看接口"><a class="markdownIt-Anchor" href="#先看接口"></a> 先看接口</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeInitClosure</span> = ((<span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeClosure</span> = ((<span class="number">_</span> previous: <span class="type">Me?</span>, <span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Me</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> index: <span class="type">UInt</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> parameters: [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式节点函数，static 是起点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(name: String = <span class="string">""</span>, this: @escaping MeInitClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(this: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">(name: String = <span class="string">""</span>, next: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNextOnMain</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toName jump: String)</span></span></span><br></pre></td></tr></table></figure><ol><li>提供 Me 节点 index，name，代码库内部维护</li><li>只提供其实节点 first</li><li>提供线程队列调度接口</li><li>parameters 是干什么的？像是 [name: MeClouse] 字典，每个 me 节点都有一个clouse</li></ol><h3 id="看代码实现"><a class="markdownIt-Anchor" href="#看代码实现"></a> 看代码实现</h3><ol><li>核心代码，这个地方封装了 GCD</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> next = <span class="keyword">self</span>.next &#123;</span><br><span class="line">    <span class="comment">//self.nextObj!.parameters = self.parameters //enable to pass parameters to the next object</span></span><br><span class="line">    queue.async &#123;</span><br><span class="line">      next(<span class="keyword">self</span>, <span class="keyword">self</span>.nextObj!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> to = me(at: jump) &#123;</span><br><span class="line">    to.this(<span class="keyword">self</span>, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个问题是：<code>jump</code> 的queue 没有用……（这个库的使用价值不大）只有 <code>runNext</code> 相关方法可以调度线程<br>parameters: 是 me 节点保存数据，用于用户自己传递数据使用</p><ol start="2"><li>内部数据结构使用的是链表</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> nextObj: <span class="type">Me?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _first: <span class="type">Me?</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="读源码" scheme="https://changzw.github.io/categories/%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift + MVVM:如何提供ViewModels</title>
    <link href="https://changzw.github.io/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/"/>
    <id>https://changzw.github.io/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/</id>
    <published>2019-04-16T12:58:40.000Z</published>
    <updated>2020-04-25T02:21:37.289Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">原文：RxSwift + MVVM: how to feed ViewModels</a></p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>自从我们开始在BlaBlaCar的Model-View-ViewModel（MVVM）架构中使用RxSwift以来，已经快一年了。我们对结果感到兴奋。我们使用这种方法编写的代码更容易理解，维护，测试和扩展。但是，最初的几周并不是小菜一碟。我们必须在MVVM + RxSwift架构的某些方面进行迭代，以使事情变得正确。其中一个方式——给 ViewModels 提供 Inputs。</p><p>让我们通过两种不同方式给ViewModels 提供 Inputs（Rx Event）</p><p>但是首先，让我们简单谈一下 ViewModels</p><h2 id="viewmodels"><a class="markdownIt-Anchor" href="#viewmodels"></a> ViewModels</h2><p>ViewModel的职责，你必须正确理解它（不止一个）：</p><ul><li>它应该是可以插入到任何View上的。比如，不是先造一个View再去定义一个ViewModel。注意，是View拥有ViewModel。View知道ViewModel，而不是反过来。</li><li>它是可测试的。最终，MVVM架构最大的好处就是让业务逻辑可测。</li><li>MVVM使用绑定机制更加牛逼，所以让使用 RxSwift 来更好地利用 ViewModel</li></ul><p>to be continued…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>如何读代码写代码</title>
    <link href="https://changzw.github.io/2019/03/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://changzw.github.io/2019/03/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2019-03-02T22:31:09.000Z</published>
    <updated>2020-04-25T02:43:24.383Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="怎么读"><a class="markdownIt-Anchor" href="#怎么读"></a> 怎么读</h2><ol><li>这个库是用来干嘛？</li><li>看文件结构<ol><li>思考作者分了那些模块</li><li>每个模块都是干啥的</li><li>模块联系实际场景是啥，文件上用了哪些架构or设计模式（MVC，MVVM，ViewStateModel，Coordinate，Meditate……）</li><li>模块间是如何联系的——数据流</li><li>了解具体模块细节</li></ol></li><li>看具体协议&amp;类的接口<ol><li>作者想要给用户提供什么功能</li><li>类的数据出口&amp;入口是什么</li><li>类之间关系使用了什么设计模式，如何提高了复用性</li></ol></li><li>看数据流向<ol><li>对于文档少&amp;想更深入理解代码，借助 IDE 调试代码，跟踪数据输入输出，看函数调用栈</li><li>根据数据流向可以更清楚类之间的关系</li></ol></li><li>看具体实现<ol><li>想知道具体细节如何实现的时候，看文件，定位源码位置</li></ol></li></ol><h2 id="怎么写"><a class="markdownIt-Anchor" href="#怎么写"></a> 怎么写</h2><ol><li>确定功能</li><li>根据功能确定模块</li><li>根据模块分文件夹<ol><li>思考模块之间关系，出口入口，相互依赖关系</li></ol></li><li>每个模块写接口——API<ol><li>API 层级关系，抽象层级，高层及实现通用功能</li><li>接口出口入口，依赖注入</li><li>接口之间依赖关系，思考使用何种设计模式</li></ol></li><li>根据模块，实现协议<ol><li>class 开发</li><li>class 之间关系，使用什么设计模式，提高复用效率</li><li>class 的出口入口，依赖注入</li><li>私有成员内部逻辑</li></ol></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>雪球速读法--迭代树--整体&amp;细节</title>
    <link href="https://changzw.github.io/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/"/>
    <id>https://changzw.github.io/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/</id>
    <published>2019-02-05T11:01:50.000Z</published>
    <updated>2020-04-25T03:03:03.779Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="雪球速读法浅析"><a class="markdownIt-Anchor" href="#雪球速读法浅析"></a> 雪球速读法–浅析</h2><p>《雪球速读法》中说：</p><blockquote><p>速读的方式是：<br>速度技巧 * 资料库(大小) = 速读</p><ul><li>反复读 n 变</li><li>每次快速阅读，要求1.不求甚解，2.脑子里不要有读的声音</li></ul><p>具体：</p><ul><li>先话读目录，前言，后记 用 15~30，思考书的整体结构，作者写作意图</li><li>从框架的外层一层层向知识细节挖，每次处理一层，理解一层，构建自己对这本书的资料库（滚雪球的过程）</li></ul></blockquote><p>这样做的好处是：</p><ol><li>强调先掌握知识的框架！从整体的角度一层层学习知识。</li><li>有了框架就知道森林大概的样子！</li><li>如果单纯的按照目录一点点学习书本上的知识，会陷在局部细节中出不来浪费大量时间，读书时间过长，前面的知识会忘，后面不一定会认真读完，最后整本书都很难理解。</li><li>作者是以什么样的方式写书的呢？类似于《雪球速读法》先有中心思想，目录，段落，然后落实到细节，《雪球速读法》就是按照作者的写作的方式理解知识的过程。</li><li>速读不发出声音，更有利于读者跟作者产生共鸣！这个也是读书的一个目的</li></ol><h2 id="目标-vs-任务"><a class="markdownIt-Anchor" href="#目标-vs-任务"></a> 目标 vs 任务</h2><p>目标：一个你想要看见的好结果<br>任务：为实现目标你要做的事</p><p>在缺少动力的时候多思考目标带来那些美好的愿景，用 Deadline 给自己施加压力，对比人的承诺。</p><p>在执行的时候多看细节，任务，因为总是关注目标，会无从下手，很多细节上的困难乐观对待！导致目标最终搁浅。</p><h2 id="树状结构知识"><a class="markdownIt-Anchor" href="#树状结构知识"></a> 树状结构知识</h2><p>有关树状结构，知识迭代过程都是一层层包裹的知识，有历史气息的知识都是树状结构<br>这样的知识可以像《雪球速读法》一样层层学习</p><h2 id="计算机知识"><a class="markdownIt-Anchor" href="#计算机知识"></a> 计算机知识</h2><p>计算机知识就是一个大大的树，找到一个大树枝，然后一层层分解这个知识点<br><img src="/img/knowledge_tree.jpg" alt="-"></p><p>程序开发的时候也是，现有结构，然后再是细节！</p><p>有时间补充</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift 5.RxDataSources</title>
    <link href="https://changzw.github.io/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/"/>
    <id>https://changzw.github.io/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/</id>
    <published>2019-01-31T05:58:32.000Z</published>
    <updated>2020-04-25T02:21:27.338Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/RxSwiftCommunity/RxDataSources/issues?q=is%3Aissue+is%3Aclosed" target="_blank" rel="noopener">原文: RxDataSources</a></p><h2 id="table-和-collection-view-data-sources"><a class="markdownIt-Anchor" href="#table-和-collection-view-data-sources"></a> Table 和 Collection View data sources</h2><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li>[x] O(N)计算差异的算法<ul><li>该算法假设所有 sections 和 items 都是唯一的，因此没有二义性</li><li>如果有歧义，在非动画刷新时自动回退</li></ul></li><li>[x] 他使用其他启发式方法以将最少数量的命令发送到分段视图<ul><li>即使运行时间是线性的，发送命令的首选数量通常也比线性少</li><li>最好（并且有可能）将更改数量限制为较小的数量，并且如果更改数量朝线性方向增长，则只需进行正常的reload即可</li></ul></li><li>[x] 支持扩展你的 item 和 section 结构<ul><li>只需使用 <code>IdentifiableType</code> 和 <code>Equatable</code> 扩展你的 item，并使用 <code>AnimatableSectionModelType</code> 扩展 section</li></ul></li><li>[x] 支持 section 和 item 的两级分层动画的所有组合<ul><li>Section 动画: Insert, Delete, Mov</li><li>Item 动画: Insert, Delete, Move, Reload (如果旧值不等于新值)</li></ul></li><li>[x] 可配置动画类型对于 Insert, Reload and Delete (Automatic, Fade, …)</li><li>[x] 示例 app</li><li>[x] 随机压力测试（eg app）</li><li>[x] 支持开箱即用的编辑（eg app）</li><li>[x] 同 UITableView 和 UICollectionView 一起工作</li></ul><h2 id="为什么"><a class="markdownIt-Anchor" href="#为什么"></a> 为什么</h2><p>编写 table 和 collection View 数据源很繁琐。对于最简单的情况，需要实现大量的委托方法。</p><p>RxSwift 通过简单的数据绑定机制有助于减轻一些负担：</p><ol><li>把你的数据转化成可见听序列 Observable</li><li>使用下面方法把数据绑定到 tableView/collectionView 上<ul><li>rx.items(dataSource:protocol&lt;RxTableViewDataSourceType, UITableViewDataSource&gt;)</li><li>rx.items(cellIdentifier:String)</li><li>rx.items(cellIdentifier:String:Cell.Type:_: )</li><li>rx.items(<em>:</em>: )</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">Observable</span>&lt;[<span class="type">String</span>]&gt;.just([<span class="string">"first element"</span>, <span class="string">"second element"</span>, <span class="string">"third element"</span>])</span><br><span class="line"></span><br><span class="line">data.bind(to: tableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; index, model, cell <span class="keyword">in</span></span><br><span class="line">  cell.textLabel?.text = model</span><br><span class="line">&#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这适用于简单数据集，但不适用于需要将复杂数据集与多个section 绑定或在添加/修改/删除item 时需要执行动画的情况。</p><p>这些正是RxDataSources帮助解决的用例。</p><p>使用RxDataSources，写起来非常容易</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">SectionModel</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;&gt;(configureCell: configureCell)</span><br><span class="line"><span class="type">Observable</span>.just([<span class="type">SectionModel</span>(model: <span class="string">"title"</span>, items: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])])</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/rxdatasources/RxDataSources.gif" alt="-"></p><h2 id="怎么用"><a class="markdownIt-Anchor" href="#怎么用"></a> 怎么用</h2><p>给定以下自定义数据结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anInt: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> aString: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> aCGPoint: <span class="type">CGPoint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先使用遵循 SectionModelType 协议的结构定义你的section：<ul><li>定义 item 类型别名：等于该 section 将包含的 item 类型</li><li>声明一个 items 属性：Item 类型数组</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOfCustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> header: <span class="type">String</span>    </span><br><span class="line">  <span class="keyword">var</span> items: [<span class="type">Item</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SectionOfCustomData</span>: <span class="title">SectionModelType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Item</span> = <span class="type">CustomData</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(original: <span class="type">SectionOfCustomData</span>, items: [<span class="type">Item</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span> = original</span><br><span class="line">    <span class="keyword">self</span>.items = items</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个dataSource对象，并将其传递给 SectionOfCustomData 类型：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedAnimatedDataSource</span>&lt;<span class="type">MySection</span>&gt;(</span><br><span class="line">    configureCell: &#123; ds, tv, <span class="number">_</span>, item <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> cell = tv.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>) ?? <span class="type">UITableViewCell</span>(style: .<span class="keyword">default</span>, reuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"Item \(item)"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;,</span><br><span class="line">    titleForHeaderInSection: &#123; ds, index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> ds.sectionModels[index].header</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>根据需要在dataSource上自定义闭包：<ul><li>titleForHeaderInSection</li><li>titleForFooterInSection</li><li>etc</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataSource.titleForHeaderInSection = &#123; dataSource, index <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.titleForFooterInSection = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].footer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canEditRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canMoveRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将实际数据定义为 CustomData 对象的 Observable序列，并将其绑定到tableView</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sections = [</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"First section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">0</span>, aString: <span class="string">"zero"</span>, aCGPoint: <span class="type">CGPoint</span>.zero), <span class="type">CustomData</span>(anInt: <span class="number">1</span>, aString: <span class="string">"one"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)) ]),</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"Second section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">2</span>, aString: <span class="string">"two"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)), <span class="type">CustomData</span>(anInt: <span class="number">3</span>, aString: <span class="string">"three"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">3</span>, y: <span class="number">3</span>)) ])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.just(sections)</span><br><span class="line">  .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="数据源动画"><a class="markdownIt-Anchor" href="#数据源动画"></a> 数据源动画</h2><p>RxDataSources 提供了两种特殊的数据源类型，它们可以自动处理绑定数据源中的动画变化：<code>RxTableViewSectionedAnimatedDataSource</code> 和 <code>RxCollectionViewSectionedAnimatedDataSource</code> 。</p><p>要使用两个动画数据源之一，你必须在上述概述的基础上采取一些额外的步骤：</p><ul><li>SectionOfCustomData需要遵守 AnimatableSectionModelType 协议</li><li>数据模型必须符合<ul><li>IdentifiableType：IdentifiableType 协议提供的 <code>identity</code> 必须是表示模型实例的不可变标识符(identifier)。例如，对于 Car 模型，你可能要使用 Car 的plateNumber 作为其标识。</li><li>Equatable：遵从 Equatable 协议 有助于RxDataSources确定哪些 cell 已更改，因此它只能为这些特定 cell 设置动画。这意味着，更改Car模型的任何属性都会触发该 cell 的动画重新加载。</li></ul></li></ul><h2 id="需要"><a class="markdownIt-Anchor" href="#需要"></a> 需要</h2><p>Xcode 10.2</p><p>Swift 5.0</p><p>For Swift 4.x version please use versions 3.0.0 … 3.1.0 For Swift 3.x version please use versions 1.0 … 2.0.2 For Swift 2.3 version please use versions 0.1 … 0.9</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="cocoapods"><a class="markdownIt-Anchor" href="#cocoapods"></a> CocoaPods</h3><p>Podfile</p><blockquote><p>pod ‘RxDataSources’, ‘~&gt; 4.0’</p></blockquote><h3 id="carthage"><a class="markdownIt-Anchor" href="#carthage"></a> Carthage</h3><p>Cartfile</p><blockquote><p>github “RxSwiftCommunity/RxDataSources” ~&gt; 4.0</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>简化设计 App 的过程</title>
    <link href="https://changzw.github.io/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://changzw.github.io/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2018-12-06T09:31:17.000Z</published>
    <updated>2020-05-06T10:18:58.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>一个 app 原型&amp;需求来了以后，如何实现呢？<br>本来一个完成的东西如何把需求翻译成程序呢？</p><h2 id="正常节奏"><a class="markdownIt-Anchor" href="#正常节奏"></a> 正常节奏：</h2><ol><li>分析需求<ol><li>原型分析</li><li>需求分析</li></ol></li><li>技术点调研分析<ol><li>架构方式</li><li>使用什么框架（框架对比）</li><li>View 层使用什么渲染方式，Model层使用什么组件，中间层使用什么工具</li></ol></li><li>时间预估<ol><li>新技术学习时间</li><li>开发时间</li><li>调试时间</li></ol></li></ol><h2 id="遇到问题"><a class="markdownIt-Anchor" href="#遇到问题"></a> 遇到问题</h2><ol><li>需求量大，强调代码的复用性！思考时间过长</li><li>需求理解错误，理解不深，差异性问题没有解决</li><li>新技术，熟练度问题，错误使用</li><li>沟通问题！</li></ol><h2 id="简单思考"><a class="markdownIt-Anchor" href="#简单思考"></a> 简单思考</h2><ol><li>简化开发流程！</li><li>App 编码过程<ol><li>照着画 UI</li><li>确定数据渲染方式！</li><li>简化让 model 层数据传到 UI 层渲染的过程，让水流通（我喜欢的方式是函数响应式 rx）</li><li>数据流连接完成以后，添加各种逻辑<ol><li>单链逻辑</li><li>一条条加</li><li>复用的地方在复用</li></ol></li></ol></li><li>代码不是一下子完美的！<ol><li>开始的时候不要太复杂</li><li>不要用太高端自己又不熟悉的技巧</li><li>重构优化使用更好地技术手段都是迭代的过程</li></ol></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>viewController transitions</title>
    <link href="https://changzw.github.io/2018/11/06/viewController-transitions/"/>
    <id>https://changzw.github.io/2018/11/06/viewController-transitions/</id>
    <published>2018-11-06T09:21:48.000Z</published>
    <updated>2020-05-18T15:29:03.607Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>iOS 系统提供了像 <code>push, pop, cover vertically</code> 这样的 <code>ViewController</code> 过渡，该篇分析如何自定义自己的 ViewController transitions。为啥要写这个因为“看着很麻烦”，比起 push，pop，present 来说……</p><p>思考：</p><ol><li>ViewController 的 过渡流程步骤是什么样的</li><li>都有什么组成，他们之间的逻辑是什么样的</li><li>用户如何使用</li></ol><p>过渡的过程，应该有：</p><ol><li>负责触发事件</li><li>负责管理过渡动画</li><li>负责过渡相关的ViewControllers，Views</li></ol><h2 id="transitions-结构"><a class="markdownIt-Anchor" href="#transitions-结构"></a> transitions 结构</h2><p>transitioning API 一组 protocols 结合，允许我们自定义化，使用一个现有的 transition 对象 or 自己定义一个新的。<br><img src="/img/Transition-Frame.jpeg" alt="transitioning API"></p><p>Q: 每个协议的责任是什么？<br>Q: 执行步骤是什么</p><h3 id="transitioning-delegate"><a class="markdownIt-Anchor" href="#transitioning-delegate"></a> Transitioning Delegate</h3><p>每个 ViewController 都有对象—— <code>transitioningDelegate: UIViewControllerTransitioningDelegate</code> 用来得到 Animation controller 对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CardViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlipPresentAnimationController</span>(originFrame: cardView.frame)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你 present or dismiss <code>ViewController</code> 的时候，UIKit 会向 <code>transitioningDelegate</code> 要你自定义的 <code>Animation controller</code> 来替代默认动画。你要做的是实现 <code>UIViewControllerTransitioningDelegate</code> 代理方法返回 <code>Animation controller</code></p><h3 id="animation-controller"><a class="markdownIt-Anchor" href="#animation-controller"></a> Animation Controller</h3><p>用来做过渡动画，他实现自 <code>UIViewControllerAnimatedTransitioning</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipPresentAnimationController</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置动画时间</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 从UIViewControllerContextTransitioning 中得到 toVc &amp; fromVc，对其制作动画</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1 通过 transitionContext 得到 fromVC 是触发 present的VC，toVC 是要被呈现的 VC，snapShot，是toVC 呈现以后的view 截图用于做动画</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: .from),</span><br><span class="line">      <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: .to),</span><br><span class="line">      <span class="keyword">let</span> snapshot = toVC.view.snapshotView(afterScreenUpdates: <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//containerView 是过渡过程中的容器 view</span></span><br><span class="line">    <span class="keyword">let</span> containerView = transitionContext.containerView</span><br><span class="line">    <span class="keyword">let</span> finalFrame = transitionContext.finalFrame(<span class="keyword">for</span>: toVC)</span><br><span class="line"></span><br><span class="line">    snapshot.frame = originFrame</span><br><span class="line">    snapshot.layer.cornerRadius = <span class="type">CardViewController</span>.cardCornerRadius</span><br><span class="line">    snapshot.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    containerView.addSubview(toVC.view)</span><br><span class="line">    containerView.addSubview(snapshot)</span><br><span class="line">    toVC.view.isHidden = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnimationHelper</span>.perspectiveTransform(<span class="keyword">for</span>: containerView)</span><br><span class="line">    snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(.pi / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 view 做动画处理</span></span><br><span class="line">    <span class="type">UIView</span>.animateKeyframes(</span><br><span class="line">      withDuration: duration,</span><br><span class="line">      delay: <span class="number">0</span>,</span><br><span class="line">      options: .calculationModeCubic,</span><br><span class="line">      animations: &#123;</span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">0.0</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          fromVC.view.layer.transform = <span class="type">AnimationHelper</span>.yRotation(-.pi / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">1</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(<span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">2</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.frame = finalFrame</span><br><span class="line">          snapshot.layer.cornerRadius = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">      completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        toVC.view.isHidden = <span class="literal">false</span></span><br><span class="line">        snapshot.removeFromSuperview()</span><br><span class="line">        fromVC.view.layer.transform = <span class="type">CATransform3DIdentity</span></span><br><span class="line">        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><p>对于需要自定义的 transitioning 的 ViewController，CustomViewController</p><ol><li>CustomViewController: UIViewControllerTransitioningDelegate 实现协议</li><li>实现协议的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animationController(presented:, presenting:, source:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br><span class="line">animationController(dismiss:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 Animation Controller（CustomeAnimationController: UIViewControllerAnimatedTransitioning)</li><li>实现 UIViewControllerAnimatedTransitioning 中的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transitionDuration(using transitionContext: <span class="type">UIViewControllerContextTransitioning?</span>) -&gt; <span class="type">TimeInterval</span></span><br><span class="line">animateTransition(transitionContext:)</span><br></pre></td></tr></table></figure><h2 id="给-dismiss-添加手势交互"><a class="markdownIt-Anchor" href="#给-dismiss-添加手势交互"></a> 给 dismiss 添加手势交互</h2><p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/settings.gif" alt=""></p><blockquote><p><a href="https://www.raywenderlich.com/322-custom-uiviewcontroller-transitions-getting-started#toc-anchor-011" target="_blank" rel="noopener">Custom UIViewController Transitions: Getting Started</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>App 架构</title>
    <link href="https://changzw.github.io/2018/09/18/App-%E6%9E%B6%E6%9E%84/"/>
    <id>https://changzw.github.io/2018/09/18/App-%E6%9E%B6%E6%9E%84/</id>
    <published>2018-09-18T02:28:02.000Z</published>
    <updated>2020-04-25T02:45:36.292Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><p>objc 《App 架构》 笔记</p><h2 id="如何设计架构"><a class="markdownIt-Anchor" href="#如何设计架构"></a> 如何设计架构</h2><ol><li>确定模块（Model 层，View 层，协调器……）<ol><li>如何确定模块？联想实际场景，分析责任、行为，确定模块！！</li><li>为什么要确定模块？确定模块后，程序不会被应用框架中的实现细节所支配</li></ol></li><li>模块间的联系，依赖，变换，通知行为如何定义。<ol><li>尽可能让数据流向单向清晰</li><li>确定数据流向行为统一一致，统一程序开发维护<ol><li>delegate，notification，block，kvo，Rx……</li></ol></li></ol></li></ol><h2 id="mvc"><a class="markdownIt-Anchor" href="#mvc"></a> MVC</h2><p><img src="/img/MVC.jpeg" alt="mvc"></p><p>Model 层包括，data model和server model<br>controler：引用 server model</p><h2 id="mvvm-c"><a class="markdownIt-Anchor" href="#mvvm-c"></a> MVVM-C</h2><p><img src="/img/mvvm-c.jpeg" alt="mvvm-c"></p><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><h2 id="mvcviewstate"><a class="markdownIt-Anchor" href="#mvcviewstate"></a> MVC+ViewState</h2><p><img src="/img/mvc-viewstate.jpeg" alt="mvc-viewstate"></p><h2 id="model-适配器-view-绑定器"><a class="markdownIt-Anchor" href="#model-适配器-view-绑定器"></a> Model 适配器 + View 绑定器</h2><h2 id="elm-架构"><a class="markdownIt-Anchor" href="#elm-架构"></a> Elm 架构</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="设计思想" scheme="https://changzw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="设计思想" scheme="https://changzw.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>“T” 字模型</title>
    <link href="https://changzw.github.io/2018/08/24/%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://changzw.github.io/2018/08/24/%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2018-08-24T07:30:54.000Z</published>
    <updated>2020-04-25T03:03:14.403Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="架构的时候容易乱使用-t-字模型思考"><a class="markdownIt-Anchor" href="#架构的时候容易乱使用-t-字模型思考"></a> 架构的时候容易乱——使用 “T” 字模型思考</h2><p>原因：<br>架构代码的时候，总想有没有更好地解决方案，如何尽可能的模块解耦，责任单一……，如何查分类，架构中需要有什么模块，需要使用什么工具链……</p><p>可是一下子把所有问放在一起，整个人很多时候会乱，而且想的越多越乱</p><p>解决方案：</p><ol><li>简单化模块，现有最基本的框架 eg MVVM，MVC</li><li>把最简单的模型先搭建起来，然后实现一个主流程功能</li><li>接着在实现其他主流程功能</li><li>想想可以添加那些 模块组件 让自己的架构更加优美</li><li>重构，然后再先有个主流程线</li></ol><p>总结：</p><ol><li>现有要做的东西有个 外在的整体认识，想给用户提供什么 接口！</li><li>先实现一个接口的功能，然后再把所有线的实现出来</li><li>重构</li></ol><p>整体思想方式 是 “T” 字思考</p><h2 id="模块组件间交互繁杂-为什么有-中介者"><a class="markdownIt-Anchor" href="#模块组件间交互繁杂-为什么有-中介者"></a> 模块组件间交互繁杂—— 为什么有 中介者</h2><ol><li>程序调用流程是线性的，思维混乱的程序员很容易把这条线搞的杂乱无章，虽然可以让程序跑起来，可是维护费劲</li><li>中介者：模块中提供中介者，定义一种编程规范，使用 中介者 让代码分类，这样把模块减少，减少杂乱的线，这些线放在中介者中</li></ol><p><img src="/img/meditator_chaos.jpg" alt="chaos"><br><img src="/img/meditator_order.jpg" alt="order"></p><p>中介者—— 像个管理者一样，在实际中调度各个部门，部门有什么问题想中介者汇报</p><p>如果没有中介者——管理者，那么 部门之间问题相互穿插 orz</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift 源码分析</title>
    <link href="https://changzw.github.io/2018/08/18/RxSwfit+RAC/RxSwift-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2018/08/18/RxSwfit+RAC/RxSwift-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2018-08-18T08:56:26.000Z</published>
    <updated>2020-04-25T02:21:11.915Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><p><img src="/img/RxSwift001.jpg" alt="frame"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;img src=&quot;/img/RxSwift001.jpg&quot; alt=&quot;frame&quot;&gt;&lt;/p&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>关联对象</title>
    <link href="https://changzw.github.io/2018/07/01/deep%20analyse/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    <id>https://changzw.github.io/2018/07/01/deep%20analyse/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</id>
    <published>2018-07-01T14:32:13.000Z</published>
    <updated>2020-04-25T02:55:18.668Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="关联对象是什么"><a class="markdownIt-Anchor" href="#关联对象是什么"></a> 关联对象是什么</h2><ul><li>他是 objective-c runtime 机制中提供的一个接口，让用户在运行时，动态的给类添加关联属性</li></ul><h2 id="关联对象的主要作用"><a class="markdownIt-Anchor" href="#关联对象的主要作用"></a> 关联对象的主要作用</h2><p>开发中如何给 category 添加成员属性呢？或者说，如何在运行时给 class 关联新的属性？</p><ul><li>主要作用：给category 添加成员变量<ul><li>category 底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接添加。</li><li>分类中的 @property 只能声明属性，不提供 _name, getName, setName 的实现</li><li>类中 @property 提供 _name, getName, setName 的实现</li></ul></li></ul><h2 id="如何使用关联对象呢"><a class="markdownIt-Anchor" href="#如何使用关联对象呢"></a> 如何使用关联对象呢</h2><h3 id="关联对象接口"><a class="markdownIt-Anchor" href="#关联对象接口"></a> 关联对象接口</h3><p><code>&lt;objc/runtime.h&gt;</code> 中定义的以下三个允许你将任何键值在运行时关联到对象上的函数：</p><ul><li>objc_setAssociatedObject</li><li>objc_getAssociatedObject</li><li>objc_removeAssociatedObjects</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object   :表示关联者，是一个对象，变量名理所当然也是object</span></span><br><span class="line"><span class="comment">key      :获取被关联者的索引key</span></span><br><span class="line"><span class="comment">value    :被关联者</span></span><br><span class="line"><span class="comment">policy   :关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line"><span class="comment">//移除某个对象身上的所有关联的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure><h2 id="实际使用效果"><a class="markdownIt-Anchor" href="#实际使用效果"></a> 实际使用效果</h2><p>对比字典实现给分类添加 property</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> weight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Key [NSString stringWithFormat:@<span class="meta-string">"%p"</span>, self]</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *names_;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *weights_;</span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    weights_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    names_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    names_[Key] = name;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> names_[Key];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    weights_[Key] = @(weight);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    <span class="keyword">return</span> [weights_[Key] intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面使用全局字典的方式，给分类中的成员变量添加get，set 实现体</p><p>那么如何使用关联对象呢？</p><ul><li>关联对象实现分类添加成员属性</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 隐式参数_cmd == @selector(name)</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="关联对象源码分析"><a class="markdownIt-Anchor" href="#关联对象源码分析"></a> 关联对象源码分析</h2><p>关联对象也是用全局 hash 表来保存的。<br><a href="https://opensource.apple.com/tarballs/objc4/objc4-779.1.tar.gz" target="_blank" rel="noopener">objc4-779.1源码</a> 这个文件中 <a href="http://objc-references.mm" target="_blank" rel="noopener">objc-references.mm</a></p><p>关联对象的核心类</p><div align="left"><img src="/img/ao.jpeg" style="width:800px;height:370px"></div><ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">  <span class="comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">  <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsHashMap</span> :</span> <span class="keyword">public</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAssociationMap</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">  id _value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关联对象何时释放"><a class="markdownIt-Anchor" href="#关联对象何时释放"></a> 关联对象何时释放</h3><p>…… 不想看了，想看了再补充，总之他在所关联的对象释放后，会释放的</p><h3 id="关联时采用的协议"><a class="markdownIt-Anchor" href="#关联时采用的协议"></a> 关联时采用的协议</h3><table><thead><tr><th>Behavior</th><th>@property Equivalent</th><th>Description</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) 或 @property (unsafe_unretained)</td><td>指定一个关联对象的弱引用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (nonatomic, strong)</td><td>指定一个关联对象的强引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (nonatomic, copy)</td><td>指定一个关联对象的copy引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (atomic, strong)</td><td>指定一个关联对象的强引用，能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (atomic, copy)</td><td>指定一个关联对象的copy引用，能被原子化使用。</td></tr></tbody></table><h2 id="实际中使用关联对象的例子"><a class="markdownIt-Anchor" href="#实际中使用关联对象的例子"></a> 实际中使用关联对象的例子</h2><p><a href="https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/">使用 closures 添加 Gesture Recognizers</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="objc" scheme="https://changzw.github.io/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>swift 序列化Codable</title>
    <link href="https://changzw.github.io/2018/05/10/swift-%E5%BA%8F%E5%88%97%E5%8C%96Codable/"/>
    <id>https://changzw.github.io/2018/05/10/swift-%E5%BA%8F%E5%88%97%E5%8C%96Codable/</id>
    <published>2018-05-10T02:10:46.000Z</published>
    <updated>2020-04-25T02:48:33.269Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>序列化是将对象的状态信息转换为可以存储或传输的形式的过程(对象&lt;–&gt;I/O流)。<br>对象信息序列化以后变成 I/O 流：</p><ol><li>可以本地化存储（持久化对象）</li><li>网络通讯（网络传输对象）</li><li>定制协议，跨平台、跨语言通讯</li></ol><h2 id="swift-中的序列化"><a class="markdownIt-Anchor" href="#swift-中的序列化"></a> Swift 中的序列化</h2><ol><li>Swift 4.0 之前仍需要手动解析</li><li>Swift 4.0 以后，提供 Codable 协议</li><li>仍然存在问题</li></ol><h3 id="没有encoder和decoder"><a class="markdownIt-Anchor" href="#没有encoder和decoder"></a> 没有Encoder和Decoder</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json: [<span class="type">String</span> : <span class="type">Any</span>] = [</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"cap"</span>,</span><br><span class="line">  <span class="string">"points"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"this is a cat"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要手动解析</span></span><br><span class="line">  <span class="keyword">init</span>?(json: [<span class="type">String</span>: <span class="type">Any</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = json[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">      <span class="keyword">let</span> points = json[<span class="string">"points"</span>] <span class="keyword">as</span>? <span class="type">Int</span>,</span><br><span class="line">      <span class="keyword">let</span> description = json[<span class="string">"description"</span>] <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.points = points</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> p = <span class="type">Product</span>(json: json) &#123;</span><br><span class="line">  <span class="built_in">print</span>(p.name + <span class="string">" \(p.points) "</span> + p.description!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用编码器类型遵循-codableencodable-decodable-协议"><a class="markdownIt-Anchor" href="#使用编码器类型遵循-codableencodable-decodable-协议"></a> 使用编码器，类型遵循 Codable(Encodable &amp; Decodable) 协议</h3><ol><li>类型遵循Codable</li><li>Encode</li><li>Decode</li></ol><p>2017年6月发布的 Swift4.0 中的 Codable(Encodable &amp; Decodable) 协议，表明该协议具有被序列化和/或反序列化的能⼒。<br>Swift 标准库中的所有基本类型都遵循 <code>Codable</code> 协议，<code>Data，Date， URL，CGPoint 和 CGRect</code> 在内的许多 Apple 框架中的常⽤数据类型，也已经适配了 Codable。<br>自定义类型需要用户遵循 Codable协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 某个类型可以将⾃身编码为⼀种外部表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Encodable</span> </span>&#123; <span class="comment">/// 将值编码到给定的 encoder 中</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 某个类型可以从外部表示中解码得到⾃身</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123; <span class="comment">/// 通过从给定的 decoder 中解码来创建新的实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⼀旦你拥有 codable 类型的值，你可以创建⼀个编码器，并让它将这个值转换到像是 JSON 这样的序列化格式。反过来，⼀个解码器可以将序列化后的数据转回为它原来类型的⼀个实例。</p><p>Swift ⾃带两套编码解码器，<code>JSONEncoder/JSONDecoder</code> 和 <code>PropertyListEncoder/PropertyListDecoder</code>，它们存在于 Foundation 中。</p><h2 id="jsonencoderjsondecoder"><a class="markdownIt-Anchor" href="#jsonencoderjsondecoder"></a> JSONEncoder/JSONDecoder</h2><h3 id="不需要手动解码"><a class="markdownIt-Anchor" href="#不需要手动解码"></a> 不需要手动解码</h3><p>属性名 = key，属性类型 = value 类型一致，使用 decoder 对json解码，不需要手动解码了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"""</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "name": "Banana",</span></span><br><span class="line"><span class="string">        "points": 200,</span></span><br><span class="line"><span class="string">        "description": "A banana grown in Ecuador."</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "name": "Orange",</span></span><br><span class="line"><span class="string">        "points": 100</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span>.data(using: .utf8)!</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> products = <span class="keyword">try</span> decoder.decode([<span class="type">GroceryProduct</span>].<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following products are available:"</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\t\(product.name) (\(product.points) points)"</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> description = product.description &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t\t\(description)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上文无关，只描述下编码过程</span></span><br><span class="line"><span class="keyword">let</span> jsonEncoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="keyword">try</span>? jsonEncoder.encode(products)</span><br><span class="line"><span class="keyword">let</span> str = <span class="type">String</span>(decoding: jsonData!, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"><span class="keyword">let</span> jsonObject = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: jsonData!, options: .allowFragments)</span><br><span class="line"><span class="built_in">print</span>(jsonObject)</span><br></pre></td></tr></table></figure><p>GroceryProduct 类中属性都遵循 <code>Codable</code> 协议，Array也是，所以不需要实现 <code>encode(to encoder: Encoder)</code> 和 <code>init(from decoder: Decoder)</code> 方法</p><h3 id="需要手动解码"><a class="markdownIt-Anchor" href="#需要手动解码"></a> 需要手动解码</h3><h4 id="json中的key值与属性名称不一致"><a class="markdownIt-Anchor" href="#json中的key值与属性名称不一致"></a> json中的key值与属性名称不一致</h4><p>但是这个类型实际上并不⼀定需要是枚 举)。提供⾃定义的编码键是⼀种很简单，⽽且是声明式的改变类型编码的⽅式。在枚举中，我 们可以：</p><p>→ 使⽤明确给定的字符串值，在编码后的输出中重命名字段，或者</p><p>→ 将某个键从枚举中移除，以此完全跳过字段。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"""</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "product_name": "Bananas",</span></span><br><span class="line"><span class="string">        "product_cost": 200,</span></span><br><span class="line"><span class="string">        "description": "A banana grown in Ecuador."</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "product_name": "Oranges",</span></span><br><span class="line"><span class="string">        "product_cost": 100,</span></span><br><span class="line"><span class="string">        "description": "A juicy orange."</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span>.data(using: .utf8)!</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> name = <span class="string">"product_name"</span></span><br><span class="line">    <span class="keyword">case</span> points = <span class="string">"product_cost"</span></span><br><span class="line">    <span class="keyword">case</span> description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> products = <span class="keyword">try</span> decoder.decode([<span class="type">GroceryProduct</span>].<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following products are available:"</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\t\(product.name) (\(product.points) points)"</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> description = product.description &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t\t\(description)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型嵌套"><a class="markdownIt-Anchor" href="#类型嵌套"></a> 类型嵌套</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Mon May 18 2020 23:34:25 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="开发语言" scheme="https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift" scheme="https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/swift/"/>
    
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
  </entry>
  
</feed>
