<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fri.</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://changzw.github.io/"/>
  <updated>2020-04-25T07:00:42.842Z</updated>
  <id>https://changzw.github.io/</id>
  
  <author>
    <name>Fri.</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SnapKit 分析</title>
    <link href="https://changzw.github.io/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2020/04/10/source-code/SnapKit-%E5%88%86%E6%9E%90/</id>
    <published>2020-04-10T07:24:23.000Z</published>
    <updated>2020-04-25T07:00:42.842Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:12 GMT+0800 (CST) --><a id="more"></a><p>对应 <a href="https://changzw.github.io/2017/06/01/source-code/Masonry-%E5%88%86%E6%9E%90/">Masonry 源码分析</a>, 看这篇文章前最好先看看这篇</p><p>（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言）</p><p>分析源码：</p><ol><li>这个第三方库，他设计的目标是什么？</li><li>需要哪些基础知识</li><li>整体结构是什么样的</li><li>由外而内逐层分析层次结构</li><li>每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点</li><li>为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？</li></ol><h2 id="snapkit-是什么"><a class="markdownIt-Anchor" href="#snapkit-是什么"></a> <code>SnapKit</code> 是什么</h2><p><a href="https://github.com/SnapKit/SnapKit" target="_blank" rel="noopener">SnapKit 源码地址</a></p><h2 id="为什么要设计-snapkit"><a class="markdownIt-Anchor" href="#为什么要设计-snapkit"></a> 为什么要设计 <code>SnapKit</code></h2><p>首先和系统提供接口对比下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> constraint1 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .<span class="keyword">left</span>,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">150</span>);</span><br><span class="line">constraint1.isActive = <span class="literal">true</span></span><br><span class="line">... top, width</span><br><span class="line"><span class="keyword">let</span> constraint4 = <span class="type">NSLayoutConstraint</span>.<span class="keyword">init</span>(item: label,</span><br><span class="line">                                          attribute: .height,</span><br><span class="line">                                          relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                                          toItem: view,</span><br><span class="line">                                          attribute: .notAnAttribute,</span><br><span class="line">                                          multiplier: <span class="number">1</span>,</span><br><span class="line">                                          constant: <span class="number">20</span>);</span><br><span class="line">constraint4.isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Anchor: 只支持 ios &gt;= 9</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">label.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">  label.leftAnchor.constraint(equalTo: view.leftAnchor, constant: <span class="number">150</span>),</span><br><span class="line">  label.topAnchor.constraint(equalTo: view.topAnchor, constant: <span class="number">200</span>),</span><br><span class="line">  label.widthAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">  label.heightAnchor.constraint(equalToConstant: <span class="number">200</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><span id="code1"></span></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.top.equalToSuperview().offset(<span class="number">200</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P.S. SnapKit 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = true</p><p>SnapKit 设计的目的，就是以链式编程手段封装 <code>NSLayoutConstraint</code> 冗余代码！</p><ol><li>如何处理原来繁杂接口</li><li>如何实现链式</li><li>如何封装 <code>NSLayoutConstraint</code> 的</li><li>如何把多个 <code>NSLayoutConstraint</code> 封装成简单的一句搞定的</li><li>使用了何种编程手段</li></ol><hr><h2 id="snapkit-代码结构分析"><a class="markdownIt-Anchor" href="#snapkit-代码结构分析"></a> <code>SnapKit</code> 代码结构分析</h2><h3 id="从调用层次分析"><a class="markdownIt-Anchor" href="#从调用层次分析"></a> 从调用层次分析</h3><p>这里我要像洋葱一样一层一层的拨开</p><ol><li>最外层接口<br>根据这段代码分析</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">label.snp.makeConstraints &#123; (make) <span class="keyword">in</span></span><br><span class="line">  make.<span class="keyword">left</span>.equalTo(view).offset(<span class="number">150</span>)</span><br><span class="line">  make.size.equalTo(<span class="type">CGSize</span>(width: <span class="number">200</span>, height: <span class="number">20</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ConstraintMaker.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">prepareConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; [<span class="type">Constraint</span>]</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">remakeConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">updateConstraints</span><span class="params">(item: LayoutConstraintItem, closure: <span class="params">(<span class="number">_</span> make: ConstraintMaker)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从👆源码可以看到</p><ul><li>三个见名知意的方法</li><li>方法参数 <code>ConstraintMaker</code> 这个就是 make</li><li>属性 <code>ConstraintMakerExtendable</code> 这个就是 make 后面的 make.left</li></ul><p>我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口<br>我还要找到 下图的这些信息<br><img src="/img/view_formula.jpeg" alt="view formula"></p><ol start="2"><li>接着往里面看</li></ol><ul><li><code>ConstraintMakerExtendable</code> 继承自 <code>ConstraintMakerRelatable</code></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerExtendable</span> : <span class="title">ConstraintMakerRelatable</span>  </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">left</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .top</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .bottom</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintMakerExtendable</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.description.attributes += .<span class="keyword">right</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><ul><li><p>问题&amp;猜测：</p><ul><li><code>description</code> 是啥？不知道</li><li>不过他有 <code>attributes</code> 属性，看样子对应 <code>NSLayoutConstraint.Attribute</code></li><li>left, top …… 这些都返回 <code>ConstraintMakerExtendable</code> ，猜测他是链的节点对象</li></ul></li><li><p>继续看 <code>ConstraintMakerRelatable</code></p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintMakerRelatable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> description: <span class="type">ConstraintDescription</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(<span class="number">_</span> description: <span class="type">ConstraintDescription</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">relatedTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> related: <span class="type">ConstraintItem</span></span><br><span class="line">    <span class="keyword">let</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintItem</span> &#123;</span><br><span class="line">      <span class="keyword">guard</span> other.attributes == <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span> ||</span><br><span class="line">          other.attributes.layoutAttributes.<span class="built_in">count</span> &lt;= <span class="number">1</span> ||</span><br><span class="line">          other.attributes.layoutAttributes == <span class="keyword">self</span>.description.attributes.layoutAttributes ||</span><br><span class="line">          other.attributes == .edges &amp;&amp; <span class="keyword">self</span>.description.attributes == .margins ||</span><br><span class="line">          other.attributes == .margins &amp;&amp; <span class="keyword">self</span>.description.attributes == .edges ||</span><br><span class="line">          other.attributes == .directionalEdges &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalMargins ||</span><br><span class="line">          other.attributes == .directionalMargins &amp;&amp; <span class="keyword">self</span>.description.attributes == .directionalEdges <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"Cannot constraint to multiple non identical attributes. (\(file), \(line))"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      related = other</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintView</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintConstantTarget</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: <span class="literal">nil</span>, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = other</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> #available(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *), <span class="keyword">let</span> other = other <span class="keyword">as</span>? <span class="type">ConstraintLayoutGuide</span> &#123;</span><br><span class="line">      related = <span class="type">ConstraintItem</span>(target: other, attributes: <span class="type">ConstraintAttributes</span>.<span class="keyword">none</span>)</span><br><span class="line">      constant = <span class="number">0.0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">fatalError</span>(<span class="string">"Invalid constraint. (\(file), \(line))"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> editable = <span class="type">ConstraintMakerEditable</span>(<span class="keyword">self</span>.description)</span><br><span class="line">    editable.description.sourceLocation = (file, line)</span><br><span class="line">    editable.description.relation = relation</span><br><span class="line">    editable.description.related = related</span><br><span class="line">    editable.description.constant = constant</span><br><span class="line">    <span class="keyword">return</span> editable</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@discardableResult</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">equalTo</span><span class="params">(<span class="number">_</span> other: ConstraintRelatableTarget, <span class="number">_</span> file: String = #file, <span class="number">_</span> line: UInt = #line)</span></span> -&gt; <span class="type">ConstraintMakerEditable</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.relatedTo(other, relation: .<span class="built_in">equal</span>, file: file, line: line)</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找到了</p><ul><li>ConstraintConstantTarget(struct)</li><li>ConstraintRelation(struct)</li><li>ConstraintAttributes(struct)</li><li>ConstraintDescription(class)</li><li>ConstraintItem(class)</li><li>ConstraintMakerEditable(class)</li></ul><h3 id="model-层数据分析"><a class="markdownIt-Anchor" href="#model-层数据分析"></a> model 层数据分析</h3><h4 id="constraintconstanttarget"><a class="markdownIt-Anchor" href="#constraintconstanttarget"></a> ConstraintConstantTarget</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">LayoutAttribute</span> = <span class="type">NSLayoutConstraint</span>.<span class="type">Attribute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGPoint</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGSize</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintInsets</span>: <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">NSDirectionalEdgeInsets</span> : <span class="title">ConstraintConstantTarget</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintConstantTarget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> <span class="title">constraintConstantTargetValueFor</span><span class="params">(layoutAttribute: LayoutAttribute)</span></span> -&gt; <span class="type">CGFloat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码知道 <code>ConstraintConstantTarget</code> 是 autolayout 方程式中的 constant，他是这个 constant 扩展封装</p><h4 id="constraintrelation"><a class="markdownIt-Anchor" href="#constraintrelation"></a> ConstraintRelation</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConstraintRelation</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">  <span class="keyword">case</span> <span class="built_in">equal</span> </span><br><span class="line">  <span class="keyword">case</span> lessThanOrEqual </span><br><span class="line">  <span class="keyword">case</span> greaterThanOrEqual </span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutRelation: <span class="type">LayoutRelation</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintRelation</code> 是 方程式中的 关系符号</p><h4 id="constraintattributes"><a class="markdownIt-Anchor" href="#constraintattributes"></a> ConstraintAttributes</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConstraintAttributes</span> : <span class="title">OptionSet</span>, <span class="title">ExpressibleByIntegerLiteral</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">none</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">0</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">left</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> top: <span class="type">ConstraintAttributes</span> &#123;  <span class="keyword">return</span> <span class="number">2</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> <span class="keyword">right</span>: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">4</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> bottom: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">8</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> leading: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">16</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> trailing: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">32</span> &#125;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">static</span> <span class="keyword">var</span> width: <span class="type">ConstraintAttributes</span> &#123; <span class="keyword">return</span> <span class="number">64</span> &#125;</span><br><span class="line">...</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutAttributes:[<span class="type">LayoutAttribute</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> attrs = [<span class="type">LayoutAttribute</span>]()</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.<span class="keyword">left</span>)) &#123;</span><br><span class="line">      attrs.append(.<span class="keyword">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.<span class="built_in">contains</span>(<span class="type">ConstraintAttributes</span>.top)) &#123;</span><br><span class="line">      attrs.append(.top)</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> attrs</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> + <span class="params">(<span class="keyword">left</span>: ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> -&gt; <span class="type">ConstraintAttributes</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">left</span>.union(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">func</span> +=<span class="params">(<span class="keyword">left</span>: <span class="keyword">inout</span> ConstraintAttributes, <span class="keyword">right</span>: ConstraintAttributes)</span></span> &#123;</span><br><span class="line">  <span class="keyword">left</span>.formUnion(<span class="keyword">right</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ConstraintAttributes 使用了swift 的选择集(可选枚举)</li><li>重载了运算符</li><li>依然猜测 它对应 <code>NSLayoutConstraint.Attribute</code></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintItem</span> </span>&#123;</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">AnyObject?</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">let</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">init</span>(target: <span class="type">AnyObject?</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">  <span class="keyword">internal</span> <span class="keyword">var</span> layoutConstraintItem: <span class="type">LayoutConstraintItem?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.target <span class="keyword">as</span>? <span class="type">LayoutConstraintItem</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> == <span class="params">(lhs: ConstraintItem, rhs: ConstraintItem)</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LayoutConstraintItem.swift</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">LayoutConstraintItem</span>: <span class="title">class</span> </span>&#123;&#125;</span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">9.0</span>, <span class="type">OSX</span> <span class="number">10.11</span>, *)</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintLayoutGuide</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ConstraintView</span> : <span class="title">LayoutConstraintItem</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintLayoutGuide</span> = <span class="type">UILayoutGuide</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">ConstraintView</span> = <span class="type">UIView</span></span><br></pre></td></tr></table></figure><p>nice~<br>ConstraintItem 就是 view 和 他对应布局属性的元组 (view, attr)</p><h4 id="constraintdescription"><a class="markdownIt-Anchor" href="#constraintdescription"></a> ConstraintDescription</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstraintDescription</span> </span>&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">let</span> item: <span class="type">LayoutConstraintItem</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> attributes: <span class="type">ConstraintAttributes</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> relation: <span class="type">ConstraintRelation?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> sourceLocation: (<span class="type">String</span>, <span class="type">UInt</span>)?</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> label: <span class="type">String?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> related: <span class="type">ConstraintItem?</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> multiplier: <span class="type">ConstraintMultiplierTarget</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> constant: <span class="type">ConstraintConstantTarget</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> priority: <span class="type">ConstraintPriorityTarget</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="built_in">lazy</span> <span class="keyword">var</span> constraint: <span class="type">SnapKit</span>.<span class="type">Constraint?</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125; <span class="comment">// main</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">init</span>(item: <span class="type">LayoutConstraintItem</span>, attributes: <span class="type">ConstraintAttributes</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ConstraintDescription</code> 包含了 autolayout 布局方程式中所有信息，可是不知道为啥不在这里调用 NSLayoutConstraint 添加属性，非要搞一个 SnapKit.Constraint来做这些事</p><ul><li>ConstraintMakerEditable 是链式编程技巧里面的往后看</li></ul><h3 id="分析-snapkit-链式封装"><a class="markdownIt-Anchor" href="#分析-snapkit-链式封装"></a> 分析 <code>SnapKit</code> 链式封装</h3><h4 id="主要组件结"><a class="markdownIt-Anchor" href="#主要组件结"></a> 主要组件结</h4><ul><li>文件分组<br><img src="/img/snapkit_files.jpeg" alt="snapkit_files"></li></ul><h4 id="使用函数调用栈分析"><a class="markdownIt-Anchor" href="#使用函数调用栈分析"></a> 使用函数调用栈分析</h4><details><summary>SnapKit 主流程</summary><pres><p><img src="/img/snapKit_main_flow.jpeg" alt="snapKit main flow"><br></p></pres><p></p></details><details><summary>SnapKit 链式流程</summary><pres><p><img src="/img/snapKit_chain.jpeg" alt="snapKit chain"><br></p></pres><p></p></details><p>maker 创建一个其实节点 ContraintExtentable，他维护自己的 description<br>maker 保存 descriptions[] 数组</p><p>传递 description 来延续链节点</p><p>to be continued</p><h3 id="代码组件分析"><a class="markdownIt-Anchor" href="#代码组件分析"></a> 代码组件分析</h3><blockquote><p><a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853-CH7-SW1" target="_blank" rel="noopener">Auto Layout Guide</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:12 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="UI 布局" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>使用 closures 代替 Gesture Recognizers 选择器</title>
    <link href="https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/"/>
    <id>https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/</id>
    <published>2020-03-08T01:56:45.000Z</published>
    <updated>2020-04-25T02:56:00.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/@sdrzn/adding-gesture-recognizers-with-closures-instead-of-selectors-9fb3e09a8f0b" target="_blank" rel="noopener">原文 Adding Gesture Recognizers with Closures Instead of Selectors<br></a></p><p>添加UITapGestureRecognizer或任何 recognizer/target action 的最糟糕的部分是仅针对选择器参数实现新功能。今天，我想分享一个巧妙的技巧，让你添加不带选择器的手势识别器。</p><p>假设我们在View Controller中有一个UIImageView，我们想向其中添加一个UITapGestureRecognizer，以便在点击它时打印出一条语句.</p><p>通常，我们会创建一个 UITapGestureRecognizer 的实例，并将其目标设置为视图控制器及其选择器，因为我们会快速将它们组合在一起(myImageViewTapped(sender：UITapGestureRecognizer))。</p><p>这可能会有点多余，并且可能导致要添加交互性的每个子视图的函数的代码混乱。</p><p>我以为我可以快速扩展一下，以便为我的图像视图添加敲击手势识别器，但是然后我必须为每个识别器创建一个新功能，对吗？错误！利用关联对象的功能，我们实际上可以将闭包存储为扩展中的计算属性！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In order to create computed properties for extensions, we need a key to </span></span><br><span class="line">  <span class="comment">// store and access the stored property</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="class"><span class="keyword">struct</span> <span class="title">AssociatedObjectKeys</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> tapGestureRecognizer = <span class="string">"MediaViewerAssociatedObjectKey_mediaViewer"</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">typealias</span> <span class="type">Action</span> = (() -&gt; <span class="type">Void</span>)?</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Set our computed property type to a closure</span></span><br><span class="line">  <span class="keyword">fileprivate</span> <span class="keyword">var</span> tapGestureRecognizerAction: <span class="type">Action?</span> &#123;</span><br><span class="line">    <span class="keyword">set</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newValue = newValue &#123;</span><br><span class="line">        <span class="comment">// Computed properties get stored as associated objects</span></span><br><span class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer, newValue, objc_AssociationPolicy.<span class="type">OBJC_ASSOCIATION_RETAIN</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">get</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> tapGestureRecognizerActionInstance = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;<span class="type">AssociatedObjectKeys</span>.tapGestureRecognizer) <span class="keyword">as</span>? <span class="type">Action</span></span><br><span class="line">      <span class="keyword">return</span> tapGestureRecognizerActionInstance</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// This is the meat of the sauce, here we create the tap gesture recognizer and</span></span><br><span class="line">  <span class="comment">// store the closure the user passed to us in the associated object we declared above</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">addTapGestureRecognizer</span><span class="params">(action: <span class="params">(<span class="params">()</span></span></span></span> -&gt; <span class="type">Void</span>)?) &#123;</span><br><span class="line">    <span class="keyword">self</span>.isUserInteractionEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">self</span>.tapGestureRecognizerAction = action</span><br><span class="line">    <span class="keyword">let</span> tapGestureRecognizer = <span class="type">UITapGestureRecognizer</span>(target: <span class="keyword">self</span>, action: #selector(handleTapGesture))</span><br><span class="line">    <span class="keyword">self</span>.addGestureRecognizer(tapGestureRecognizer)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Every time the user taps on the UIImageView, this function gets called,</span></span><br><span class="line">  <span class="comment">// which triggers the closure we stored</span></span><br><span class="line">  <span class="meta">@objc</span> <span class="keyword">fileprivate</span> <span class="function"><span class="keyword">func</span> <span class="title">handleTapGesture</span><span class="params">(sender: UITapGestureRecognizer)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> action = <span class="keyword">self</span>.tapGestureRecognizerAction &#123;</span><br><span class="line">      action?()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"no action"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，每当我们要将UITapGestureRecognizer添加到UIView或UIView子类（如UIImageView）时，都可以这样做，而无需为选择器创建关联的功能！这是一个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sampleImageView.addTapGestureRecognizer &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"image tapped"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有UITapGestureRecognizers实例，没有targets，没有selectors，没有不必要的functions！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>自定义 keyboard</title>
    <link href="https://changzw.github.io/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/"/>
    <id>https://changzw.github.io/2020/02/17/%E8%87%AA%E5%AE%9A%E4%B9%89-keyboard/</id>
    <published>2020-02-17T09:18:39.000Z</published>
    <updated>2020-04-25T02:44:20.510Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><p>原文：<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html" target="_blank" rel="noopener">CustomKeyboard</a></p><h3 id="自定义键盘api"><a class="markdownIt-Anchor" href="#自定义键盘api"></a> 自定义键盘API</h3><p>开发自定义键盘的快速入门,如下图，它展示了键盘运行过程中一些重要的对象，以及它们在开发流程中的的位置：</p><p><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/keyboard_architecture_2x.png" alt="keyboard"></p><p>自定义键盘模板（在iOS“Application Extension”目标模板组）包含一个UIInputViewController的子类，它是你开发的键盘的主视图控制器。该模板包含</p><p>键盘所必需的“下一个键盘”按钮的实现，它调用了UIInputViewController类的advanceToNextInputMode方法。如上图所示，可以在输入视图控制器的主视图（在其inputView属性）中添加子视图、控制器以及手势识别器等。对于其它类型的扩展应用，在目标上并不存在窗体，因此也就没有根视图控制器了。</p><p>在模板的Info.plist文件中有预先配置好的键盘所需要的最基本的值。参见其中的NSExtensionAttributes字典关键字，配置一个键盘的关键字在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW18" target="_blank" rel="noopener">《配置自定义键盘的Info.plist文件》</a>中有介绍。</p><p>默认，键盘不能访问网络，不能和它的app共享容器。如果要具备这种能力，必须要将Info.plist文件中RequestsOpenAccess的值置为YES。这需要扩展键盘的沙盒，在<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《设计用户信任》</a>中有介绍相关内容。</p><p>一个输入视图控制器遵从各种与文本输入对象内容交互的协议：</p><ul><li>响应触摸消息时如果要插入或删除文本，可以使用<a href="https://developer.apple.com/reference/uikit/uikeyinput" target="_blank" rel="noopener">UIKeyInput</a>协议的insertText:和deleteBackward方法。可以在视图控制器的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618193-textdocumentproxy" target="_blank" rel="noopener">textDocumentProxy</a>属性中调用这些方法，该属性代表当前文本输入对象，它遵从<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy" target="_blank" rel="noopener">UITextDocumentProxy</a>协议。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"hello "</span>]; <span class="comment">// Inserts the string "hello " at the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy deleteBackward];       <span class="comment">// Deletes the character to the left of the insertion point</span></span><br><span class="line">[<span class="keyword">self</span>.textDocumentProxy insertText:<span class="string">@"\n"</span>];     <span class="comment">// In a text view, inserts a newline character at the insertion point</span></span><br></pre></td></tr></table></figure><ul><li>在调用deleteBackward之前要先决定删除的字符数。可以通过textDocumentProxy的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618190-documentcontextbeforeinput" target="_blank" rel="noopener">documentContextBeforeInput</a>属性，来获得光标附近的文本上下文信息。如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *precedingContext = <span class="keyword">self</span>.textDocumentProxy.documentContextBeforeInput;</span><br></pre></td></tr></table></figure><ul><li>为了控制光标所在位置的操作，比如支持向前删除文字，需要调用UITextDocumentProxy协议中的<a href="https://developer.apple.com/reference/uikit/uitextdocumentproxy/1618194-adjusttextposition" target="_blank" rel="noopener">adjustTextPositionByCharacterOffset:</a>方法。比如向前删除一个字符，代码如下：</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) deleteForward &#123;</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy adjustTextPositionByCharacterOffset: <span class="number">1</span>];</span><br><span class="line">    [<span class="keyword">self</span>.textDocumentProxy deleteBackward];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过实现<a href="https://developer.apple.com/reference/uikit/uitextinputdelegate" target="_blank" rel="noopener">UITextInputDelegate</a>协议中的方法，可以响应当前输入文本对象的一些变化，比如内容变化以及用户触发的光标位置的变化。</li></ul><p>为了展现与当前文本输入对象适配的键盘布局，需要参照该对象的<a href="https://developer.apple.com/reference/uikit/uikeyboardtype" target="_blank" rel="noopener">UIKeyboardType</a>属性，根据每种你的键盘所能支持的属性，变化布局内容。</p><p><strong>在自定义键盘中，有两种方式来支持多语言：</strong></p><ul><li>为每个语言创建一个键盘，每个键盘都作为向容器app添加的独立的Target</li><li>创建一个多语言键盘，动态切换当前语言。可以使用UIInputViewController类的primaryLanguage属性来动态切换语言。</li></ul><p>根据你要支持的语言数量以及你想提供的用户体验，你可以从上面选择最合适的方案。</p><p>每种自定义键盘（需要RequestsOpenAccess）都可以通过UILexicon类访问自动纠错的词典。通过使用该类，并结合你自己的词典设计，可以在用户输入过程中为他提供输入建议和自动纠错。UILexicon对象包含来自如下源的单词：</p><ul><li>来自用户通讯录的人名和姓</li><li>在 设置 &gt; 通用 &gt; 键盘 &gt; 快捷方式（文本替换） 列表</li><li>通用词典</li></ul><p>你可以使用自动布局来调整你的自定义键盘主视图的高度。默认情况下，自定义键盘会根据屏幕尺寸以及设备方向，和系统键盘的尺寸保持一致。自定义键盘的宽度通常与屏幕当前宽度一致。修改自定义键盘主视图的高度约束即可修改其高度。</p><p>下面的代码展示如何定义和添加约束：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> _expandedHeight = <span class="number">500</span>;</span><br><span class="line"><span class="built_in">NSLayoutConstraint</span> *_heightConstraint = </span><br><span class="line">    [<span class="built_in">NSLayoutConstraint</span> constraintWithItem: <span class="keyword">self</span>.view </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeHeight</span> </span><br><span class="line">                                 relatedBy: <span class="built_in">NSLayoutRelationEqual</span> </span><br><span class="line">                                    toItem: <span class="literal">nil</span> </span><br><span class="line">                                 attribute: <span class="built_in">NSLayoutAttributeNotAnAttribute</span></span><br><span class="line">                                multiplier: <span class="number">0.0</span> </span><br><span class="line">                                  constant: _expandedHeight];</span><br><span class="line">[<span class="keyword">self</span>.view addConstraint: _heightConstraint];</span><br></pre></td></tr></table></figure><h2 id="自定义键盘的开发关键"><a class="markdownIt-Anchor" href="#自定义键盘的开发关键"></a> 自定义键盘的开发关键</h2><p>自定义键盘开发有两个关键点：</p><ul><li>信任。 自定义键盘能访问用户输入的内容 ，因此在键盘和用户间建立信任非常关键。</li><li>“下一个键盘”键。 通过键盘界面必须能让用户能切换到下一个键盘。</li></ul><h3 id="为用户信任所做的设计"><a class="markdownIt-Anchor" href="#为用户信任所做的设计"></a> 为用户信任所做的设计</h3><p>作为自定义键盘的开发者，你首先应当考虑的是如何建立和维护用户信任。你要理解隐私策略的最佳实践并知道如何实现它才能很好地践行。</p><blockquote><p>注意<br>本节为你创建自定义键盘提供相关的开发手册，该手册要求尊重用户隐私。了解iOS编程要求，请阅读应用商店审核手册，iOS人机交互手册，iOS开发许可协议，请参见苹果的<a href="https://developer.apple.com/support/appstore/app-review/" target="_blank" rel="noopener">《应用审核支持》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/ExpectedAppBehaviors/ExpectedAppBehaviors.html#//apple_ref/doc/uid/TP40007072-CH3-SW6" target="_blank" rel="noopener">《支持用户隐私》</a>，<a href="https://developer.apple.com/library/content/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007072" target="_blank" rel="noopener">《iOS应用编程指南》</a>。</p></blockquote><p>对于键盘，如下三个方面对于建立和维护用户信任至关重要：</p><ul><li>按键数据的安全。 用户希望他们的敲键会落在文档以及输入区域内，而不是上传到服务器或者用于其他不明目的。</li><li>最小化合理利用其它用户数据。 如果你的键盘还需要使用其他用户数据，例如定位服务或者通讯录，你有义务解释这给用户带来的好处是什么。</li><li>准确。 把输入事件转换成文本要求精准，这本身虽然不是一个隐私话题，但他会影响到信任：每次文字转换需要体现出你的代码的精准。</li></ul><p>在信任的开发设计过程中，首先考虑的是是否要获取open access权限。尽管开启了open access权限能给自定义键盘开发带来极大便利，但这也增加了你作为开发者的责任。下面是标准的open access的能力和隐私考虑：</p><table><thead><tr><th>Open Access</th><th>能力和限制</th><th>隐私考虑</th></tr></thead><tbody><tr><td>Off(default)</td><td>·键盘可以执行所有基本键盘的职责<br>·可以访问通用词典以支持自动纠错和输入建议<br>·访问设置里的快捷短语<br>·不与containing应用共享容器<br>·不访问键盘容器以外的文件系统<br>·不访问键盘容器以外的文件系统<br>·不能直接或间接访问iCloud或游戏中心或应用内购买</td><td>用户了解按键仅仅被发送到当前使用键盘的应用里</td></tr><tr><td>On</td><td>·具备非联网自定义键盘的所有能力<br>·在用户许可情况下可以访问位置服务和通讯录<br>·键盘和containing app可以访问共享容器<br>·键盘可以为服务器侧处理过程发送按键或其他输入事件<br>·containing app自动纠错字典提供编辑界面<br>·通过containing app键盘可以使用iCloud来保证自动纠错词典和设置的更新<br>·通过containing app，键盘可以参与到游戏中心和应用内购买<br>·如果键盘支持移动设备管理(MDM)，它可与被管理的应用共同工作</td><td>·用户了解键盘开发者会利用按键数据<br>·你必须遵守有联网能力的键盘开发手册和iOS开发许可协议，可参见《应用审核支持》</td></tr></tbody></table><p>如果你的自定义键盘不需要open access权限，系统确保敲键信息不会被发送给你的键盘以及别的地方。如果只想提供一般的键盘功能，请不要给键盘配备联网能力。由于有沙盒限制，不联网的键盘一定是满足苹果的数据隐私手册并能获得用户信任的。</p><p>开启open access权限（如上所述，可以在Info.plist文件中配置），能给你的开发带来更多可能性，同时也带来更多的责任。</p><blockquote><p>注意<br>向应用商店提交一个open-access的键盘必须遵守苹果《应用审核支持》中的相关条款。</p></blockquote><p>每一个与open access相关的功能都需要你履行相应的责任，应当最大限度地尊重用户数据，不得用于与用户输入无关的其他任何目的。下表列出了open access带来的好处以及开发者需承担的责任：</p><table><thead><tr><th>能力</th><th>用户利益示例</th><th>开发者责任</th></tr></thead><tbody><tr><td>与containing app共享容器</td><td>为键盘的自动纠错词典管理UI界面</td><td>要考虑到自动纠错数据属于用户隐私。不要把他发到你的服务器，用作与输入无关的用途。</td></tr><tr><td>把按键数据发到你的服务器</td><td>通过开发者的计算资源可以提供更好的按键处理结果和输入预测</td><td>只有为用户提供更好的输入体验之用时，才能保存按键和语音数据</td></tr><tr><td>基于云的自动纠错词典</td><td>把人名、地名、热点新闻加入到自动纠错词典中</td><td>不要把用户身份与输入数据关联起来，不得将用户信息用作与输入体验无关的其他目的</td></tr><tr><td>通讯录</td><td>把人名、地名、电话号码添加到自动纠错词典中</td><td>不得讲通讯录用作与输入体验无关的其他目的</td></tr><tr><td>位置服务</td><td>将附近的地名添加到自动纠错词典中</td><td>不要在后台使用位置服务，不得将位置信息发送到你的服务器并用于与输入体验无关的其他目的</td></tr></tbody></table><p>一个具有open-access权限的键盘和其containing app能将按键数据发送到服务器端，通过这些数据可以为用户提供更好的输入体验。如果你使用了这些能力，当不需要这些数据的时候，请及时在服务器端删除。参见上面的表格来履行你使用open-access权限中的义务。</p><h3 id="提供切换到其他键盘的方法"><a class="markdownIt-Anchor" href="#提供切换到其他键盘的方法"></a> 提供切换到其他键盘的方法</h3><p>系统键盘的小地球按键用于切换到其他键盘：<br><img src="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/Art/globe_key_2x.png" alt="The system keyboard’s Globe key"></p><p>你的自定义键盘必须提供类似的机制能切换到其他键盘。</p><p>调用UIInputViewController类的<a href="https://developer.apple.com/reference/uikit/uiinputviewcontroller/1618191-advancetonextinputmode" target="_blank" rel="noopener">advanceToNextInputMode</a>方法可以切换到其他键盘。系统会选择下一个键盘，没有能获得键盘列表的API，也没有切换到指定键盘的API。</p><p>Xcode自定义键盘模板中就已经在下一个键盘按钮上具备了advanceToNextInputMode的功能。为了提供最好的用户体验，应当把你的下一个键盘按键放在靠近系统键盘的小地球键的位置。</p><blockquote><p>注意<br>要通过应用审核，必须在你的键盘上提供明显允许用户切换键盘的UI标识。</p></blockquote><h2 id="开始自定义键盘的开发"><a class="markdownIt-Anchor" href="#开始自定义键盘的开发"></a> 开始自定义键盘的开发</h2><h3 id="使用xcode自定义键盘模板"><a class="markdownIt-Anchor" href="#使用xcode自定义键盘模板"></a> 使用Xcode自定义键盘模板</h3><p>创建键盘及其containing app与其他扩展应用略有不同。本节将带你领略基本键盘的开发和运行。</p><p><strong>在一个容器app中创建键盘，步骤如下</strong></p><ol><li>在Xcode中选择File &gt; New &gt; Project &gt; iOS &gt; Application选择Single View Application模板。</li><li>点击Next。</li><li>填写Project Name（如CKIme），点击Next。</li><li>选择要保存的位置，点击Create。这样，你就有了一个空app，该app只能完成一个简单的操作，接下来它将承载键盘。在你提交到应用商店之前，你需要完成一些有用的功能。请到应用审核支持参考应用商店审核指南。</li><li>选择File &gt; New &gt; Target &gt; iOS &gt; Application Extension选择Custom Keyboard Extension，点击Next。</li><li>填写Product Name（如CKbd），点击Finish。</li><li>确认Project和Embed in Application中都显示的是容器app的名字（CKIme），点击Finish。如果弹出Activate “CKbd” scheme提示让激活键盘工程，点击Activate。</li></ol><p><strong>定义键盘group name，步骤如下：</strong></p><ol><li>在Xcode工程导航视图中，选择容器app的Info.plist文件，</li><li>在右侧plist编辑器中，鼠标hover到Bundle name上，点“+”按钮创建一行空属性。</li><li>在Key中填写Bundle display name，回车</li><li>双击该行的Value，填写你要自定义的键盘group name。</li><li>选择File &gt; Save保存设置。</li></ol><p>下表汇总了在容器app和键盘app的Info.plist文件中你可以配置的UI字符串：</p><table><thead><tr><th>iOS UI字符串</th><th>Info.plist关键字</th></tr></thead><tbody><tr><td>· 在系统设置的已购键盘列表中的键盘group name</td><td>在容器app的Info.plist文件中的Bundle display name</td></tr><tr><td>· 系统设置中的键盘名称<br>· 键盘换列表中的键盘名称</td><td>在键盘app的Info.plist文件中的Bundle display name</td></tr></tbody></table><p><strong>运行自定义键盘并将Xcode调试器attach到它上面</strong></p><ol><li>在Xcode，你的view controller实现中设置一个断点（比如可以断在viewDidLoad上）。</li><li>在Xcode工具栏确保当前活动的项目为键盘项目，并对应iOS模拟器或设备。</li><li>选择菜单Project &gt; Run，或点击Build and then run the current scheme按钮（即播放按钮）。Xcode会提示选择host app。选择一个带有输入框的，比如通讯录或Safari。</li><li>点击Run。Xcode将运行起你指定的host app。如果这是你第一次使用键盘扩展应用，需要现在设置中添加并启用键盘：<ol><li>Settings &gt; General &gt; Keyboard &gt; Keyboards</li><li>点击Add New Keyboard…</li><li>在OTHER IPHONE KEYBOARDS中点击你刚刚创建的键盘</li></ol></li><li>在iOS模拟器或真机上，调出你的自定义键盘。<br>点击任意可输入区域，将显示出系统键盘。按住小地球，选择你的自定义键盘。<br>此时你将看到自定义键盘，但是调试器尚未attach上来。一个从模板构建而来的极简键盘仅有一个Next Keyboard按钮，点击后切换回前一个键盘。</li><li>取消你的键盘（以便在第8步中你可以再次调出键盘以命中viewDidLoad断点）</li><li>在Xcode中，选择Debug &gt; Attach to Process &gt; By Process Identifier(PID) or Name 在弹出对话框中，输入你的键盘扩展应用的名字（包含空格）.默认就是该扩展应用在工程导航窗口里的group name。</li><li>点击Attach。Xcode将显示出等待attach的调试器。</li><li>在任意能输入文字的app中调出键盘。<br>当你的键盘主视图开始加载时，Xcode调试器将attache到你的键盘，并命中断点。</li></ol><h3 id="为自定义键盘配置infoplist文件"><a class="markdownIt-Anchor" href="#为自定义键盘配置infoplist文件"></a> 为自定义键盘配置Info.plist文件</h3><p>自定义键盘的Info.plist文件允许静态定义键盘的现式特征，包括主要语言，以及是否需要open access权限。</p><p>打开Xcode并切换到自定义键盘的 target。在工程导航栏选择Info.plist文件，按文本格式呈现如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtension<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionAttributes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>IsASCIICapable<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrefersRightToLeft<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PrimaryLanguage<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>en-US<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>RequestsOpenAccess<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPointIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.keyboard-service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExtensionPrincipalClass<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span>&gt;</span>KeyboardViewController<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个关键字在App Extension Keys中都有解释。可以使用字典NSExtensionAttributes中的关键字来描述你的自定义键盘的特征和需求，如下：</p><p><code>IsASCIICapable</code> - 默认为NO的布尔值。用户键盘是否可以向文档中插入ASCII字串。如果要为<code>UIKeyboardTypeASCIICapable</code>属性的输入对象展现单独类型的键盘，需要将该值置为YES。</p><p><code>PrefersRightToLeft</code> - 默认为NO的布尔值。是否为从右到左的语种设计的的自定义键盘。</p><p><code>PrimaryLanguage</code> - 默认为en-US的字串。以&lt;语种&gt;-&lt;区域&gt;的形式描述键盘的主语言。可以到http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c找到对应的语种和区域。</p><p><code>RequestsOpenAccess</code> - 默认为NO的布尔值。是否需要比基础键盘更大的沙盒范围。把该值置为YES将需要完全访问权限，你的键盘将获得如下能力，每个能力都伴随有相应的权限：</p><ul><li>访问定位服务，通讯录数据库，相机，每个都需要用户允许</li><li>与键盘的容器app共享容器数据，以便完成比如在容器app中管理用户词库的界面的功能</li><li>通过网络发送按键、输入事件之类的数据供云端处理</li><li>使用UIPasteboard类</li><li>播放音频，包括使用playInputClick方法播放按键音</li><li>访问iCloud，可以用来根据用户身份同步比如键盘设置、自定义自动纠错词典</li><li>通过容器app访问游戏中心和应用内购买</li><li>如果你的键盘支持移动设备管理（MDM），可以与被管理的app无缝合作</li></ul><p>当考虑是否将这些关键字设置为YES之前，一定要先阅读<a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ExtensibilityPG/CustomKeyboard.html#//apple_ref/doc/uid/TP40014214-CH16-SW3" target="_blank" rel="noopener">《用户信任设计》</a>，这里描述了如何尊重和保护用户数据。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="AppExtensions" scheme="https://changzw.github.io/categories/iOS-Programming/AppExtensions/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>runloop 实践相关</title>
    <link href="https://changzw.github.io/2019/12/29/runloop/runloop-%E5%AE%9E%E8%B7%B5%E7%9B%B8%E5%85%B3/"/>
    <id>https://changzw.github.io/2019/12/29/runloop/runloop-%E5%AE%9E%E8%B7%B5%E7%9B%B8%E5%85%B3/</id>
    <published>2019-12-29T11:00:54.000Z</published>
    <updated>2020-05-29T04:54:34.402Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:12 GMT+0800 (CST) --><a id="more"></a><p>RunLoop 是系统层级上的设计，用来给管理系统消息队列派发，那我们都可以用 runLoop 做什么呢？<br>简单来说，RunLoop 是用来监听输入源，进行调度处理的。</p><p>RunLoop 输入源可以是：</p><ul><li>输入设备</li><li>网络</li><li>周期性或者延迟时间</li><li>异步回调</li></ul><p><img src="/img/runloop_core.jpeg" alt="runloop activities"></p><p>runloop 的 observer 可以监听的 7中状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">  kCFRunLoopEntry ,         <span class="comment">// 进入 loop</span></span><br><span class="line">  kCFRunLoopBeforeTimers ,  <span class="comment">// 触发 Timer 之前</span></span><br><span class="line">  kCFRunLoopBeforeSources , <span class="comment">// 触发 Source0 之前</span></span><br><span class="line">  kCFRunLoopBeforeWaiting , <span class="comment">// 等待 mach_port 消息（等待源Source和计时器Timer之前，进入睡眠）</span></span><br><span class="line">  <span class="comment">// 在这两个状态中真正处理事件</span></span><br><span class="line">  kCFRunLoopAfterWaiting ), <span class="comment">// 接收 mach_port 消息（等待源Source和计时器Timer后，同时在被唤醒之前）</span></span><br><span class="line">  kCFRunLoopExit , <span class="comment">// 退出 loop</span></span><br><span class="line">  kCFRunLoopAllActivities  <span class="comment">// loop 所有状态改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="检测-ios-app-卡顿"><a class="markdownIt-Anchor" href="#检测-ios-app-卡顿"></a> 检测 iOS App 卡顿</h2><h3 id="思路分析"><a class="markdownIt-Anchor" href="#思路分析"></a> 思路分析</h3><h4 id="卡顿如何造成的"><a class="markdownIt-Anchor" href="#卡顿如何造成的"></a> 卡顿如何造成的</h4><p>iOS系统页面刷新频率：60 FPS，60次/s, <code>let refresh_time_per = 1s/60 &lt; 0.02</code><br>如果在 <code>refresh_time_per</code> 时间内没有完成图片绘制，那么就会出现卡顿现象！<br>而系统页面刷新事件处理…… 事件几乎都是由 runloop 调用执行的。<br>那么如果 runloop 一次循环时间 &gt; <code>refresh_time_per</code> 就说明图片没有渲染完成，导致卡顿。</p><p>问题来了，如何判断 runloop 一次循环时间 &gt; <code>refresh_time_per</code> 呢？</p><p>RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。</p><p>所以要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。<br>RunLoop 的两个 loop 状态<br>在进入睡眠之前: kCFRunLoopBeforeSources<br>在进入唤醒之后: kCFRunLoopAfterWaiting<br>也就是要触发 Source0 回调和接收 mach_port 消息两个状态。</p><details><summary>runloop 核心源码</summary><pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// while</span></span><br><span class="line"><span class="comment">// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line"><span class="comment">// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line"><span class="comment">// 执行被加入的block</span></span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line"><span class="comment">// 执行被加入的block</span></span><br><span class="line">__CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line"><span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">  Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">  <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line"><span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">  __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line"><span class="comment">// • 一个基于 port 的Source 的事件。</span></span><br><span class="line"><span class="comment">// • 一个 Timer 到时间了</span></span><br><span class="line"><span class="comment">// • RunLoop 自身的超时时间到了</span></span><br><span class="line"><span class="comment">// • 被其他什么调用者手动唤醒</span></span><br><span class="line">__CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">  mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 收到消息，处理消息。</span></span><br><span class="line">handle_msg:</span><br><span class="line">      <span class="comment">// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line"><span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">  __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">  __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">  sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">  <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  退出 runloop 逻辑 retVal != 0 exit</span></span><br><span class="line"><span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">  <span class="comment">// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">  retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">  <span class="comment">// 超出传入参数标记的超时时间了</span></span><br><span class="line">  retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">  <span class="comment">// 被外部调用者强制停止了</span></span><br><span class="line">  retVal = kCFRunLoopRunStopped;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">  <span class="comment">// source/timer/observer一个都没有了</span></span><br><span class="line">  retVal = kCFRunLoopRunFinished;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></pre></details><h3 id="卡顿监听实践"><a class="markdownIt-Anchor" href="#卡顿监听实践"></a> 卡顿监听实践</h3><ol><li>创建 runloop 的observer对象:</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weakSelf = <span class="type">Unmanaged</span>&lt;<span class="type">Monitor</span>&gt;.passUnretained(<span class="keyword">self</span>).toOpaque()</span><br><span class="line"><span class="keyword">var</span> ctx: <span class="type">CFRunLoopObserverContext</span> = <span class="type">CFRunLoopObserverContext</span>(version: <span class="number">0</span>, weakSelf: info, retain: <span class="literal">nil</span>, release: <span class="literal">nil</span>, copyDescription: <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">self</span>.runLoopObserver = <span class="type">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.allActivities.rawValue, <span class="literal">true</span>, <span class="number">0</span>, runLoopCallBack(), &amp;ctx)</span><br></pre></td></tr></table></figure><ol start="2"><li>将 observer 添加到 runloop 的 commonModes 中</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CFRunLoopAddObserver</span>(<span class="type">CFRunLoopGetCurrent</span>(), <span class="keyword">self</span>.runLoopObserver, <span class="type">CFRunLoopMode</span>.commonModes)</span><br></pre></td></tr></table></figure><ol start="3"><li>创建子线程，监听runloop的状态<ul><li>beforeSources: 进入睡眠前</li><li>afterWaiting: 唤醒后的状态</li><li>设置卡顿阀值</li><li>打印堆栈信息</li></ul></li></ol><p>为什么要监听 beforeSources 和 afterWaiting 这两个状态呢？<br>因为只有这两个状态 runloop 触发事件回调，如果runloop 长时间处于这两个状态中说明卡顿！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DispatchQueue</span>.global().async &#123;</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> sem = <span class="keyword">self</span>.dispatchSemaphore?.wait(timeout: <span class="type">DispatchTime</span>.now() + <span class="number">1</span> / <span class="number">50</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">case</span> <span class="type">DispatchTimeoutResult</span>.timedOut = sem &#123;</span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.runLoopObserver <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.dispatchSemaphore = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">self</span>.runLoopActivity = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>.runLoopActivity == <span class="type">CFRunLoopActivity</span>.beforeSources || <span class="keyword">self</span>.runLoopActivity == <span class="type">CFRunLoopActivity</span>.afterWaiting) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"symbo: \(Thread.callStackSymbols)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"打印卡顿堆栈..."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何获取卡顿的方法堆栈信息"><a class="markdownIt-Anchor" href="#如何获取卡顿的方法堆栈信息"></a> 如何获取卡顿的方法堆栈信息？</h3><h4 id="直接调用系统函数获取"><a class="markdownIt-Anchor" href="#直接调用系统函数获取"></a> 直接调用系统函数获取</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signals[] = &#123;</span><br><span class="line">  SIGABRT,</span><br><span class="line">  SIGBUS,</span><br><span class="line">  SIGFPE,</span><br><span class="line">  SIGILL,</span><br><span class="line">  SIGSEGV,</span><br><span class="line">  SIGTRAP,</span><br><span class="line">  SIGTERM,</span><br><span class="line">  SIGKILL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> s_fatal_signal_num = <span class="keyword">sizeof</span>(s_fatal_signals) / <span class="keyword">sizeof</span>(s_fatal_signals[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> UncaughtExceptionHandler(<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">  <span class="built_in">NSArray</span> *exceptionArray = [exception callStackSymbols]; <span class="comment">// 得到当前调用栈信息</span></span><br><span class="line">  <span class="built_in">NSString</span> *exceptionReason = [exception reason];     <span class="comment">// 非常重要，就是崩溃的原因</span></span><br><span class="line">  <span class="built_in">NSString</span> *exceptionName = [exception name];       <span class="comment">// 异常类型</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> SignalHandler(<span class="keyword">int</span> code) &#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"signal handler = %d"</span>,code);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> InitCrashReport() &#123;</span><br><span class="line">  <span class="comment">// 系统错误信号捕获</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s_fatal_signal_num; ++i) &#123;</span><br><span class="line">    signal(s_fatal_signals[i], SignalHandler);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//oc 未捕获异常的捕获</span></span><br><span class="line">  <span class="built_in">NSSetUncaughtExceptionHandler</span>(&amp;UncaughtExceptionHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">  <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    InitCrashReport();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br></pre></td></tr></table></figure><h4 id="第三方库来获取堆栈信息"><a class="markdownIt-Anchor" href="#第三方库来获取堆栈信息"></a> 第三方库来获取堆栈信息</h4><p><a href="https://opensource.plausible.coop/src/projects/PLCR/repos/plcrashreporter/browse" target="_blank" rel="noopener">PLCrashReporter</a></p><h2 id="利用runloop空闲时间"><a class="markdownIt-Anchor" href="#利用runloop空闲时间"></a> 利用RunLoop空闲时间</h2><p>卡顿是因为 runloop 一次时间 &gt; 1/60s<br>那么如果 runloop 一次运行时间 &lt; 1/60s 呢？<br>譬如你把手机放在那看着 app，runloop 在那睡觉(<code>kCFRunLoopBeforeWaiting</code>)</p><p>这个时候往 runloop 里面放个 source or timer，runloop 就会醒来 进入 <code>kCFRunLoopAfterWaiting</code> 状态</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">BeforeWaitingDo</span> = () -&gt; ()</span><br><span class="line"><span class="keyword">var</span> tasks: [<span class="type">BeforeWaitingDo</span>] = []</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">exec</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> t = <span class="keyword">self</span>.tasks.remove(at: <span class="number">0</span>)</span><br><span class="line">  t()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">registerObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> rl = <span class="type">CFRunLoopGetCurrent</span>()</span><br><span class="line">  <span class="keyword">let</span> observer = <span class="type">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, <span class="type">CFRunLoopActivity</span>.beforeWaiting.rawValue, <span class="literal">true</span>, <span class="number">0</span>) &#123;[<span class="keyword">weak</span> <span class="keyword">self</span>] (observer, actives) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">self</span> = <span class="keyword">self</span>,</span><br><span class="line">    <span class="keyword">let</span> <span class="number">_</span> = <span class="keyword">self</span>.tasks.first <span class="keyword">else</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">    <span class="comment">// 创建一个 source0 把 runloop 被叫醒</span></span><br><span class="line">    <span class="keyword">self</span>.perform(#selector(<span class="type">ChatEmojiViewController</span>.exec), on: <span class="type">Thread</span>.current, with: <span class="literal">nil</span>, waitUntilDone: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">CFRunLoopAddObserver</span>(rl, observer, <span class="type">CFRunLoopMode</span>.commonModes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Ftime.geekbang.org%2Fcolumn%2Fintro%2F161%3Fcode%3DQjb1JtJcvAPISj9QjxdKrAmeXmURMroQbkOcLNm0jeY%253D%26from%3Dsinglemessage%26isappinstalled%3D0" target="_blank" rel="noopener">《iOS开发高手课》</a><br><a href="https://www.jianshu.com/p/632d7a1526e9" target="_blank" rel="noopener">iOS 性能监控（二）—— 主线程卡顿监控</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:12 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="runloop" scheme="https://changzw.github.io/categories/iOS-Programming/runloop/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="底层" scheme="https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>调试内存不足问题：使用运行时魔法捕获布局反馈循环</title>
    <link href="https://changzw.github.io/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/"/>
    <id>https://changzw.github.io/2019/12/01/performance/%E8%B0%83%E8%AF%95%E5%86%85%E5%AD%98%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E9%AD%94%E6%B3%95%E6%8D%95%E8%8E%B7%E5%B8%83%E5%B1%80%E5%8F%8D%E9%A6%88%E5%BE%AA%E7%8E%AF/</id>
    <published>2019-11-30T23:25:43.000Z</published>
    <updated>2020-04-25T02:55:55.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><p>目标：<br>使用代码替代 <code>UIViewLayoutFeedbackLoopDebuggingThreshold</code> 符号调试，来捕获 Autolayout反馈循环所导致的内存不足问题。</p><h2 id="导致内存不足的原因"><a class="markdownIt-Anchor" href="#导致内存不足的原因"></a> 导致内存不足的原因</h2><p>如果 App，开始有大量日活用户并且崩溃率很低，但是过段时间，总会出现崩溃问题，检查 Fabric 也没啥用。</p><p>出现这种情况很可能是因为，内存不足，导致应用被系统终止。</p><p>导致内存不足的原因：</p><ul><li>循环引用;</li><li>竞争条件;</li><li>废弃的线程;</li><li>死锁;</li><li>布局反馈循环。</li></ul><p>Apple 提供了很多方法来解决这类问题：</p><ul><li>Instruments 里的 Allocations 和 Leaks 工具用于解决循环引用和 <a href="https://developer.apple.com/videos/play/wwdc2015/230/" target="_blank" rel="noopener">其他类型的泄漏</a></li><li>在 Xcode 8 中引入的 <a href="https://developer.apple.com/videos/play/wwdc2016/410/" target="_blank" rel="noopener">Memory Debugger</a> 代替了 Allocations 和 Leaks 的一部分功能</li><li><a href="https://developer.apple.com/videos/play/wwdc2016/412/" target="_blank" rel="noopener">Thread Sanitizer</a> 帮助你找到竞争条件、废弃的线程或者死锁</li></ul><h2 id="布局反馈循环"><a class="markdownIt-Anchor" href="#布局反馈循环"></a> 布局反馈循环</h2><blockquote><p>当视图正在运行它们的布局代码，但某种方法导致它们再一次开始布局传递，此时布局反馈循环就会出现。这可能是因为某个视图正在改变某个父视图的大小，或者因为你有一个模棱两可的布局。无论哪种原因，这个问题的表现是你的 CPU 使用被占满和 RAM 使用量稳步上升，因为你的视图正在一次又一次地运行它们的布局代码，却没有返回。<br>-来自<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">HackingWithSwift 的 Paul Hudson</a></p></blockquote><p>在 WWDC 16 中 Apple 介绍了“布局反馈循环调试器”。这个调试器有助于识别在调试过程中发生循环的时间点。这就是一个符号断点，它的工作方式非常简单：它会计算在单个 run loop 迭代中调用每个视图上的 <font color="red">layoutSubviews()</font> 方法的次数。一旦这个计数值超过某个临界值（比如，100），这个应用程序将会停在这个断点并打印出日志。<a href="https://www.hackingwithswift.com/articles/59/debugging-auto-layout-feedback-loops" target="_blank" rel="noopener">这篇文章</a> 快速地介绍如何使用这个调试器。</p><p>这个方法在可以重现问题的情况下十分有效。但是在线上出现就不用容易调试。但是你可以尝试把 <font color="red">UIViewLayoutFeedbackLoopDebuggingThreshold</font> 的代码复制到生产代码中。</p><h3 id="如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"><a class="markdownIt-Anchor" href="#如何用代码实现-uiviewlayoutfeedbackloopdebuggingthreshold-的功能呢"></a> 如何用代码实现 UIViewLayoutFeedbackLoopDebuggingThreshold 的功能呢</h3><p>符号断点是如何工作的：它会计算 layoutSubviews() 的调用次数并在单个 run loop 迭代中超过某个临界值时发送一个事件。听起来很简单，对吧？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrackableView</span>: <span class="title">UIView</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> counter: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="type">YourAnalyticsFramework</span>.event(name: <span class="string">"loop"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于一个视图，这段代码运行正常。</li><li>但是现在你想要在另一个视图上实现它。当然，你可以创建一个 UIView 的子类，在这里实现它并使你项目中的所有视图都继承这个子类。</li><li>然后为 UITableView，UIScrollView，UIStackView 等做同样的事情。</li></ol><p>如果将此逻辑注入你想要的任何类，而无需编写大量重复的代码。这时候就可以 <code>借助运行时编程</code> 了。</p><h3 id="使用-runtime-实现子类"><a class="markdownIt-Anchor" href="#使用-runtime-实现子类"></a> 使用 runtime 实现子类</h3><p>我们会做同样的事情——创建一个子类，重写 layoutSubviews() 方法并计算其调用次数。唯一的区别是所有这些都使用 runtime 完成，而不是在项目中创建重复的类。</p><p><strong>创建自定义子类</strong>，并将原始视图的类更改为新的子类：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>objc_allocateClassPair() 方法的文档告诉我们这个方法何时失败：</li></ol><blockquote><p>新类，或者如果无法创建类，则为 Nil （例如，所需名称已被使用）。</p></blockquote><p>这就意味着不能拥有两个同名的类。我们的策略是为单个视图类创建一个单独的运行时类。这就是我们在原始类名前加上前缀来形成新类的名称的原因。</p><ol start="2"><li>现在添加一个计数器到子类中。理论上，有两种方法可以做到这一点。</li><li>添加一个保存计数器的属性。</li><li>为这个类创建一个关联对象（Associated object）。</li></ol><p>但是目前，只有一个方法奏效。你可以想象属性是存储在分配给类的内存里的东西，然而关联对象则储存在一个完全不同的地方。因为分配给已存在对象的内存是固定的，所以我们<font color="red">在自定义类上新添加的属性将会从其他资源里“窃取”内存</font>。它可能导致意料之外的行为和难以调试的程序崩溃（点击 <a href="https://stackoverflow.com/questions/3346427/object-setclass-to-bigger-class" target="_blank" rel="noopener">这里</a> 查看更多信息）。但是在使用关联对象的情况下，它们将会存储在运行时创建的一个哈希表里，这是完全安全的。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = <span class="string">"_counter"</span></span><br><span class="line">...</span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>当新的子类被创建时，计数器初值设置为 0。</p><p><strong>实现这个新的layoutSubviews() 方法，并将它添加到我们的类中</strong>：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">      onLoop()</span><br><span class="line">    &#125;</span><br><span class="line">    objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>为了理解上面这段代码实际上在干什么，让我们看一下这个来自 &lt;objc/runtime.h&gt; 的结构体：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method</span> </span>&#123;</span><br><span class="line">  <span class="type">SEL</span> method_name;</span><br><span class="line">  char *method_types;</span><br><span class="line">  <span class="type">IMP</span> method_imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法实际上是由什么组成的：</p><ul><li>方法的实现 method_imp，这是调用方法时要执行的实际函数。它的前两个形参总是方法接收者和消息选择器。</li><li>包含方法签名的方法类型字符串 method_types。你可以在 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">这里</a> 详细了解其格式。但是在现在的情况下，需要明确说明的字符串是 “v@:”。作为返回类型，v 代表 void，而 @ 和 : 分别代表接收者和消息选择器。</li><li>选择器 method_name 作为键，用于在运行时查找方法的实现。</li></ul><p>你可以把 Witness Table（在其他编程语言中，它也被称作方法派发表）想象成一个简单的字典数据结构。那么选择器为键，且实现部分则为对应的值。<br>在下面这行代码中:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_addMethod(trackableClass,#selector(originalClass.layoutSubviews), implementation, <span class="string">"v@:"</span>)</span><br></pre></td></tr></table></figure><p>我们所做的是给 layoutSubviews() 方法对应的键分配新值。</p><p>这个方法直截了当。我们获得这个计数器，使它的计数值加一。如果计数值超过临界值，我们会发送分析事件，其中包含类名和想要的任何数据体。</p><p>让我们回顾一下如何对关联对象实现和使用键：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line">objc_setAssociatedObject(trackableClass, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>为什么我们使用 var 来修饰计数器的键这个静态属性并在传递到其他地方时使用引用？答案隐藏在 Swift 语言基础——字符串之中。字符串像其他所有的值类型一样，是按值传递的。那么，当你把它传入这个闭包时，这个字符串将会被复制到一个不同的地址，这会导致在关联对象表中产生一个完全不同的键。&amp; 符号总是保证将相同的地址作为键参数的值。你可以尝试以下代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printAddress</span><span class="params">(<span class="number">_</span> string: UnsafeRawPointer)</span></span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(string)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line">printAddress(str)</span><br><span class="line">printAddress(str)</span><br><span class="line"><span class="keyword">let</span> closure = &#123;</span><br><span class="line">  printAddress(str)</span><br><span class="line">  printAddress(str)</span><br><span class="line">&#125;</span><br><span class="line">closure()</span><br><span class="line"><span class="comment">// 最后两个函数调用的地址将始终不同</span></span><br></pre></td></tr></table></figure><p>用引用的方式来传递键的主意总是好的，因为有时，即使你没有使用闭包，变量的地址仍可能因内存管理而更改。在我们例子中，如果你把上面的代码运行多次，即使是前两个 printAddress() 的调用也可能会输出不同的地址。</p><p>让我们回到运行时的魔法里来。在新 layoutSubviews() 的实现里，还有一件很重要的事情没有完成。这件事是每次重写父类的方法时通常都会做的事情——调用父类实现。layoutSubviews() 的文档里提到：</p><blockquote><p>在 iOS 5.1 及更早版本中，这个方法的默认实现不执行任何操作。而之后的默认实现会使用你设置的任何约束来确定任何子视图的大小和位置。</p></blockquote><p>为了避免发生一些难以预料的布局行为，我们得调用父类的实现，但这不像平常那样简单明了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line"><span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line"><span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line"><span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line"><span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line"><span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">originalLayoutSubviews(view, selector)</span><br></pre></td></tr></table></figure><p>这里实际发生的是：我们检索方法所需的实现部分，并直接从代码中调用它，而不是用常见的方式来调用方法（即执行一个会在 Witness Table 中寻找对应实现的选择器）。</p><p>目前为止，让我们看看实现部分：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">  <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称</span></span><br><span class="line">  <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">  <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 在当前运行时会话期间尚未创建此类</span></span><br><span class="line">    <span class="comment">// 注册这个类并将其与原始视图的类交换</span></span><br><span class="line">    objc_registerClassPair(trackableClass)</span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">    objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">    <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">      <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">      <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">      <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">      <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">      <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">      originalLayoutSubviews(view, selector)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">          onLoop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">    class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">    <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类</span></span><br><span class="line">    <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换</span></span><br><span class="line">    object_setClass(view, trackableClass)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们为视图创建模拟布局循环，并为其设置计数器来进行测试：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"> </span><br><span class="line">    <span class="type">LayoutLoopHunter</span>.setUp(<span class="keyword">for</span>: view) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"Hello, world"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLayoutSubviews</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLayoutSubviews()</span><br><span class="line">    view.setNeedsLayout() <span class="comment">// loop creation</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是忘记了什么事情？让我们再次回顾一下 UIViewLayoutFeedbackLoopDebuggingThreshold 断点的工作原理：</p><blockquote><p>在确认为反馈循环之前，定义某个视图的子视图在单个 run loop 里必须布局的次数</p></blockquote><p>我们从未把“单个 run loop ”这一条件考虑进来。如果视图在屏幕上停留了相当长的时间，并经常被反复布局，计数器迟早会超过临界值。但这可不是因为内存的问题。</p><p>我们该怎么解决这个问题呢？只需在每次 run loop 迭代时重置计数器。为了做到这一点，我们可以创建一个 <a href="https://www.appcoda.com/grand-central-dispatch/" target="_blank" rel="noopener">DispatchWorkItem</a>，它重置计数器，并在主队列上异步传递它。通过这种方式，它会在 run loop 下一次进入主线程时被调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">  previousResetWorkItem.cancel()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> currentResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">  objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">DispatchQueue</span>.main.async(execute: currentResetWorkItem)</span><br><span class="line">objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, currentResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br></pre></td></tr></table></figure><p>最终的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LayoutLoopHunter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">RuntimeConstants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> <span class="type">Prefix</span> = “runtime”</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Associated objects keys</span></span><br><span class="line">    <span class="comment">// 关联对象键</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">CounterKey</span> = “_counter”</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> <span class="type">ResetWorkItemKey</span> = “_resetWorkItem”</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">setUp</span><span class="params">(<span class="keyword">for</span> view: UIView, threshold: Int = <span class="number">100</span>, onLoop: @escaping <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    <span class="comment">// 我们根据功能的前缀和原始类名为新类创建名称。</span></span><br><span class="line">    <span class="keyword">let</span> classFullName = “\(<span class="type">RuntimeConstants</span>.<span class="type">Prefix</span>)<span class="number">_</span>\(<span class="type">String</span>(describing: view.<span class="keyword">self</span>))”</span><br><span class="line">    <span class="keyword">let</span> originalClass = type(of: view)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = objc_allocateClassPair(originalClass, classFullName, <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 在当前运行时会话期间尚未创建此类。</span></span><br><span class="line">      <span class="comment">// 注册这个类，并且用原始视图的类来和它交换。</span></span><br><span class="line">      objc_registerClassPair(trackableClass)</span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 现在可以创建关联对象</span></span><br><span class="line">      objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 添加我们自己 layoutSubviews 的实现</span></span><br><span class="line">      <span class="keyword">let</span> layoutSubviews: <span class="meta">@convention</span>(block) (<span class="type">Any?</span>) -&gt; () = &#123; nullableSelf <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> _self = nullableSelf <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> selector = #selector(originalClass.layoutSubviews)</span><br><span class="line">        <span class="keyword">let</span> originalImpl = class_getMethodImplementation(originalClass, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）</span></span><br><span class="line">        <span class="comment">// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数</span></span><br><span class="line">        <span class="comment">// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符</span></span><br><span class="line">        <span class="keyword">typealias</span> <span class="type">ObjCVoidVoidFn</span> = <span class="meta">@convention</span>(<span class="built_in">c</span>) (<span class="type">Any</span>, <span class="type">Selector</span>) -&gt; <span class="type">Void</span></span><br><span class="line">        <span class="keyword">let</span> originalLayoutSubviews = <span class="built_in">unsafeBitCast</span>(originalImpl, to: <span class="type">ObjCVoidVoidFn</span>.<span class="keyword">self</span>)</span><br><span class="line">        originalLayoutSubviews(view, selector)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> counter = objc_getAssociatedObject(_self, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> counter == threshold &#123;</span><br><span class="line">            onLoop()</span><br><span class="line">          &#125;</span><br><span class="line"> </span><br><span class="line">          objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, counter+<span class="number">1</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 为重置计数器，在每个新的 run loop 遍历中分发 work item</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> previousResetWorkItem = objc_getAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>) <span class="keyword">as</span>? <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">          previousResetWorkItem.cancel()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> counterResetWorkItem = <span class="type">DispatchWorkItem</span> &#123; [<span class="keyword">weak</span> view] <span class="keyword">in</span></span><br><span class="line">          <span class="keyword">guard</span> <span class="keyword">let</span> strongView = view <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">          objc_setAssociatedObject(strongView, &amp;<span class="type">RuntimeConstants</span>.<span class="type">CounterKey</span>, <span class="number">0</span>, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async(execute: counterResetWorkItem)</span><br><span class="line">        objc_setAssociatedObject(view, &amp;<span class="type">RuntimeConstants</span>.<span class="type">ResetWorkItemKey</span>, counterResetWorkItem, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> implementation = imp_implementationWithBlock(layoutSubviews)</span><br><span class="line">      class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> trackableClass = <span class="type">NSClassFromString</span>(classFullName) &#123;</span><br><span class="line">      <span class="comment">// 我们之前在此运行时会话中分配了一个具有相同名称的类。</span></span><br><span class="line">      <span class="comment">// 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。</span></span><br><span class="line">      object_setClass(view, trackableClass)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2><p>是的！现在你可以为所有可疑的视图设置分析事件了，发布应用程序，并找到这个问题的确切出处。你可以把这个问题的范围缩小到某个特定的视图，并在用户不知情的情况下借助于他们来解决这个问题。</p><p>最后要提到的一件事是：能力越大责任越大。运行时编程非常容易出错，因此很容易在不知情的情况下为应用程序引入另一个严重的问题。这就是为什么总是建议将应用程序中的所有危险代码包装在某种可停止开关中，因为你可以在发现代码导致问题时从后端触发开关禁用该功能。这有一篇介绍 Firebase 的 Feature Flags 的 <a href="https://medium.com/@rwbutler/feature-flags-a-b-testing-mvt-on-ios-718339ac7aa1" target="_blank" rel="noopener">(好文章</a></p><p>完整代码可以从这个 <a href="https://github.com/rsrbk/LayoutLoopHunter" target="_blank" rel="noopener">GitHub 仓库</a> 里获取，并且也将会发布到 CocoPods 上，以跟踪项目中的布局循环。</p><blockquote><p><a href="https://swift.gg/2019/11/11/layout-feedback-loop/" target="_blank" rel="noopener">大量引用</a><br>原文读起来费劲，只是想让自己读的容易写的这篇文章</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="性能优化" scheme="https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>AlamoFire 分析</title>
    <link href="https://changzw.github.io/2019/08/23/source-code/AlamoFire-%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2019/08/23/source-code/AlamoFire-%E5%88%86%E6%9E%90/</id>
    <published>2019-08-23T02:24:19.000Z</published>
    <updated>2020-05-20T03:01:51.578Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:12 GMT+0800 (CST) --><a id="more"></a><p>分析源码：</p><ol><li>这个第三方库，他设计的目标是什么？</li><li>需要哪些基础知识</li><li>整体结构是什么样的</li><li>由外而内逐层分析层次结构</li><li>每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点</li><li>为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？</li></ol><p>为什么要分析 AlamoFire</p><ul><li>分析它的接口设计</li><li>分析他是如何封装 URL Loading System 的</li><li>分析网络层次思考数据传输过程</li></ul><p>AlamoFire 都做了什么？</p><ul><li>Chainable Request / Response Methods</li><li>URL / JSON Parameter Encoding</li><li>Upload File / Data / Stream / MultipartFormData</li><li>Download File using Request or Resume Data</li><li>Authentication with URLCredential</li><li>HTTP Response Validation</li><li>Upload and Download Progress Closures with Progress</li><li>cURL Command Output</li><li>Dynamically Adapt and Retry Requests</li><li>TLS Certificate and Public Key Pinning</li><li>Network Reachability</li></ul><h2 id="foundation-中提供的网络相关接口"><a class="markdownIt-Anchor" href="#foundation-中提供的网络相关接口"></a> Foundation 中提供的网络相关接口</h2><p><code>AlamoFire</code> 是一个网络请求库，底层封装的事 Apple 提供的 <code>URL Loading System</code></p><h3 id="后台-session下载流程注意事项"><a class="markdownIt-Anchor" href="#后台-session下载流程注意事项"></a> 后台 session下载流程&amp;注意事项</h3><p>后台 sessionConfiguration 下载文件保存 到本地沙盒</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启后台 请求 task</span></span><br><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> session = <span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration, delegate: <span class="keyword">self</span>, delegateQueue: <span class="type">OperationQueue</span>.main)</span><br><span class="line">session.downloadTask(with: <span class="type">URL</span>(string: urlDownloadStr)!).resume()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">ViewController</span>: <span class="title">URLSessionDownloadDelegate</span> </span>&#123;</span><br><span class="line"><span class="comment">// 下载完成后代理回调方法，将文件移动到沙盒指定位置</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载完成 - \(location)"</span>)</span><br><span class="line">    <span class="keyword">let</span> locationPath = location.path</span><br><span class="line">    <span class="keyword">let</span> documnets = <span class="type">NSHomeDirectory</span>() + <span class="string">"/Documents/xxxx"</span> + <span class="string">".zip"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"移动地址:\(documnets)"</span>)</span><br><span class="line">    <span class="keyword">let</span> fileManager = <span class="type">FileManager</span>.<span class="keyword">default</span></span><br><span class="line">    <span class="keyword">try</span>! fileManager.moveItem(atPath: locationPath, toPath: documnets)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// http 分段传输，会不断调用这个方法直到，全部下载完成</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" bytesWritten \(bytesWritten)\n totalBytesWritten \(totalBytesWritten)\n totalBytesExpectedToWrite \(totalBytesExpectedToWrite)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"下载进度: \(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\n"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后台请求，需要申请后台权限，这样 app 进入 background 的时候才可以继续下载</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于保存后台下载的completionHandler</span></span><br><span class="line"><span class="keyword">var</span> backgroundSessionCompletionHandler: (() -&gt; <span class="type">Void</span>)? </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"background: \(identifier)"</span>)</span><br><span class="line">  <span class="keyword">self</span>.backgroundSessionCompletionHandler = completionHandler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-alamofire"><a class="markdownIt-Anchor" href="#使用-alamofire"></a> 使用 AlamoFire</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(urlString)</span><br><span class="line">  .responseJSON &#123; (data) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟上面对比[原生的方法(#code1), 思考 <code>AlamoFire</code> 都封装了什么，如何实现链式调用的，内部如何使用 oop，pop 的, 思考 <code>AlamoFire</code> 接口设计</p><p>下面这些都是怎么实现的？</p><ul><li>链式语法</li><li>直接传 string</li><li>封装调用 session，resume</li><li>Response 回调的返回的是 json 数据</li><li><code>Alamofire</code> 模块导入调用</li></ul><p>调用的第一层：<br>Alamofire.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Alamofire Model</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">request</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> url: URLConvertible,</span></span></span><br><span class="line"><span class="function"><span class="params">  method: HTTPMethod = .<span class="keyword">get</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  parameters: Parameters? = <span class="literal">nil</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  encoding: ParameterEncoding = URLEncoding.<span class="keyword">default</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  headers: HTTPHeaders? = <span class="literal">nil</span>)</span></span></span><br><span class="line">  -&gt; <span class="type">DataRequest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>.<span class="keyword">default</span>.request(</span><br><span class="line">    url,</span><br><span class="line">    method: method,</span><br><span class="line">    parameters: parameters,</span><br><span class="line">    encoding: encoding,</span><br><span class="line">    headers: headers</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SessionManager.swift</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SessionManager</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A default instance of `SessionManager`, used by top-level Alamofire request methods, and suitable for use</span></span><br><span class="line"><span class="comment">/// directly for any ad hoc requests.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> `<span class="keyword">default</span>`: <span class="type">SessionManager</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.httpAdditionalHeaders = <span class="type">SessionManager</span>.defaultHTTPHeaders </span><br><span class="line">  <span class="keyword">return</span> <span class="type">SessionManager</span>(configuration: configuration)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>(</span><br><span class="line">  configuration: <span class="type">URLSessionConfiguration</span> = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span> = <span class="type">SessionDelegate</span>(),</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = <span class="type">URLSession</span>(configuration: configuration, delegate: delegate, delegateQueue: <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">init</span>?(</span><br><span class="line">  session: <span class="type">URLSession</span>,</span><br><span class="line">  delegate: <span class="type">SessionDelegate</span>,</span><br><span class="line">  serverTrustPolicyManager: <span class="type">ServerTrustPolicyManager?</span> = <span class="literal">nil</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> delegate === session.delegate <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">self</span>.delegate = delegate</span><br><span class="line">  <span class="keyword">self</span>.session = session</span><br><span class="line"></span><br><span class="line">  commonInit(serverTrustPolicyManager: serverTrustPolicyManager)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SessionDelegate()</code> 代理移交 <code>SessionDelegate</code> 是个 class, 处理 <code>URLSession</code> 的事件回调代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionDataDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionTaskDelegate</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SessionDelegate</span>: <span class="title">URLSessionStreamDelegate</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>为什么 Manager 不处理 <code>URLSession</code> 的代理回调方法，要搞一个 <code>SessionDelegate</code> 处理，因为 Manager 是一个中介者，用于管理各个 class 之间的联系，处理回调的那些方法应该归属于 xxxClass 来处理</p><p><img src="/img/AlamoFire-Manager.jpg" alt="AlamoFire 基本核心框架"></p><p>使用 Manager 主要作用是把代码模块之间的 频繁调用关系化简。划分业务层，管理层<br>Manager 统一管理调度<br>各个模块处理完成后，回调给 Manager</p><h3 id="处理后台下载"><a class="markdownIt-Anchor" href="#处理后台下载"></a> 处理后台下载</h3><h2 id="request"><a class="markdownIt-Anchor" href="#request"></a> request</h2><h3 id="编码"><a class="markdownIt-Anchor" href="#编码"></a> 编码</h3><p><img src="/img/requst_encode.jpeg" alt="提供的3种编码方式"></p><ul><li>url</li><li>json</li><li>propertyList</li></ul><p>url 是ASCII码编码的，他不是 Unicode，ASCII 码中的外文无法识别，所以要百分号编码——将 ACSII -&gt; Unicode 这样可以被识别</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(<span class="number">_</span> urlRequest: URLRequestConvertible, with parameters: Parameters?)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">URLRequest</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> urlRequest = <span class="keyword">try</span> urlRequest.asURLRequest()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> parameters = parameters <span class="keyword">else</span> &#123; <span class="keyword">return</span> urlRequest &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// header</span></span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> method = <span class="type">HTTPMethod</span>(rawValue: urlRequest.httpMethod ?? <span class="string">"GET"</span>), encodesParametersInURL(with: method) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = urlRequest.url <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="type">AFError</span>.parameterEncodingFailed(reason: .missingURL)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">var</span> urlComponents = <span class="type">URLComponents</span>(url: url, resolvingAgainstBaseURL: <span class="literal">false</span>), !parameters.isEmpty &#123;</span><br><span class="line">      <span class="keyword">let</span> percentEncodedQuery = (urlComponents.percentEncodedQuery.<span class="built_in">map</span> &#123; $<span class="number">0</span> + <span class="string">"&amp;"</span> &#125; ?? <span class="string">""</span>) + query(parameters)</span><br><span class="line">      urlComponents.percentEncodedQuery = percentEncodedQuery</span><br><span class="line">      urlRequest.url = urlComponents.url</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> urlRequest.value(forHTTPHeaderField: <span class="string">"Content-Type"</span>) == <span class="literal">nil</span> &#123;</span><br><span class="line">      urlRequest.setValue(<span class="string">"application/x-www-form-urlencoded; charset=utf-8"</span>, forHTTPHeaderField: <span class="string">"Content-Type"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// body</span></span><br><span class="line">    urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> urlRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>p.s. 传输组的时候一定要传 json 字符串！</p><p><a href="https://github.com/Alamofire/Alamofire/issues/1920" target="_blank" rel="noopener">iOS 10: Background Session won’t inform when downloads have failed #1920</a></p><blockquote><p><a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">URL Loading System</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:12 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Net" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Net/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>URL Loading System</title>
    <link href="https://changzw.github.io/2019/08/19/URL-Loading-System/"/>
    <id>https://changzw.github.io/2019/08/19/URL-Loading-System/</id>
    <published>2019-08-19T01:52:28.000Z</published>
    <updated>2020-05-20T07:28:52.914Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2><ul><li>在 Foundation 框架中</li><li>支持协议：<ul><li>FTP协议（ftp://）</li><li>超文本传输协议（http://）</li><li>加密超文本传输协议(https://)</li><li>本地资源(file://)</li><li>数据URLs(data://)</li></ul></li><li>关键类：URLSession，URL，URLRequest，Tasks，Data</li><li>支持：Authorization credentials，cache 和cookies， 配置管理</li><li>使用 closure 和 delegate 处理 Response</li></ul><p><img src="/img/url_loading_system.jpg" alt="url_loading_system 核心类 分 6 个部分"></p><h2 id="核心-urlsession-urlsessiontask"><a class="markdownIt-Anchor" href="#核心-urlsession-urlsessiontask"></a> 核心 URLSession &amp; URLSessionTask</h2><p>一个 session 请求网络数据需要的核心内容</p><p><img src="/img/urlsession.jpg" alt="urlsession"></p><h3 id="session-configuration"><a class="markdownIt-Anchor" href="#session-configuration"></a> Session Configuration</h3><p>每个配置属性都值得研究<br><img src="/img/urlsession_configuration.jpg" alt="configuration"><br><a href="https://juejin.im/post/5d5f5bcbe51d4561c02a2547" target="_blank" rel="noopener">这篇文章有各个参数翻译</a></p><p>总共有三种 configuration</p><ul><li><code>Default</code>: 使用本地沙盒缓存，用户credential保存在 keychain 中</li><li><code>Ephemeral</code>: 不使用沙盒，所有缓存credential 等数据存在 与 session 绑定的 RAM 中，session 失效后内存自动清理</li><li><code>Background</code>: 跟 default session 相似，但是使用的是另外一个 进程(process) 处理数据传输，因为是跨进程，所以 background session 有些限制操作。（嗯后台session 使用了进程间通信）</li></ul><p>为什么要有 configuration？<br>session 相当一个 manager，用来管理组织 task，网络事件处理的枢纽，configuration是这个枢纽的参数信息！相当于 一个 app 他都有 自己 preference</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.background(withIdentifier: <span class="string">"com.czw.backgroundDownload"</span>)</span><br><span class="line"><span class="keyword">let</span> configuration1 = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span><span class="comment">// 允许用户拥有沙盒缓存器，当session 释放的时候，数据依然存在</span></span><br><span class="line"><span class="keyword">let</span> configuration2 = <span class="type">URLSessionConfiguration</span>.ephemeral<span class="comment">// session 无效时，东西就会消失</span></span><br><span class="line"></span><br><span class="line"><span class="type">URLSession</span>.<span class="keyword">init</span>(configuration: configuration).dataTask(with: <span class="type">URL</span>(string: urlDownloadStr)!)</span><br><span class="line">  .resume()<span class="comment">// 后台 sessionConfiguration 不能设置 completeHandler，需要自己设置代理</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"background-内存大小：\(String(describing: configuration.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"background-沙盒大小：\(String(describing: configuration.urlCache.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-内存大小：\(String(describing: configuration1.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"default-沙盒大小：\(String(describing: configuration1.urlCache.diskCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-内存大小：\(String(describing: configuration2.urlCache.memoryCapacity))"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"ephemeral-沙盒大小：\(String(describing: configuration2.urlCache.diskCapacity))"</span>)</span><br></pre></td></tr></table></figure><p>打印结果：<br>background-内存大小：nil<br>background-沙盒大小：nil<br>default-内存大小：512000<br>default-沙盒大小：10000000<br>ephemeral-内存大小：512000<br>ephemeral-沙盒大小：0</p><p>就像文档说的，当session 失效以后 ephemeral 的 cache 会消失，因为他没有沙盒空间</p><h3 id="session-网络请求"><a class="markdownIt-Anchor" href="#session-网络请求"></a> session 网络请求</h3><p><img src="/img/urlsession_flow.jpg" alt="urlsession request flow"></p><p>我们要做的</p><ol><li>配置需要的 session configuration，</li><li>配置 session<ol><li>系统提供的 shared 单例，系统自己配置 configuration，sessionDelegate，delegateQueue</li><li>自定义 session，自己设置 configuration，sessionDelegate，delegateQueue(是 serial queue)</li></ol></li><li>提供 request &amp; url 给 session</li><li>生成 task<ol><li>URLSessionTask<ul><li>URLSessionDataTask</li><li>URLSessionUploadTask</li><li>URLSessionDownloadTask</li><li>URLSessionStreamTask</li><li>URLSessionWebSocketTask（iOS 13.0）</li></ul></li></ol></li><li>配置SessionDelegate, SessionTaskDelegate 对网络事件处理 (URLSessionTaskDelegate: URLSessionDelegate<ul><li>URLSessionDataDelegate</li><li>URLSessionDownloadDelegate</li><li>URLSessionStreamDelegate</li><li>URLSessionWebSocketDelegate（iOS 13.0）</li></ul></li></ol><p>SessionDelegate 只有3个接口</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, didBecomeInvalidWithError error: Error?)</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping <span class="params">(URLSession.AuthChallengeDisposition, URLCredential?)</span></span></span> -&gt; <span class="type">Void</span>) </span><br><span class="line"></span><br><span class="line"><span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSessionDidFinishEvents</span><span class="params">(forBackgroundURLSession session: URLSession)</span></span></span><br></pre></td></tr></table></figure><p>至于各个 taskDelegate，对应不同的task 类型有个字不同协议接口<br>这里主要看 SessionTaskDelegate</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">URLSessionTaskDelegate</span> : <span class="title">URLSessionDelegate</span> </span>&#123; </span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest, completionHandler: @escaping <span class="params">(URLSession.DelayedRequestDisposition, URLRequest?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">11.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping <span class="params">(URLRequest?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping <span class="params">(URLSession.AuthChallengeDisposition, URLCredential?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping <span class="params">(InputStream?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">10.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的是 dataTask，downloadTask，uploadTask</p><h2 id="实际使用"><a class="markdownIt-Anchor" href="#实际使用"></a> 实际使用</h2><h3 id="从网站获取数据到内存"><a class="markdownIt-Anchor" href="#从网站获取数据到内存"></a> 从网站获取数据到内存</h3><h4 id="使用回调处理接受结果使用closure-回调得到-data"><a class="markdownIt-Anchor" href="#使用回调处理接受结果使用closure-回调得到-data"></a> 使用回调处理接受结果：使用closure 回调得到 data</h4><p><img src="https://docs-assets.developer.apple.com/published/c7124fb5d7/bf4501ff-82b2-4dd4-9ec3-243ef0e70d21.png" alt=""></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// task 的状态</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">URLSessionTask</span> </span>&#123; </span><br><span class="line">  <span class="meta">@available</span>(iOS <span class="number">7.0</span>, *)</span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> : <span class="title">Int</span> </span>&#123; </span><br><span class="line">    <span class="keyword">case</span> running </span><br><span class="line">    <span class="keyword">case</span> suspended <span class="comment">// 初试状态</span></span><br><span class="line">    <span class="keyword">case</span> canceling </span><br><span class="line">    <span class="keyword">case</span> completed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/"</span>)!</span><br><span class="line">  <span class="keyword">let</span> task = <span class="type">URLSession</span>.shared.dataTask(with: url) &#123; data, response, error <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">      <span class="keyword">self</span>.handleClientError(error)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> httpResponse = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>,</span><br><span class="line">      (<span class="number">200</span>...<span class="number">299</span>).<span class="built_in">contains</span>(httpResponse.statusCode) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">self</span>.handleServerError(response)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> mimeType = httpResponse.mimeType, mimeType == <span class="string">"text/html"</span>,</span><br><span class="line">      <span class="keyword">let</span> data = data,</span><br><span class="line">      <span class="keyword">let</span> string = <span class="type">String</span>(data: data, encoding: .utf8) &#123;</span><br><span class="line">      <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">        <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: url)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// session create 出来的 task 是 suspend 的状态</span></span><br><span class="line">  task.resume()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点：</p><ol><li>session create 出来的 task 初始状态是 suspend</li><li>回调处理是在 serial queue 任务放到子线程处理的，通知 UI 变化应切换主线程</li></ol><h4 id="接受请求详情结果使用-delegate"><a class="markdownIt-Anchor" href="#接受请求详情结果使用-delegate"></a> 接受请求详情&amp;结果：使用 Delegate</h4><p><img src="https://docs-assets.developer.apple.com/published/8b22355c7f/730c8e1b-654f-4eb9-9c63-d439a69ac5d2.png" alt=""></p><p>这个时候 session 不应该使用 <code>shared</code>，而是要自己配置</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> session: <span class="type">URLSession</span> = &#123;</span><br><span class="line">  <span class="keyword">let</span> configuration = <span class="type">URLSessionConfiguration</span>.<span class="keyword">default</span></span><br><span class="line">  configuration.waitsForConnectivity = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: configuration,</span><br><span class="line">                    delegate: <span class="keyword">self</span>,</span><br><span class="line">                    delegateQueue: <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> receivedData: <span class="type">Data?</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">  loadButton.isEnabled = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">let</span> url = <span class="type">URL</span>(string: <span class="string">"https://www.example.com/"</span>)!</span><br><span class="line">  receivedData = <span class="type">Data</span>()</span><br><span class="line">  <span class="keyword">let</span> task = session.dataTask(with: url)</span><br><span class="line">  task.resume()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// delegate methods</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse,</span></span></span><br><span class="line"><span class="function"><span class="params">        completionHandler: @escaping <span class="params">(URLSession.ResponseDisposition)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> response = response <span class="keyword">as</span>? <span class="type">HTTPURLResponse</span>,</span><br><span class="line">    (<span class="number">200</span>...<span class="number">299</span>).<span class="built_in">contains</span>(response.statusCode),</span><br><span class="line">    <span class="keyword">let</span> mimeType = response.mimeType,</span><br><span class="line">    mimeType == <span class="string">"text/html"</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    completionHandler(.cancel)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  completionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</span></span> &#123;</span><br><span class="line">  <span class="keyword">self</span>.receivedData?.append(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">urlSession</span><span class="params">(<span class="number">_</span> session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)</span></span> &#123;</span><br><span class="line">  <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">    <span class="keyword">self</span>.loadButton.isEnabled = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> error = error &#123;</span><br><span class="line">      handleClientError(error)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> receivedData = <span class="keyword">self</span>.receivedData,</span><br><span class="line">      <span class="keyword">let</span> string = <span class="type">String</span>(data: receivedData, encoding: .utf8) &#123;</span><br><span class="line">      <span class="keyword">self</span>.webView.loadHTMLString(string, baseURL: task.currentRequest?.url)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用代理的方式，可以处理很多特殊的情况：</p><ul><li>authentication challenges</li><li>following redirects</li></ul><blockquote><p><a href="https://developer.apple.com/documentation/foundation/url_loading_system" target="_blank" rel="noopener">URL Loading System</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="Guide" scheme="https://changzw.github.io/categories/iOS-Programming/Guide/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>读代码 Me</title>
    <link href="https://changzw.github.io/2019/05/17/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/"/>
    <id>https://changzw.github.io/2019/05/17/%E8%AF%BB%E4%BB%A3%E7%A0%81-Me/</id>
    <published>2019-05-16T16:47:30.000Z</published>
    <updated>2020-05-18T12:08:33.197Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="为什么看"><a class="markdownIt-Anchor" href="#为什么看"></a> 为什么看</h2><p>抽空晚上睡不着看 <a href="https://github.com/vsouza/awesome-ios#gcd" target="_blank" rel="noopener">awesome-ios</a> 提供的优秀代码库<br>[Me](<a href="https://github.com/pascalbros/Me" target="_blank" rel="noopener">https://github.com/pascalbros/Me</a> 源码</p><h2 id="他是做什么的"><a class="markdownIt-Anchor" href="#他是做什么的"></a> 他是做什么的</h2><p>Me 是解决嵌套异步问题的一个轻量级库——就一个文件</p><h2 id="使用他以后的效果"><a class="markdownIt-Anchor" href="#使用他以后的效果"></a> 使用他以后的效果</h2><p>before</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MyAPI</span>.login &#123;</span><br><span class="line">  <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">    <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">    <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">      <span class="comment">//We are done here</span></span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>after</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Me</span>.start &#123; (me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.login &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request posts...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.posts &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request comments...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.comments &#123;</span><br><span class="line">   <span class="comment">//Do your stuff and then request likes...</span></span><br><span class="line">   me.runNext()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.next &#123; (caller, me) <span class="keyword">in</span></span><br><span class="line">  <span class="type">MyAPI</span>.likes &#123;</span><br><span class="line">   <span class="comment">//We are done here</span></span><br><span class="line">   me.end()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.run()</span><br></pre></td></tr></table></figure><p>看效果：</p><ol><li>Me 把异步嵌套代码–&gt; 链式代码（想想他是怎么做的？）</li><li>Me 是链条型的，start，next，next(name:)，jump(toName:)，end<ol><li>他是如何做异步通知的？</li><li>如何开始，如何结束？</li><li>支持实现多链条并发执行吗？</li></ol></li><li>从提供的接口上可以看出<ol><li>Me开启结束要由用户控制</li><li>节点驱动需要用户触发</li><li>支持指定节点跳转</li></ol></li></ol><p>ok 使用demo&amp;基本特性分析完了，接下来看源码</p><hr><h2 id="源码"><a class="markdownIt-Anchor" href="#源码"></a> 源码</h2><h3 id="先看接口"><a class="markdownIt-Anchor" href="#先看接口"></a> 先看接口</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeInitClosure</span> = ((<span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">MeClosure</span> = ((<span class="number">_</span> previous: <span class="type">Me?</span>, <span class="number">_</span> current: <span class="type">Me</span>) -&gt; ())</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Me</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> index: <span class="type">UInt</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">var</span> name: <span class="type">String</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">var</span> parameters: [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式节点函数，static 是起点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">start</span><span class="params">(name: String = <span class="string">""</span>, this: @escaping MeInitClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(this: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">(name: String = <span class="string">""</span>, next: @escaping MeClosure)</span></span> -&gt; <span class="type">Me</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNextOnMain</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String, queue: DispatchQueue)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toName jump: String)</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jumpOnMain</span><span class="params">(toName jump: String)</span></span></span><br></pre></td></tr></table></figure><ol><li>提供 Me 节点 index，name，代码库内部维护</li><li>只提供其实节点 first</li><li>提供线程队列调度接口</li><li>parameters 是干什么的？像是 [name: MeClouse] 字典，每个 me 节点都有一个clouse</li></ol><h3 id="看代码实现"><a class="markdownIt-Anchor" href="#看代码实现"></a> 看代码实现</h3><ol><li>核心代码，这个地方封装了 GCD</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">runNext</span><span class="params">(queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> next = <span class="keyword">self</span>.next &#123;</span><br><span class="line">    <span class="comment">//self.nextObj!.parameters = self.parameters //enable to pass parameters to the next object</span></span><br><span class="line">    queue.async &#123;</span><br><span class="line">      next(<span class="keyword">self</span>, <span class="keyword">self</span>.nextObj!)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">jump</span><span class="params">(toIndex jump: UInt = <span class="number">0</span>, queue: DispatchQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> to = me(at: jump) &#123;</span><br><span class="line">    to.this(<span class="keyword">self</span>, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个问题是：<code>jump</code> 的queue 没有用……（这个库的使用价值不大）只有 <code>runNext</code> 相关方法可以调度线程<br>parameters: 是 me 节点保存数据，用于用户自己传递数据使用</p><ol start="2"><li>内部数据结构使用的是链表</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> nextObj: <span class="type">Me?</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _first: <span class="type">Me?</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="读源码" scheme="https://changzw.github.io/categories/%E8%AF%BB%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift + MVVM:如何提供ViewModels</title>
    <link href="https://changzw.github.io/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/"/>
    <id>https://changzw.github.io/2019/04/16/RxSwfit+RAC/RxSwift-MVVM-%E5%A6%82%E4%BD%95%E6%8F%90%E4%BE%9BViewModels/</id>
    <published>2019-04-16T12:58:40.000Z</published>
    <updated>2020-04-25T02:21:37.289Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><p><a href="https://medium.com/blablacar-tech/rxswift-mvvm-66827b8b3f10" target="_blank" rel="noopener">原文：RxSwift + MVVM: how to feed ViewModels</a></p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>自从我们开始在BlaBlaCar的Model-View-ViewModel（MVVM）架构中使用RxSwift以来，已经快一年了。我们对结果感到兴奋。我们使用这种方法编写的代码更容易理解，维护，测试和扩展。但是，最初的几周并不是小菜一碟。我们必须在MVVM + RxSwift架构的某些方面进行迭代，以使事情变得正确。其中一个方式——给 ViewModels 提供 Inputs。</p><p>让我们通过两种不同方式给ViewModels 提供 Inputs（Rx Event）</p><p>但是首先，让我们简单谈一下 ViewModels</p><h2 id="viewmodels"><a class="markdownIt-Anchor" href="#viewmodels"></a> ViewModels</h2><p>ViewModel的职责，你必须正确理解它（不止一个）：</p><ul><li>它应该是可以插入到任何View上的。比如，不是先造一个View再去定义一个ViewModel。注意，是View拥有ViewModel。View知道ViewModel，而不是反过来。</li><li>它是可测试的。最终，MVVM架构最大的好处就是让业务逻辑可测。</li><li>MVVM使用绑定机制更加牛逼，所以让使用 RxSwift 来更好地利用 ViewModel</li></ul><p>to be continued…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>如何读代码写代码</title>
    <link href="https://changzw.github.io/2019/03/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://changzw.github.io/2019/03/03/%E5%A6%82%E4%BD%95%E8%AF%BB%E4%BB%A3%E7%A0%81%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2019-03-02T22:31:09.000Z</published>
    <updated>2020-04-25T02:43:24.383Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="怎么读"><a class="markdownIt-Anchor" href="#怎么读"></a> 怎么读</h2><ol><li>这个库是用来干嘛？</li><li>看文件结构<ol><li>思考作者分了那些模块</li><li>每个模块都是干啥的</li><li>模块联系实际场景是啥，文件上用了哪些架构or设计模式（MVC，MVVM，ViewStateModel，Coordinate，Meditate……）</li><li>模块间是如何联系的——数据流</li><li>了解具体模块细节</li></ol></li><li>看具体协议&amp;类的接口<ol><li>作者想要给用户提供什么功能</li><li>类的数据出口&amp;入口是什么</li><li>类之间关系使用了什么设计模式，如何提高了复用性</li></ol></li><li>看数据流向<ol><li>对于文档少&amp;想更深入理解代码，借助 IDE 调试代码，跟踪数据输入输出，看函数调用栈</li><li>根据数据流向可以更清楚类之间的关系</li></ol></li><li>看具体实现<ol><li>想知道具体细节如何实现的时候，看文件，定位源码位置</li></ol></li></ol><h2 id="怎么写"><a class="markdownIt-Anchor" href="#怎么写"></a> 怎么写</h2><ol><li>确定功能</li><li>根据功能确定模块</li><li>根据模块分文件夹<ol><li>思考模块之间关系，出口入口，相互依赖关系</li></ol></li><li>每个模块写接口——API<ol><li>API 层级关系，抽象层级，高层及实现通用功能</li><li>接口出口入口，依赖注入</li><li>接口之间依赖关系，思考使用何种设计模式</li></ol></li><li>根据模块，实现协议<ol><li>class 开发</li><li>class 之间关系，使用什么设计模式，提高复用效率</li><li>class 的出口入口，依赖注入</li><li>私有成员内部逻辑</li></ol></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>雪球速读法--迭代树--整体&amp;细节</title>
    <link href="https://changzw.github.io/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/"/>
    <id>https://changzw.github.io/2019/02/05/%E9%9B%AA%E7%90%83%E9%80%9F%E8%AF%BB%E6%B3%95/</id>
    <published>2019-02-05T11:01:50.000Z</published>
    <updated>2020-04-25T03:03:03.779Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="雪球速读法浅析"><a class="markdownIt-Anchor" href="#雪球速读法浅析"></a> 雪球速读法–浅析</h2><p>《雪球速读法》中说：</p><blockquote><p>速读的方式是：<br>速度技巧 * 资料库(大小) = 速读</p><ul><li>反复读 n 变</li><li>每次快速阅读，要求1.不求甚解，2.脑子里不要有读的声音</li></ul><p>具体：</p><ul><li>先话读目录，前言，后记 用 15~30，思考书的整体结构，作者写作意图</li><li>从框架的外层一层层向知识细节挖，每次处理一层，理解一层，构建自己对这本书的资料库（滚雪球的过程）</li></ul></blockquote><p>这样做的好处是：</p><ol><li>强调先掌握知识的框架！从整体的角度一层层学习知识。</li><li>有了框架就知道森林大概的样子！</li><li>如果单纯的按照目录一点点学习书本上的知识，会陷在局部细节中出不来浪费大量时间，读书时间过长，前面的知识会忘，后面不一定会认真读完，最后整本书都很难理解。</li><li>作者是以什么样的方式写书的呢？类似于《雪球速读法》先有中心思想，目录，段落，然后落实到细节，《雪球速读法》就是按照作者的写作的方式理解知识的过程。</li><li>速读不发出声音，更有利于读者跟作者产生共鸣！这个也是读书的一个目的</li></ol><h2 id="目标-vs-任务"><a class="markdownIt-Anchor" href="#目标-vs-任务"></a> 目标 vs 任务</h2><p>目标：一个你想要看见的好结果<br>任务：为实现目标你要做的事</p><p>在缺少动力的时候多思考目标带来那些美好的愿景，用 Deadline 给自己施加压力，对比人的承诺。</p><p>在执行的时候多看细节，任务，因为总是关注目标，会无从下手，很多细节上的困难乐观对待！导致目标最终搁浅。</p><h2 id="树状结构知识"><a class="markdownIt-Anchor" href="#树状结构知识"></a> 树状结构知识</h2><p>有关树状结构，知识迭代过程都是一层层包裹的知识，有历史气息的知识都是树状结构<br>这样的知识可以像《雪球速读法》一样层层学习</p><h2 id="计算机知识"><a class="markdownIt-Anchor" href="#计算机知识"></a> 计算机知识</h2><p>计算机知识就是一个大大的树，找到一个大树枝，然后一层层分解这个知识点<br><img src="/img/knowledge_tree.jpg" alt="-"></p><p>程序开发的时候也是，现有结构，然后再是细节！</p><p>有时间补充</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift 5.RxDataSources</title>
    <link href="https://changzw.github.io/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/"/>
    <id>https://changzw.github.io/2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/</id>
    <published>2019-01-31T05:58:32.000Z</published>
    <updated>2020-04-25T02:21:27.338Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><p><a href="https://github.com/RxSwiftCommunity/RxDataSources/issues?q=is%3Aissue+is%3Aclosed" target="_blank" rel="noopener">原文: RxDataSources</a></p><h2 id="table-和-collection-view-data-sources"><a class="markdownIt-Anchor" href="#table-和-collection-view-data-sources"></a> Table 和 Collection View data sources</h2><h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2><ul><li>[x] O(N)计算差异的算法<ul><li>该算法假设所有 sections 和 items 都是唯一的，因此没有二义性</li><li>如果有歧义，在非动画刷新时自动回退</li></ul></li><li>[x] 他使用其他启发式方法以将最少数量的命令发送到分段视图<ul><li>即使运行时间是线性的，发送命令的首选数量通常也比线性少</li><li>最好（并且有可能）将更改数量限制为较小的数量，并且如果更改数量朝线性方向增长，则只需进行正常的reload即可</li></ul></li><li>[x] 支持扩展你的 item 和 section 结构<ul><li>只需使用 <code>IdentifiableType</code> 和 <code>Equatable</code> 扩展你的 item，并使用 <code>AnimatableSectionModelType</code> 扩展 section</li></ul></li><li>[x] 支持 section 和 item 的两级分层动画的所有组合<ul><li>Section 动画: Insert, Delete, Mov</li><li>Item 动画: Insert, Delete, Move, Reload (如果旧值不等于新值)</li></ul></li><li>[x] 可配置动画类型对于 Insert, Reload and Delete (Automatic, Fade, …)</li><li>[x] 示例 app</li><li>[x] 随机压力测试（eg app）</li><li>[x] 支持开箱即用的编辑（eg app）</li><li>[x] 同 UITableView 和 UICollectionView 一起工作</li></ul><h2 id="为什么"><a class="markdownIt-Anchor" href="#为什么"></a> 为什么</h2><p>编写 table 和 collection View 数据源很繁琐。对于最简单的情况，需要实现大量的委托方法。</p><p>RxSwift 通过简单的数据绑定机制有助于减轻一些负担：</p><ol><li>把你的数据转化成可见听序列 Observable</li><li>使用下面方法把数据绑定到 tableView/collectionView 上<ul><li>rx.items(dataSource:protocol&lt;RxTableViewDataSourceType, UITableViewDataSource&gt;)</li><li>rx.items(cellIdentifier:String)</li><li>rx.items(cellIdentifier:String:Cell.Type:_: )</li><li>rx.items(<em>:</em>: )</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">Observable</span>&lt;[<span class="type">String</span>]&gt;.just([<span class="string">"first element"</span>, <span class="string">"second element"</span>, <span class="string">"third element"</span>])</span><br><span class="line"></span><br><span class="line">data.bind(to: tableView.rx.items(cellIdentifier: <span class="string">"Cell"</span>)) &#123; index, model, cell <span class="keyword">in</span></span><br><span class="line">  cell.textLabel?.text = model</span><br><span class="line">&#125;</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p>这适用于简单数据集，但不适用于需要将复杂数据集与多个section 绑定或在添加/修改/删除item 时需要执行动画的情况。</p><p>这些正是RxDataSources帮助解决的用例。</p><p>使用RxDataSources，写起来非常容易</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedReloadDataSource</span>&lt;<span class="type">SectionModel</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;&gt;(configureCell: configureCell)</span><br><span class="line"><span class="type">Observable</span>.just([<span class="type">SectionModel</span>(model: <span class="string">"title"</span>, items: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])])</span><br><span class="line">    .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/kzaher/rxswiftcontent/rxdatasources/RxDataSources.gif" alt="-"></p><h2 id="怎么用"><a class="markdownIt-Anchor" href="#怎么用"></a> 怎么用</h2><p>给定以下自定义数据结构：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> anInt: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> aString: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> aCGPoint: <span class="type">CGPoint</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先使用遵循 SectionModelType 协议的结构定义你的section：<ul><li>定义 item 类型别名：等于该 section 将包含的 item 类型</li><li>声明一个 items 属性：Item 类型数组</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SectionOfCustomData</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> header: <span class="type">String</span>    </span><br><span class="line">  <span class="keyword">var</span> items: [<span class="type">Item</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SectionOfCustomData</span>: <span class="title">SectionModelType</span> </span>&#123;</span><br><span class="line">  <span class="keyword">typealias</span> <span class="type">Item</span> = <span class="type">CustomData</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span>(original: <span class="type">SectionOfCustomData</span>, items: [<span class="type">Item</span>]) &#123;</span><br><span class="line">    <span class="keyword">self</span> = original</span><br><span class="line">    <span class="keyword">self</span>.items = items</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建一个dataSource对象，并将其传递给 SectionOfCustomData 类型：</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataSource = <span class="type">RxTableViewSectionedAnimatedDataSource</span>&lt;<span class="type">MySection</span>&gt;(</span><br><span class="line">    configureCell: &#123; ds, tv, <span class="number">_</span>, item <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> cell = tv.dequeueReusableCell(withIdentifier: <span class="string">"Cell"</span>) ?? <span class="type">UITableViewCell</span>(style: .<span class="keyword">default</span>, reuseIdentifier: <span class="string">"Cell"</span>)</span><br><span class="line">        cell.textLabel?.text = <span class="string">"Item \(item)"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cell</span><br><span class="line">    &#125;,</span><br><span class="line">    titleForHeaderInSection: &#123; ds, index <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">return</span> ds.sectionModels[index].header</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol start="3"><li>根据需要在dataSource上自定义闭包：<ul><li>titleForHeaderInSection</li><li>titleForFooterInSection</li><li>etc</li></ul></li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dataSource.titleForHeaderInSection = &#123; dataSource, index <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].header</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.titleForFooterInSection = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> dataSource.sectionModels[index].footer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canEditRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dataSource.canMoveRowAtIndexPath = &#123; dataSource, indexPath <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>将实际数据定义为 CustomData 对象的 Observable序列，并将其绑定到tableView</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sections = [</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"First section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">0</span>, aString: <span class="string">"zero"</span>, aCGPoint: <span class="type">CGPoint</span>.zero), <span class="type">CustomData</span>(anInt: <span class="number">1</span>, aString: <span class="string">"one"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>)) ]),</span><br><span class="line">  <span class="type">SectionOfCustomData</span>(header: <span class="string">"Second section"</span>, items: [<span class="type">CustomData</span>(anInt: <span class="number">2</span>, aString: <span class="string">"two"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">2</span>, y: <span class="number">2</span>)), <span class="type">CustomData</span>(anInt: <span class="number">3</span>, aString: <span class="string">"three"</span>, aCGPoint: <span class="type">CGPoint</span>(x: <span class="number">3</span>, y: <span class="number">3</span>)) ])</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="type">Observable</span>.just(sections)</span><br><span class="line">  .bind(to: tableView.rx.items(dataSource: dataSource))</span><br><span class="line">  .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure><h2 id="数据源动画"><a class="markdownIt-Anchor" href="#数据源动画"></a> 数据源动画</h2><p>RxDataSources 提供了两种特殊的数据源类型，它们可以自动处理绑定数据源中的动画变化：<code>RxTableViewSectionedAnimatedDataSource</code> 和 <code>RxCollectionViewSectionedAnimatedDataSource</code> 。</p><p>要使用两个动画数据源之一，你必须在上述概述的基础上采取一些额外的步骤：</p><ul><li>SectionOfCustomData需要遵守 AnimatableSectionModelType 协议</li><li>数据模型必须符合<ul><li>IdentifiableType：IdentifiableType 协议提供的 <code>identity</code> 必须是表示模型实例的不可变标识符(identifier)。例如，对于 Car 模型，你可能要使用 Car 的plateNumber 作为其标识。</li><li>Equatable：遵从 Equatable 协议 有助于RxDataSources确定哪些 cell 已更改，因此它只能为这些特定 cell 设置动画。这意味着，更改Car模型的任何属性都会触发该 cell 的动画重新加载。</li></ul></li></ul><h2 id="需要"><a class="markdownIt-Anchor" href="#需要"></a> 需要</h2><p>Xcode 10.2</p><p>Swift 5.0</p><p>For Swift 4.x version please use versions 3.0.0 … 3.1.0 For Swift 3.x version please use versions 1.0 … 2.0.2 For Swift 2.3 version please use versions 0.1 … 0.9</p><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><h3 id="cocoapods"><a class="markdownIt-Anchor" href="#cocoapods"></a> CocoaPods</h3><p>Podfile</p><blockquote><p>pod ‘RxDataSources’, ‘~&gt; 4.0’</p></blockquote><h3 id="carthage"><a class="markdownIt-Anchor" href="#carthage"></a> Carthage</h3><p>Cartfile</p><blockquote><p>github “RxSwiftCommunity/RxDataSources” ~&gt; 4.0</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>简化设计 App 的过程</title>
    <link href="https://changzw.github.io/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>https://changzw.github.io/2018/12/06/%E7%AE%80%E5%8C%96%E8%AE%BE%E8%AE%A1-App-%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2018-12-06T09:31:17.000Z</published>
    <updated>2020-05-06T10:18:58.018Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>一个 app 原型&amp;需求来了以后，如何实现呢？<br>本来一个完成的东西如何把需求翻译成程序呢？</p><h2 id="正常节奏"><a class="markdownIt-Anchor" href="#正常节奏"></a> 正常节奏：</h2><ol><li>分析需求<ol><li>原型分析</li><li>需求分析</li></ol></li><li>技术点调研分析<ol><li>架构方式</li><li>使用什么框架（框架对比）</li><li>View 层使用什么渲染方式，Model层使用什么组件，中间层使用什么工具</li></ol></li><li>时间预估<ol><li>新技术学习时间</li><li>开发时间</li><li>调试时间</li></ol></li></ol><h2 id="遇到问题"><a class="markdownIt-Anchor" href="#遇到问题"></a> 遇到问题</h2><ol><li>需求量大，强调代码的复用性！思考时间过长</li><li>需求理解错误，理解不深，差异性问题没有解决</li><li>新技术，熟练度问题，错误使用</li><li>沟通问题！</li></ol><h2 id="简单思考"><a class="markdownIt-Anchor" href="#简单思考"></a> 简单思考</h2><ol><li>简化开发流程！</li><li>App 编码过程<ol><li>照着画 UI</li><li>确定数据渲染方式！</li><li>简化让 model 层数据传到 UI 层渲染的过程，让水流通（我喜欢的方式是函数响应式 rx）</li><li>数据流连接完成以后，添加各种逻辑<ol><li>单链逻辑</li><li>一条条加</li><li>复用的地方在复用</li></ol></li></ol></li><li>代码不是一下子完美的！<ol><li>开始的时候不要太复杂</li><li>不要用太高端自己又不熟悉的技巧</li><li>重构优化使用更好地技术手段都是迭代的过程</li></ol></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>viewController transitions</title>
    <link href="https://changzw.github.io/2018/11/06/viewController-transitions/"/>
    <id>https://changzw.github.io/2018/11/06/viewController-transitions/</id>
    <published>2018-11-06T09:21:48.000Z</published>
    <updated>2020-05-18T15:29:03.607Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>iOS 系统提供了像 <code>push, pop, cover vertically</code> 这样的 <code>ViewController</code> 过渡，该篇分析如何自定义自己的 ViewController transitions。为啥要写这个因为“看着很麻烦”，比起 push，pop，present 来说……</p><p>思考：</p><ol><li>ViewController 的 过渡流程步骤是什么样的</li><li>都有什么组成，他们之间的逻辑是什么样的</li><li>用户如何使用</li></ol><p>过渡的过程，应该有：</p><ol><li>负责触发事件</li><li>负责管理过渡动画</li><li>负责过渡相关的ViewControllers，Views</li></ol><h2 id="transitions-结构"><a class="markdownIt-Anchor" href="#transitions-结构"></a> transitions 结构</h2><p>transitioning API 一组 protocols 结合，允许我们自定义化，使用一个现有的 transition 对象 or 自己定义一个新的。<br><img src="/img/Transition-Frame.jpeg" alt="transitioning API"></p><p>Q: 每个协议的责任是什么？<br>Q: 执行步骤是什么</p><h3 id="transitioning-delegate"><a class="markdownIt-Anchor" href="#transitioning-delegate"></a> Transitioning Delegate</h3><p>每个 ViewController 都有对象—— <code>transitioningDelegate: UIViewControllerTransitioningDelegate</code> 用来得到 Animation controller 对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CardViewController</span>: <span class="title">UIViewControllerTransitioningDelegate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animationController</span><span class="params">(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController)</span></span> -&gt; <span class="type">UIViewControllerAnimatedTransitioning?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">FlipPresentAnimationController</span>(originFrame: cardView.frame)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你 present or dismiss <code>ViewController</code> 的时候，UIKit 会向 <code>transitioningDelegate</code> 要你自定义的 <code>Animation controller</code> 来替代默认动画。你要做的是实现 <code>UIViewControllerTransitioningDelegate</code> 代理方法返回 <code>Animation controller</code></p><h3 id="animation-controller"><a class="markdownIt-Anchor" href="#animation-controller"></a> Animation Controller</h3><p>用来做过渡动画，他实现自 <code>UIViewControllerAnimatedTransitioning</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlipPresentAnimationController</span>: <span class="title">NSObject</span>,<span class="title">UIViewControllerAnimatedTransitioning</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置动画时间</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">transitionDuration</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning?)</span></span> -&gt; <span class="type">TimeInterval</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.6</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 从UIViewControllerContextTransitioning 中得到 toVc &amp; fromVc，对其制作动画</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">animateTransition</span><span class="params">(using transitionContext: UIViewControllerContextTransitioning)</span></span> &#123;</span><br><span class="line">    <span class="comment">//1 通过 transitionContext 得到 fromVC 是触发 present的VC，toVC 是要被呈现的 VC，snapShot，是toVC 呈现以后的view 截图用于做动画</span></span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> fromVC = transitionContext.viewController(forKey: .from),</span><br><span class="line">      <span class="keyword">let</span> toVC = transitionContext.viewController(forKey: .to),</span><br><span class="line">      <span class="keyword">let</span> snapshot = toVC.view.snapshotView(afterScreenUpdates: <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//containerView 是过渡过程中的容器 view</span></span><br><span class="line">    <span class="keyword">let</span> containerView = transitionContext.containerView</span><br><span class="line">    <span class="keyword">let</span> finalFrame = transitionContext.finalFrame(<span class="keyword">for</span>: toVC)</span><br><span class="line"></span><br><span class="line">    snapshot.frame = originFrame</span><br><span class="line">    snapshot.layer.cornerRadius = <span class="type">CardViewController</span>.cardCornerRadius</span><br><span class="line">    snapshot.layer.masksToBounds = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    containerView.addSubview(toVC.view)</span><br><span class="line">    containerView.addSubview(snapshot)</span><br><span class="line">    toVC.view.isHidden = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="type">AnimationHelper</span>.perspectiveTransform(<span class="keyword">for</span>: containerView)</span><br><span class="line">    snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(.pi / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">let</span> duration = transitionDuration(using: transitionContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对 view 做动画处理</span></span><br><span class="line">    <span class="type">UIView</span>.animateKeyframes(</span><br><span class="line">      withDuration: duration,</span><br><span class="line">      delay: <span class="number">0</span>,</span><br><span class="line">      options: .calculationModeCubic,</span><br><span class="line">      animations: &#123;</span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">0.0</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          fromVC.view.layer.transform = <span class="type">AnimationHelper</span>.yRotation(-.pi / <span class="number">2</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">1</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.layer.transform = <span class="type">AnimationHelper</span>.yRotation(<span class="number">0.0</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">UIView</span>.addKeyframe(withRelativeStartTime: <span class="number">2</span>/<span class="number">3</span>, relativeDuration: <span class="number">1</span>/<span class="number">3</span>) &#123;</span><br><span class="line">          snapshot.frame = finalFrame</span><br><span class="line">          snapshot.layer.cornerRadius = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">      completion: &#123; <span class="number">_</span> <span class="keyword">in</span></span><br><span class="line">        toVC.view.isHidden = <span class="literal">false</span></span><br><span class="line">        snapshot.removeFromSuperview()</span><br><span class="line">        fromVC.view.layer.transform = <span class="type">CATransform3DIdentity</span></span><br><span class="line">        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简述"><a class="markdownIt-Anchor" href="#简述"></a> 简述</h2><p>对于需要自定义的 transitioning 的 ViewController，CustomViewController</p><ol><li>CustomViewController: UIViewControllerTransitioningDelegate 实现协议</li><li>实现协议的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">animationController(presented:, presenting:, source:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br><span class="line">animationController(dismiss:) -&gt; <span class="type">UIViewControllerAnimatedTransitioning</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自定义 Animation Controller（CustomeAnimationController: UIViewControllerAnimatedTransitioning)</li><li>实现 UIViewControllerAnimatedTransitioning 中的</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transitionDuration(using transitionContext: <span class="type">UIViewControllerContextTransitioning?</span>) -&gt; <span class="type">TimeInterval</span></span><br><span class="line">animateTransition(transitionContext:)</span><br></pre></td></tr></table></figure><h2 id="给-dismiss-添加手势交互"><a class="markdownIt-Anchor" href="#给-dismiss-添加手势交互"></a> 给 dismiss 添加手势交互</h2><p><img src="https://koenig-media.raywenderlich.com/uploads/2015/07/settings.gif" alt=""></p><blockquote><p><a href="https://www.raywenderlich.com/322-custom-uiviewcontroller-transitions-getting-started#toc-anchor-011" target="_blank" rel="noopener">Custom UIViewController Transitions: Getting Started</a></p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
    
      <category term="iOS" scheme="https://changzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>App 架构</title>
    <link href="https://changzw.github.io/2018/09/18/architecture/App-%E6%9E%B6%E6%9E%84/"/>
    <id>https://changzw.github.io/2018/09/18/architecture/App-%E6%9E%B6%E6%9E%84/</id>
    <published>2018-09-18T02:28:02.000Z</published>
    <updated>2020-04-25T02:45:36.292Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><p>objc 《App 架构》 笔记</p><h2 id="如何设计架构"><a class="markdownIt-Anchor" href="#如何设计架构"></a> 如何设计架构</h2><ol><li>确定模块（Model 层，View 层，协调器……）<ol><li>如何确定模块？联想实际场景，分析责任、行为，确定模块！！</li><li>为什么要确定模块？确定模块后，程序不会被应用框架中的实现细节所支配</li></ol></li><li>模块间的联系，依赖，变换，通知行为如何定义。<ol><li>尽可能让数据流向单向清晰</li><li>确定数据流向行为统一一致，统一程序开发维护<ol><li>delegate，notification，block，kvo，Rx……</li></ol></li></ol></li></ol><h2 id="mvc"><a class="markdownIt-Anchor" href="#mvc"></a> MVC</h2><p><img src="/img/MVC.jpeg" alt="mvc"></p><p>Model 层包括，data model和server model<br>controler：引用 server model</p><h2 id="mvvm-c"><a class="markdownIt-Anchor" href="#mvvm-c"></a> MVVM-C</h2><p><img src="/img/mvvm-c.jpeg" alt="mvvm-c"></p><h2 id="网络"><a class="markdownIt-Anchor" href="#网络"></a> 网络</h2><h2 id="mvcviewstate"><a class="markdownIt-Anchor" href="#mvcviewstate"></a> MVC+ViewState</h2><p><img src="/img/mvc-viewstate.jpeg" alt="mvc-viewstate"></p><h2 id="model-适配器-view-绑定器"><a class="markdownIt-Anchor" href="#model-适配器-view-绑定器"></a> Model 适配器 + View 绑定器</h2><h2 id="elm-架构"><a class="markdownIt-Anchor" href="#elm-架构"></a> Elm 架构</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="设计思想" scheme="https://changzw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="设计思想" scheme="https://changzw.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>“T” 字模型</title>
    <link href="https://changzw.github.io/2018/08/24/%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>https://changzw.github.io/2018/08/24/%E5%BC%80%E5%8F%91%E4%B8%8A%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2018-08-24T07:30:54.000Z</published>
    <updated>2020-04-25T03:03:14.403Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="架构的时候容易乱使用-t-字模型思考"><a class="markdownIt-Anchor" href="#架构的时候容易乱使用-t-字模型思考"></a> 架构的时候容易乱——使用 “T” 字模型思考</h2><p>原因：<br>架构代码的时候，总想有没有更好地解决方案，如何尽可能的模块解耦，责任单一……，如何查分类，架构中需要有什么模块，需要使用什么工具链……</p><p>可是一下子把所有问放在一起，整个人很多时候会乱，而且想的越多越乱</p><p>解决方案：</p><ol><li>简单化模块，现有最基本的框架 eg MVVM，MVC</li><li>把最简单的模型先搭建起来，然后实现一个主流程功能</li><li>接着在实现其他主流程功能</li><li>想想可以添加那些 模块组件 让自己的架构更加优美</li><li>重构，然后再先有个主流程线</li></ol><p>总结：</p><ol><li>现有要做的东西有个 外在的整体认识，想给用户提供什么 接口！</li><li>先实现一个接口的功能，然后再把所有线的实现出来</li><li>重构</li></ol><p>整体思想方式 是 “T” 字思考</p><h2 id="模块组件间交互繁杂-为什么有-中介者"><a class="markdownIt-Anchor" href="#模块组件间交互繁杂-为什么有-中介者"></a> 模块组件间交互繁杂—— 为什么有 中介者</h2><ol><li>程序调用流程是线性的，思维混乱的程序员很容易把这条线搞的杂乱无章，虽然可以让程序跑起来，可是维护费劲</li><li>中介者：模块中提供中介者，定义一种编程规范，使用 中介者 让代码分类，这样把模块减少，减少杂乱的线，这些线放在中介者中</li></ol><p><img src="/img/meditator_chaos.jpg" alt="chaos"><br><img src="/img/meditator_order.jpg" alt="order"></p><p>中介者—— 像个管理者一样，在实际中调度各个部门，部门有什么问题想中介者汇报</p><p>如果没有中介者——管理者，那么 部门之间问题相互穿插 orz</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="思考" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"/>
    
      <category term="开发" scheme="https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="学习感悟" scheme="https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift 源码分析</title>
    <link href="https://changzw.github.io/2018/08/18/RxSwfit+RAC/RxSwift-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://changzw.github.io/2018/08/18/RxSwfit+RAC/RxSwift-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2018-08-18T08:56:26.000Z</published>
    <updated>2020-04-25T02:21:11.915Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><p><img src="/img/RxSwift001.jpg" alt="frame"></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;&lt;p&gt;&lt;img src=&quot;/img/RxSwift001.jpg&quot; alt=&quot;frame&quot;&gt;&lt;/p&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"/>
    
    
      <category term="源码" scheme="https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="RxSwift" scheme="https://changzw.github.io/tags/RxSwift/"/>
    
  </entry>
  
  <entry>
    <title>关联对象</title>
    <link href="https://changzw.github.io/2018/07/01/deep%20analyse/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/"/>
    <id>https://changzw.github.io/2018/07/01/deep%20analyse/%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1/</id>
    <published>2018-07-01T14:32:13.000Z</published>
    <updated>2020-04-25T02:55:18.668Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="关联对象是什么"><a class="markdownIt-Anchor" href="#关联对象是什么"></a> 关联对象是什么</h2><ul><li>他是 objective-c runtime 机制中提供的一个接口，让用户在运行时，动态的给类添加关联属性</li></ul><h2 id="关联对象的主要作用"><a class="markdownIt-Anchor" href="#关联对象的主要作用"></a> 关联对象的主要作用</h2><p>开发中如何给 category 添加成员属性呢？或者说，如何在运行时给 class 关联新的属性？</p><ul><li>主要作用：给category 添加成员变量<ul><li>category 底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接添加。</li><li>分类中的 @property 只能声明属性，不提供 _name, getName, setName 的实现</li><li>类中 @property 提供 _name, getName, setName 的实现</li></ul></li></ul><h2 id="如何使用关联对象呢"><a class="markdownIt-Anchor" href="#如何使用关联对象呢"></a> 如何使用关联对象呢</h2><h3 id="关联对象接口"><a class="markdownIt-Anchor" href="#关联对象接口"></a> 关联对象接口</h3><p><code>&lt;objc/runtime.h&gt;</code> 中定义的以下三个允许你将任何键值在运行时关联到对象上的函数：</p><ul><li>objc_setAssociatedObject</li><li>objc_getAssociatedObject</li><li>objc_removeAssociatedObjects</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">object   :表示关联者，是一个对象，变量名理所当然也是object</span></span><br><span class="line"><span class="comment">key      :获取被关联者的索引key</span></span><br><span class="line"><span class="comment">value    :被关联者</span></span><br><span class="line"><span class="comment">policy   :关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line"><span class="comment">//移除某个对象身上的所有关联的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure><h2 id="实际使用效果"><a class="markdownIt-Anchor" href="#实际使用效果"></a> 实际使用效果</h2><p>对比字典实现给分类添加 property</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> weight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Key [NSString stringWithFormat:@<span class="meta-string">"%p"</span>, self]</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *names_;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *weights_;</span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    weights_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    names_ = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    names_[Key] = name;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> names_[Key];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    weights_[Key] = @(weight);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    <span class="keyword">return</span> [weights_[Key] intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>上面使用全局字典的方式，给分类中的成员变量添加get，set 实现体</p><p>那么如何使用关联对象呢？</p><ul><li>关联对象实现分类添加成员属性</li></ul><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Banana</span> (<span class="title">Test</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="comment">// 隐式参数_cmd == @selector(name)</span></span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setWeight:(<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">int</span>)weight &#123;</span><br><span class="line">    <span class="keyword">return</span> [objc_getAssociatedObject(<span class="keyword">self</span>, _cmd) intValue];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="关联对象源码分析"><a class="markdownIt-Anchor" href="#关联对象源码分析"></a> 关联对象源码分析</h2><p>关联对象也是用全局 hash 表来保存的。<br><a href="https://opensource.apple.com/tarballs/objc4/objc4-779.1.tar.gz" target="_blank" rel="noopener">objc4-779.1源码</a> 这个文件中 <a href="http://objc-references.mm" target="_blank" rel="noopener">objc-references.mm</a></p><p>关联对象的核心类</p><div align="left"><img src="/img/ao.jpeg" style="width:800px;height:370px"></div><ul><li>AssociationsManager</li><li>AssociationsHashMap</li><li>ObjectAssociationMap</li><li>ObjcAssociation</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsManager</span> &#123;</span></span><br><span class="line">  <span class="comment">// associative references: object pointer -&gt; PtrPtrHashMap.</span></span><br><span class="line">  <span class="keyword">static</span> AssociationsHashMap *_map;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssociationsHashMap</span> :</span> <span class="keyword">public</span> <span class="built_in">unordered_map</span>&lt;<span class="keyword">disguised_ptr_t</span>, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectAssociationMap</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">void</span> *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjcAssociation</span> &#123;</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> _policy;</span><br><span class="line">  id _value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关联对象何时释放"><a class="markdownIt-Anchor" href="#关联对象何时释放"></a> 关联对象何时释放</h3><p>…… 不想看了，想看了再补充，总之他在所关联的对象释放后，会释放的</p><h3 id="关联时采用的协议"><a class="markdownIt-Anchor" href="#关联时采用的协议"></a> 关联时采用的协议</h3><table><thead><tr><th>Behavior</th><th>@property Equivalent</th><th>Description</th></tr></thead><tbody><tr><td>OBJC_ASSOCIATION_ASSIGN</td><td>@property (assign) 或 @property (unsafe_unretained)</td><td>指定一个关联对象的弱引用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td><td>@property (nonatomic, strong)</td><td>指定一个关联对象的强引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY_NONATOMIC</td><td>@property (nonatomic, copy)</td><td>指定一个关联对象的copy引用，不能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_RETAIN</td><td>@property (atomic, strong)</td><td>指定一个关联对象的强引用，能被原子化使用。</td></tr><tr><td>OBJC_ASSOCIATION_COPY</td><td>@property (atomic, copy)</td><td>指定一个关联对象的copy引用，能被原子化使用。</td></tr></tbody></table><h2 id="实际中使用关联对象的例子"><a class="markdownIt-Anchor" href="#实际中使用关联对象的例子"></a> 实际中使用关联对象的例子</h2><p><a href="https://changzw.github.io/2020/03/08/%E4%BD%BF%E7%94%A8-closures-%E6%B7%BB%E5%8A%A0-Gesture-Recognizers/">使用 closures 添加 Gesture Recognizers</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="iOS Programming" scheme="https://changzw.github.io/categories/iOS-Programming/"/>
    
      <category term="objc" scheme="https://changzw.github.io/categories/iOS-Programming/objc/"/>
    
      <category term="runtime" scheme="https://changzw.github.io/categories/iOS-Programming/objc/runtime/"/>
    
    
      <category term="objc" scheme="https://changzw.github.io/tags/objc/"/>
    
  </entry>
  
  <entry>
    <title>swift 序列化Codable</title>
    <link href="https://changzw.github.io/2018/05/10/swift-%E5%BA%8F%E5%88%97%E5%8C%96Codable/"/>
    <id>https://changzw.github.io/2018/05/10/swift-%E5%BA%8F%E5%88%97%E5%8C%96Codable/</id>
    <published>2018-05-10T02:10:46.000Z</published>
    <updated>2020-04-25T02:48:33.269Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>序列化是将对象的状态信息转换为可以存储或传输的形式的过程(对象&lt;–&gt;I/O流)。<br>对象信息序列化以后变成 I/O 流：</p><ol><li>可以本地化存储（持久化对象）</li><li>网络通讯（网络传输对象）</li><li>定制协议，跨平台、跨语言通讯</li></ol><h2 id="swift-中的序列化"><a class="markdownIt-Anchor" href="#swift-中的序列化"></a> Swift 中的序列化</h2><ol><li>Swift 4.0 之前仍需要手动解析</li><li>Swift 4.0 以后，提供 Codable 协议</li><li>仍然存在问题</li></ol><h3 id="没有encoder和decoder"><a class="markdownIt-Anchor" href="#没有encoder和decoder"></a> 没有Encoder和Decoder</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json: [<span class="type">String</span> : <span class="type">Any</span>] = [</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"cap"</span>,</span><br><span class="line">  <span class="string">"points"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"this is a cat"</span>,</span><br><span class="line">]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要手动解析</span></span><br><span class="line">  <span class="keyword">init</span>?(json: [<span class="type">String</span>: <span class="type">Any</span>]) &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> name = json[<span class="string">"name"</span>] <span class="keyword">as</span>? <span class="type">String</span>,</span><br><span class="line">      <span class="keyword">let</span> points = json[<span class="string">"points"</span>] <span class="keyword">as</span>? <span class="type">Int</span>,</span><br><span class="line">      <span class="keyword">let</span> description = json[<span class="string">"description"</span>] <span class="keyword">as</span>? <span class="type">String</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.points = points</span><br><span class="line">    <span class="keyword">self</span>.description = description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> p = <span class="type">Product</span>(json: json) &#123;</span><br><span class="line">  <span class="built_in">print</span>(p.name + <span class="string">" \(p.points) "</span> + p.description!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用编码器类型遵循-codableencodable-decodable-协议"><a class="markdownIt-Anchor" href="#使用编码器类型遵循-codableencodable-decodable-协议"></a> 使用编码器，类型遵循 Codable(Encodable &amp; Decodable) 协议</h3><ol><li>类型遵循Codable</li><li>Encode</li><li>Decode</li></ol><p>2017年6月发布的 Swift4.0 中的 Codable(Encodable &amp; Decodable) 协议，表明该协议具有被序列化和/或反序列化的能⼒。<br>Swift 标准库中的所有基本类型都遵循 <code>Codable</code> 协议，<code>Data，Date， URL，CGPoint 和 CGRect</code> 在内的许多 Apple 框架中的常⽤数据类型，也已经适配了 Codable。<br>自定义类型需要用户遵循 Codable协议。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Codable</span> = <span class="type">Decodable</span> &amp; <span class="type">Encodable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 某个类型可以将⾃身编码为⼀种外部表示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Encodable</span> </span>&#123; <span class="comment">/// 将值编码到给定的 encoder 中</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">encode</span><span class="params">(to encoder: Encoder)</span></span> <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/// 某个类型可以从外部表示中解码得到⾃身</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">protocol</span> <span class="title">Decodable</span> </span>&#123; <span class="comment">/// 通过从给定的 decoder 中解码来创建新的实例</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">init</span>(from decoder: <span class="type">Decoder</span>) <span class="keyword">throws</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⼀旦你拥有 codable 类型的值，你可以创建⼀个编码器，并让它将这个值转换到像是 JSON 这样的序列化格式。反过来，⼀个解码器可以将序列化后的数据转回为它原来类型的⼀个实例。</p><p>Swift ⾃带两套编码解码器，<code>JSONEncoder/JSONDecoder</code> 和 <code>PropertyListEncoder/PropertyListDecoder</code>，它们存在于 Foundation 中。</p><h2 id="jsonencoderjsondecoder"><a class="markdownIt-Anchor" href="#jsonencoderjsondecoder"></a> JSONEncoder/JSONDecoder</h2><h3 id="不需要手动解码"><a class="markdownIt-Anchor" href="#不需要手动解码"></a> 不需要手动解码</h3><p>属性名 = key，属性类型 = value 类型一致，使用 decoder 对json解码，不需要手动解码了</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"""</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "name": "Banana",</span></span><br><span class="line"><span class="string">        "points": 200,</span></span><br><span class="line"><span class="string">        "description": "A banana grown in Ecuador."</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "name": "Orange",</span></span><br><span class="line"><span class="string">        "points": 100</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span>.data(using: .utf8)!</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码</span></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> products = <span class="keyword">try</span> decoder.decode([<span class="type">GroceryProduct</span>].<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following products are available:"</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\t\(product.name) (\(product.points) points)"</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> description = product.description &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t\t\(description)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与上文无关，只描述下编码过程</span></span><br><span class="line"><span class="keyword">let</span> jsonEncoder = <span class="type">JSONEncoder</span>()</span><br><span class="line"><span class="keyword">let</span> jsonData = <span class="keyword">try</span>? jsonEncoder.encode(products)</span><br><span class="line"><span class="keyword">let</span> str = <span class="type">String</span>(decoding: jsonData!, <span class="keyword">as</span>: <span class="type">UTF8</span>.<span class="keyword">self</span>)</span><br><span class="line"><span class="built_in">print</span>(str)</span><br><span class="line"><span class="keyword">let</span> jsonObject = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.jsonObject(with: jsonData!, options: .allowFragments)</span><br><span class="line"><span class="built_in">print</span>(jsonObject)</span><br></pre></td></tr></table></figure><p>GroceryProduct 类中属性都遵循 <code>Codable</code> 协议，Array也是，所以不需要实现 <code>encode(to encoder: Encoder)</code> 和 <code>init(from decoder: Decoder)</code> 方法</p><h3 id="需要手动解码"><a class="markdownIt-Anchor" href="#需要手动解码"></a> 需要手动解码</h3><h4 id="json中的key值与属性名称不一致"><a class="markdownIt-Anchor" href="#json中的key值与属性名称不一致"></a> json中的key值与属性名称不一致</h4><p>但是这个类型实际上并不⼀定需要是枚 举)。提供⾃定义的编码键是⼀种很简单，⽽且是声明式的改变类型编码的⽅式。在枚举中，我 们可以：</p><p>→ 使⽤明确给定的字符串值，在编码后的输出中重命名字段，或者</p><p>→ 将某个键从枚举中移除，以此完全跳过字段。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> json = <span class="string">"""</span></span><br><span class="line"><span class="string">[</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "product_name": "Bananas",</span></span><br><span class="line"><span class="string">        "product_cost": 200,</span></span><br><span class="line"><span class="string">        "description": "A banana grown in Ecuador."</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">        "product_name": "Oranges",</span></span><br><span class="line"><span class="string">        "product_cost": 100,</span></span><br><span class="line"><span class="string">        "description": "A juicy orange."</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">]</span></span><br><span class="line"><span class="string">"""</span>.data(using: .utf8)!</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GroceryProduct</span>: <span class="title">Codable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> points: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">var</span> description: <span class="type">String?</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">CodingKeys</span>: <span class="title">String</span>, <span class="title">CodingKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> name = <span class="string">"product_name"</span></span><br><span class="line">    <span class="keyword">case</span> points = <span class="string">"product_cost"</span></span><br><span class="line">    <span class="keyword">case</span> description</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line"><span class="keyword">let</span> products = <span class="keyword">try</span> decoder.decode([<span class="type">GroceryProduct</span>].<span class="keyword">self</span>, from: json)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"The following products are available:"</span>)</span><br><span class="line"><span class="keyword">for</span> product <span class="keyword">in</span> products &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\t\(product.name) (\(product.points) points)"</span>)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> description = product.description &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\t\t\(description)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型嵌套"><a class="markdownIt-Anchor" href="#类型嵌套"></a> 类型嵌套</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="开发语言" scheme="https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"/>
    
      <category term="swift" scheme="https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/swift/"/>
    
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Texture 布局</title>
    <link href="https://changzw.github.io/2018/04/11/Texture-%E5%B8%83%E5%B1%80/"/>
    <id>https://changzw.github.io/2018/04/11/Texture-%E5%B8%83%E5%B1%80/</id>
    <published>2018-04-11T03:10:14.000Z</published>
    <updated>2020-04-25T02:31:32.562Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --><a id="more"></a><h2 id="texture-目标优点"><a class="markdownIt-Anchor" href="#texture-目标优点"></a> Texture 目标&amp;优点</h2><p>Texture 的 Layout API是 UIKit AutoLayout 的高效替代品</p><ul><li>Fast：自动布局比 AutoLayout 快的多</li><li>Asynchronous &amp; Concurrent: Layout 在后台计算，所以用户交互不会被终端</li><li>Declarative：布局用不可变的数据结构声明。这使布局代码更易于开发，文档编制，代码审查，测试，调试，配置文件和维护。</li><li>Cacheable：布局结果是不可变的数据结构，因此可以在后台对其进行预先计算并进行缓存以提高用户的感知性能。</li><li>Extensible：易于在类之间共享代码。</li></ul><p>受 CSS Flexbox 模型启发<a href="https://changzw.github.io/2017/12/09/flexbox-model/">flexbox model</a></p><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>Texture 布局系统的两个核心概念：</p><ol><li>Layout Specs</li><li>Layout Elements</li></ol><h3 id="layout-specs"><a class="markdownIt-Anchor" href="#layout-specs"></a> Layout Specs</h3><p>class <code>ASLayoutSpec</code><br>布局规范（layout specification）通过了解这些子布局元素之间的相互关系布局元素，是布局元素的容器。</p><h3 id="layout-elements"><a class="markdownIt-Anchor" href="#layout-elements"></a> Layout Elements</h3><p>protocol <code>&lt;ASLayoutElement&gt;</code><br>Layout Specs 包含并排列 Layout Elements<br>所有 <code>ASDisplayNodes</code> &amp; <code>ASLayoutSpecs</code> 都遵循<aslayoutelement>协议</aslayoutelement></p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----------------------ASStackLayoutSpec----------------------</span><br><span class="line">|  -----ASStackLayoutSpec-----  -----ASStackLayoutSpec-----  |</span><br><span class="line">|  |       ASImageNode       |  |       ASImageNode       |  |</span><br><span class="line">|  |       ASImageNode       |  |       ASImageNode       |  |</span><br><span class="line">|  ---------------------------  ---------------------------  |</span><br><span class="line">--------------------------------------------------------------</span><br></pre></td></tr></table></figure><h2 id="layout-specs-子类"><a class="markdownIt-Anchor" href="#layout-specs-子类"></a> Layout Specs 子类</h2><ul><li>ASWrapperLayoutSpec</li><li>ASStackLayoutSpec</li><li>ASInsetLayoutSpec</li><li>ASOverlayLayoutSpec</li><li>ASBackgroundLayoutSpec</li><li>ASCenterLayoutSpec</li><li>ASRatioLayoutSpec</li><li>ASRelativeLayoutSpec</li><li>ASAbsoluteLayoutSpec</li><li>ASCornerLayoutSpec</li></ul><h3 id="aswrapperlayoutspec"><a class="markdownIt-Anchor" href="#aswrapperlayoutspec"></a> ASWrapperLayoutSpec</h3><p>它可以包裹一个 <code>ASLayoutElement</code> ，通过这个 element 的siez set 计算这个 element 的layout。</p><p>用于：<br><code>ASWrapperLayoutSpec</code> 对于在 <code>-layoutSpecThatFits:</code> 中包裹单个 node，返回spec.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a single subnode from layoutSpecThatFits:</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASWrapperLayoutSpec</span>(layoutElement: _subnode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set a size (but not position)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  _subnode.style.preferredSize = <span class="type">CGSize</span>(width: constrainedSize.<span class="built_in">max</span>.width,</span><br><span class="line">                                        height: constrainedSize.<span class="built_in">max</span>.height / <span class="number">2.0</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASWrapperLayoutSpec</span>(layoutElement: _subnode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asinsetlayoutspec"><a class="markdownIt-Anchor" href="#asinsetlayoutspec"></a> ASInsetLayoutSpec</h3><p>给 element 添加 inset margin。element 必须有 instrinsic size or 显示设置的size</p><div align="left"><img src="/img/texture-insetlayout.jpeg" alt="runloop" style="width:150px;height:96px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> insets = <span class="type">UIEdgeInsets</span>(top: <span class="number">10.0</span>, <span class="keyword">left</span>: <span class="number">10.0</span>, bottom: <span class="number">10.0</span>, <span class="keyword">right</span>: <span class="number">10.0</span>)</span><br><span class="line">  <span class="keyword">let</span> headerWithInset = <span class="type">ASInsetLayoutSpec</span>(insets: insets, child: textNode)</span><br><span class="line">  <span class="keyword">return</span> headerWithInset</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asoverlaylayoutspec"><a class="markdownIt-Anchor" href="#asoverlaylayoutspec"></a> ASOverlayLayoutSpec</h3><p>重叠布局规范尺寸是根据 element 的尺寸计算得出的。在下图中，element 是蓝色层<br>重叠布局规范尺寸是根据包裹 element 的尺寸计算出来的。在下图中，子元素是蓝色图层。蓝色 element 会把他的 size 作为 <code>constrainedSize</code> 传给重叠布局元素（红色图层）。所以 element （蓝色layer）必须要有自己的 intrinsic size 或者 已经设置 size了。</p><div align="left"><img src="/img/texture-OverlayLayout.jpeg" alt="OverlayLayout" style="width:150px;height:96px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> backgroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.blue)</span><br><span class="line">  <span class="keyword">let</span> foregroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.red)</span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASOverlayLayoutSpec</span>(child: backgroundNode, overlay: foregroundNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asbackgroundlayoutspec"><a class="markdownIt-Anchor" href="#asbackgroundlayoutspec"></a> ASBackgroundLayoutSpec</h3><p>ASBackgroundLayoutSpec 布局一个组件（蓝色），并拉伸其后的另一个组件作为背景（红色）。</p><p>background 规范 size根据 child 的尺寸计算。下图中，蓝色是child。将 blue child 的size 当做 <code>constrainedSize</code> 传给 background layout element (red layer). so child(blue layer) 一定要有自己的intrinsic size 或者 已经设置 size了。</p><div align="left"><img src="/img/Texture-BackgroundLayout.jpeg" alt="Texture-BackgroundLayout" style="width:150px;height:110px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> backgroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.red)</span><br><span class="line">  <span class="keyword">let</span> foregroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.blue)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASBackgroundLayoutSpec</span>(child: foregroundNode, background: backgroundNode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ascenterlayoutspec"><a class="markdownIt-Anchor" href="#ascenterlayoutspec"></a> ASCenterLayoutSpec</h3><p>ASCenterLayoutSpec 在最大 <code>constrainedSize</code> 将放在 child 中心位置。<br>如果center spec’s width 和 height 没有限制，那么 ASCenterLayoutSpec 缩到 child 的size大小。</p><p><code>ASCenterLayoutSpec</code> 两个属性:</p><ul><li>centeringOptions. 确定 child 如何在中心规格内居中。选项包括：None, X, Y, XY.</li><li>sizingOptions. 确定中心规格将占用多少空间。选项包括：Default, minimum X, minimum Y, minimum XY.</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> subnode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.green, <span class="type">CGSize</span>(width: <span class="number">60.0</span>, height: <span class="number">100.0</span>))</span><br><span class="line">  <span class="keyword">let</span> centerSpec = <span class="type">ASCenterLayoutSpec</span>(centeringOptions: .<span class="type">XY</span>, sizingOptions: [], child: subnode)</span><br><span class="line">  <span class="keyword">return</span> centerSpec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asratiolayoutspec"><a class="markdownIt-Anchor" href="#asratiolayoutspec"></a> ASRatioLayoutSpec</h3><p>ASRatioLayoutSpec 使用固定宽高比来布局组件。ASRatioLayoutSpec 他的 <code>constrainedSize</code> 必须要配置 width or height。这样才能够使用 scale</p><p>ASRatioLayoutSpec 经常用于那些没有 intrinsic size 的node（ASNetworkImageNode or ASVideoNode）。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="comment">// Half Ratio</span></span><br><span class="line">  <span class="keyword">let</span> subnode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.green, <span class="type">CGSize</span>(width: <span class="number">100</span>, height: <span class="number">100.0</span>))</span><br><span class="line">  <span class="keyword">let</span> ratioSpec = <span class="type">ASRatioLayoutSpec</span>(ratio: <span class="number">0.5</span>, child: subnode)</span><br><span class="line">  <span class="keyword">return</span> ratioSpec</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asrelativelayoutspec"><a class="markdownIt-Anchor" href="#asrelativelayoutspec"></a> ASRelativeLayoutSpec</h3><p>并根据垂直和水平位置说明符对组件进行布局.<br>与“ 9部分”图像区域相似，可以将孩子放置在4个角的任意一个或4个边缘中的任意一个的中间以及中心。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> backgroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.blue)</span><br><span class="line">  <span class="keyword">let</span> foregroundNode = <span class="type">ASDisplayNodeWithBackgroundColor</span>(<span class="type">UIColor</span>.red, <span class="type">CGSize</span>(width: <span class="number">70.0</span>, height: <span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> relativeSpec = <span class="type">ASRelativeLayoutSpec</span>(horizontalPosition: .start,</span><br><span class="line">                                          verticalPosition: .start,</span><br><span class="line">                                          sizingOption: [],</span><br><span class="line">                                          child: foregroundNode)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> backgroundSpec = <span class="type">ASBackgroundLayoutSpec</span>(child: relativeSpec, background: backgroundNode)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asabsolutelayoutspec"><a class="markdownIt-Anchor" href="#asabsolutelayoutspec"></a> ASAbsoluteLayoutSpec</h3><p>通过设置其子节点的layoutPosition属性来指定其子节点的确切位置（x / y坐标）。<br>绝对布局比其他类型的布局更不灵活且难以维护。</p><p>唯一属性sizing: 确定 ASAbsoluteLayoutSpec 占用多少空间。选项包括：Default 和 Size to Fit。请注意，Size to Fit 选项将复制旧的ASStaticLayoutSpec的行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> maxConstrainedSize = constrainedSize.<span class="built_in">max</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Layout all nodes absolute in a static layout spec</span></span><br><span class="line">  guitarVideoNode.style.layoutPosition = <span class="type">CGPoint</span>.zero</span><br><span class="line">  guitarVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  nicCageVideoNode.style.layoutPosition = <span class="type">CGPoint</span>(x: maxConstrainedSize.width / <span class="number">2.0</span>, y: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line">  nicCageVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width / <span class="number">2.0</span>, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  simonVideoNode.style.layoutPosition = <span class="type">CGPoint</span>(x: <span class="number">0.0</span>, y: maxConstrainedSize.height - (maxConstrainedSize.height / <span class="number">3.0</span>))</span><br><span class="line">  simonVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width / <span class="number">2.0</span>, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  hlsVideoNode.style.layoutPosition = <span class="type">CGPoint</span>(x: <span class="number">0.0</span>, y: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line">  hlsVideoNode.style.preferredSize = <span class="type">CGSize</span>(width: maxConstrainedSize.width / <span class="number">2.0</span>, height: maxConstrainedSize.height / <span class="number">3.0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="type">ASAbsoluteLayoutSpec</span>(children: [guitarVideoNode, nicCageVideoNode, simonVideoNode, hlsVideoNode])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ascornerlayoutspec"><a class="markdownIt-Anchor" href="#ascornerlayoutspec"></a> ASCornerLayoutSpec</h3><p>ASCornerLayoutSpec 提供一个简单方法，把 element 放在角落。</p><div align="left"><img src="/img/texture-CornerLayout.jpeg" alt="Texture-BackgroundLayout" style="width:80px;height:80px"></div><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Layout the center of badge to the top right corner of avatar.</span></span><br><span class="line">  <span class="keyword">let</span> cornerSpec = <span class="type">ASCornerLayoutSpec</span>(child: avatarNode, corner: badgeNode, location: .topRight)</span><br><span class="line">  <span class="comment">// Slightly shift center of badge inside of avatar.</span></span><br><span class="line">  cornerSpec.offset = <span class="type">CGPoint</span>(x: -<span class="number">3</span>, y: <span class="number">3</span>)</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="aslayoutspec"><a class="markdownIt-Anchor" href="#aslayoutspec"></a> ASLayoutSpec</h3><ol><li>所有 layout spec 都继承自它</li><li>主要任务：处理 children 布局管理，用户可以 子类化它实现自己自定义 layout spec。</li><li>作为间隔区：充当 <code>ASStackLayoutSpec</code> 的spacer，当使用 <code>.flexGrow</code> and/or <code>.flexShrink</code> 时候</li></ol><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">let</span> spacer = <span class="type">ASLayoutSpec</span>()</span><br><span class="line">  spacer.style.flexGrow = <span class="number">1.0</span></span><br><span class="line"></span><br><span class="line">  stack.children = [imageNode, spacer, textNode]</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="asstacklayoutspecflexbox-container"><a class="markdownIt-Anchor" href="#asstacklayoutspecflexbox-container"></a> ASStackLayoutSpec(Flexbox Container)</h3><p>相关属性对照<a href="https://changzw.github.io/2017/12/09/flexbox-model/">flexbox-model</a></p><p>有 7 个属性：</p><ul><li>direction. 确定 stack 方向。如果已经设置了 horizontalAlignment and verticalAlignment, 他们会被重新解析一遍。导致 justifyContent and alignItems也会相应的变化。</li><li>spacing. 每个 child element 之间的距离.</li><li>horizontalAlignment. 指定 children 是如何水平对齐的。根据stack direction方向。设置对齐方式 会导致 justifyContent or alignItems 更新。</li><li>verticalAlignment. 指定 children 是如何垂直对齐的。根据stack direction方向。设置对齐方式 会导致 justifyContent or alignItems 更新。</li><li>justifyContent. 沿主轴的对齐方式.</li><li>alignItems. 沿交叉轴的方向布局.</li><li>flexWrap. element 堆叠成单行还是多行。默认为单行。</li><li>alignContent. 元素组成有多行，cross-axis方向空间充足，内容行的对齐方式。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> mainStack = <span class="type">ASStackLayoutSpec</span>(direction: .horizontal,</span><br><span class="line">                                    spacing: <span class="number">6.0</span>,</span><br><span class="line">                                    justifyContent: .start,</span><br><span class="line">                                    alignItems: .center,</span><br><span class="line">                                    children: [titleNode, subtitleNode])</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set some constrained size to the stack</span></span><br><span class="line">  mainStack.style.minWidth = <span class="type">ASDimensionMakeWithPoints</span>(<span class="number">60.0</span>)</span><br><span class="line">  mainStack.style.maxHeight = <span class="type">ASDimensionMakeWithPoints</span>(<span class="number">40.0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mainStack</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="layout-element-属性"><a class="markdownIt-Anchor" href="#layout-element-属性"></a> Layout Element 属性</h2><ul><li>ASStackLayoutElement Properties：只会在 StackLayoutSpec 中的元素(node or layout spec)生效</li><li>ASAbsoluteLayoutElement Properties：只会在AbsoluateLayoutSpec中的元素（ subnode 或 layoutSpec）生效；</li><li>ASLayoutElement Properties：适用于所有 Node 和 layoutSpec；</li></ul><h3 id="asstacklayoutelementflex-item属性"><a class="markdownIt-Anchor" href="#asstacklayoutelementflex-item属性"></a> ASStackLayoutElement(flex-item)属性</h3><p>相关属性对照<a href="https://changzw.github.io/2017/12/09/flexbox-model/">flexbox-model</a></p><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>.style.spacingBefore</td><td>CGFloat</td><td>direction 上与前一个 node 的间隔</td></tr><tr><td>.style.spacingAfter</td><td>CGFloat</td><td>direction 上与后一个 node 的间隔</td></tr><tr><td>.style.flexGrow</td><td>Bool</td><td>子节点尺寸总和小于 minimum即存在剩余空间时，是否放大</td></tr><tr><td>.style.flexShrink</td><td>Bool</td><td>子节点总和大于 maximum，即空间不足时，是否缩小</td></tr><tr><td>.style.flexBasis</td><td>ASDimension</td><td>在使用flexGrow 或 flexShrink 属性之前，并且剩余空间被均分之前，指定item的初始size</td></tr><tr><td>.style.alignSelf</td><td>ASStackLayoutAlignSelf</td><td>item 在cross-axis方向布局方式，此属性会覆盖 layoutSpec(flex-container) 属性alignItems，可选值有：Auto、Start、End、Center、Stretch</td></tr><tr><td>.style.ascender</td><td>CGFloat</td><td>用于基线对齐，描述对象从顶部到其基线的距离</td></tr><tr><td>.style.descender</td><td>CGFloat</td><td>用于基线对齐，描述对象从基线到其底部的距离</td></tr></tbody></table><h3 id="asabsolutelayoutelement-属性"><a class="markdownIt-Anchor" href="#asabsolutelayoutelement-属性"></a> ASAbsoluteLayoutElement 属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>.style.layoutPosition</td><td>CGPoint</td><td>该对象在 ASAbsoluteLayoutSpec 中的位置</td></tr></tbody></table><h3 id="aslayoutelement-属性"><a class="markdownIt-Anchor" href="#aslayoutelement-属性"></a> ASLayoutElement 属性</h3><table><thead><tr><th>属性</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>.style.width</td><td>ASDimension</td><td>指定 ASLayoutElement 内容区域的宽度。minWidth 和 maxWidth 属性会覆盖 width，默认值为 ASDimensionAuto</td></tr><tr><td>.style.height</td><td>ASDimension</td><td>指定ASLayoutElement 内容区域的高度。minHeight 和 maxHeight 属性会覆盖 height，默认值为 ASDimensionAuto</td></tr><tr><td>.style.minWidth</td><td>ASDimension</td><td>minWidth 属性用于设置一个特定布局元素的最小宽度.它可以防止 width 属性值小于 minWidth 指定的值，minWidth 的值会覆盖 maxWidth 和 width. 默认值为 ASDimensionAuto</td></tr><tr><td>.style.maxWidth</td><td>ASDimension</td><td>maxWidth 属性用于设置一个特定布局元素的最大宽度.它可以防止 width 属性值大于 maxWidth 指定的值. maxWidth 的值会覆盖 width，minWidth 会覆盖 maxWidth. 默认值为 ASDimensionAuto</td></tr><tr><td>.style.minHeight</td><td>ASDimension</td><td>minHeight 属性用于设置一个特定布局元素的最小高度.它可以防止 height 属性值小于 minHeight 指定的值.minHeight 的值会覆盖 maxHeight 和 height. 默认值为 ASDimensionAuto</td></tr><tr><td>.style.maxHeight</td><td>ASDimension</td><td>maxHeight 属性用于设置一个特定布局元素的最大高度，它可以防止 height 属性值大于 maxHeight 指定的值.maxHeight 的值会覆盖 height，minHeight 会覆盖 maxHeight.默认值为 ASDimensionAuto</td></tr><tr><td>.style.preferredSize</td><td>CGSize</td><td>提供布局元素的建议 size.如果提供了 minSize 或 maxSize，并且 preferredSize 超过了这些值，则强制使用 minSize 或 maxSize.如果未提供 preferredSize，则布局元素的 size 默认为 calculateSizeThatFits: 方法提供的固有大小.此方法是可选的，但是对于没有固有大小或需要用与固有大小不同的的 size 进行布局的节点，则必须指定 preferredSize 或 preferredLayoutSize 中的一个，比如没这个属性可以在 ASImageNode 上设置，使这个节点的 size 和图片 size 不同, 警告：当 size 的宽度或高度是相对值时调用 getter 将进行断言</td></tr><tr><td>.style.minSize</td><td>CGSize</td><td>可选属性，为布局元素提供最小尺寸，如果提供，minSize 将会强制使用.如果父级布局元素的 minSize 小于其子级的 minSize，则强制使用子级的 minSize，并且其大小将扩展到布局规则之外,例如，如果给全屏容器中的某个元素设置 50％ 的 preferredSize 相对宽度，和 200pt 的 minSize 宽度，preferredSize 会在 iPhone 屏幕上产生 160pt 的宽度，但由于 160pt 低于 200pt 的 minSize 宽度，因此最终该元素的宽度会是 200pt</td></tr><tr><td>.style.maxSize</td><td>CGSize</td><td>可选属性，为布局元素提供最大尺寸，如果提供，maxSize 将会强制使用</td></tr><tr><td>.style.preferredLayoutSize</td><td>ASLayoutSize</td><td>为布局元素提供建议的相对 size.ASLayoutSize 使用百分比而不是点来指定布局.例如，子布局元素的宽度应该是父宽度的 50％.如果提供了可选的 minLayoutSize 或 maxLayoutSize，并且 preferredLayoutSize 超过了这些值，则将使用 minLayoutSize 或 maxLayoutSize</td></tr><tr><td>.style.minLayoutSize</td><td>ASLayoutSize</td><td>可选属性，为布局元素提供最小的相对尺寸， 如果提供，minLayoutSize 将会强制使用.如果父级布局元素的 minLayoutSize 小于其子级的 minLayoutSize，则会强制使用子级的 minLayoutSize，并且其大小将扩展到布局规则之外</td></tr><tr><td>.style.maxLayoutSize</td><td>ASLayoutSize</td><td>可选属性，为布局元素提供最大的相对尺寸.如果提供，maxLayoutSize 将会强制使用.如果父级布局元素的 maxLayoutSize 小于其子级的 maxLayoutSize，那么将强制使用子级的 maxLayoutSize，并且其大小将扩展到布局规则之外</td></tr></tbody></table><h2 id="layout-api-sizing"><a class="markdownIt-Anchor" href="#layout-api-sizing"></a> Layout API Sizing</h2><p>在Layout API中，理解复合尺寸类型的最简单方法是查看所有的 unit 之间的关系。</p><div align="left"><img src="/img/texture-sizing.jpeg" alt="texture-sizing" style="width:400px;height:100px"></div><h3 id="values-cgfloat-asdimension"><a class="markdownIt-Anchor" href="#values-cgfloat-asdimension"></a> Values (CGFloat, ASDimension)</h3><p>ASDimension本质上是一个普通的CGFloat，支持表示点值，相对百分比值或自动值。</p><p>unit 允许相同的API接受固定值和相对值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dimension returned is relative (%)</span></span><br><span class="line"><span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line"><span class="type">ASDimensionMakeWithFraction</span>(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dimension returned in points</span></span><br><span class="line"><span class="type">ASDimensionMake</span>(<span class="string">"70pt"</span>)</span><br><span class="line"><span class="type">ASDimensionMake</span>(<span class="number">70</span>)</span><br><span class="line"><span class="type">ASDimensionMakeWithPoints</span>(<span class="number">70</span>)</span><br></pre></td></tr></table></figure><h3 id="使用-asdimension-的例子"><a class="markdownIt-Anchor" href="#使用-asdimension-的例子"></a> 使用 ASDimension 的例子</h3><p>ASDimension 用于设置 <code>ASStackLayoutSpec</code> 中element 的 <code>flexBasis</code>. <code>flexBasis</code> 属性在 stack layout 中指定对象的初始大小，</p><p>在下面的视图中，我们希望左侧堆栈占据水平宽度的40％，右侧堆栈占据宽度的60％。</p><div align="left"><img src="/img/flexbasis.jpeg" alt="flexbasis" style="width:300px;height:450px"></div><p>为此，我们在水平堆栈的两个子级上设置.flexBasis属性：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.leftStack.style.flexBasis = <span class="type">ASDimensionMake</span>(<span class="string">"40%"</span>)</span><br><span class="line"><span class="keyword">self</span>.rightStack.style.flexBasis = <span class="type">ASDimensionMake</span>(<span class="string">"60%"</span>)</span><br><span class="line"></span><br><span class="line">horizontalStack.children = [<span class="keyword">self</span>.leftStack, <span class="keyword">self</span>.rightStack]</span><br></pre></td></tr></table></figure><h3 id="sizes-cgsize-aslayoutsize"><a class="markdownIt-Anchor" href="#sizes-cgsize-aslayoutsize"></a> Sizes (CGSize, ASLayoutSize)</h3><p>ASLayoutSize与CGSize相似，但是其宽度和高度值可以表示点或百分比值。宽度和高度的类型是独立的；一个可以是点或百分比值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ASLayoutSizeMake</span>(<span class="type">ASDimension</span> width, <span class="type">ASDimension</span> height);</span><br></pre></td></tr></table></figure><p>ASLayoutSize用于设置布局元素的 <code>.preferredLayoutSize</code> , <code>.minLayoutSize</code> 和 <code>.maxLayoutSize</code> 属性。它允许相同的API接受固定大小以及相对大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dimension type "Auto" indicates that the layout element may </span></span><br><span class="line"><span class="comment">// be resolved in whatever way makes most sense given the circumstances</span></span><br><span class="line"><span class="keyword">let</span> width = <span class="type">ASDimensionMake</span>(.auto, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> height = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.preferredLayoutSize = <span class="type">ASLayoutSizeMake</span>(width, height)</span><br></pre></td></tr></table></figure><p>如果不需要相对值，则可以设置布局元素的.preferredSize，.minSize和.maxSize属性。这些属性采用常规CGSize值。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layoutElement.style.preferredSize = <span class="type">CGSize</span>(width: <span class="number">30</span>, height: <span class="number">60</span>)</span><br></pre></td></tr></table></figure><p>大多数时候，都不想同时限制宽度和高度。在这种情况下，可以使用ASDimension值分别设置布局元素的尺寸属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">layoutElement.style.width     = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.minWidth  = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.maxWidth  = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line"></span><br><span class="line">layoutElement.style.height    = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.minHeight = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br><span class="line">layoutElement.style.maxHeight = <span class="type">ASDimensionMake</span>(<span class="string">"50%"</span>)</span><br></pre></td></tr></table></figure><h3 id="size-range-assizerange"><a class="markdownIt-Anchor" href="#size-range-assizerange"></a> Size Range (ASSizeRange)</h3><p>UIKit没有提供组合最小和最大CGSize的 struct。因此，创建了ASSizeRange以支持最小和最大CGSize对。</p><p>ASSizeRange通常用于布局API的内部。但是，作为输入传递给layoutSpecThatFits：的constrainedSize值是ASSizeRange。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">layoutSpecThatFits</span><span class="params">(<span class="number">_</span> constrainedSize: ASSizeRange)</span></span> -&gt; <span class="type">ASLayoutSpec</span></span><br></pre></td></tr></table></figure><p>传递给ASDisplayNode子类的layoutSpecThatFits：方法的constrainedSize是节点应适合的最小和最大大小。constrainedSize中包含的最小CGSize和最大CGSize可用于调整节点的布局元素的大小。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Fri May 29 2020 12:55:11 GMT+0800 (CST) --&gt;
    
    </summary>
    
    
      <category term="第三方框架" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"/>
    
      <category term="UI 布局" scheme="https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="swift" scheme="https://changzw.github.io/tags/swift/"/>
    
      <category term="Texture" scheme="https://changzw.github.io/tags/Texture/"/>
    
      <category term="翻译" scheme="https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
</feed>
