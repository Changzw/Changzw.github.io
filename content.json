{"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-12-26T08:16:51.761Z","path":"/404.html","text":""},{"title":"关于","date":"2020-04-25T03:12:39.220Z","path":"about/index.html","text":"个人详细介绍"},{"title":"书单","date":"2019-12-26T08:16:51.762Z","path":"books/index.html","text":""},{"title":"友情链接","date":"2019-12-26T08:16:51.762Z","path":"links/index.html","text":""},{"title":"Repositories","date":"2019-12-26T08:16:51.763Z","path":"repository/index.html","text":""},{"title":"标签","date":"2020-04-25T03:29:22.060Z","path":"tags/index.html","text":""},{"title":"分类","date":"2020-04-25T03:12:19.979Z","path":"categories/index.html","text":""}],"posts":[{"title":"SnapKit 分析","date":"2020-04-10T07:24:23.000Z","path":"2020/04/10/source-code/SnapKit-分析/","text":"对应 Masonry 源码分析, 看这篇文章前最好先看看这篇（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言）分析源码：这个第三方库，他设计的目标是什么？需要哪些基础知识整体结构是什么样的由外而内逐层分析层次结构每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？ SnapKit 是什么SnapKit 源码地址 为什么要设计 SnapKit首先和系统提供接口对比下123456789101112131415161718label.translatesAutoresizingMaskIntoConstraints = falselet constraint1 = NSLayoutConstraint.init(item: label, attribute: .left, relatedBy: .equal, toItem: view, attribute: .left, multiplier: 1, constant: 150);constraint1.isActive = true... top, widthlet constraint4 = NSLayoutConstraint.init(item: label, attribute: .height, relatedBy: .equal, toItem: view, attribute: .notAnAttribute, multiplier: 1, constant: 20);constraint4.isActive = trueAnchor: 只支持 ios &gt;= 91234567label.translatesAutoresizingMaskIntoConstraints = falseNSLayoutConstraint.activate([ label.leftAnchor.constraint(equalTo: view.leftAnchor, constant: 150), label.topAnchor.constraint(equalTo: view.topAnchor, constant: 200), label.widthAnchor.constraint(equalToConstant: 200), label.heightAnchor.constraint(equalToConstant: 200),])12345label.snp.makeConstraints &#123; (make) in make.left.equalTo(view).offset(150) make.top.equalToSuperview().offset(200) make.size.equalTo(CGSize(width: 200, height: 20))&#125;P.S. SnapKit 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = trueSnapKit 设计的目的，就是以链式编程手段封装 NSLayoutConstraint 冗余代码！如何处理原来繁杂接口如何实现链式如何封装 NSLayoutConstraint 的如何把多个 NSLayoutConstraint 封装成简单的一句搞定的使用了何种编程手段 SnapKit 代码结构分析 从调用层次分析这里我要像洋葱一样一层一层的拨开最外层接口根据这段代码分析1234label.snp.makeConstraints &#123; (make) in make.left.equalTo(view).offset(150) make.size.equalTo(CGSize(width: 200, height: 20))&#125;ConstraintMaker.swift123456789101112 public class ConstraintMaker &#123; public var left: ConstraintMakerExtendable &#123; get &#125; public var top: ConstraintMakerExtendable &#123; get &#125; public var bottom: ConstraintMakerExtendable &#123; get &#125; public var right: ConstraintMakerExtendable &#123; get &#125; ...... internal static func prepareConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -&gt; Void) -&gt; [Constraint] internal static func makeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -&gt; Void) internal static func remakeConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -&gt; Void) internal static func updateConstraints(item: LayoutConstraintItem, closure: (_ make: ConstraintMaker) -&gt; Void) ......&#125;从👆源码可以看到三个见名知意的方法方法参数 ConstraintMaker 这个就是 make属性 ConstraintMakerExtendable 这个就是 make 后面的 make.left我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口我还要找到 下图的这些信息接着往里面看ConstraintMakerExtendable 继承自 ConstraintMakerRelatable123456789101112131415161718public class ConstraintMakerExtendable : ConstraintMakerRelatable &#123; public var left: ConstraintMakerExtendable &#123; self.description.attributes += .left return self &#125; public var top: ConstraintMakerExtendable &#123; self.description.attributes += .top return self &#125; public var bottom: ConstraintMakerExtendable &#123; self.description.attributes += .bottom return self &#125; public var right: ConstraintMakerExtendable &#123; self.description.attributes += .right return self &#125; ......问题&amp;猜测：description 是啥？不知道不过他有 attributes 属性，看样子对应 NSLayoutConstraint.Attributeleft, top …… 这些都返回 ConstraintMakerExtendable ，猜测他是链的节点对象继续看 ConstraintMakerRelatable1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ConstraintMakerRelatable &#123; internal let description: ConstraintDescription internal init(_ description: ConstraintDescription) &#123; self.description = description &#125; internal func relatedTo(_ other: ConstraintRelatableTarget, relation: ConstraintRelation, file: String, line: UInt) -&gt; ConstraintMakerEditable &#123; let related: ConstraintItem let constant: ConstraintConstantTarget if let other = other as? ConstraintItem &#123; guard other.attributes == ConstraintAttributes.none || other.attributes.layoutAttributes.count &lt;= 1 || other.attributes.layoutAttributes == self.description.attributes.layoutAttributes || other.attributes == .edges &amp;&amp; self.description.attributes == .margins || other.attributes == .margins &amp;&amp; self.description.attributes == .edges || other.attributes == .directionalEdges &amp;&amp; self.description.attributes == .directionalMargins || other.attributes == .directionalMargins &amp;&amp; self.description.attributes == .directionalEdges else &#123; fatalError(\"Cannot constraint to multiple non identical attributes. (\\(file), \\(line))\"); &#125; related = other constant = 0.0 &#125; else if let other = other as? ConstraintView &#123; related = ConstraintItem(target: other, attributes: ConstraintAttributes.none) constant = 0.0 &#125; else if let other = other as? ConstraintConstantTarget &#123; related = ConstraintItem(target: nil, attributes: ConstraintAttributes.none) constant = other &#125; else if #available(iOS 9.0, OSX 10.11, *), let other = other as? ConstraintLayoutGuide &#123; related = ConstraintItem(target: other, attributes: ConstraintAttributes.none) constant = 0.0 &#125; else &#123; fatalError(\"Invalid constraint. (\\(file), \\(line))\") &#125; let editable = ConstraintMakerEditable(self.description) editable.description.sourceLocation = (file, line) editable.description.relation = relation editable.description.related = related editable.description.constant = constant return editable &#125; @discardableResult public func equalTo(_ other: ConstraintRelatableTarget, _ file: String = #file, _ line: UInt = #line) -&gt; ConstraintMakerEditable &#123; return self.relatedTo(other, relation: .equal, file: file, line: line) &#125; ......&#125;找到了ConstraintConstantTarget(struct)ConstraintRelation(struct)ConstraintAttributes(struct)ConstraintDescription(class)ConstraintItem(class)ConstraintMakerEditable(class) model 层数据分析 ConstraintConstantTarget12345678910typealias LayoutAttribute = NSLayoutConstraint.Attributepublic protocol ConstraintConstantTarget &#123;&#125;extension CGPoint: ConstraintConstantTarget &#123;&#125;extension CGSize: ConstraintConstantTarget &#123;&#125;extension ConstraintInsets: ConstraintConstantTarget &#123;&#125;extension NSDirectionalEdgeInsets : ConstraintConstantTarget &#123;&#125;extension ConstraintConstantTarget &#123; internal func constraintConstantTargetValueFor(layoutAttribute: LayoutAttribute) -&gt; CGFloat&#125;看源码知道 ConstraintConstantTarget 是 autolayout 方程式中的 constant，他是这个 constant 扩展封装 ConstraintRelation123456internal enum ConstraintRelation : Int &#123; case equal case lessThanOrEqual case greaterThanOrEqual internal var layoutRelation: LayoutRelation &#123; get &#125;&#125;ConstraintRelation 是 方程式中的 关系符号 ConstraintAttributes123456789101112131415161718192021222324252627282930internal struct ConstraintAttributes : OptionSet, ExpressibleByIntegerLiteral &#123;... internal static var none: ConstraintAttributes &#123; return 0 &#125; internal static var left: ConstraintAttributes &#123; return 1 &#125; internal static var top: ConstraintAttributes &#123; return 2 &#125; internal static var right: ConstraintAttributes &#123; return 4 &#125; internal static var bottom: ConstraintAttributes &#123; return 8 &#125; internal static var leading: ConstraintAttributes &#123; return 16 &#125; internal static var trailing: ConstraintAttributes &#123; return 32 &#125; internal static var width: ConstraintAttributes &#123; return 64 &#125;... internal var layoutAttributes:[LayoutAttribute] &#123; var attrs = [LayoutAttribute]() if (self.contains(ConstraintAttributes.left)) &#123; attrs.append(.left) &#125; if (self.contains(ConstraintAttributes.top)) &#123; attrs.append(.top) &#125; .... return attrs &#125;&#125;internal func + (left: ConstraintAttributes, right: ConstraintAttributes) -&gt; ConstraintAttributes &#123; return left.union(right)&#125;internal func +=(left: inout ConstraintAttributes, right: ConstraintAttributes) &#123; left.formUnion(right)&#125;ConstraintAttributes 使用了swift 的选择集(可选枚举)重载了运算符依然猜测 它对应 NSLayoutConstraint.Attribute1234567891011121314151617181920//ConstraintItem.swiftpublic final class ConstraintItem &#123; internal weak var target: AnyObject? internal let attributes: ConstraintAttributes internal init(target: AnyObject?, attributes: ConstraintAttributes) internal var layoutConstraintItem: LayoutConstraintItem? &#123; return self.target as? LayoutConstraintItem &#125;&#125;public func == (lhs: ConstraintItem, rhs: ConstraintItem) -&gt; Bool// LayoutConstraintItem.swiftpublic protocol LayoutConstraintItem: class &#123;&#125;@available(iOS 9.0, OSX 10.11, *)extension ConstraintLayoutGuide : LayoutConstraintItem &#123;&#125;extension ConstraintView : LayoutConstraintItem &#123;&#125;//public typealias ConstraintLayoutGuide = UILayoutGuidepublic typealias ConstraintView = UIViewnice~ConstraintItem 就是 view 和 他对应布局属性的元组 (view, attr) ConstraintDescription1234567891011121314public class ConstraintDescription &#123; internal let item: LayoutConstraintItem internal var attributes: ConstraintAttributes internal var relation: ConstraintRelation? internal var sourceLocation: (String, UInt)? internal var label: String? internal var related: ConstraintItem? internal var multiplier: ConstraintMultiplierTarget internal var constant: ConstraintConstantTarget internal var priority: ConstraintPriorityTarget internal lazy var constraint: SnapKit.Constraint? &#123; get set &#125; // main internal init(item: LayoutConstraintItem, attributes: ConstraintAttributes)&#125;ConstraintDescription 包含了 autolayout 布局方程式中所有信息，可是不知道为啥不在这里调用 NSLayoutConstraint 添加属性，非要搞一个 SnapKit.Constraint来做这些事ConstraintMakerEditable 是链式编程技巧里面的往后看 分析 SnapKit 链式封装 主要组件结文件分组 使用函数调用栈分析SnapKit 主流程SnapKit 链式流程maker 创建一个其实节点 ContraintExtentable，他维护自己的 descriptionmaker 保存 descriptions[] 数组传递 description 来延续链节点to be continued 代码组件分析Auto Layout Guide","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"},{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"源码","slug":"源码","permalink":"https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"UI 布局","slug":"第三方框架/UI-布局","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"}]},{"title":"使用 closures 代替 Gesture Recognizers 选择器","date":"2020-03-08T01:56:45.000Z","path":"2020/03/08/使用-closures-添加-Gesture-Recognizers/","text":"原文 Adding Gesture Recognizers with Closures Instead of Selectors添加UITapGestureRecognizer或任何 recognizer/target action 的最糟糕的部分是仅针对选择器参数实现新功能。今天，我想分享一个巧妙的技巧，让你添加不带选择器的手势识别器。假设我们在View Controller中有一个UIImageView，我们想向其中添加一个UITapGestureRecognizer，以便在点击它时打印出一条语句.通常，我们会创建一个 UITapGestureRecognizer 的实例，并将其目标设置为视图控制器及其选择器，因为我们会快速将它们组合在一起(myImageViewTapped(sender：UITapGestureRecognizer))。这可能会有点多余，并且可能导致要添加交互性的每个子视图的函数的代码混乱。我以为我可以快速扩展一下，以便为我的图像视图添加敲击手势识别器，但是然后我必须为每个识别器创建一个新功能，对吗？错误！利用关联对象的功能，我们实际上可以将闭包存储为扩展中的计算属性！1234567891011121314151617181920212223242526272829303132333435363738394041424344import UIKitextension UIView &#123; // In order to create computed properties for extensions, we need a key to // store and access the stored property fileprivate struct AssociatedObjectKeys &#123; static var tapGestureRecognizer = \"MediaViewerAssociatedObjectKey_mediaViewer\" &#125; fileprivate typealias Action = (() -&gt; Void)? // Set our computed property type to a closure fileprivate var tapGestureRecognizerAction: Action? &#123; set &#123; if let newValue = newValue &#123; // Computed properties get stored as associated objects objc_setAssociatedObject(self, &amp;AssociatedObjectKeys.tapGestureRecognizer, newValue, objc_AssociationPolicy.OBJC_ASSOCIATION_RETAIN) &#125; &#125; get &#123; let tapGestureRecognizerActionInstance = objc_getAssociatedObject(self, &amp;AssociatedObjectKeys.tapGestureRecognizer) as? Action return tapGestureRecognizerActionInstance &#125; &#125; // This is the meat of the sauce, here we create the tap gesture recognizer and // store the closure the user passed to us in the associated object we declared above public func addTapGestureRecognizer(action: (() -&gt; Void)?) &#123; self.isUserInteractionEnabled = true self.tapGestureRecognizerAction = action let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(handleTapGesture)) self.addGestureRecognizer(tapGestureRecognizer) &#125; // Every time the user taps on the UIImageView, this function gets called, // which triggers the closure we stored @objc fileprivate func handleTapGesture(sender: UITapGestureRecognizer) &#123; if let action = self.tapGestureRecognizerAction &#123; action?() &#125; else &#123; print(\"no action\") &#125; &#125;&#125;现在，每当我们要将UITapGestureRecognizer添加到UIView或UIView子类（如UIImageView）时，都可以这样做，而无需为选择器创建关联的功能！这是一个例子：123sampleImageView.addTapGestureRecognizer &#123; print(\"image tapped\")&#125;没有UITapGestureRecognizers实例，没有targets，没有selectors，没有不必要的functions！","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"},{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"Apple 系统界面渲染过程","date":"2020-03-06T06:39:27.000Z","path":"2020/03/06/iOS 渲染过程/","text":"苹果的渲染框架(通俗的理解)根据日常开发和上图分析渲染流程UIKit: 开发中使用的用户交互组件都来自于 UIKit (理解为收集渲染信息+用户交互事件信息的框架)提供各种 UI 组件提供配置 UI 组件的样式接口(autoLayout, Frame, Color, Text ……)，交由 Core Animation 处理封装用户事件接口Core Animation：字面翻译是核心动画，看下 CALayer，CA 表示的就是 Core Animation，Core Animation 理解为收集渲染信息，触底给底部然后得到一个渲染结果 contents（UIKit 上所有能看到的东西都是通过 layer.contents 呈现的）给 UIKit 提供 layer管理动画收集渲染数据交由渲染引擎处理不负责用户事件相关处理！OpenGL ES &amp; Core Graphics 渲染引擎收集 Core Animation 提供的渲染数据Core Graphics 是基于 Quartz(轻量级 2D 渲染) 高级绘图引擎Graphics Hardware 译为图形硬件，也就是我们经常提及的 GPUGPU 的高度并行结构使其在大块数据并行处理的算法中比通用 CPU 更有效用户操作的核心在 Core Animation，你要渲染的数据都要放在（layer.contents）上当然用户也可以直接访问OpenGL ES(GLKView) 来处理渲染Core Graphic (CG-- 相关接口) 来生成 bitmap 数据，然后将其放到 Core Animation 上layer.contentsUIKit 中的组件都会关联到相应的 CALayer渲染引擎 OpenGL ES &amp; Core Graphic 都会把渲染结果交给 layer.contents (CGImage) 用户使用渲染框架的数据流向 官方渲染流程 Core Animation Pipeline在看完 wwdc2014 session419(Advanced Graphics and Animations for iOS Apps) 有了更深入的了解上图需要注意：苹果的 UI 渲染频率是 60hz 16.67ms 一次（Vsync）每个垂直的虚线表示一个 Vsync水平虚线，表示一个硬件资源问题来了，根据上图一个渲染周期需要 3frame，那么真实的渲染频率只有 20hz那么系统是怎么做到 60hz 的呢？答案： 流水线如果在每一帧上对应硬件操作都完成了，那么就会以 60hz 的速度渲染接下来说一下渲染过程中的每个细节部分 提交事务（commit transaction）主要是 4个阶段Layout：构建 Views调用 layoutSubviews 如果重载了创建 view，addSubView:填充内容，轻量级的数据查询（就是 string 赋值之类的）通常是 CPU, I/O 负责Display：绘制 ViewsdrawRect 绘制内容，如果重载了（主要使用 Core Graphic，避免执行复杂操作）String drawing通常是 CPU / memory 负责Prepare：做些 Core Animation 相关操作image decoding（view hierachy 绘制的，jpeg，png）image conversion（因为有些图片 GPU 不支持），通常是解码成 bitmapCommit：打包 layers，然后将他们发给 render server递归上述流程如果 layer 树很复杂，那么会很耗性能。所以尽可能的让 layer tree 平一些（少几层） 动画Animation主要是 3个阶段，有 2个阶段发生在 Application 进程中，1个在 Render Server 进程中创建动画接着更新视图层级 animateWithDuration:animations:准备动画，然后提交 layoutSubviews, drawRect: 就是提交事务这几步使用进程间通信，render server 进程绘制出动画相关的每一帧，在交由 App 进程 渲染 render一个 view 的渲染过程添加 masking 后的渲染过程GPU 的离屏渲染，就是对于一个 view 需要多次渲染组合，因为需要多个渲染层所以需要离屏渲染开辟缓存，绘制这些mask，radius，blend ……如果需要组合的那些渲染过程在 CPU 中完成，然后CPU直接把一个绘制好的 image 交给 GPU 渲染就不会有这些问题了！不过 CPU 性能问题！drawRect 中如果绘制 image 太过复杂依然会出现掉帧问题 Runloop &amp; Core AnimationRunLoop主要处理以下6类事件：12345678910111213static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();1. Observer2. block3. timer4. main_dispatch_queue5. source06. source1Observer事件：runloop中状态变化时进行通知。Core Animation 监听 RunloopObserver 闲置的时候触发。Block事件：Main_Dispatch_Queue事件：GCD中dispatch到main queue的block 会在 main loop 中执行。Timer事件：延迟的NSObject PerformSelector，延迟的dispatch_after，timer事件。Source0事件：处理如UIEvent，CFSocket这类事件。需要手动触发。触摸事件其实是Source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback() 内触发的 Source0，Source0 再触发的 _UIApplicationHandleEventQueue()。source0一定是要唤醒runloop及时响应并执行的，如果runloop此时在休眠等待系统的 mach_msg事件，那么就会通过source1来唤醒runloop执行。(用户可以手动调用performSelector 方法触发 source0)Source1事件：处理系统内核的mach_msg事件。（推测CADisplayLink也是这里触发）。App 进程的 Core Animation 在 RunLoop 中注册了一个 Observer，监听了 BeforeWaiting 和 Exit 事件（就是不让 runloop 睡！）。这个 Observer 的优先级是 2000000，低于常见的其他 Observer。当一个触摸事件到来时，RunLoop 被唤醒，App 中的代码会执行一些操作，比如创建和调整视图层级、设置 UIView 的 frame、修改 CALayer 的透明度、为视图添加一个动画；这些操作最终都会被 CALayer 捕获，并通过 CATransaction 提交到一个中间状态去（CATransaction 的文档略有提到这些内容，但并不完整）。当上面所有操作结束后，RunLoop 即将进入休眠（或者退出）时，关注该事件的 Observer 都会得到通知。这时 CA 注册的那个 Observer 就会在回调中，把所有的中间状态合并提交到 GPU 去显示；如果此处有动画，CA 会通过 DisplayLink 等机制多次触发相关流程。 布局&amp;渲染渲染图片之前一定要先计算好尺寸位置，也就是 frame，AutoLayout 最终结果也是 frame，在 iOS12以后 AutoLayout 性能大幅提升更新布局限制的过程是：子–&gt;父(super.updateConstraints最后调用)更新布局的过程是：父–&gt;子 (layoutSubview) 布局渲染相关方法布局限制autulayout 的布局限制不要将布局 放到 updateContraints 方法中，这里是放大量布局更新的地方，通常布局代码放在 view 的 init, awakeFromNib or viewcontroller 的 viewDidLoad，loadView 方法中setNeedXXXX 是标记脏布局，在下一次 RunLoop循环的时候就会调用 updateXXX 方法布局layoutSubViews 被系统调用的时候，所有相关的子view的 frame 都已经被 AutoLayout 的布局引擎布局好了，都有了自己 frame，这个时候可以更改 他们的frame了显示（CPU）嗯以上的1~3都是 CPU的操作drawRect方法 通过 CoreGraphic库绘制 2D image，放在 layer.contents 编码交给 Render Server处理同理 CALayer 的 drawLayer 方法CALayer 的 delegate12345678910111213@protocol CALayerDelegate &lt;NSObject&gt;@optional/* If defined, called by the default implementation of the -display * method, in which case it should implement the entire display * process (typically by setting the `contents' property). */- (void)displayLayer:(CALayer *)layer;/* If defined, called by the default implementation of -drawInContext: */- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;@end默认情况 UIView 是 CALayer 的CALayerDelegate，drawRect 内部就是调用 CALayerDelegate的方法 给 Layer 绘制 contents只要 layer.contents 的东西交由 Render Server，内部render 引擎渲染就是系统的事了所以有了写异步渲染框架，只要程序员在子线程配置好了 contents然后在主线程交给 layer 就可以了","tags":[{"name":"源码","slug":"源码","permalink":"https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"性能优化","slug":"性能优化","permalink":"https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"自定义 keyboard","date":"2020-02-17T09:18:39.000Z","path":"2020/02/17/自定义-keyboard/","text":"原文：CustomKeyboard 自定义键盘API开发自定义键盘的快速入门,如下图，它展示了键盘运行过程中一些重要的对象，以及它们在开发流程中的的位置：自定义键盘模板（在iOS“Application Extension”目标模板组）包含一个UIInputViewController的子类，它是你开发的键盘的主视图控制器。该模板包含键盘所必需的“下一个键盘”按钮的实现，它调用了UIInputViewController类的advanceToNextInputMode方法。如上图所示，可以在输入视图控制器的主视图（在其inputView属性）中添加子视图、控制器以及手势识别器等。对于其它类型的扩展应用，在目标上并不存在窗体，因此也就没有根视图控制器了。在模板的Info.plist文件中有预先配置好的键盘所需要的最基本的值。参见其中的NSExtensionAttributes字典关键字，配置一个键盘的关键字在《配置自定义键盘的Info.plist文件》中有介绍。默认，键盘不能访问网络，不能和它的app共享容器。如果要具备这种能力，必须要将Info.plist文件中RequestsOpenAccess的值置为YES。这需要扩展键盘的沙盒，在《设计用户信任》中有介绍相关内容。一个输入视图控制器遵从各种与文本输入对象内容交互的协议：响应触摸消息时如果要插入或删除文本，可以使用UIKeyInput协议的insertText:和deleteBackward方法。可以在视图控制器的textDocumentProxy属性中调用这些方法，该属性代表当前文本输入对象，它遵从UITextDocumentProxy协议。如下：123self.textDocumentProxy insertText:@\"hello \"]; // Inserts the string \"hello \" at the insertion point[self.textDocumentProxy deleteBackward]; // Deletes the character to the left of the insertion point[self.textDocumentProxy insertText:@\"\\n\"]; // In a text view, inserts a newline character at the insertion point在调用deleteBackward之前要先决定删除的字符数。可以通过textDocumentProxy的documentContextBeforeInput属性，来获得光标附近的文本上下文信息。如下：1NSString *precedingContext = self.textDocumentProxy.documentContextBeforeInput;为了控制光标所在位置的操作，比如支持向前删除文字，需要调用UITextDocumentProxy协议中的adjustTextPositionByCharacterOffset:方法。比如向前删除一个字符，代码如下：1234- (void) deleteForward &#123; [self.textDocumentProxy adjustTextPositionByCharacterOffset: 1]; [self.textDocumentProxy deleteBackward];&#125;通过实现UITextInputDelegate协议中的方法，可以响应当前输入文本对象的一些变化，比如内容变化以及用户触发的光标位置的变化。为了展现与当前文本输入对象适配的键盘布局，需要参照该对象的UIKeyboardType属性，根据每种你的键盘所能支持的属性，变化布局内容。在自定义键盘中，有两种方式来支持多语言：为每个语言创建一个键盘，每个键盘都作为向容器app添加的独立的Target创建一个多语言键盘，动态切换当前语言。可以使用UIInputViewController类的primaryLanguage属性来动态切换语言。根据你要支持的语言数量以及你想提供的用户体验，你可以从上面选择最合适的方案。每种自定义键盘（需要RequestsOpenAccess）都可以通过UILexicon类访问自动纠错的词典。通过使用该类，并结合你自己的词典设计，可以在用户输入过程中为他提供输入建议和自动纠错。UILexicon对象包含来自如下源的单词：来自用户通讯录的人名和姓在 设置 &gt; 通用 &gt; 键盘 &gt; 快捷方式（文本替换） 列表通用词典你可以使用自动布局来调整你的自定义键盘主视图的高度。默认情况下，自定义键盘会根据屏幕尺寸以及设备方向，和系统键盘的尺寸保持一致。自定义键盘的宽度通常与屏幕当前宽度一致。修改自定义键盘主视图的高度约束即可修改其高度。下面的代码展示如何定义和添加约束：12345678910CGFloat _expandedHeight = 500;NSLayoutConstraint *_heightConstraint = [NSLayoutConstraint constraintWithItem: self.view attribute: NSLayoutAttributeHeight relatedBy: NSLayoutRelationEqual toItem: nil attribute: NSLayoutAttributeNotAnAttribute multiplier: 0.0 constant: _expandedHeight];[self.view addConstraint: _heightConstraint]; 自定义键盘的开发关键自定义键盘开发有两个关键点：信任。 自定义键盘能访问用户输入的内容 ，因此在键盘和用户间建立信任非常关键。“下一个键盘”键。 通过键盘界面必须能让用户能切换到下一个键盘。 为用户信任所做的设计作为自定义键盘的开发者，你首先应当考虑的是如何建立和维护用户信任。你要理解隐私策略的最佳实践并知道如何实现它才能很好地践行。注意本节为你创建自定义键盘提供相关的开发手册，该手册要求尊重用户隐私。了解iOS编程要求，请阅读应用商店审核手册，iOS人机交互手册，iOS开发许可协议，请参见苹果的《应用审核支持》，《支持用户隐私》，《iOS应用编程指南》。对于键盘，如下三个方面对于建立和维护用户信任至关重要：按键数据的安全。 用户希望他们的敲键会落在文档以及输入区域内，而不是上传到服务器或者用于其他不明目的。最小化合理利用其它用户数据。 如果你的键盘还需要使用其他用户数据，例如定位服务或者通讯录，你有义务解释这给用户带来的好处是什么。准确。 把输入事件转换成文本要求精准，这本身虽然不是一个隐私话题，但他会影响到信任：每次文字转换需要体现出你的代码的精准。在信任的开发设计过程中，首先考虑的是是否要获取open access权限。尽管开启了open access权限能给自定义键盘开发带来极大便利，但这也增加了你作为开发者的责任。下面是标准的open access的能力和隐私考虑：Open Access能力和限制隐私考虑Off(default)·键盘可以执行所有基本键盘的职责·可以访问通用词典以支持自动纠错和输入建议·访问设置里的快捷短语·不与containing应用共享容器·不访问键盘容器以外的文件系统·不访问键盘容器以外的文件系统·不能直接或间接访问iCloud或游戏中心或应用内购买用户了解按键仅仅被发送到当前使用键盘的应用里On·具备非联网自定义键盘的所有能力·在用户许可情况下可以访问位置服务和通讯录·键盘和containing app可以访问共享容器·键盘可以为服务器侧处理过程发送按键或其他输入事件·containing app自动纠错字典提供编辑界面·通过containing app键盘可以使用iCloud来保证自动纠错词典和设置的更新·通过containing app，键盘可以参与到游戏中心和应用内购买·如果键盘支持移动设备管理(MDM)，它可与被管理的应用共同工作·用户了解键盘开发者会利用按键数据·你必须遵守有联网能力的键盘开发手册和iOS开发许可协议，可参见《应用审核支持》如果你的自定义键盘不需要open access权限，系统确保敲键信息不会被发送给你的键盘以及别的地方。如果只想提供一般的键盘功能，请不要给键盘配备联网能力。由于有沙盒限制，不联网的键盘一定是满足苹果的数据隐私手册并能获得用户信任的。开启open access权限（如上所述，可以在Info.plist文件中配置），能给你的开发带来更多可能性，同时也带来更多的责任。注意向应用商店提交一个open-access的键盘必须遵守苹果《应用审核支持》中的相关条款。每一个与open access相关的功能都需要你履行相应的责任，应当最大限度地尊重用户数据，不得用于与用户输入无关的其他任何目的。下表列出了open access带来的好处以及开发者需承担的责任：能力用户利益示例开发者责任与containing app共享容器为键盘的自动纠错词典管理UI界面要考虑到自动纠错数据属于用户隐私。不要把他发到你的服务器，用作与输入无关的用途。把按键数据发到你的服务器通过开发者的计算资源可以提供更好的按键处理结果和输入预测只有为用户提供更好的输入体验之用时，才能保存按键和语音数据基于云的自动纠错词典把人名、地名、热点新闻加入到自动纠错词典中不要把用户身份与输入数据关联起来，不得将用户信息用作与输入体验无关的其他目的通讯录把人名、地名、电话号码添加到自动纠错词典中不得讲通讯录用作与输入体验无关的其他目的位置服务将附近的地名添加到自动纠错词典中不要在后台使用位置服务，不得将位置信息发送到你的服务器并用于与输入体验无关的其他目的一个具有open-access权限的键盘和其containing app能将按键数据发送到服务器端，通过这些数据可以为用户提供更好的输入体验。如果你使用了这些能力，当不需要这些数据的时候，请及时在服务器端删除。参见上面的表格来履行你使用open-access权限中的义务。 提供切换到其他键盘的方法系统键盘的小地球按键用于切换到其他键盘：你的自定义键盘必须提供类似的机制能切换到其他键盘。调用UIInputViewController类的advanceToNextInputMode方法可以切换到其他键盘。系统会选择下一个键盘，没有能获得键盘列表的API，也没有切换到指定键盘的API。Xcode自定义键盘模板中就已经在下一个键盘按钮上具备了advanceToNextInputMode的功能。为了提供最好的用户体验，应当把你的下一个键盘按键放在靠近系统键盘的小地球键的位置。注意要通过应用审核，必须在你的键盘上提供明显允许用户切换键盘的UI标识。 开始自定义键盘的开发 使用Xcode自定义键盘模板创建键盘及其containing app与其他扩展应用略有不同。本节将带你领略基本键盘的开发和运行。在一个容器app中创建键盘，步骤如下在Xcode中选择File &gt; New &gt; Project &gt; iOS &gt; Application选择Single View Application模板。点击Next。填写Project Name（如CKIme），点击Next。选择要保存的位置，点击Create。这样，你就有了一个空app，该app只能完成一个简单的操作，接下来它将承载键盘。在你提交到应用商店之前，你需要完成一些有用的功能。请到应用审核支持参考应用商店审核指南。选择File &gt; New &gt; Target &gt; iOS &gt; Application Extension选择Custom Keyboard Extension，点击Next。填写Product Name（如CKbd），点击Finish。确认Project和Embed in Application中都显示的是容器app的名字（CKIme），点击Finish。如果弹出Activate “CKbd” scheme提示让激活键盘工程，点击Activate。定义键盘group name，步骤如下：在Xcode工程导航视图中，选择容器app的Info.plist文件，在右侧plist编辑器中，鼠标hover到Bundle name上，点“+”按钮创建一行空属性。在Key中填写Bundle display name，回车双击该行的Value，填写你要自定义的键盘group name。选择File &gt; Save保存设置。下表汇总了在容器app和键盘app的Info.plist文件中你可以配置的UI字符串：iOS UI字符串Info.plist关键字· 在系统设置的已购键盘列表中的键盘group name在容器app的Info.plist文件中的Bundle display name· 系统设置中的键盘名称· 键盘换列表中的键盘名称在键盘app的Info.plist文件中的Bundle display name运行自定义键盘并将Xcode调试器attach到它上面在Xcode，你的view controller实现中设置一个断点（比如可以断在viewDidLoad上）。在Xcode工具栏确保当前活动的项目为键盘项目，并对应iOS模拟器或设备。选择菜单Project &gt; Run，或点击Build and then run the current scheme按钮（即播放按钮）。Xcode会提示选择host app。选择一个带有输入框的，比如通讯录或Safari。点击Run。Xcode将运行起你指定的host app。如果这是你第一次使用键盘扩展应用，需要现在设置中添加并启用键盘：Settings &gt; General &gt; Keyboard &gt; Keyboards点击Add New Keyboard…在OTHER IPHONE KEYBOARDS中点击你刚刚创建的键盘在iOS模拟器或真机上，调出你的自定义键盘。点击任意可输入区域，将显示出系统键盘。按住小地球，选择你的自定义键盘。此时你将看到自定义键盘，但是调试器尚未attach上来。一个从模板构建而来的极简键盘仅有一个Next Keyboard按钮，点击后切换回前一个键盘。取消你的键盘（以便在第8步中你可以再次调出键盘以命中viewDidLoad断点）在Xcode中，选择Debug &gt; Attach to Process &gt; By Process Identifier(PID) or Name 在弹出对话框中，输入你的键盘扩展应用的名字（包含空格）.默认就是该扩展应用在工程导航窗口里的group name。点击Attach。Xcode将显示出等待attach的调试器。在任意能输入文字的app中调出键盘。当你的键盘主视图开始加载时，Xcode调试器将attache到你的键盘，并命中断点。 为自定义键盘配置Info.plist文件自定义键盘的Info.plist文件允许静态定义键盘的现式特征，包括主要语言，以及是否需要open access权限。打开Xcode并切换到自定义键盘的 target。在工程导航栏选择Info.plist文件，按文本格式呈现如下：123456789101112131415161718&lt;key&gt;NSExtension&lt;/key&gt;&lt;dict&gt; &lt;key&gt;NSExtensionAttributes&lt;/key&gt; &lt;dict&gt; &lt;key&gt;IsASCIICapable&lt;/key&gt; &lt;false/&gt; &lt;key&gt;PrefersRightToLeft&lt;/key&gt; &lt;false/&gt; &lt;key&gt;PrimaryLanguage&lt;/key&gt; &lt;string&gt;en-US&lt;/string&gt; &lt;key&gt;RequestsOpenAccess&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt; &lt;key&gt;NSExtensionPointIdentifier&lt;/key&gt; &lt;string&gt;com.apple.keyboard-service&lt;/string&gt; &lt;key&gt;NSExtensionPrincipalClass&lt;/key&gt; &lt;string&gt;KeyboardViewController&lt;/string&gt;&lt;/dict&gt;每个关键字在App Extension Keys中都有解释。可以使用字典NSExtensionAttributes中的关键字来描述你的自定义键盘的特征和需求，如下：IsASCIICapable - 默认为NO的布尔值。用户键盘是否可以向文档中插入ASCII字串。如果要为UIKeyboardTypeASCIICapable属性的输入对象展现单独类型的键盘，需要将该值置为YES。PrefersRightToLeft - 默认为NO的布尔值。是否为从右到左的语种设计的的自定义键盘。PrimaryLanguage - 默认为en-US的字串。以&lt;语种&gt;-&lt;区域&gt;的形式描述键盘的主语言。可以到http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c找到对应的语种和区域。RequestsOpenAccess - 默认为NO的布尔值。是否需要比基础键盘更大的沙盒范围。把该值置为YES将需要完全访问权限，你的键盘将获得如下能力，每个能力都伴随有相应的权限：访问定位服务，通讯录数据库，相机，每个都需要用户允许与键盘的容器app共享容器数据，以便完成比如在容器app中管理用户词库的界面的功能通过网络发送按键、输入事件之类的数据供云端处理使用UIPasteboard类播放音频，包括使用playInputClick方法播放按键音访问iCloud，可以用来根据用户身份同步比如键盘设置、自定义自动纠错词典通过容器app访问游戏中心和应用内购买如果你的键盘支持移动设备管理（MDM），可以与被管理的app无缝合作当考虑是否将这些关键字设置为YES之前，一定要先阅读《用户信任设计》，这里描述了如何尊重和保护用户数据。","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"AppExtensions","slug":"iOS-Programming/AppExtensions","permalink":"https://changzw.github.io/categories/iOS-Programming/AppExtensions/"}]},{"title":"runloop 实践相关","date":"2019-12-29T11:00:54.000Z","path":"2019/12/29/runloop/runloop-实践相关/","text":"RunLoop 是系统层级上的设计，用来给管理系统消息队列派发，那我们都可以用 runLoop 做什么呢？简单来说，RunLoop 是用来监听输入源，进行调度处理的。RunLoop 输入源可以是：输入设备网络周期性或者延迟时间异步回调runloop 的 observer 可以监听的 7中状态12345678910typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry , // 进入 loop kCFRunLoopBeforeTimers , // 触发 Timer 之前 kCFRunLoopBeforeSources , // 触发 Source0 之前 kCFRunLoopBeforeWaiting , // 等待 mach_port 消息（等待源Source和计时器Timer之前，进入睡眠） // 在这两个状态中真正处理事件 kCFRunLoopAfterWaiting ), // 接收 mach_port 消息（等待源Source和计时器Timer后，同时在被唤醒之前） kCFRunLoopExit , // 退出 loop kCFRunLoopAllActivities // loop 所有状态改变&#125; 检测 iOS App 卡顿 思路分析 卡顿如何造成的iOS系统页面刷新频率：60 FPS，60次/s, let refresh_time_per = 1s/60 &lt; 0.02如果在 refresh_time_per 时间内没有完成图片绘制，那么就会出现卡顿现象！而系统页面刷新事件处理…… 事件几乎都是由 runloop 调用执行的。那么如果 runloop 一次循环时间 &gt; refresh_time_per 就说明图片没有渲染完成，导致卡顿。问题来了，如何判断 runloop 一次循环时间 &gt; refresh_time_per 呢？RunLoop 的线程，进入睡眠前方法的执行时间过长而导致无法进入睡眠，或者线程唤醒后接收消息时间过长而无法进入下一步的话，就可以认为是线程受阻了。如果这个线程是主线程的话，表现出来的就是出现了卡顿。所以要利用 RunLoop 原理来监控卡顿的话，就是要关注这两个阶段。RunLoop 的两个 loop 状态在进入睡眠之前: kCFRunLoopBeforeSources在进入唤醒之后: kCFRunLoopAfterWaiting也就是要触发 Source0 回调和接收 mach_port 消息两个状态。runloop 核心源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// while// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);// 4. RunLoop 触发 Source0 (非port) 回调。sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);// 执行被加入的block__CFRunLoopDoBlocks(runloop, currentMode);// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg;&#125;// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);&#125;// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。// • 一个基于 port 的Source 的事件。// • 一个 Timer 到时间了// • RunLoop 自身的超时时间到了// • 被其他什么调用者手动唤醒__CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg&#125;// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。__CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);// 收到消息，处理消息。handle_msg: // 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())&#125;// 9.2 如果有dispatch到main_queue的block，执行block。else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);&#125;// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125;&#125;// 退出 runloop 逻辑 retVal != 0 exitif (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; // 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource;&#125; else if (timeout) &#123; // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut;&#125; else if (__CFRunLoopIsStopped(runloop)) &#123; // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped;&#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; // source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished;&#125; 卡顿监听实践创建 runloop 的observer对象:123let weakSelf = Unmanaged&lt;Monitor&gt;.passUnretained(self).toOpaque()var ctx: CFRunLoopObserverContext = CFRunLoopObserverContext(version: 0, weakSelf: info, retain: nil, release: nil, copyDescription: nil)self.runLoopObserver = CFRunLoopObserverCreate(kCFAllocatorDefault, CFRunLoopActivity.allActivities.rawValue, true, 0, runLoopCallBack(), &amp;ctx)将 observer 添加到 runloop 的 commonModes 中1CFRunLoopAddObserver(CFRunLoopGetCurrent(), self.runLoopObserver, CFRunLoopMode.commonModes)创建子线程，监听runloop的状态beforeSources: 进入睡眠前afterWaiting: 唤醒后的状态设置卡顿阀值打印堆栈信息为什么要监听 beforeSources 和 afterWaiting 这两个状态呢？因为只有这两个状态 runloop 触发事件回调，如果runloop 长时间处于这两个状态中说明卡顿！1234567891011121314151617DispatchQueue.global().async &#123; while true &#123; guard let sem = self.dispatchSemaphore?.wait(timeout: DispatchTime.now() + 1 / 50) else &#123; return &#125; if case DispatchTimeoutResult.timedOut = sem &#123; guard let _ = self.runLoopObserver else &#123; self.dispatchSemaphore = nil self.runLoopActivity = nil return &#125; if (self.runLoopActivity == CFRunLoopActivity.beforeSources || self.runLoopActivity == CFRunLoopActivity.afterWaiting) &#123; print(\"symbo: \\(Thread.callStackSymbols)\") print(\"打印卡顿堆栈...\") &#125; &#125; &#125;&#125; 如何获取卡顿的方法堆栈信息？ 直接调用系统函数获取12345678910111213141516171819202122232425262728293031323334353637static int s_fatal_signals[] = &#123; SIGABRT, SIGBUS, SIGFPE, SIGILL, SIGSEGV, SIGTRAP, SIGTERM, SIGKILL,&#125;;static int s_fatal_signal_num = sizeof(s_fatal_signals) / sizeof(s_fatal_signals[0]);void UncaughtExceptionHandler(NSException *exception) &#123; NSArray *exceptionArray = [exception callStackSymbols]; // 得到当前调用栈信息 NSString *exceptionReason = [exception reason]; // 非常重要，就是崩溃的原因 NSString *exceptionName = [exception name]; // 异常类型&#125; void SignalHandler(int code) &#123; NSLog(@\"signal handler = %d\",code);&#125; void InitCrashReport() &#123; // 系统错误信号捕获 for (int i = 0; i &lt; s_fatal_signal_num; ++i) &#123; signal(s_fatal_signals[i], SignalHandler); &#125; //oc 未捕获异常的捕获 NSSetUncaughtExceptionHandler(&amp;UncaughtExceptionHandler);&#125;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; InitCrashReport(); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); 第三方库来获取堆栈信息PLCrashReporter 利用RunLoop空闲时间卡顿是因为 runloop 一次时间 &gt; 1/60s那么如果 runloop 一次运行时间 &lt; 1/60s 呢？譬如你把手机放在那看着 app，runloop 在那睡觉(kCFRunLoopBeforeWaiting)这个时候往 runloop 里面放个 source or timer，runloop 就会醒来 进入 kCFRunLoopAfterWaiting 状态12345678910111213141516171819typealias BeforeWaitingDo = () -&gt; ()var tasks: [BeforeWaitingDo] = []@objc func exec() &#123; let t = self.tasks.remove(at: 0) t()&#125;func registerObserver() &#123; let rl = CFRunLoopGetCurrent() let observer = CFRunLoopObserverCreateWithHandler(kCFAllocatorDefault, CFRunLoopActivity.beforeWaiting.rawValue, true, 0) &#123;[weak self] (observer, actives) in guard let self = self, let _ = self.tasks.first else &#123;return&#125; // 创建一个 source0 把 runloop 被叫醒 self.perform(#selector(ChatEmojiViewController.exec), on: Thread.current, with: nil, waitUntilDone: false) &#125; CFRunLoopAddObserver(rl, observer, CFRunLoopMode.commonModes)&#125;《iOS开发高手课》iOS 性能监控（二）—— 主线程卡顿监控优化UITableViewCell高度计算的那些事","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"runloop","slug":"iOS-Programming/runloop","permalink":"https://changzw.github.io/categories/iOS-Programming/runloop/"}]},{"title":"调试内存不足问题：使用运行时魔法捕获布局反馈循环","date":"2019-11-30T23:25:43.000Z","path":"2019/12/01/performance/调试内存不足问题：使用运行时魔法捕获布局反馈循环/","text":"目标：使用代码替代 UIViewLayoutFeedbackLoopDebuggingThreshold 符号调试，来捕获 Autolayout反馈循环所导致的内存不足问题。 导致内存不足的原因如果 App，开始有大量日活用户并且崩溃率很低，但是过段时间，总会出现崩溃问题，检查 Fabric 也没啥用。出现这种情况很可能是因为，内存不足，导致应用被系统终止。导致内存不足的原因：循环引用;竞争条件;废弃的线程;死锁;布局反馈循环。Apple 提供了很多方法来解决这类问题：Instruments 里的 Allocations 和 Leaks 工具用于解决循环引用和 其他类型的泄漏在 Xcode 8 中引入的 Memory Debugger 代替了 Allocations 和 Leaks 的一部分功能Thread Sanitizer 帮助你找到竞争条件、废弃的线程或者死锁 布局反馈循环当视图正在运行它们的布局代码，但某种方法导致它们再一次开始布局传递，此时布局反馈循环就会出现。这可能是因为某个视图正在改变某个父视图的大小，或者因为你有一个模棱两可的布局。无论哪种原因，这个问题的表现是你的 CPU 使用被占满和 RAM 使用量稳步上升，因为你的视图正在一次又一次地运行它们的布局代码，却没有返回。-来自HackingWithSwift 的 Paul Hudson在 WWDC 16 中 Apple 介绍了“布局反馈循环调试器”。这个调试器有助于识别在调试过程中发生循环的时间点。这就是一个符号断点，它的工作方式非常简单：它会计算在单个 run loop 迭代中调用每个视图上的 layoutSubviews() 方法的次数。一旦这个计数值超过某个临界值（比如，100），这个应用程序将会停在这个断点并打印出日志。这篇文章 快速地介绍如何使用这个调试器。这个方法在可以重现问题的情况下十分有效。但是在线上出现就不用容易调试。但是你可以尝试把 UIViewLayoutFeedbackLoopDebuggingThreshold 的代码复制到生产代码中。 如何用代码实现 UIViewLayoutFeedbackLoopDebuggingThreshold 的功能呢符号断点是如何工作的：它会计算 layoutSubviews() 的调用次数并在单个 run loop 迭代中超过某个临界值时发送一个事件。听起来很简单，对吧？12345678910class TrackableView: UIView &#123; var counter: Int = 0 override func layoutSubviews() &#123; super.layoutSubviews() counter += 1; if (counter == 100) &#123; YourAnalyticsFramework.event(name: \"loop\") &#125; &#125;&#125;对于一个视图，这段代码运行正常。但是现在你想要在另一个视图上实现它。当然，你可以创建一个 UIView 的子类，在这里实现它并使你项目中的所有视图都继承这个子类。然后为 UITableView，UIScrollView，UIStackView 等做同样的事情。如果将此逻辑注入你想要的任何类，而无需编写大量重复的代码。这时候就可以 借助运行时编程 了。 使用 runtime 实现子类我们会做同样的事情——创建一个子类，重写 layoutSubviews() 方法并计算其调用次数。唯一的区别是所有这些都使用 runtime 完成，而不是在项目中创建重复的类。创建自定义子类，并将原始视图的类更改为新的子类：123456789101112131415161718192021struct LayoutLoopHunter &#123; struct RuntimeConstants &#123; static let Prefix = “runtime” &#125; static func setUp(for view: UIView, threshold: Int = 100, onLoop: @escaping () -&gt; ()) &#123; // 我们根据功能的前缀和原始类名为新类创建名称。 let classFullName = “\\(RuntimeConstants.Prefix)_\\(String(describing: view.self))” let originalClass = type(of: view) if let trackableClass = objc_allocateClassPair(originalClass, classFullName, 0) &#123; // 在当前运行时会话期间尚未创建此类。 // 注册这个类，并且用原始视图的类来和它交换。 objc_registerClassPair(trackableClass) object_setClass(view, trackableClass) &#125; else if let trackableClass = NSClassFromString(classFullName) &#123; // 我们之前在此运行时会话中分配了一个具有相同名称的类。 // 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。 object_setClass(view, trackableClass) &#125; &#125;&#125;objc_allocateClassPair() 方法的文档告诉我们这个方法何时失败：新类，或者如果无法创建类，则为 Nil （例如，所需名称已被使用）。这就意味着不能拥有两个同名的类。我们的策略是为单个视图类创建一个单独的运行时类。这就是我们在原始类名前加上前缀来形成新类的名称的原因。现在添加一个计数器到子类中。理论上，有两种方法可以做到这一点。添加一个保存计数器的属性。为这个类创建一个关联对象（Associated object）。但是目前，只有一个方法奏效。你可以想象属性是存储在分配给类的内存里的东西，然而关联对象则储存在一个完全不同的地方。因为分配给已存在对象的内存是固定的，所以我们在自定义类上新添加的属性将会从其他资源里“窃取”内存。它可能导致意料之外的行为和难以调试的程序崩溃（点击 这里 查看更多信息）。但是在使用关联对象的情况下，它们将会存储在运行时创建的一个哈希表里，这是完全安全的。123static var CounterKey = \"_counter\"...objc_setAssociatedObject(trackableClass, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)当新的子类被创建时，计数器初值设置为 0。实现这个新的layoutSubviews() 方法，并将它添加到我们的类中：1234567891011let layoutSubviews: @convention(block) (Any?) -&gt; () = &#123; nullableSelf in guard let _self = nullableSelf else &#123; return &#125; if let counter = objc_getAssociatedObject(_self, &amp;RuntimeConstants.CounterKey) as? Int &#123; if counter == threshold &#123; onLoop() &#125; objc_setAssociatedObject(trackableClass, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125;&#125;let implementation = imp_implementationWithBlock(layoutSubviews)class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, \"v@:\")为了理解上面这段代码实际上在干什么，让我们看一下这个来自 &lt;objc/runtime.h&gt; 的结构体：12345struct objc_method &#123; SEL method_name; char *method_types; IMP method_imp;&#125;方法实际上是由什么组成的：方法的实现 method_imp，这是调用方法时要执行的实际函数。它的前两个形参总是方法接收者和消息选择器。包含方法签名的方法类型字符串 method_types。你可以在 这里 详细了解其格式。但是在现在的情况下，需要明确说明的字符串是 “v@:”。作为返回类型，v 代表 void，而 @ 和 : 分别代表接收者和消息选择器。选择器 method_name 作为键，用于在运行时查找方法的实现。你可以把 Witness Table（在其他编程语言中，它也被称作方法派发表）想象成一个简单的字典数据结构。那么选择器为键，且实现部分则为对应的值。在下面这行代码中:1class_addMethod(trackableClass,#selector(originalClass.layoutSubviews), implementation, \"v@:\")我们所做的是给 layoutSubviews() 方法对应的键分配新值。这个方法直截了当。我们获得这个计数器，使它的计数值加一。如果计数值超过临界值，我们会发送分析事件，其中包含类名和想要的任何数据体。让我们回顾一下如何对关联对象实现和使用键：1234static var CounterKey = “_counter”... objc_setAssociatedObject(trackableClass, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)为什么我们使用 var 来修饰计数器的键这个静态属性并在传递到其他地方时使用引用？答案隐藏在 Swift 语言基础——字符串之中。字符串像其他所有的值类型一样，是按值传递的。那么，当你把它传入这个闭包时，这个字符串将会被复制到一个不同的地址，这会导致在关联对象表中产生一个完全不同的键。&amp; 符号总是保证将相同的地址作为键参数的值。你可以尝试以下代码：1234567891011121314func printAddress(_ string: UnsafeRawPointer) &#123; print(\"\\(string)\")&#125;let str = \"test\"printAddress(str)printAddress(str)let closure = &#123; printAddress(str) printAddress(str)&#125;closure()// 最后两个函数调用的地址将始终不同用引用的方式来传递键的主意总是好的，因为有时，即使你没有使用闭包，变量的地址仍可能因内存管理而更改。在我们例子中，如果你把上面的代码运行多次，即使是前两个 printAddress() 的调用也可能会输出不同的地址。让我们回到运行时的魔法里来。在新 layoutSubviews() 的实现里，还有一件很重要的事情没有完成。这件事是每次重写父类的方法时通常都会做的事情——调用父类实现。layoutSubviews() 的文档里提到：在 iOS 5.1 及更早版本中，这个方法的默认实现不执行任何操作。而之后的默认实现会使用你设置的任何约束来确定任何子视图的大小和位置。为了避免发生一些难以预料的布局行为，我们得调用父类的实现，但这不像平常那样简单明了：12345678910let selector = #selector(originalClass.layoutSubviews)let originalImpl = class_getMethodImplementation(originalClass, selector) // @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象）// 所有的 Obj-C 方法函数把接收者和消息当作前两个参数// 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符typealias ObjCVoidVoidFn = @convention(c) (Any, Selector) -&gt; Voidlet originalLayoutSubviews = unsafeBitCast(originalImpl, to: ObjCVoidVoidFn.self)originalLayoutSubviews(view, selector)这里实际发生的是：我们检索方法所需的实现部分，并直接从代码中调用它，而不是用常见的方式来调用方法（即执行一个会在 Witness Table 中寻找对应实现的选择器）。目前为止，让我们看看实现部分：1234567891011121314151617181920212223242526272829303132333435363738394041424344static func setUp(for view: UIView, threshold: Int = 100, onLoop: @escaping () -&gt; ()) &#123; // 我们根据功能的前缀和原始类名为新类创建名称 let classFullName = “\\(RuntimeConstants.Prefix)_\\(String(describing: view.self))” let originalClass = type(of: view) if let trackableClass = objc_allocateClassPair(originalClass, classFullName, 0) &#123; // 在当前运行时会话期间尚未创建此类 // 注册这个类并将其与原始视图的类交换 objc_registerClassPair(trackableClass) object_setClass(view, trackableClass) // 现在可以创建关联对象 objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) // 添加我们自己 layoutSubviews 的实现 let layoutSubviews: @convention(block) (Any?) -&gt; () = &#123; nullableSelf in guard let _self = nullableSelf else &#123; return &#125; let selector = #selector(originalClass.layoutSubviews) let originalImpl = class_getMethodImplementation(originalClass, selector) // @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象） // 所有的 Obj-C 方法函数把接收者和消息当作前两个参数 // 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符 typealias ObjCVoidVoidFn = @convention(c) (Any, Selector) -&gt; Void let originalLayoutSubviews = unsafeBitCast(originalImpl, to: ObjCVoidVoidFn.self) originalLayoutSubviews(view, selector) if let counter = objc_getAssociatedObject(_self, &amp;RuntimeConstants.CounterKey) as? Int &#123; if counter == threshold &#123; onLoop() &#125; objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; &#125; let implementation = imp_implementationWithBlock(layoutSubviews) class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“) &#125; else if let trackableClass = NSClassFromString(classFullName) &#123; // 我们之前在此运行时会话中分配了一个具有相同名称的类 // 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换 object_setClass(view, trackableClass) &#125;&#125;让我们为视图创建模拟布局循环，并为其设置计数器来进行测试：1234567891011121314class ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() LayoutLoopHunter.setUp(for: view) &#123; print(\"Hello, world\") &#125; &#125; override func viewDidLayoutSubviews() &#123; super.viewDidLayoutSubviews() view.setNeedsLayout() // loop creation &#125;&#125;是不是忘记了什么事情？让我们再次回顾一下 UIViewLayoutFeedbackLoopDebuggingThreshold 断点的工作原理：在确认为反馈循环之前，定义某个视图的子视图在单个 run loop 里必须布局的次数我们从未把“单个 run loop ”这一条件考虑进来。如果视图在屏幕上停留了相当长的时间，并经常被反复布局，计数器迟早会超过临界值。但这可不是因为内存的问题。我们该怎么解决这个问题呢？只需在每次 run loop 迭代时重置计数器。为了做到这一点，我们可以创建一个 DispatchWorkItem，它重置计数器，并在主队列上异步传递它。通过这种方式，它会在 run loop 下一次进入主线程时被调用：12345678910111213static var ResetWorkItemKey = “_resetWorkItem”...if let previousResetWorkItem = objc_getAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey) as? DispatchWorkItem &#123; previousResetWorkItem.cancel()&#125;let currentResetWorkItem = DispatchWorkItem &#123; [weak view] in guard let strongView = view else &#123; return &#125; objc_setAssociatedObject(strongView, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)&#125;DispatchQueue.main.async(execute: currentResetWorkItem)objc_setAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey, currentResetWorkItem, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)最终的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667struct LayoutLoopHunter &#123; struct RuntimeConstants &#123; static let Prefix = “runtime” // Associated objects keys // 关联对象键 static var CounterKey = “_counter” static var ResetWorkItemKey = “_resetWorkItem” &#125; static func setUp(for view: UIView, threshold: Int = 100, onLoop: @escaping () -&gt; ()) &#123; // 我们根据功能的前缀和原始类名为新类创建名称。 let classFullName = “\\(RuntimeConstants.Prefix)_\\(String(describing: view.self))” let originalClass = type(of: view) if let trackableClass = objc_allocateClassPair(originalClass, classFullName, 0) &#123; // 在当前运行时会话期间尚未创建此类。 // 注册这个类，并且用原始视图的类来和它交换。 objc_registerClassPair(trackableClass) object_setClass(view, trackableClass) // 现在可以创建关联对象 objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) // 添加我们自己 layoutSubviews 的实现 let layoutSubviews: @convention(block) (Any?) -&gt; () = &#123; nullableSelf in guard let _self = nullableSelf else &#123; return &#125; let selector = #selector(originalClass.layoutSubviews) let originalImpl = class_getMethodImplementation(originalClass, selector) // @convention(c) 告知 Swift 这是一个裸函数指针（没有上下文对象） // 所有的 Obj-C 方法函数把接收者和消息当作前两个参数 // 所以这意味着一个类型为 `() -&gt; Void` 的方法，这与 `layoutSubview` 方法相符 typealias ObjCVoidVoidFn = @convention(c) (Any, Selector) -&gt; Void let originalLayoutSubviews = unsafeBitCast(originalImpl, to: ObjCVoidVoidFn.self) originalLayoutSubviews(view, selector) if let counter = objc_getAssociatedObject(_self, &amp;RuntimeConstants.CounterKey) as? Int &#123; if counter == threshold &#123; onLoop() &#125; objc_setAssociatedObject(view, &amp;RuntimeConstants.CounterKey, counter+1, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; // 为重置计数器，在每个新的 run loop 遍历中分发 work item if let previousResetWorkItem = objc_getAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey) as? DispatchWorkItem &#123; previousResetWorkItem.cancel() &#125; let counterResetWorkItem = DispatchWorkItem &#123; [weak view] in guard let strongView = view else &#123; return &#125; objc_setAssociatedObject(strongView, &amp;RuntimeConstants.CounterKey, 0, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; DispatchQueue.main.async(execute: counterResetWorkItem) objc_setAssociatedObject(view, &amp;RuntimeConstants.ResetWorkItemKey, counterResetWorkItem, .OBJC_ASSOCIATION_RETAIN_NONATOMIC) &#125; let implementation = imp_implementationWithBlock(layoutSubviews) class_addMethod(trackableClass, #selector(originalClass.layoutSubviews), implementation, “v@:“) &#125; else if let trackableClass = NSClassFromString(classFullName) &#123; // 我们之前在此运行时会话中分配了一个具有相同名称的类。 // 我们可以从原始字符串中获取它，并以相同的方式与我们的视图交换。 object_setClass(view, trackableClass) &#125; &#125;&#125; 结论是的！现在你可以为所有可疑的视图设置分析事件了，发布应用程序，并找到这个问题的确切出处。你可以把这个问题的范围缩小到某个特定的视图，并在用户不知情的情况下借助于他们来解决这个问题。最后要提到的一件事是：能力越大责任越大。运行时编程非常容易出错，因此很容易在不知情的情况下为应用程序引入另一个严重的问题。这就是为什么总是建议将应用程序中的所有危险代码包装在某种可停止开关中，因为你可以在发现代码导致问题时从后端触发开关禁用该功能。这有一篇介绍 Firebase 的 Feature Flags 的 (好文章完整代码可以从这个 GitHub 仓库 里获取，并且也将会发布到 CocoPods 上，以跟踪项目中的布局循环。大量引用原文读起来费劲，只是想让自己读的容易写的这篇文章","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"性能优化","slug":"性能优化","permalink":"https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"AlamoFire 分析","date":"2019-08-23T02:24:19.000Z","path":"2019/08/23/source-code/AlamoFire-分析/","text":"分析源码：这个第三方库，他设计的目标是什么？需要哪些基础知识整体结构是什么样的由外而内逐层分析层次结构每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？为什么要分析 AlamoFire分析它的接口设计分析他是如何封装 URL Loading System 的分析网络层次思考数据传输过程AlamoFire 都做了什么？Chainable Request / Response MethodsURL / JSON Parameter EncodingUpload File / Data / Stream / MultipartFormDataDownload File using Request or Resume DataAuthentication with URLCredentialHTTP Response ValidationUpload and Download Progress Closures with ProgresscURL Command OutputDynamically Adapt and Retry RequestsTLS Certificate and Public Key PinningNetwork Reachability Foundation 中提供的网络相关接口AlamoFire 是一个网络请求库，底层封装的事 Apple 提供的 URL Loading System 后台 session下载流程&amp;注意事项后台 sessionConfiguration 下载文件保存 到本地沙盒12345678910111213141516171819202122// 开启后台 请求 tasklet configuration = URLSessionConfiguration.background(withIdentifier: \"com.czw.backgroundDownload\")let session = URLSession.init(configuration: configuration, delegate: self, delegateQueue: OperationQueue.main)session.downloadTask(with: URL(string: urlDownloadStr)!).resume()extension ViewController: URLSessionDownloadDelegate &#123;// 下载完成后代理回调方法，将文件移动到沙盒指定位置 func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL) &#123; print(\"下载完成 - \\(location)\") let locationPath = location.path let documnets = NSHomeDirectory() + \"/Documents/xxxx\" + \".zip\" print(\"移动地址:\\(documnets)\") let fileManager = FileManager.default try! fileManager.moveItem(atPath: locationPath, toPath: documnets) &#125; // http 分段传输，会不断调用这个方法直到，全部下载完成 func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64) &#123; print(\" bytesWritten \\(bytesWritten)\\n totalBytesWritten \\(totalBytesWritten)\\n totalBytesExpectedToWrite \\(totalBytesExpectedToWrite)\") print(\"下载进度: \\(Double(totalBytesWritten)/Double(totalBytesExpectedToWrite))\\n\") &#125;&#125;后台请求，需要申请后台权限，这样 app 进入 background 的时候才可以继续下载1234567//用于保存后台下载的completionHandlervar backgroundSessionCompletionHandler: (() -&gt; Void)? func application(_ application: UIApplication, handleEventsForBackgroundURLSession identifier: String, completionHandler: @escaping () -&gt; Void) &#123; print(\"background: \\(identifier)\") self.backgroundSessionCompletionHandler = completionHandler&#125; 使用 AlamoFire1234Alamofire.request(urlString) .responseJSON &#123; (data) in print(data)&#125;跟上面对比[原生的方法(#code1), 思考 AlamoFire 都封装了什么，如何实现链式调用的，内部如何使用 oop，pop 的, 思考 AlamoFire 接口设计下面这些都是怎么实现的？链式语法直接传 string封装调用 session，resumeResponse 回调的返回的是 json 数据Alamofire 模块导入调用调用的第一层：Alamofire.swift1234567891011121314151617//Alamofire Modelpublic func request( _ url: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil) -&gt; DataRequest &#123; return SessionManager.default.request( url, method: method, parameters: parameters, encoding: encoding, headers: headers )&#125;SessionManager.swift123456789101112131415161718192021222324252627282930313233//SessionManager/// A default instance of `SessionManager`, used by top-level Alamofire request methods, and suitable for use/// directly for any ad hoc requests.public static let `default`: SessionManager = &#123; let configuration = URLSessionConfiguration.default configuration.httpAdditionalHeaders = SessionManager.defaultHTTPHeaders return SessionManager(configuration: configuration)&#125;()public init( configuration: URLSessionConfiguration = URLSessionConfiguration.default, delegate: SessionDelegate = SessionDelegate(), serverTrustPolicyManager: ServerTrustPolicyManager? = nil)&#123; self.delegate = delegate self.session = URLSession(configuration: configuration, delegate: delegate, delegateQueue: nil) commonInit(serverTrustPolicyManager: serverTrustPolicyManager)&#125;public init?( session: URLSession, delegate: SessionDelegate, serverTrustPolicyManager: ServerTrustPolicyManager? = nil) &#123; guard delegate === session.delegate else &#123; return nil &#125; self.delegate = delegate self.session = session commonInit(serverTrustPolicyManager: serverTrustPolicyManager)&#125;SessionDelegate() 代理移交 SessionDelegate 是个 class, 处理 URLSession 的事件回调代理方法。123extension SessionDelegate: URLSessionDataDelegate &#123;extension SessionDelegate: URLSessionTaskDelegate &#123;extension SessionDelegate: URLSessionStreamDelegate &#123;为什么 Manager 不处理 URLSession 的代理回调方法，要搞一个 SessionDelegate 处理，因为 Manager 是一个中介者，用于管理各个 class 之间的联系，处理回调的那些方法应该归属于 xxxClass 来处理使用 Manager 主要作用是把代码模块之间的 频繁调用关系化简。划分业务层，管理层Manager 统一管理调度各个模块处理完成后，回调给 Manager 处理后台下载 request 编码urljsonpropertyListurl 是ASCII码编码的，他不是 Unicode，ASCII 码中的外文无法识别，所以要百分号编码——将 ACSII -&gt; Unicode 这样可以被识别123456789101112131415161718192021222324252627public func encode(_ urlRequest: URLRequestConvertible, with parameters: Parameters?) throws -&gt; URLRequest &#123; var urlRequest = try urlRequest.asURLRequest() guard let parameters = parameters else &#123; return urlRequest &#125;// header if let method = HTTPMethod(rawValue: urlRequest.httpMethod ?? \"GET\"), encodesParametersInURL(with: method) &#123; guard let url = urlRequest.url else &#123; throw AFError.parameterEncodingFailed(reason: .missingURL) &#125; if var urlComponents = URLComponents(url: url, resolvingAgainstBaseURL: false), !parameters.isEmpty &#123; let percentEncodedQuery = (urlComponents.percentEncodedQuery.map &#123; $0 + \"&amp;\" &#125; ?? \"\") + query(parameters) urlComponents.percentEncodedQuery = percentEncodedQuery urlRequest.url = urlComponents.url &#125; &#125; else &#123; if urlRequest.value(forHTTPHeaderField: \"Content-Type\") == nil &#123; urlRequest.setValue(\"application/x-www-form-urlencoded; charset=utf-8\", forHTTPHeaderField: \"Content-Type\") &#125;// body urlRequest.httpBody = query(parameters).data(using: .utf8, allowLossyConversion: false) &#125; return urlRequest&#125;p.s. 传输组的时候一定要传 json 字符串！iOS 10: Background Session won’t inform when downloads have failed #1920URL Loading System","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"源码","slug":"源码","permalink":"https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"Net","slug":"第三方框架/Net","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/Net/"}]},{"title":"URL Loading System","date":"2019-08-19T01:52:28.000Z","path":"2019/08/19/URL-Loading-System/","text":"简介在 Foundation 框架中支持协议：FTP协议（ftp://）超文本传输协议（http://）加密超文本传输协议(https://)本地资源(file://)数据URLs(data://)关键类：URLSession，URL，URLRequest，Tasks，Data支持：Authorization credentials，cache 和cookies， 配置管理使用 closure 和 delegate 处理 Response 核心 URLSession &amp; URLSessionTask一个 session 请求网络数据需要的核心内容 Session Configuration每个配置属性都值得研究这篇文章有各个参数翻译总共有三种 configurationDefault: 使用本地沙盒缓存，用户credential保存在 keychain 中Ephemeral: 不使用沙盒，所有缓存credential 等数据存在 与 session 绑定的 RAM 中，session 失效后内存自动清理Background: 跟 default session 相似，但是使用的是另外一个 进程(process) 处理数据传输，因为是跨进程，所以 background session 有些限制操作。（嗯后台session 使用了进程间通信）为什么要有 configuration？session 相当一个 manager，用来管理组织 task，网络事件处理的枢纽，configuration是这个枢纽的参数信息！相当于 一个 app 他都有 自己 preference12345678910111213let configuration = URLSessionConfiguration.background(withIdentifier: \"com.czw.backgroundDownload\")let configuration1 = URLSessionConfiguration.default// 允许用户拥有沙盒缓存器，当session 释放的时候，数据依然存在let configuration2 = URLSessionConfiguration.ephemeral// session 无效时，东西就会消失URLSession.init(configuration: configuration).dataTask(with: URL(string: urlDownloadStr)!) .resume()// 后台 sessionConfiguration 不能设置 completeHandler，需要自己设置代理print(\"background-内存大小：\\(String(describing: configuration.urlCache.memoryCapacity))\")print(\"background-沙盒大小：\\(String(describing: configuration.urlCache.diskCapacity))\")print(\"default-内存大小：\\(String(describing: configuration1.urlCache.memoryCapacity))\")print(\"default-沙盒大小：\\(String(describing: configuration1.urlCache.diskCapacity))\")print(\"ephemeral-内存大小：\\(String(describing: configuration2.urlCache.memoryCapacity))\")print(\"ephemeral-沙盒大小：\\(String(describing: configuration2.urlCache.diskCapacity))\")打印结果：background-内存大小：nilbackground-沙盒大小：nildefault-内存大小：512000default-沙盒大小：10000000ephemeral-内存大小：512000ephemeral-沙盒大小：0就像文档说的，当session 失效以后 ephemeral 的 cache 会消失，因为他没有沙盒空间 session 网络请求我们要做的配置需要的 session configuration，配置 session系统提供的 shared 单例，系统自己配置 configuration，sessionDelegate，delegateQueue自定义 session，自己设置 configuration，sessionDelegate，delegateQueue(是 serial queue)提供 request &amp; url 给 session生成 taskURLSessionTaskURLSessionDataTaskURLSessionUploadTaskURLSessionDownloadTaskURLSessionStreamTaskURLSessionWebSocketTask（iOS 13.0）配置SessionDelegate, SessionTaskDelegate 对网络事件处理 (URLSessionTaskDelegate: URLSessionDelegateURLSessionDataDelegateURLSessionDownloadDelegateURLSessionStreamDelegateURLSessionWebSocketDelegate（iOS 13.0）SessionDelegate 只有3个接口12345678@available(iOS 7.0, *)optional func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?) @available(iOS 7.0, *)optional func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) @available(iOS 7.0, *)optional func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession)至于各个 taskDelegate，对应不同的task 类型有个字不同协议接口这里主要看 SessionTaskDelegate12345678910111213141516171819202122232425public protocol URLSessionTaskDelegate : URLSessionDelegate &#123; @available(iOS 11.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest, completionHandler: @escaping (URLSession.DelayedRequestDisposition, URLRequest?) -&gt; Void) @available(iOS 11.0, *) optional func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask) @available(iOS 7.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping (URLRequest?) -&gt; Void) @available(iOS 7.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -&gt; Void) @available(iOS 7.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping (InputStream?) -&gt; Void) @available(iOS 7.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64) @available(iOS 10.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics) @available(iOS 7.0, *) optional func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)&#125;常用的是 dataTask，downloadTask，uploadTask 实际使用 从网站获取数据到内存 使用回调处理接受结果：使用closure 回调得到 data1234567891011121314151617181920212223242526272829303132333435// task 的状态extension URLSessionTask &#123; @available(iOS 7.0, *) public enum State : Int &#123; case running case suspended // 初试状态 case canceling case completed &#125;&#125;func startLoad() &#123; let url = URL(string: \"https://www.example.com/\")! let task = URLSession.shared.dataTask(with: url) &#123; data, response, error in if let error = error &#123; self.handleClientError(error) return &#125; guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else &#123; self.handleServerError(response) return &#125; if let mimeType = httpResponse.mimeType, mimeType == \"text/html\", let data = data, let string = String(data: data, encoding: .utf8) &#123; DispatchQueue.main.async &#123; self.webView.loadHTMLString(string, baseURL: url) &#125; &#125; &#125;// session create 出来的 task 是 suspend 的状态 task.resume()&#125;注意点：session create 出来的 task 初始状态是 suspend回调处理是在 serial queue 任务放到子线程处理的，通知 UI 变化应切换主线程 接受请求详情&amp;结果：使用 Delegate这个时候 session 不应该使用 shared，而是要自己配置1234567private lazy var session: URLSession = &#123; let configuration = URLSessionConfiguration.default configuration.waitsForConnectivity = true return URLSession(configuration: configuration, delegate: self, delegateQueue: nil)&#125;()123456789101112131415161718192021222324252627282930313233343536373839var receivedData: Data?func startLoad() &#123; loadButton.isEnabled = false let url = URL(string: \"https://www.example.com/\")! receivedData = Data() let task = session.dataTask(with: url) task.resume()&#125;// delegate methodsfunc urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping (URLSession.ResponseDisposition) -&gt; Void) &#123; guard let response = response as? HTTPURLResponse, (200...299).contains(response.statusCode), let mimeType = response.mimeType, mimeType == \"text/html\" else &#123; completionHandler(.cancel) return &#125; completionHandler(.allow)&#125;func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data) &#123; self.receivedData?.append(data)&#125;func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?) &#123; DispatchQueue.main.async &#123; self.loadButton.isEnabled = true if let error = error &#123; handleClientError(error) &#125; else if let receivedData = self.receivedData, let string = String(data: receivedData, encoding: .utf8) &#123; self.webView.loadHTMLString(string, baseURL: task.currentRequest?.url) &#125; &#125;&#125;使用代理的方式，可以处理很多特殊的情况：authentication challengesfollowing redirectsURL Loading System","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"Guide","slug":"iOS-Programming/Guide","permalink":"https://changzw.github.io/categories/iOS-Programming/Guide/"}]},{"title":"load和initialize","date":"2019-07-12T03:58:04.000Z","path":"2019/07/12/load和initialize/","text":"+ loadload 是通过 c 函数调用的load 调用在 main 函数之前，动态链接器通知调用 load_images，执行load 方法load 加载顺序：父类-&gt; 类-&gt; 分类load 方法中最常用的就是方法交换 method swizzling load 方法的调用栈在 + load 方法出打断点，查看 load 调用栈1234560 +[XXObject load]1 call_class_loads()2 call_load_methods3 load_images4 dyld::notifySingle(dyld_image_states, ImageLoader const*)11 _dyld_startdyld(dynamic link editor)，它是苹果的动态链接器。在系统内核做好程序准备工作之后，交由 dyld 负责余下的工作在 runtime 时调用 load_images 方法,那么就看下他的源码(objc4-756.2)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145/************************************************************************ load_images* Process +load in the given images which are being mapped in by dyld.** Locking: write-locks runtimeLock and loadMethodLock**********************************************************************/extern bool hasLoadMethods(const headerType *mhdr);extern void prepare_load_methods(const headerType *mhdr); void load_images(const char *path __unused, const struct mach_header *mh) &#123; if (!hasLoadMethods((const headerType *)mh)) return; recursive_mutex_locker_t lock(loadMethodLock); // Discover load methods &#123; mutex_locker_t lock2(runtimeLock); prepare_load_methods((const headerType *)mh); &#125; // Call +load methods (without runtimeLock - re-entrant) call_load_methods();&#125;void prepare_load_methods(const headerType *mhdr)&#123; size_t count, i; runtimeLock.assertLocked(); classref_t *classlist = _getObjc2NonlazyClassList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; schedule_class_load(remapClass(classlist[i])); &#125; category_t **categorylist = _getObjc2NonlazyCategoryList(mhdr, &amp;count); for (i = 0; i &lt; count; i++) &#123; category_t *cat = categorylist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) continue; // category for ignored weak-linked class if (cls-&gt;isSwiftStable()) &#123; _objc_fatal(\"Swift class extensions and categories on Swift \" \"classes are not allowed to have +load methods\"); &#125; realizeClassWithoutSwift(cls); assert(cls-&gt;ISA()-&gt;isRealized()); add_category_to_loadable_list(cat); &#125;&#125;/************************************************************************ prepare_load_methods* Schedule +load for classes in this image, any un-+load-ed * superclasses in other images, and any categories in this image.**********************************************************************/// Recursively schedule +load for cls and any un-+load-ed superclasses.// cls must already be connected.static void schedule_class_load(Class cls) &#123; if (!cls) return; assert(cls-&gt;isRealized()); // _read_images should realize if (cls-&gt;data()-&gt;flags &amp; RW_LOADED) return; // Ensure superclass-first ordering schedule_class_load(cls-&gt;superclass); add_class_to_loadable_list(cls); cls-&gt;setInfo(RW_LOADED); &#125;/************************************************************************ add_class_to_loadable_list* Class cls has just become connected. Schedule it for +load if* it implements a +load method.**********************************************************************/void add_class_to_loadable_list(Class cls) &#123; IMP method; method = cls-&gt;getLoadMethod(); if (!method) return; // Don't bother if cls has no +load method if (loadable_classes_used == loadable_classes_allocated) &#123; loadable_classes_allocated = loadable_classes_allocated*2 + 16; // 分配类对象空间，加载类 loadable_classes = (struct loadable_class *) realloc(loadable_classes, loadable_classes_allocated * sizeof(struct loadable_class)); &#125; loadable_classes[loadable_classes_used].cls = cls; loadable_classes[loadable_classes_used].method = method; loadable_classes_used++;&#125;/************************************************************************ call_load_methods* Call all pending class and category +load methods.* Class +load methods are called superclass-first. * Category +load methods are not called until after the parent class's +load.* * This method must be RE-ENTRANT, because a +load could trigger * more image mapping. In addition, the superclass-first ordering * must be preserved in the face of re-entrant calls. Therefore, * only the OUTERMOST call of this function will do anything, and * that call will handle all loadable classes, even those generated * while it was running.** The sequence below preserves +load ordering in the face of * image loading during a +load, and make sure that no * +load method is forgotten because it was added during * a +load call.* Sequence:* 1. Repeatedly call class +loads until there aren't any more* 2. Call category +loads ONCE.* 3. Run more +loads if:* (a) there are more classes to load, OR* (b) there are some potential category +loads that have * still never been attempted.* Category +loads are only run once to ensure \"parent class first\" * ordering, even if a category +load triggers a new loadable class * and a new loadable category attached to that class. ** Locking: loadMethodLock must be held by the caller * All other locks must not be held.**********************************************************************/void call_load_methods(void) &#123; static bool loading = NO; bool more_categories; // Re-entrant calls do nothing; the outermost call will finish the job. if (loading) return; loading = YES; void *pool = objc_autoreleasePoolPush(); do &#123; // 1. Repeatedly call class +loads until there aren't any more while (loadable_classes_used &gt; 0) &#123; call_class_loads(); &#125; // 2. Call category +loads ONCE more_categories = call_category_loads(); // 3. Run more +loads if there are classes OR more untried categories &#125; while (loadable_classes_used &gt; 0 || more_categories); objc_autoreleasePoolPop(pool); loading = NO;&#125; initialize惰性方法，第一次初始化实例对象的时候会调用这个方法正常情况，只会调用一次不正常情况，调用多次，多个子类没有实现 initialize，那么会多次调用父类的 initialize 分析 initialize调用栈分析12345670 +[XXObject initialize]1 _class_initialize2 lookUpImpOrForward3 _class_lookupMethodAndLoadCache34 objc_msgSend5 main6 start使用 oc 消息机制发送的父类的initialize方法会比子类先执行当子类未实现initialize方法时,会调用父类initialize方法,子类实现initialize方法时,会覆盖父类initialize方法. cls.isInitialized 判断该类是否被实例化过当有多个Category都实现了initialize方法,会覆盖类中的方法,只执行一个你真的了解 load 方法么？懒惰的 initialize 方法","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"好文章","date":"2019-06-03T02:58:25.000Z","path":"2019/06/03/好文章/","text":"深入理解 Autolayout 与列表性能 – 背锅的 Cassowary 和偷懒的 CPU深入浅出iOS编译不了解GIF的加载原理？看我就够了！iOS 保持界面流畅的技巧iOS应用架构谈 组件化方案如何设计一个 iOS 控件?(iOS 控件完全解析)RxSwift + MVVM: how to feed ViewModels调试内存不足问题：使用运行时魔法捕获布局反馈循环","tags":[{"name":"readings","slug":"readings","permalink":"https://changzw.github.io/tags/readings/"}],"categories":[{"name":"favorite","slug":"favorite","permalink":"https://changzw.github.io/categories/favorite/"}]},{"title":"读代码 Me","date":"2019-05-16T16:47:30.000Z","path":"2019/05/17/source-code/读代码-Me/","text":"为什么看抽空晚上睡不着看 awesome-ios 提供的优秀代码库[Me](https://github.com/pascalbros/Me 源码 他是做什么的Me 是解决嵌套异步问题的一个轻量级库——就一个文件 使用他以后的效果before123456789101112MyAPI.login &#123; //Do your stuff and then request posts... MyAPI.posts &#123; //Do your stuff and then request comments... MyAPI.comments &#123; //Do your stuff and then request likes... MyAPI.likes &#123; //We are done here &#125; &#125; &#125;&#125;after123456789101112131415161718192021Me.start &#123; (me) in MyAPI.login &#123; //Do your stuff and then request posts... me.runNext() &#125;&#125;.next &#123; (caller, me) in MyAPI.posts &#123; //Do your stuff and then request comments... me.runNext() &#125;&#125;.next &#123; (caller, me) in MyAPI.comments &#123; //Do your stuff and then request likes... me.runNext() &#125;&#125;.next &#123; (caller, me) in MyAPI.likes &#123; //We are done here me.end() &#125;&#125;.run()看效果：Me 把异步嵌套代码–&gt; 链式代码（想想他是怎么做的？）Me 是链条型的，start，next，next(name:)，jump(toName:)，end他是如何做异步通知的？如何开始，如何结束？支持实现多链条并发执行吗？从提供的接口上可以看出Me开启结束要由用户控制节点驱动需要用户触发支持指定节点跳转ok 使用demo&amp;基本特性分析完了，接下来看源码 源码 先看接口123456789101112131415161718192021222324public typealias MeInitClosure = ((_ current: Me) -&gt; ())public typealias MeClosure = ((_ previous: Me?, _ current: Me) -&gt; ())public var first: Me &#123; get &#125;public var index: UInt &#123; get &#125;internal var name: String &#123; get &#125;public var parameters: [String : Any]// 链式节点函数，static 是起点public static func start(name: String = \"\", this: @escaping MeInitClosure) -&gt; Mepublic static func run(this: @escaping MeClosure) -&gt; Mepublic func next(name: String = \"\", next: @escaping MeClosure) -&gt; Mepublic func run()public func end()public func runNext(queue: DispatchQueue)public func runNext()public func runNextOnMain()public func jump(toIndex jump: UInt = 0, queue: DispatchQueue)public func jump(toIndex jump: UInt = 0)public func jumpOnMain(toIndex jump: UInt = 0)public func jump(toName jump: String, queue: DispatchQueue)public func jump(toName jump: String)public func jumpOnMain(toName jump: String)提供 Me 节点 index，name，代码库内部维护只提供其实节点 first提供线程队列调度接口parameters 是干什么的？像是 [name: MeClouse] 字典，每个 me 节点都有一个clouse 看代码实现核心代码，这个地方封装了 GCD1234567891011121314public func runNext(queue: DispatchQueue) &#123; if let next = self.next &#123; //self.nextObj!.parameters = self.parameters //enable to pass parameters to the next object queue.async &#123; next(self, self.nextObj!) &#125; &#125;&#125;public func jump(toIndex jump: UInt = 0, queue: DispatchQueue) &#123; if let to = me(at: jump) &#123; to.this(self, to) &#125;&#125;有个问题是：jump 的queue 没有用……（这个库的使用价值不大）只有 runNext 相关方法可以调度线程parameters: 是 me 节点保存数据，用于用户自己传递数据使用内部数据结构使用的是链表12private var nextObj: Me?private var _first: Me?","tags":[{"name":"源码","slug":"源码","permalink":"https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"读源码","slug":"读源码","permalink":"https://changzw.github.io/categories/%E8%AF%BB%E6%BA%90%E7%A0%81/"}]},{"title":"RxSwift + MVVM:如何提供ViewModels","date":"2019-04-16T12:58:40.000Z","path":"2019/04/16/RxSwfit+RAC/RxSwift-MVVM-如何提供ViewModels/","text":"原文：RxSwift + MVVM: how to feed ViewModels 介绍自从我们开始在BlaBlaCar的Model-View-ViewModel（MVVM）架构中使用RxSwift以来，已经快一年了。我们对结果感到兴奋。我们使用这种方法编写的代码更容易理解，维护，测试和扩展。但是，最初的几周并不是小菜一碟。我们必须在MVVM + RxSwift架构的某些方面进行迭代，以使事情变得正确。其中一个方式——给 ViewModels 提供 Inputs。让我们通过两种不同方式给ViewModels 提供 Inputs（Rx Event）但是首先，让我们简单谈一下 ViewModels ViewModelsViewModel的职责，你必须正确理解它（不止一个）：它应该是可以插入到任何View上的。比如，不是先造一个View再去定义一个ViewModel。注意，是View拥有ViewModel。View知道ViewModel，而不是反过来。它是可测试的。最终，MVVM架构最大的好处就是让业务逻辑可测。MVVM使用绑定机制更加牛逼，所以让使用 RxSwift 来更好地利用 ViewModelto be continued…","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"如何读代码写代码","date":"2019-03-02T22:31:09.000Z","path":"2019/03/03/如何读代码写代码/","text":"怎么读这个库是用来干嘛？看文件结构思考作者分了那些模块每个模块都是干啥的模块联系实际场景是啥，文件上用了哪些架构or设计模式（MVC，MVVM，ViewStateModel，Coordinate，Meditate……）模块间是如何联系的——数据流了解具体模块细节看具体协议&amp;类的接口作者想要给用户提供什么功能类的数据出口&amp;入口是什么类之间关系使用了什么设计模式，如何提高了复用性看数据流向对于文档少&amp;想更深入理解代码，借助 IDE 调试代码，跟踪数据输入输出，看函数调用栈根据数据流向可以更清楚类之间的关系看具体实现想知道具体细节如何实现的时候，看文件，定位源码位置 怎么写确定功能根据功能确定模块根据模块分文件夹思考模块之间关系，出口入口，相互依赖关系每个模块写接口——APIAPI 层级关系，抽象层级，高层及实现通用功能接口出口入口，依赖注入接口之间依赖关系，思考使用何种设计模式根据模块，实现协议class 开发class 之间关系，使用什么设计模式，提高复用效率class 的出口入口，依赖注入私有成员内部逻辑","tags":[{"name":"学习感悟","slug":"学习感悟","permalink":"https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"}],"categories":[{"name":"思考","slug":"思考","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"},{"name":"开发","slug":"思考/开发","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"}]},{"title":"雪球速读法--迭代树--整体&细节","date":"2019-02-05T11:01:50.000Z","path":"2019/02/05/雪球速读法/","text":"雪球速读法–浅析《雪球速读法》中说：速读的方式是：速度技巧 * 资料库(大小) = 速读反复读 n 变每次快速阅读，要求1.不求甚解，2.脑子里不要有读的声音具体：先话读目录，前言，后记 用 15~30，思考书的整体结构，作者写作意图从框架的外层一层层向知识细节挖，每次处理一层，理解一层，构建自己对这本书的资料库（滚雪球的过程）这样做的好处是：强调先掌握知识的框架！从整体的角度一层层学习知识。有了框架就知道森林大概的样子！如果单纯的按照目录一点点学习书本上的知识，会陷在局部细节中出不来浪费大量时间，读书时间过长，前面的知识会忘，后面不一定会认真读完，最后整本书都很难理解。作者是以什么样的方式写书的呢？类似于《雪球速读法》先有中心思想，目录，段落，然后落实到细节，《雪球速读法》就是按照作者的写作的方式理解知识的过程。速读不发出声音，更有利于读者跟作者产生共鸣！这个也是读书的一个目的 目标 vs 任务目标：一个你想要看见的好结果任务：为实现目标你要做的事在缺少动力的时候多思考目标带来那些美好的愿景，用 Deadline 给自己施加压力，对比人的承诺。在执行的时候多看细节，任务，因为总是关注目标，会无从下手，很多细节上的困难乐观对待！导致目标最终搁浅。 树状结构知识有关树状结构，知识迭代过程都是一层层包裹的知识，有历史气息的知识都是树状结构这样的知识可以像《雪球速读法》一样层层学习 计算机知识计算机知识就是一个大大的树，找到一个大树枝，然后一层层分解这个知识点程序开发的时候也是，现有结构，然后再是细节！有时间补充","tags":[{"name":"学习感悟","slug":"学习感悟","permalink":"https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"}],"categories":[{"name":"思考","slug":"思考","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"},{"name":"开发","slug":"思考/开发","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"}]},{"title":"iOS 渲染过程性能优化","date":"2019-02-05T07:13:29.000Z","path":"2019/02/05/iOS-渲染过程性能优化/","text":"此文整理iOS 保持界面流畅的技巧 屏幕显示原理 CRT 显示器原理一帧画面：CRT 的电子枪从上到下一行行扫描，扫描完成后显示器就呈现一帧画面，随后电子枪回到初始位置继续下一次扫描。为了把显示器的显示过程和系统的视频控制器进行同步，显示器（或者其他硬件）会用硬件时钟产生一系列的定时信号。HSync: 当电子枪换到新的一行，准备进行扫描时，显示器会发出一个水平同步信号（horizonal synchronization）VSync: 而当一帧画面绘制完成后，电子枪回复到原位，准备画下一帧前，显示器会发出一个垂直同步信号（vertical synchronization）。显示器通常以固定频率进行刷新，这个刷新率就是 VSync 信号产生的频率。尽管现在的设备大都是液晶显示屏了，但原理仍然没有变 CPU, GPU 将数据交给显示器CPU, GPU 将数据交给显示器CPU 计算好显示内容提交到 GPUGPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。在最简单的情况下，帧缓冲区只有一个，这时帧缓冲区的读取和刷新都都会有比较大的效率问题。为了解决效率问题，显示系统通常会引入两个缓冲区，即双缓冲机制。在这种情况下，GPU 会预先渲染好一帧放入一个缓冲区内，让视频控制器读取，当下一帧渲染好后，GPU 会直接把视频控制器的指针指向第二个缓冲器。如此一来效率会有很大的提升。双缓冲虽然能解决效率问题，但会引入一个新的问题。当视频控制器还未读取完成时，即屏幕内容刚显示一半时，GPU 将新的一帧内容提交到帧缓冲区并把两个缓冲区进行交换后，视频控制器就会把新的一帧数据的下半段显示到屏幕上，造成画面撕裂现象，如下图：为了解决这个问题，GPU 通常有一个机制叫做垂直同步（简写也是 V-Sync），当开启垂直同步后，GPU 会等待显示器的 VSync 信号发出后，才进行新的一帧渲染和缓冲区更新。这样能解决画面撕裂现象，也增加了画面流畅度，但需要消费更多的计算资源，也会带来部分延迟。 卡顿产生的原因和解决方案在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 AppApp 主线程 开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。 卡顿原因如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。 CPU 资源消耗原因和解决方案 对象创建对象的创建会分配内存、调整属性、甚至还有读取文件等操作，比较消耗 CPU 资源。尽量用轻量的对象代替重量的对象，可以对性能有所优化。eg:CALayer 比 UIView 要轻量许多，那么不需要响应触摸事件的控件，用 CALayer 显示会更加合适。如果对象不涉及 UI 操作，则尽量放到后台线程去创建，但可惜的是包含有 CALayer 的控件，都只能在主线程创建和操作。通过 Storyboard 创建视图对象时，其资源消耗会比直接通过代码创建对象要大非常多，在性能敏感的界面里，Storyboard 并不是一个好的技术选择。尽量推迟对象创建的时间，并把对象的创建分散到多个任务中去。尽管这实现起来比较麻烦，并且带来的优势并不多，但如果有能力做，还是要尽量尝试一下。如果对象可以复用，并且复用的代价比释放、创建新对象要小，那么这类对象应当尽量放到一个缓存池里复用。 对象调整对象的调整也经常是消耗 CPU 资源的地方。这里特别说一下 CALayer：CALayer 内部并没有属性，当调用属性方法时，它内部是通过运行时 resolveInstanceMethod 为对象临时添加一个方法，并把对应属性值保存到内部的一个 Dictionary 里，同时还会通知 delegate、创建动画等等，非常消耗资源。UIView 的关于显示相关的属性（比如 frame/bounds/transform）等实际上都是 CALayer 属性映射来的，所以对 UIView 的这些属性进行调整时，消耗的资源要远大于一般的属性。对此你在应用中，应该尽量减少不必要的属性修改。当视图层次调整时，UIView、CALayer 之间会出现很多方法调用与通知，所以在优化性能时，应该尽量避免调整视图层次、添加和移除视图。 对象销毁对象的销毁虽然消耗资源不多，但累积起来也是不容忽视的。通常当容器类持有大量对象时，其销毁时的资源消耗就非常明显。如果对象可以放到后台线程去释放，那就挪到后台线程去。这里有个小 Tip：把对象捕获到 block 中，然后扔到后台队列去随便发送个消息以避免编译器警告，就可以让对象在后台线程销毁了。12345NSArray *tmp = self.array;self.array = nil;dispatch_async(queue, ^&#123; [tmp class];&#125;);在异步线程中让引用计数变为 0，达到异步回收，swift版本，123456789101112131415161718192021222324252627282930class AsyncReleaseObjc: NSObject &#123; deinit &#123; print(\"AsyncReleaseObjc:\" + #function + \"\\(Thread.current)\") &#125;&#125;class AsyncReleaseObjcViewController: UIViewController &#123; var mainReleaseData: AsyncReleaseObjc? var threadReleaseData: AsyncReleaseObjc? override func viewDidLoad() &#123; super.viewDidLoad() view.backgroundColor = .white mainReleaseData = AsyncReleaseObjc() threadReleaseData = AsyncReleaseObjc() &#125; override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; mainReleaseData = nil var tmp = threadReleaseData threadReleaseData = nil DispatchQueue.global().async &#123;// 捕获 threadReleaseData，当async 结束时，释放 tmp &#125; &#125; deinit &#123; print(\"AsyncReleaseObjcController:\" + #function) &#125;&#125; 布局计算视图布局的计算是 App 中最为常见的消耗 CPU 资源的地方。如果能在后台线程提前计算好视图布局并且对视图布局进行缓存，那么这个地方基本就不会产生性能问题了。不论通过何种技术对视图进行布局，其最终都会落到对 UIView.frame/bounds/center 等属性的调整上。上面也说过，对这些属性的调整非常消耗资源，所以尽量提前计算好布局，在需要时一次性调整好对应属性，而不要多次、频繁的计算和调整这些属性。Autolayout 对于复杂视图来说常常会产生严重的性能问题。随着视图数量的增长，Autolayout 带来的 CPU 消耗会呈指数级上升。(iOS12 性能改善，几乎跟 frame 差不多)具体数据可以看这个文章：http://pilky.me/36/。 如果你不想手动调整 frame 等属性，你可以用一些工具方法替代（比如常见的 left/right/top/bottom/width/height 快捷属性），或者使用 ComponentKit、AsyncDisplayKit 等框架。 文本计算如果一个界面中包含大量文本（比如微博微信朋友圈等），文本的宽高计算会占用很大一部分资源，并且不可避免。如果你对文本显示没有特殊要求，可以参考下 UILabel 内部的实现方式：用 [NSAttributedString boundingRectWithSize:options:context:] 来计算文本宽高，用 -[NSAttributedString drawWithRect:options:context:] 来绘制文本。尽管这两个方法性能不错，但仍旧需要放到后台线程进行以避免阻塞主线程。如果你用 CoreText 绘制文本，那就可以先生成 CoreText 排版对象，然后自己计算了，并且 CoreText 对象还能保留以供稍后绘制使用。 文本渲染屏幕上能看到的所有文本内容控件在底层都是通过 CoreText 排版、绘制为 Bitmap 显示的。UIWebView，UILabel、UITextView 等其排版和绘制都是在主线程进行的，当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。 图片的解码当你用 UIImage 或 CGImageSource 的那几个方法创建图片时，图片数据并不会立刻解码。图片设置到 UIImageView 或者 CALayer.contents 中去，并且 CALayer 被提交到 GPU 前，CGImage 中的数据才会得到解码。这一步是发生在主线程的，并且不可避免。如果想要绕开这个机制，常见的做法是在后台线程先把图片绘制到 CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。 图像的绘制图像的绘制通常是指用那些以 CG(CoreGraphic) 开头的方法把图像绘制到画布中，然后从画布创建图片并显示这样一个过程。这个最常见的地方就是 [UIView drawRect:] 里面了。由于 CoreGraphic 方法通常都是线程安全的，所以图像的绘制可以很容易的放到后台线程进行。一个简单异步绘制的过程大致如下（实际情况会比这个复杂得多，但原理基本一致）：1234567891011- (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; GPU 资源消耗原因和解决方案相对于 CPU 来说，GPU 能干的事情比较单一：接收提交的纹理（Texture）和顶点描述（三角形）应用变换（transform）、混合并渲染，然后输出到屏幕上。通常你所能看到的内容，主要也就是纹理（图片）和形状（三角模拟的矢量图形）两类。 纹理的渲染所有的 Bitmap，包括图片、文本、栅格化的内容，最终都要由内存提交到显存，绑定为 GPU Texture。不论是提交到显存的过程，还是 GPU 调整和渲染 Texture 的过程，都要消耗不少 GPU 资源。当在较短时间显示大量图片时（比如 TableView 存在非常多的图片并且快速滑动时），CPU 占用率很低，GPU 占用非常高，界面仍然会掉帧。避免这种情况的方法只能是尽量减少在短时间内大量图片的显示，尽可能将多张图片合成为一张进行显示。当图片过大，超过 GPU 的最大纹理尺寸时，图片需要先由 CPU 进行预处理，这对 CPU 和 GPU 都会带来额外的资源消耗。目前来说，iPhone 4S 以上机型，纹理尺寸上限都是 4096×4096，更详细的资料可以看这里：iosres.com。所以，尽量不要让图片和视图的大小超过这个值。 视图的混合 (Composing)当多个视图（或者说 CALayer）重叠在一起显示时，GPU 会首先把他们混合到一起。如果视图结构过于复杂，混合的过程也会消耗很多 GPU 资源。为了减轻这种情况的 GPU 消耗应用应当尽量减少视图数量和层次并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。当然，这也可以用上面的方法，把多个视图预先渲染为一张图片来显示。 图形的生成离屏渲染通常发生在 GPU 中:CALayer 的 border、圆角、阴影、遮罩（mask）CASharpLayer 的矢量图形显示，通常会触发离屏渲染（offscreen rendering）。当一个列表视图中出现大量圆角的 CALayer，并且快速滑动时，可以观察到 GPU 资源已经占满，而 CPU 资源消耗很少。这时界面仍然能正常滑动，但平均帧数会降到很低。为了避免这种情况，可以尝试开启 CALayer.shouldRasterize 属性，但这会把原本离屏渲染的操作转嫁到 CPU 上去。对于只需要圆角的某些场合，也可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。最彻底的解决办法，就是把需要显示的图形在后台线程绘制为图片，避免使用圆角、阴影、遮罩等属性。","tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://changzw.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"RxSwift 5.RxDataSources","date":"2019-01-31T05:58:32.000Z","path":"2019/01/31/RxSwfit+RAC/RxSwift-RxDataSources/","text":"原文: RxDataSources Table 和 Collection View data sources 特性[x] O(N)计算差异的算法该算法假设所有 sections 和 items 都是唯一的，因此没有二义性如果有歧义，在非动画刷新时自动回退[x] 他使用其他启发式方法以将最少数量的命令发送到分段视图即使运行时间是线性的，发送命令的首选数量通常也比线性少最好（并且有可能）将更改数量限制为较小的数量，并且如果更改数量朝线性方向增长，则只需进行正常的reload即可[x] 支持扩展你的 item 和 section 结构只需使用 IdentifiableType 和 Equatable 扩展你的 item，并使用 AnimatableSectionModelType 扩展 section[x] 支持 section 和 item 的两级分层动画的所有组合Section 动画: Insert, Delete, MovItem 动画: Insert, Delete, Move, Reload (如果旧值不等于新值)[x] 可配置动画类型对于 Insert, Reload and Delete (Automatic, Fade, …)[x] 示例 app[x] 随机压力测试（eg app）[x] 支持开箱即用的编辑（eg app）[x] 同 UITableView 和 UICollectionView 一起工作 为什么编写 table 和 collection View 数据源很繁琐。对于最简单的情况，需要实现大量的委托方法。RxSwift 通过简单的数据绑定机制有助于减轻一些负担：把你的数据转化成可见听序列 Observable使用下面方法把数据绑定到 tableView/collectionView 上rx.items(dataSource:protocol&lt;RxTableViewDataSourceType, UITableViewDataSource&gt;)rx.items(cellIdentifier:String)rx.items(cellIdentifier:String:Cell.Type:_: )rx.items(:: )123456let data = Observable&lt;[String]&gt;.just([\"first element\", \"second element\", \"third element\"])data.bind(to: tableView.rx.items(cellIdentifier: \"Cell\")) &#123; index, model, cell in cell.textLabel?.text = model&#125;.disposed(by: disposeBag)这适用于简单数据集，但不适用于需要将复杂数据集与多个section 绑定或在添加/修改/删除item 时需要执行动画的情况。这些正是RxDataSources帮助解决的用例。使用RxDataSources，写起来非常容易1234let dataSource = RxTableViewSectionedReloadDataSource&lt;SectionModel&lt;String, Int&gt;&gt;(configureCell: configureCell)Observable.just([SectionModel(model: \"title\", items: [1, 2, 3])]) .bind(to: tableView.rx.items(dataSource: dataSource)) .disposed(by: disposeBag) 怎么用给定以下自定义数据结构：12345struct CustomData &#123; var anInt: Int var aString: String var aCGPoint: CGPoint&#125;首先使用遵循 SectionModelType 协议的结构定义你的section：定义 item 类型别名：等于该 section 将包含的 item 类型声明一个 items 属性：Item 类型数组123456789101112struct SectionOfCustomData &#123; var header: String var items: [Item]&#125;extension SectionOfCustomData: SectionModelType &#123; typealias Item = CustomData init(original: SectionOfCustomData, items: [Item]) &#123; self = original self.items = items &#125;&#125;创建一个dataSource对象，并将其传递给 SectionOfCustomData 类型：1234567891011let dataSource = RxTableViewSectionedAnimatedDataSource&lt;MySection&gt;( configureCell: &#123; ds, tv, _, item in let cell = tv.dequeueReusableCell(withIdentifier: \"Cell\") ?? UITableViewCell(style: .default, reuseIdentifier: \"Cell\") cell.textLabel?.text = \"Item \\(item)\" return cell &#125;, titleForHeaderInSection: &#123; ds, index in return ds.sectionModels[index].header &#125;)根据需要在dataSource上自定义闭包：titleForHeaderInSectiontitleForFooterInSectionetc123456789101112131415dataSource.titleForHeaderInSection = &#123; dataSource, index in return dataSource.sectionModels[index].header&#125;dataSource.titleForFooterInSection = &#123; dataSource, indexPath in return dataSource.sectionModels[index].footer&#125;dataSource.canEditRowAtIndexPath = &#123; dataSource, indexPath in return true&#125;dataSource.canMoveRowAtIndexPath = &#123; dataSource, indexPath in return true&#125;将实际数据定义为 CustomData 对象的 Observable序列，并将其绑定到tableView12345678let sections = [ SectionOfCustomData(header: \"First section\", items: [CustomData(anInt: 0, aString: \"zero\", aCGPoint: CGPoint.zero), CustomData(anInt: 1, aString: \"one\", aCGPoint: CGPoint(x: 1, y: 1)) ]), SectionOfCustomData(header: \"Second section\", items: [CustomData(anInt: 2, aString: \"two\", aCGPoint: CGPoint(x: 2, y: 2)), CustomData(anInt: 3, aString: \"three\", aCGPoint: CGPoint(x: 3, y: 3)) ])]Observable.just(sections) .bind(to: tableView.rx.items(dataSource: dataSource)) .disposed(by: disposeBag) 数据源动画RxDataSources 提供了两种特殊的数据源类型，它们可以自动处理绑定数据源中的动画变化：RxTableViewSectionedAnimatedDataSource 和 RxCollectionViewSectionedAnimatedDataSource 。要使用两个动画数据源之一，你必须在上述概述的基础上采取一些额外的步骤：SectionOfCustomData需要遵守 AnimatableSectionModelType 协议数据模型必须符合IdentifiableType：IdentifiableType 协议提供的 identity 必须是表示模型实例的不可变标识符(identifier)。例如，对于 Car 模型，你可能要使用 Car 的plateNumber 作为其标识。Equatable：遵从 Equatable 协议 有助于RxDataSources确定哪些 cell 已更改，因此它只能为这些特定 cell 设置动画。这意味着，更改Car模型的任何属性都会触发该 cell 的动画重新加载。 需要Xcode 10.2Swift 5.0For Swift 4.x version please use versions 3.0.0 … 3.1.0 For Swift 3.x version please use versions 1.0 … 2.0.2 For Swift 2.3 version please use versions 0.1 … 0.9 安装 CocoaPodsPodfilepod ‘RxDataSources’, ‘~&gt; 4.0’ CarthageCartfilegithub “RxSwiftCommunity/RxDataSources” ~&gt; 4.0","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"GCD 原理+API 分析","date":"2018-12-21T02:39:22.000Z","path":"2018/12/21/GCD-原理-API-分析/","text":"GCD 是操作系统层级的概念，他给用户提供了操作线程的 API任务派发中心，内部实现原理是有了 FIFO 分发队列,GCD 源码使用 GCD 用户不需要直接操作繁琐的 thread，线程池由系统管理，用户只需要维护分发队列，向分发队列中放 task 就可以了。直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长，每个线程都会消耗一些内存和内核资源。 主要原理主要理解三个概念queue: 管理任务的队列，确定任务派发方式task: 用户自定义需要执行的 task (代码段)thread: GCD 根据 queue 定义的方式，将 task 派发给线程池中的指定线程（thread 不需要自己创建）queue串行队列，所有任务都在同一个 thread 上一个接着一个的执行特例：主队列 main_queue，所有 task 在 mainThread 中执行并发队列，任务可以在多个 thread 中执行没有固定执行顺序特例：global 队列1234567concurrentadj. adj. 并发的；一致的；同时发生的；并存的n. [数] 共点；同时发生的事件对于并行跟并发并发：值得是程序上多thread并发执行，其实是多线程抢占资源 -- cpu 执行（任务是以在单核 CPU 上分时（时间共享））并行：是硬件上，多个thread在多个 cpu 上同事执行着同步异步执行任务sync 所有任务要在一个 thread 中执行，一个接着一个async 具备开启线程的能力，可以在多个thread 中并发执行任务thread使用 GCD，不用再直接跟线程打交道了，只需要向队列中添加代码块(task)即可，GCD 在后端管理着一个线程池。作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。根据👆图 task 真正的并发只有 右下角的才能出现，并发队列中异步执行任务P.S.：async 执行 task的时候 thread 的个数跟 task 的个数没有关系（现在 iOS系统是开辟 6个 thread，以前低版本的是 3个，thread 开辟太多，会用掉大量内存）接下来说一些 GCD 接口，根据接口分析原理 分发队列 队列的创建GCD 公开有 5 个不同的全局队列：运行在主线程中的 main queue（串行队列）global 队列，3 个不同优先级的后台队列（并发队列）以及一个优先级更低的后台队列（用于 I/O）（并发队列）得到系统的全局队列12345678dispatch_queue_main_t mainDispatchQueue = dispatch_get_main_queue();/*#define DISPATCH_QUEUE_PRIORITY_HIGH 2#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0#define DISPATCH_QUEUE_PRIORITY_LOW (-2)#define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN*/dispatch_queue_global_t globalDispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。123dispatch_queue_t queueconcurrentQueue = dispatch_queue_create(\"concurrent\", DISPATCH_QUEUE_CONCURRENT);dispatch_queue_t serialQueue = dispatch_queue_create(\"serial\", DISPATCH_QUEUE_SERIAL); 创建队列并设置优先级获取全局 global 系统队列时传递优先级dipatch_queue_attr_make_with_qos_classdispatch_set_target_queue使用 dispatch_queue_attr_t 属性设置优先级1234dispatch_queue_t queue;dispatch_queue_attr_t attr;attr = dispatch_queue_attr_make_with_qos_class(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, 0);queue = dispatch_queue_create(\"com.example.myqueue\", attr);12345* The global queue priorities map to the following QOS classes:* - DISPATCH_QUEUE_PRIORITY_HIGH: QOS_CLASS_USER_INITIATED* - DISPATCH_QUEUE_PRIORITY_DEFAULT: QOS_CLASS_DEFAULT* - DISPATCH_QUEUE_PRIORITY_LOW: QOS_CLASS_UTILITY* - DISPATCH_QUEUE_PRIORITY_BACKGROUND: QOS_CLASS_BACKGROUND设置目标队列dispatch_set_target_queue 相关注释说明 123456* When no quality of service class and relative priority is specified for a* dispatch queue at the time of creation, a dispatch queue's quality of service* class is inherited from its target queue. The dispatch_get_global_queue()* function may be used to obtain a target queue of a specific quality of* service class, however the use of dispatch_queue_attr_make_with_qos_class()* is recommended instead. QOS_CLASS_USER_INTERACTIVE 指定为该QOS class的队列负责执行与用户交互相关的任务，比如动画、事件处理、更新UI等，所以有最高优先级。该优先级的队列应该只限于做与用户交互相关的任务，所以在上面优先级的宏定义中并没有将其暴露出来。QOS_CLASS_USER_INITIATED 指定为该QOS class的队列用来执行那些会阻碍用户使用你的App的任务，所以优先级也很高。QOS_CLASS_DEFAULT 默认优先级。QOS_CLASS_UTILITY 指定为该QOS class的队列用于执行那些用户不需要立即得到结果的任务，所以优先级相对较低。QOS_CLASS_BACKGROUND 指定为该QOS class的队列用于执行维护或清理等任务，用户不需要关心其结果。将自定义 queue 中的 task 都将被放入到系统的全局队列和线程池中：默认情况下会把开发者创建的队列放入到默认优先级的全局队列中。但是也可以给自定义的队列设置一个目标队列改变自定义 queue 的优先级：让其执行优先级与该目标队列的执行优先级一致。改变 queue 中 task 执行的方式：不仅能改变优先级，如果一个队列是并行的，但是其目标队列是串行的，那么实际上这个队列也会转换为串行队列。再者，不同串行队列中的任务是可以同时执行的，如果把这些串行队列的目标队列都设置为同一个串行队列，那这些串行队列中的任务将不会并行执行。12345678910111213 * @param object * The object to modify. * The result of passing NULL in this parameter is undefined. * * @param queue * The new target queue for the object. The queue is retained, and the * previous target queue, if any, is released. * If queue is DISPATCH_TARGET_QUEUE_DEFAULT, set the object's target queue * to the default target queue for the given object type. */DISPATCH_EXPORT DISPATCH_NOTHROWvoiddispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t _Nullable queue);dispatch_set_target_queue：可以设置优先级，也可以设置队列层级体系，比如让多个串行和并行队列在统一一个串行队列里串行执行dispatch_set_target_queue使用后的效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253func setTarget() &#123; let serialQueue = DispatchQueue(label: \"serialQueue\") let aQueue = DispatchQueue(label: \"concurrent.queue.0\", attributes: .concurrent, target: serialQueue) let bQueue = DispatchQueue(label: \"concurrent.queue.1\", attributes: .concurrent, target: serialQueue) let alabel = aQueue.label let blabel = bQueue.label aQueue.async &#123; print(\"\\(alabel): 1\") sleep(3) &#125; bQueue.async &#123; print(\"\\(blabel): 2\") sleep(1) &#125; bQueue.async &#123; print(\"\\(blabel): 3\") sleep(2) &#125;&#125;/*concurrent.queue.0: 1concurrent.queue.1: 2concurrent.queue.1: 3*/func nosetTarget() &#123; let aQueue = DispatchQueue(label: \"concurrent.queue.0\", attributes: .concurrent) let bQueue = DispatchQueue(label: \"concurrent.queue.1\", attributes: .concurrent) let alabel = aQueue.label let blabel = bQueue.label aQueue.async &#123; print(\"\\(alabel): 1\") sleep(3) &#125; bQueue.async &#123; print(\"\\(blabel): 2\") sleep(1) &#125; bQueue.async &#123; print(\"\\(blabel): 3\") sleep(2) &#125;&#125;/*concurrent.queue.0: 1concurrent.queue.1: 3concurrent.queue.1: 2*/ GCD 任务调度12345678910public func sync(execute workItem: DispatchWorkItem)public func async(execute workItem: DispatchWorkItem)public func async(group: DispatchGroup, execute workItem: DispatchWorkItem)public func async(group: DispatchGroup? = nil, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -&gt; Void)public func sync&lt;T&gt;(execute work: () throws -&gt; T) rethrows -&gt; Tpublic func sync&lt;T&gt;(flags: DispatchWorkItemFlags, execute work: () throws -&gt; T) rethrows -&gt; Tpublic func asyncAfter(deadline: DispatchTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -&gt; Void)public func asyncAfter(wallDeadline: DispatchWallTime, qos: DispatchQoS = .unspecified, flags: DispatchWorkItemFlags = [], execute work: @escaping @convention(block) () -&gt; Void)public func asyncAfter(deadline: DispatchTime, execute: DispatchWorkItem)public func asyncAfter(wallDeadline: DispatchWallTime, execute: DispatchWorkItem) 只执行一次 taskdispatch_once 只执行一次指定的block。它的性能要比@synchronized要好。@synchronized每一次都要先获取锁，而dispatch_once使用一个token标识代码是否执行过。1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123;&#125;);在Swift 3.0中这个函数被废弃了，但是可以使用懒加载的全局变量或静态变量，也能保证线程安全。123let onceTask: String = &#123; return \"onceTask\"&#125;() 添加栅栏函数Dispatch Barrier解决多线程多读单写同一个资源发生死锁问题同步队列中不会出现这个问题在并发队列中，如果添加了 .barrier task 那么在 .barrier task 之前添加的任务所有任务执行之前都会有任务执行，在全局并发队列和串行队列上，效果和dispatch_sync一样12345678910111213141516func barrier() &#123; let q = DispatchQueue(label: \"barrier\", attributes: .concurrent) q.async &#123; print(1) &#125; q.async(flags: .barrier) &#123; print(\"sleep 2s----\") sleep(2) &#125; q.async &#123; print(3) &#125; q.async &#123; print(4) &#125;&#125;一个 barrier 功能的 PhotoManager 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class PhotoManager &#123; private init() &#123;&#125; static let shared = PhotoManager() private let concurrentPhotoQueue = DispatchQueue( label: \"com.raywenderlich.GooglyPuff.photoQueue\", attributes: .concurrent) private var unsafePhotos: [Photo] = [] var photos: [Photo] &#123; var photosCopy: [Photo] = [] concurrentPhotoQueue.sync &#123; photosCopy = self.unsafePhotos &#125; return photosCopy &#125; func addPhoto(_ photo: Photo) &#123; concurrentPhotoQueue.async(flags: .barrier) &#123; [weak self] in guard let self = self else &#123; return &#125; self.unsafePhotos.append(photo) DispatchQueue.main.async &#123; [weak self] in self?.postContentAddedNotification() &#125; &#125; &#125; func downloadPhotos(withCompletion completion: BatchPhotoDownloadingCompletionClosure?) &#123; var storedError: NSError? for address in [PhotoURLString.overlyAttachedGirlfriend, PhotoURLString.successKid, PhotoURLString.lotsOfFaces] &#123; let url = URL(string: address) let photo = DownloadPhoto(url: url!) &#123; _, error in if error != nil &#123; storedError = error &#125; &#125; PhotoManager.shared.addPhoto(photo) &#125; completion?(storedError) &#125; private func postContentAddedNotification() &#123; NotificationCenter.default.post(name: PhotoManagerNotification.contentAdded, object: nil) &#125;&#125; 添加 group 通知dispatch groups是专门用来监视多个异步任务。dispatch_group_t实例用来追踪不同队列中的不同任务。当group里所有事件都完成GCD API有两种方式发送通知，第一种是dispatch_group_wait，会阻塞当前进程，等所有任务都完成或等待超时。第二种方法是使用dispatch_group_notify，异步执行闭包，不会阻塞。一个很棒的 使用 group 做同步的例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class PhotoManager &#123; private init() &#123;&#125; static let shared = PhotoManager() private let concurrentPhotoQueue = DispatchQueue( label: \"com.raywenderlich.GooglyPuff.photoQueue\", attributes: .concurrent) private var unsafePhotos: [Photo] = [] var photos: [Photo] &#123; var photosCopy: [Photo]! concurrentPhotoQueue.sync &#123; photosCopy = self.unsafePhotos &#125; return photosCopy &#125; func addPhoto(_ photo: Photo) &#123; concurrentPhotoQueue.async(flags: .barrier) &#123; [weak self] in guard let self = self else &#123; return &#125; self.unsafePhotos.append(photo) DispatchQueue.main.async &#123; [weak self] in self?.postContentAddedNotification() &#125; &#125; &#125; func downloadPhotos(withCompletion completion: BatchPhotoDownloadingCompletionClosure?) &#123; var storedError: NSError? let downloadGroup = DispatchGroup() var addresses = [PhotoURLString.overlyAttachedGirlfriend, PhotoURLString.successKid, PhotoURLString.lotsOfFaces] addresses += addresses + addresses var blocks: [DispatchWorkItem] = [] for index in 0..&lt;addresses.count &#123; downloadGroup.enter() let block = DispatchWorkItem(flags: .inheritQoS) &#123; let address = addresses[index] let url = URL(string: address) let photo = DownloadPhoto(url: url!) &#123; _, error in if error != nil &#123; storedError = error &#125; downloadGroup.leave() &#125; PhotoManager.shared.addPhoto(photo) &#125; blocks.append(block) DispatchQueue.main.async(execute: block) &#125; for block in blocks[3..&lt;blocks.count] &#123; let cancel = Bool.random() if cancel &#123; block.cancel() downloadGroup.leave() &#125; &#125; downloadGroup.notify(queue: DispatchQueue.main) &#123; completion?(storedError) &#125; &#125; private func postContentAddedNotification() &#123; NotificationCenter.default.post(name: PhotoManagerNotification.contentAdded, object: nil) &#125;&#125; 挂起/恢复队列12queue.suspend()queue.resume()这里挂起不会暂停正在执行的block dispatch_apply进行快速迭代123456789101112131415func apply() &#123; let q = DispatchQueue(label: \"apply\", attributes: .concurrent) __dispatch_apply(5, q)&#123; idx in print(idx)// 异步并发 &#125; print(\"apply end\")// 同步等待&#125;/*04132apply end*/dispatch_apply在并发队列中使用将 task 追加到队列中所有 task 并发执行完以后同步执行后面的打印dispatch_apply 添加的 task 是异步并发执行，外部是同步执行用dispatch_apply替代对数组等的for循环，把这些block放到并行队列中可以提高执行效率。 Dispatch Semaphore使用变量管理多线程的同步方法123dispatch_semaphore_t dispatch_semaphore_create(long value);long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout); long dispatch_semaphore_signal(dispatch_semaphore_t dsema);并发编程：API 及挑战细说GCD（Grand Central Dispatch）如何用raywenderlich 这两篇实例很棒！Grand Central Dispatch Tutorial for Swift 4: Part 1/2Grand Central Dispatch Tutorial for Swift 4: Part 2/2","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"简化设计 App 的过程","date":"2018-12-06T09:31:17.000Z","path":"2018/12/06/简化设计-App-的过程/","text":"前言一个 app 原型&amp;需求来了以后，如何实现呢？本来一个完成的东西如何把需求翻译成程序呢？ 正常节奏：分析需求原型分析需求分析技术点调研分析架构方式使用什么框架（框架对比）View 层使用什么渲染方式，Model层使用什么组件，中间层使用什么工具时间预估新技术学习时间开发时间调试时间 遇到问题需求量大，强调代码的复用性！思考时间过长需求理解错误，理解不深，差异性问题没有解决新技术，熟练度问题，错误使用沟通问题！ 简单思考简化开发流程！App 编码过程照着画 UI确定数据渲染方式！简化让 model 层数据传到 UI 层渲染的过程，让水流通（我喜欢的方式是函数响应式 rx）数据流连接完成以后，添加各种逻辑单链逻辑一条条加复用的地方在复用代码不是一下子完美的！开始的时候不要太复杂不要用太高端自己又不熟悉的技巧重构优化使用更好地技术手段都是迭代的过程","tags":[{"name":"学习感悟","slug":"学习感悟","permalink":"https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"}],"categories":[{"name":"思考","slug":"思考","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"},{"name":"开发","slug":"思考/开发","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"}]},{"title":"viewController transitions","date":"2018-11-06T09:21:48.000Z","path":"2018/11/06/UI 相关/viewController-transitions/","text":"前言iOS 系统提供了像 push, pop, cover vertically 这样的 ViewController 过渡，该篇分析如何自定义自己的 ViewController transitions。为啥要写这个因为“看着很麻烦”，比起 push，pop，present 来说……思考：ViewController 的 过渡流程步骤是什么样的都有什么组成，他们之间的逻辑是什么样的用户如何使用过渡的过程，应该有：负责触发事件负责管理过渡动画负责过渡相关的ViewControllers，Views transitions 结构transitioning API 一组 protocols 结合，允许我们自定义化，使用一个现有的 transition 对象 or 自己定义一个新的。Q: 每个协议的责任是什么？Q: 执行步骤是什么 Transitioning Delegate每个 ViewController 都有对象—— transitioningDelegate: UIViewControllerTransitioningDelegate 用来得到 Animation controller 对象12345extension CardViewController: UIViewControllerTransitioningDelegate &#123; func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return FlipPresentAnimationController(originFrame: cardView.frame) &#125;&#125;当你 present or dismiss ViewController 的时候，UIKit 会向 transitioningDelegate 要你自定义的 Animation controller 来替代默认动画。你要做的是实现 UIViewControllerTransitioningDelegate 代理方法返回 Animation controller Animation Controller用来做过渡动画，他实现自 UIViewControllerAnimatedTransitioning12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class FlipPresentAnimationController: NSObject,UIViewControllerAnimatedTransitioning &#123;// 设置动画时间 func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0.6 &#125;// 从UIViewControllerContextTransitioning 中得到 toVc &amp; fromVc，对其制作动画 func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; //1 通过 transitionContext 得到 fromVC 是触发 present的VC，toVC 是要被呈现的 VC，snapShot，是toVC 呈现以后的view 截图用于做动画 guard let fromVC = transitionContext.viewController(forKey: .from), let toVC = transitionContext.viewController(forKey: .to), let snapshot = toVC.view.snapshotView(afterScreenUpdates: true) else &#123; return &#125;//containerView 是过渡过程中的容器 view let containerView = transitionContext.containerView let finalFrame = transitionContext.finalFrame(for: toVC) snapshot.frame = originFrame snapshot.layer.cornerRadius = CardViewController.cardCornerRadius snapshot.layer.masksToBounds = true containerView.addSubview(toVC.view) containerView.addSubview(snapshot) toVC.view.isHidden = true AnimationHelper.perspectiveTransform(for: containerView) snapshot.layer.transform = AnimationHelper.yRotation(.pi / 2) let duration = transitionDuration(using: transitionContext) // 对 view 做动画处理 UIView.animateKeyframes( withDuration: duration, delay: 0, options: .calculationModeCubic, animations: &#123; UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: 1/3) &#123; fromVC.view.layer.transform = AnimationHelper.yRotation(-.pi / 2) &#125; UIView.addKeyframe(withRelativeStartTime: 1/3, relativeDuration: 1/3) &#123; snapshot.layer.transform = AnimationHelper.yRotation(0.0) &#125; UIView.addKeyframe(withRelativeStartTime: 2/3, relativeDuration: 1/3) &#123; snapshot.frame = finalFrame snapshot.layer.cornerRadius = 0 &#125; &#125;, completion: &#123; _ in toVC.view.isHidden = false snapshot.removeFromSuperview() fromVC.view.layer.transform = CATransform3DIdentity transitionContext.completeTransition(!transitionContext.transitionWasCancelled) &#125;) &#125;&#125; 简述对于需要自定义的 transitioning 的 ViewController，CustomViewControllerCustomViewController: UIViewControllerTransitioningDelegate 实现协议实现协议的12animationController(presented:, presenting:, source:) -&gt; UIViewControllerAnimatedTransitioninganimationController(dismiss:) -&gt; UIViewControllerAnimatedTransitioning自定义 Animation Controller（CustomeAnimationController: UIViewControllerAnimatedTransitioning)实现 UIViewControllerAnimatedTransitioning 中的12transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeIntervalanimateTransition(transitionContext:) 给 dismiss 添加手势交互Custom UIViewController Transitions: Getting Started","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"App 架构","date":"2018-09-18T02:28:02.000Z","path":"2018/09/18/architecture/App-架构/","text":"objc 《App 架构》 笔记 如何设计架构确定模块（Model 层，View 层，协调器……）如何确定模块？联想实际场景，分析责任、行为，确定模块！！为什么要确定模块？确定模块后，程序不会被应用框架中的实现细节所支配模块间的联系，依赖，变换，通知行为如何定义。尽可能让数据流向单向清晰确定数据流向行为统一一致，统一程序开发维护delegate，notification，block，kvo，Rx…… MVCModel 层包括，data model和server modelcontroler：引用 server model MVVM-C 网络 MVC+ViewState Model 适配器 + View 绑定器 Elm 架构","tags":[{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"}],"categories":[{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"}]},{"title":"“T” 字模型","date":"2018-08-24T07:30:54.000Z","path":"2018/08/24/开发上的思考/","text":"架构的时候容易乱——使用 “T” 字模型思考原因：架构代码的时候，总想有没有更好地解决方案，如何尽可能的模块解耦，责任单一……，如何查分类，架构中需要有什么模块，需要使用什么工具链……可是一下子把所有问放在一起，整个人很多时候会乱，而且想的越多越乱解决方案：简单化模块，现有最基本的框架 eg MVVM，MVC把最简单的模型先搭建起来，然后实现一个主流程功能接着在实现其他主流程功能想想可以添加那些 模块组件 让自己的架构更加优美重构，然后再先有个主流程线总结：现有要做的东西有个 外在的整体认识，想给用户提供什么 接口！先实现一个接口的功能，然后再把所有线的实现出来重构整体思想方式 是 “T” 字思考 模块组件间交互繁杂—— 为什么有 中介者程序调用流程是线性的，思维混乱的程序员很容易把这条线搞的杂乱无章，虽然可以让程序跑起来，可是维护费劲中介者：模块中提供中介者，定义一种编程规范，使用 中介者 让代码分类，这样把模块减少，减少杂乱的线，这些线放在中介者中中介者—— 像个管理者一样，在实际中调度各个部门，部门有什么问题想中介者汇报如果没有中介者——管理者，那么 部门之间问题相互穿插 orz","tags":[{"name":"学习感悟","slug":"学习感悟","permalink":"https://changzw.github.io/tags/%E5%AD%A6%E4%B9%A0%E6%84%9F%E6%82%9F/"}],"categories":[{"name":"思考","slug":"思考","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/"},{"name":"开发","slug":"思考/开发","permalink":"https://changzw.github.io/categories/%E6%80%9D%E8%80%83/%E5%BC%80%E5%8F%91/"}]},{"title":"RxSwift 源码分析","date":"2018-08-18T08:56:26.000Z","path":"2018/08/18/RxSwfit+RAC/RxSwift-源码分析/","text":"","tags":[{"name":"源码","slug":"源码","permalink":"https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"爬楼梯","date":"2018-07-03T06:49:50.000Z","path":"2018/07/03/爬楼梯/","text":"爬楼梯 问题描述假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？123456789101112131415注意：给定 n 是一个正整数。示例 1：输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶示例 2：输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 分析可以查分为子问题，division 使用递归暴力解决问题找到递归关系递归终止条件优化使用记忆化递归动态规划根据图总共有 8 个方式走到第 5 个台阶可以得到递归关系climbStairs(i,n) = climbStairs(i+1,n) + climbStairs(i+2,n)参数:i: 当前第几层台阶n: 总台阶数，为了提供终止递归条件123456789101112func climbStairs(_ n: Int) -&gt; Int &#123; func climbStairs_(_ i: Int, _ n: Int) -&gt; Int &#123; if i &gt; n &#123; return 0 &#125;else if i == n &#123; return 1 &#125;else &#123; return climbStairs_(i+1, n) + climbStairs_(i+2, n) &#125; &#125; return climbStairs_(0, n)&#125;从上图可以看出有很多重复的节点，每个节点都是一次 climbStairs(i,n) 调用所以可以给递归添加缓存12345678910111213141516171819func climbStairs(_ n: Int) -&gt; Int &#123; var memo: [Int?] = Array(repeating: nil, count: n) func climbStairs(_ n: Int, _ memo: inout [Int?]) -&gt; Int &#123; if n &lt;= 2 &#123; return n &#125; let index = n - 1 if memo[index] != nil &#123; return memo[index]! &#125;else &#123; memo[index] = climbStairs(n - 1, &amp;memo) + climbStairs(n - 2, &amp;memo) &#125; return memo[index]! &#125; let res = climbStairs(n, &amp;memo) return res&#125;以上都是自顶向下的逐一拆分子问题分冶算法dp表存储路径12345678910111213141516171819202122232425262728func climbStairs(_ n: Int) -&gt; Int &#123; guard n &gt; 1 else &#123; return n &#125; var dp: [Int] = [0,1,2] var i = 3 while i &lt;= n &#123; dp.append(dp[i-1] + dp[i - 2]) i += 1 &#125; return dp[n]&#125;斐波那契数列func climbStairs(_ n: Int) -&gt; Int &#123; guard n &gt; 1 else &#123; return n &#125; var first = 1 var second = 2 var i = 3 while i &lt;= n &#123; let third = first + second first = second second = third i += 1 &#125; return second&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://changzw.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://changzw.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"算法/动态规划","permalink":"https://changzw.github.io/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"合并两个有序数组","date":"2018-07-02T04:22:17.000Z","path":"2018/07/02/合并两个有序数组/","text":"合并两个有序数组 题目描述给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。12345678910说明:初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。 示例:输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 分析有序数组合并，空间足够，那么不使用缓存处理使用两个指针，分别指向两个数组的最后面pt1 = m - 1pt2 = n - 1数组长度len = 3 + 3nums1 当前指针 curr = len - 1因为 nums1 是连续的，nums2 放到 nums1 里面，那么当 nums2 遍历完后整个遍历就结束了12345678910111213141516func merge(_ nums1: inout [Int], _ m: Int, _ nums2: [Int], _ n: Int) &#123; var cur = m + n - 1 var idx1 = m - 1 var idx2 = n - 1 while idx2 &gt;= 0 &#123; if idx1 &gt;= 0 &amp;&amp; nums1[idx1] &gt; nums2[idx2] &#123; nums1[cur] = nums1[idx1] idx1 -= 1 &#125;else &#123; nums1[cur] = nums2[idx2] idx2 -= 1 &#125; cur -= 1 &#125;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"https://changzw.github.io/tags/%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://changzw.github.io/categories/%E7%AE%97%E6%B3%95/"}]},{"title":"无重复字符的最长子串","date":"2018-07-02T02:40:51.000Z","path":"2018/07/02/无重复字符的最长子串/","text":"无重复字符的最长子串 题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。123456789101112131415示例 1:输入: \"abcabcbb\"输出: 3解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。示例 2:输入: \"bbbbb\"输出: 1解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。示例 3:输入: \"pwwkew\"输出: 3解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 分析使用什么方法呢？每个是不是都是 ascii 码？如果是就尝试使用ascii做映射做滑动窗口，从左向右滑动动态规划缩小范围先使用滑动窗口的方法做 滑动窗口要有左右指针指明窗口位置，大小右指针先行走做遍历，左指针根据具体条件向右滑动当右指针走到尽头，遍历结束题目分析：1234567left, right = 0right: 0 -&gt; n left 向右移动条件： s[right]是否存在在窗口子串中 left 移动到窗口子串中字符 s[right] 的下一个位置 记录长度length返回 max(right - left, length)123456789101112131415161718192021222324func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; var len = 0 var left = s.startIndex var right = left var window = \"\" while right != s.endIndex &#123; let curChar = s[right] if window.contains(curChar) &#123; let index = window.firstIndex(of: curChar)! let distance = window.distance(from: window.startIndex, to: index) left = s.index(left, offsetBy: distance + 1) &#125; right = s.index(after: right) window = String(s[left..&lt;right]) len = max(len, s.distance(from: left, to: right)) &#125; return len&#125;leetcode 结果104 ms 21.1 MB Swift使用 hashMap 缓存window 以后优化执行时间12345678910111213141516171819func lengthOfLongestSubstring(_ s: String) -&gt; Int &#123; var itemMap: [Character: Int] = [:] var left = 0, right = 0 var len = 0 for e in s &#123; if let idx = itemMap[e] &#123; //1. 使用max 去掉 left 之前的元素，之前是这样会有问题left = idx + 1 left = max(idx + 1, left) &#125; itemMap[e] = right len = max(len, right - left + 1) right += 1 &#125; return len&#125;44 ms 21.1 MB对于上面注释的 1，如果使用 left = idx + 1 的话 eg “abba”当 curr 指针指到第二个 b 时，left = 2当 curr 指针指到第二个 a 时，left = 1我们要做的是如何把 itemMap 中第二个 b 之前不在 window 的元素清空掉？因为结果是 index 相关，所以直接使用 max 就可以了 left = max(idx + 1, left)P.S: 使用 max方法截断数组","tags":[{"name":"算法","slug":"算法","permalink":"https://changzw.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"滑动窗口","slug":"滑动窗口","permalink":"https://changzw.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"categories":[{"name":"算法","slug":"算法","permalink":"https://changzw.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"滑动窗口","slug":"算法/滑动窗口","permalink":"https://changzw.github.io/categories/%E7%AE%97%E6%B3%95/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}]},{"title":"关联对象","date":"2018-07-01T14:32:13.000Z","path":"2018/07/01/deep analyse/关联对象/","text":"关联对象是什么他是 objective-c runtime 机制中提供的一个接口，让用户在运行时，动态的给类添加关联属性 关联对象的主要作用开发中如何给 category 添加成员属性呢？或者说，如何在运行时给 class 关联新的属性？主要作用：给category 添加成员变量category 底层结构的限制，不能添加成员变量到分类中。但可以通过关联对象来间接添加。分类中的 @property 只能声明属性，不提供 _name, getName, setName 的实现类中 @property 提供 _name, getName, setName 的实现 如何使用关联对象呢 关联对象接口&lt;objc/runtime.h&gt; 中定义的以下三个允许你将任何键值在运行时关联到对象上的函数：objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObjects12345678910/*object :表示关联者，是一个对象，变量名理所当然也是objectkey :获取被关联者的索引keyvalue :被关联者policy :关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC */id objc_getAssociatedObject(id object, const void *key);void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy);//移除某个对象身上的所有关联的对象。void objc_removeAssociatedObjects(id object) 实际使用效果对比字典实现给分类添加 property1234@interface Banana (Test)@property (assign, nonatomic) CGFloat weight;@property (copy, nonatomic) NSString *name;@end123456789101112131415161718192021#define Key [NSString stringWithFormat:@\"%p\", self]@implementation Banana (Test)NSMutableDictionary *names_;NSMutableDictionary *weights_;+ (void)load &#123; weights_ = [NSMutableDictionary dictionary]; names_ = [NSMutableDictionary dictionary];&#125;- (void)setName:(NSString *)name &#123; names_[Key] = name;&#125;- (NSString *)name &#123; return names_[Key];&#125;- (void)setWeight:(int)weight &#123; weights_[Key] = @(weight);&#125;- (int)weight &#123; return [weights_[Key] intValue];&#125;@end上面使用全局字典的方式，给分类中的成员变量添加get，set 实现体那么如何使用关联对象呢？关联对象实现分类添加成员属性123456789101112131415@implementation Banana (Test)- (void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)name &#123; // 隐式参数_cmd == @selector(name) return objc_getAssociatedObject(self, _cmd);&#125;- (void)setWeight:(int)weight &#123; objc_setAssociatedObject(self, @selector(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (int)weight &#123; return [objc_getAssociatedObject(self, _cmd) intValue];&#125;@end 关联对象源码分析关联对象也是用全局 hash 表来保存的。objc4-779.1源码 这个文件中 objc-references.mm关联对象的核心类AssociationsManagerAssociationsHashMapObjectAssociationMapObjcAssociation12345678910class AssociationsManager &#123; // associative references: object pointer -&gt; PtrPtrHashMap. static AssociationsHashMap *_map;&#125;;class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt;class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt;class ObjcAssociation &#123; uintptr_t _policy; id _value;&#125;; 关联对象何时释放…… 不想看了，想看了再补充，总之他在所关联的对象释放后，会释放的 关联时采用的协议Behavior@property EquivalentDescriptionOBJC_ASSOCIATION_ASSIGN@property (assign) 或 @property (unsafe_unretained)指定一个关联对象的弱引用。OBJC_ASSOCIATION_RETAIN_NONATOMIC@property (nonatomic, strong)指定一个关联对象的强引用，不能被原子化使用。OBJC_ASSOCIATION_COPY_NONATOMIC@property (nonatomic, copy)指定一个关联对象的copy引用，不能被原子化使用。OBJC_ASSOCIATION_RETAIN@property (atomic, strong)指定一个关联对象的强引用，能被原子化使用。OBJC_ASSOCIATION_COPY@property (atomic, copy)指定一个关联对象的copy引用，能被原子化使用。 实际中使用关联对象的例子使用 closures 添加 Gesture Recognizers","tags":[{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"__weak 实现分析","date":"2018-06-01T03:58:04.000Z","path":"2018/06/01/weak-实现分析/","text":"前言runtime 维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表：key是所指对象的地址value是weak指针的地址（这个地址的值是所指对象指针的地址）数组 weak 源码分析初始化一个新的weak指针指向对象的地址__weak变量的存储12NSObject *obj = [[NSObject alloc] init];id __weak obj1 = obj;1234/* 编译器模拟代码 */id obj1;objc_initWeak(&amp;obj1, obj);objc_destroyWeak(&amp;obj1);123456789101112131415161718192021222324252627/** * Initialize a fresh weak pointer to some object location. * It would be used for code like: * * (The nil case) * __weak id weakPtr; * (The non-nil case) * NSObject *o = ...; * __weak id weakPtr = o; * * This function IS NOT thread-safe with respect to concurrent * modifications to the weak variable. (Concurrent weak clear is safe.) * * @param location Address of __weak ptr. * @param newObj Object ptr. */enum HaveOld &#123; DontHaveOld = false, DoHaveOld = true &#125;;enum HaveNew &#123; DontHaveNew = false, DoHaveNew = true &#125;;id objc_initWeak(id *location, id newObj)&#123; if (!newObj) &#123; *location = nil; return nil; &#125; return storeWeak&lt;DontHaveOld, DoHaveNew, DoCrashIfDeallocating&gt; (location, (objc_object*)newObj);&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879template &lt;HaveOld haveOld, HaveNew haveNew, CrashIfDeallocating crashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj) &#123; Class previouslyInitializedClass = nil; id oldObj; SideTable *oldTable; SideTable *newTable; // Acquire locks for old and new values. // Order by lock address to prevent lock ordering problems. // Retry if the old value changes underneath us. retry: if (haveOld) &#123; oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (haveNew) &#123; newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; SideTable::lockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); if (haveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); goto retry; &#125; // Prevent a deadlock between the weak reference machinery // and the +initialize machinery by ensuring that no // weakly-referenced object has an un-+initialized isa. if (haveNew &amp;&amp; newObj) &#123; Class cls = newObj-&gt;getIsa(); if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); class_initialize(cls, (id)newObj); // If this class is finished with +initialize then we're good. // If this class is still running +initialize on this thread // (i.e. +initialize called storeWeak on an instance of itself) // then we may proceed but it will appear initializing and // not yet initialized to the check above. // Instead set previouslyInitializedClass to recognize it on retry. previouslyInitializedClass = cls; goto retry; &#125; &#125; // Clean up old value, if any. if (haveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // Assign new value, if any. if (haveNew) &#123; newObj = (objc_object *) weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, crashIfDeallocating); // weak_register_no_lock returns nil if weak store should be rejected // Set is-weakly-referenced bit in refcount table. if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; newObj-&gt;setWeaklyReferenced_nolock(); &#125; // Do not set *location anywhere else. That would introduce a race. *location = (id)newObj; &#125; else &#123; // No new value. The storage is not changed. &#125; SideTable::unlockTwo&lt;haveOld, haveNew&gt;(oldTable, newTable); return (id)newObj;&#125; SideTable123456789struct SideTable &#123; // 自旋锁，用于对SideTable操作时进行加锁 spinlock_t slock; // 存储对象的引用计数 RefcountMap refcnts; // 存储对象的弱引用 weak_table_t weak_table; ...&#125;从 SideTables 是一个 StripedMap123static StripedMap&lt;SideTable&gt;&amp; SideTables() &#123; return *reinterpret_cast&lt;StripedMap&lt;SideTable&gt;*&gt;(SideTableBuf);&#125;12345678910111213141516171819202122template&lt;typename T&gt;class StripedMap &#123; // 定义散列表的大小#if TARGET_OS_IPHONE &amp;&amp; !TARGET_OS_SIMULATOR enum &#123; StripeCount = 8 &#125;;#else enum &#123; StripeCount = 64 &#125;;#endif struct PaddedT &#123; T value alignas(CacheLineSize); &#125;; PaddedT array[StripeCount]; // 散列函数：通过指针地址计算出index static unsigned int indexForPointer(const void *p) &#123; uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(p); return ((addr &gt;&gt; 4) ^ (addr &gt;&gt; 9)) % StripeCount; &#125; ...&#125;在发生散列冲突的时候，多个对象会共用一个SideTable，也就是多个对象会共用一个refcnts和weak_table。weak_table_t12345678910struct weak_table_t &#123; // 存储weak_entry_t weak_entry_t *weak_entries; // 当前weak_entry_t的个数 size_t num_entries; // 当前数组能够容纳的最大个数 uintptr_t mask; // 发生散列冲突时，能够遍历的元素的最大个数 uintptr_t max_hash_displacement;&#125;;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"autoreleasepool 实现分析","date":"2018-05-31T08:20:55.000Z","path":"2018/05/31/autoreleasepool-实现分析/","text":"AutoRelease 内部结构AutoReleasePool 是利用语言上的特性，程序内存自动回收问题的12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125;@autoreleasepool 是什么？在命令行中使用 clang -rewrite-objc main.m 让编译器重新改写这个文件：123456789struct __AtAutoreleasePool &#123; void * atautoreleasepoolobj; __AtAutoreleasePool() &#123; // 构造函数 atautoreleasepoolobj = objc_autoreleasePoolPush(); &#125; ~__AtAutoreleasePool() &#123;// 析构函数 objc_autoreleasePoolPop(atautoreleasepoolobj); &#125;&#125;;12345678int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125;没有 AutoreleasePool 相关的类，而在 objc 源码中搜 objc_autoreleasePoolPush1234567void * objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; AutoreleasePage 结构AutoreleasePage 是实现 AutoreleasePool 的主要类12345678910111213141516171819202122class AutoreleasePoolPage &#123; static pthread_key_t const key = AUTORELEASE_POOL_KEY; static uint8_t const SCRIBBLE = 0xA3; // 0xA3A3A3A3 after releasing static size_t const SIZE =#if PROTECT_AUTORELEASEPOOL PAGE_MAX_SIZE; // must be multiple of vm page size#else PAGE_MAX_SIZE; // size and alignment, power of 2#endif static size_t const COUNT = SIZE / sizeof(id);//一个page里要管理释放对象的个数#define EMPTY_POOL_PLACEHOLDER ((id*)1) // 空池占位 #define POOL_BOUNDARY nil // 释放池边界 magic_t const magic; // 用来校验 AutoreleasePoolPage 的结构是否完整 id *next; // 存储要用 AutoRelease 释放的对象的指针，初始化时指向 begin() pthread_t const thread; // 所属 thread AutoreleasePoolPage * const parent; // 指向父结点，第一个结点的 parent 值为 nil AutoreleasePoolPage *child; // 指向子结点，最后一个结点的 child 值为 nil uint32_t const depth; // 代表深度，从 0 开始，往后递增 1 uint32_t hiwat; // (high water mark)数据容纳的一个上限&#125;POOL_BOUNDARY 是一个边界对象 nil,之前的源代码变量名是 POOL_SENTINEL哨兵对象,用来区别每个page即每个 AutoreleasePoolPage 边界 AutoreleasePage 原理分析以上知道 AutoreleasePage 的结构，根据分析过程，思考为何如此设计 Page::push一开始调用的就是 AutoreleasePage::push()12345678910111213141516static inline void *push() &#123; id *dest; dest = autoreleaseFast(POOL_BOUNDARY); // POOL_BOUNDARY 是 nil的宏定义 return dest;&#125;static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125;autoreleaseFast 插入新 oc 对象元素的时候分三种情况需要处理：page未满，直接插入到当前pagepage已满，创建一个新page并插入page不存在，创建一个新page并插入最终都会通过 add 方法把当前需要背 AutoRelease 的对象放到 page 中，next++12345678id *add(id obj)&#123; assert(!full()); unprotect(); id *ret = next; *next++ = obj; protect(); return ret;&#125;hotPage 是当前使用的页对于autoreleasePool 多层嵌套问题，每一次push 首先插入 POOL_BOUNDARY 作为哨兵，然后接着 hotPage 中的 next 指针一个个添加对象 Page::pop(ctxt)12345678910111213141516171819202122232425static inline void pop(void *token) &#123; AutoreleasePoolPage *page; id *stop; if (token == (void*)EMPTY_POOL_PLACEHOLDER) &#123; if (hotPage()) &#123; pop(coldPage()-&gt;begin()); &#125; else &#123; setHotPage(nil); &#125; return; &#125; page = pageForPointer(token); stop = (id *)token; page-&gt;releaseUntil(stop); // memory: delete empty children if (page-&gt;lessThanHalfFull()) &#123; page-&gt;child-&gt;kill(); &#125;else if (page-&gt;child-&gt;child) &#123; page-&gt;child-&gt;child-&gt;kill(); &#125;&#125;token : pop到参数元素所在的地址,整体过程判断是不是EMPTY_POOL_PLACEHOLDER（EMPTY_POOL_PLACEHOLDER是存储在TLS中的用来表示链表最上层没有元素的pool,这样就不用创建pool可以节约内存。TLS是什么以及具体实现这篇[文章](https://blog.csdn.net/cywosp/article/details/26469435)介绍的比较详细）如果当前 pool里面有数据，就把里面的数据清空；否者就把hotPage设置为nil。接着调用page-&gt;releaseUntil(stop)给此参数之前的所有对象发送release释放内存，对象内存释放之后终点page之前的page都会变成空的最后调用page-&gt;child-&gt;kill()回收这些空page资源。 如何使用 AutoReleasePool呢官网文档使用 Cocoa 框架 创建的 thread 都会维护自己的 autorelease pool. 如果你用其他方式自己创建的 thread 需要添加 autorelease pool.如果你的 thread 常驻的，会产生大量临时对象，那就需要使用 autorelease pool (like AppKit and UIKit do on the main thread)使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool：123[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; // 这里被一个局部@autoreleasepool包围着&#125;]; 主线程的 AutoReleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。 子线程 AutoReleasePool子线程默认不会开启 Runloop，那出现 Autorelease 对象如何处理？不手动处理会内存泄漏吗？如果创建了 pool 产生的对象由 pool 管理如果没有创建 pool 产生了 AutoRelease 对象，就会调用 autoreleaseNoPage 方法。在这个方法中，会自动帮你创建一个 hotpage，并调用 page-&gt;add(obj)将对象添加到 AutoreleasePoolPage 的栈中，也就是说你不进行手动的内存管理，也不会内存泄漏Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop 什么对象自动加入到 autoreleasepool中黑幕背后的Autorelease深入理解RunLoopdoes NSThread create autoreleasepool automatically now黑幕背后的Autorelease","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"obj","slug":"obj","permalink":"https://changzw.github.io/tags/obj/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"}]},{"title":"swift 序列化Codable","date":"2018-05-10T02:10:46.000Z","path":"2018/05/10/swift 语法/swift-序列化Codable/","text":"前言序列化是将对象的状态信息转换为可以存储或传输的形式的过程(对象&lt;–&gt;I/O流)。对象信息序列化以后变成 I/O 流：可以本地化存储（持久化对象）网络通讯（网络传输对象）定制协议，跨平台、跨语言通讯 Swift 中的序列化Swift 4.0 之前仍需要手动解析Swift 4.0 以后，提供 Codable 协议仍然存在问题 没有Encoder和Decoder1234567891011121314151617181920212223let json: [String : Any] = [ \"name\": \"cap\", \"points\": 1, \"description\": \"this is a cat\",]struct Product &#123; var name: String var points: Int var description: String? // 需要手动解析 init?(json: [String: Any]) &#123; guard let name = json[\"name\"] as? String, let points = json[\"points\"] as? Int, let description = json[\"description\"] as? String else &#123; return nil &#125; self.name = name self.points = points self.description = description &#125;&#125;if let p = Product(json: json) &#123; print(p.name + \" \\(p.points) \" + p.description!)&#125; 使用编码器，类型遵循 Codable(Encodable &amp; Decodable) 协议类型遵循CodableEncodeDecode2017年6月发布的 Swift4.0 中的 Codable(Encodable &amp; Decodable) 协议，表明该协议具有被序列化和/或反序列化的能⼒。Swift 标准库中的所有基本类型都遵循 Codable 协议，Data，Date， URL，CGPoint 和 CGRect 在内的许多 Apple 框架中的常⽤数据类型，也已经适配了 Codable。自定义类型需要用户遵循 Codable协议。12345678910public typealias Codable = Decodable &amp; Encodable/// 某个类型可以将⾃身编码为⼀种外部表示public protocol Encodable &#123; /// 将值编码到给定的 encoder 中 public func encode(to encoder: Encoder) throws&#125;/// 某个类型可以从外部表示中解码得到⾃身public protocol Decodable &#123; /// 通过从给定的 decoder 中解码来创建新的实例 public init(from decoder: Decoder) throws&#125;⼀旦你拥有 codable 类型的值，你可以创建⼀个编码器，并让它将这个值转换到像是 JSON 这样的序列化格式。反过来，⼀个解码器可以将序列化后的数据转回为它原来类型的⼀个实例。Swift ⾃带两套编码解码器，JSONEncoder/JSONDecoder 和 PropertyListEncoder/PropertyListDecoder，它们存在于 Foundation 中。 JSONEncoder/JSONDecoder 不需要手动解码属性名 = key，属性类型 = value 类型一致，使用 decoder 对json解码，不需要手动解码了123456789101112131415161718192021222324252627282930313233343536373839let json = \"\"\"[ &#123; \"name\": \"Banana\", \"points\": 200, \"description\": \"A banana grown in Ecuador.\" &#125;, &#123; \"name\": \"Orange\", \"points\": 100 &#125;]\"\"\".data(using: .utf8)!struct GroceryProduct: Codable &#123; var name: String var points: Int var description: String?&#125;// 解码let decoder = JSONDecoder()let products = try decoder.decode([GroceryProduct].self, from: json)print(\"The following products are available:\")for product in products &#123; print(\"\\t\\(product.name) (\\(product.points) points)\") if let description = product.description &#123; print(\"\\t\\t\\(description)\") &#125;&#125;// 与上文无关，只描述下编码过程let jsonEncoder = JSONEncoder()let jsonData = try? jsonEncoder.encode(products)let str = String(decoding: jsonData!, as: UTF8.self)print(str)let jsonObject = try JSONSerialization.jsonObject(with: jsonData!, options: .allowFragments)print(jsonObject)GroceryProduct 类中属性都遵循 Codable 协议，Array也是，所以不需要实现 encode(to encoder: Encoder) 和 init(from decoder: Decoder) 方法 需要手动解码 json中的key值与属性名称不一致但是这个类型实际上并不⼀定需要是枚 举)。提供⾃定义的编码键是⼀种很简单，⽽且是声明式的改变类型编码的⽅式。在枚举中，我 们可以：→ 使⽤明确给定的字符串值，在编码后的输出中重命名字段，或者→ 将某个键从枚举中移除，以此完全跳过字段。12345678910111213141516171819202122232425262728293031323334353637let json = \"\"\"[ &#123; \"product_name\": \"Bananas\", \"product_cost\": 200, \"description\": \"A banana grown in Ecuador.\" &#125;, &#123; \"product_name\": \"Oranges\", \"product_cost\": 100, \"description\": \"A juicy orange.\" &#125;]\"\"\".data(using: .utf8)!struct GroceryProduct: Codable &#123; var name: String var points: Int var description: String? private enum CodingKeys: String, CodingKey &#123; case name = \"product_name\" case points = \"product_cost\" case description &#125;&#125;let decoder = JSONDecoder()let products = try decoder.decode([GroceryProduct].self, from: json)print(\"The following products are available:\")for product in products &#123; print(\"\\t\\(product.name) (\\(product.points) points)\") if let description = product.description &#123; print(\"\\t\\t\\(description)\") &#125;&#125; 类型嵌套","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"}],"categories":[{"name":"开发语言","slug":"开发语言","permalink":"https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"},{"name":"swift","slug":"开发语言/swift","permalink":"https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/swift/"}]},{"title":"Texture 布局","date":"2018-04-11T03:10:14.000Z","path":"2018/04/11/Texture-布局/","text":"Texture 目标&amp;优点Texture 的 Layout API是 UIKit AutoLayout 的高效替代品Fast：自动布局比 AutoLayout 快的多Asynchronous &amp; Concurrent: Layout 在后台计算，所以用户交互不会被终端Declarative：布局用不可变的数据结构声明。这使布局代码更易于开发，文档编制，代码审查，测试，调试，配置文件和维护。Cacheable：布局结果是不可变的数据结构，因此可以在后台对其进行预先计算并进行缓存以提高用户的感知性能。Extensible：易于在类之间共享代码。受 CSS Flexbox 模型启发flexbox model 基本概念Texture 布局系统的两个核心概念：Layout SpecsLayout Elements Layout Specsclass ASLayoutSpec布局规范（layout specification）通过了解这些子布局元素之间的相互关系布局元素，是布局元素的容器。 Layout Elementsprotocol &lt;ASLayoutElement&gt;Layout Specs 包含并排列 Layout Elements所有 ASDisplayNodes &amp; ASLayoutSpecs 都遵循协议123456-----------------------ASStackLayoutSpec----------------------| -----ASStackLayoutSpec----- -----ASStackLayoutSpec----- || | ASImageNode | | ASImageNode | || | ASImageNode | | ASImageNode | || --------------------------- --------------------------- |-------------------------------------------------------------- Layout Specs 子类ASWrapperLayoutSpecASStackLayoutSpecASInsetLayoutSpecASOverlayLayoutSpecASBackgroundLayoutSpecASCenterLayoutSpecASRatioLayoutSpecASRelativeLayoutSpecASAbsoluteLayoutSpecASCornerLayoutSpec ASWrapperLayoutSpec它可以包裹一个 ASLayoutElement ，通过这个 element 的siez set 计算这个 element 的layout。用于：ASWrapperLayoutSpec 对于在 -layoutSpecThatFits: 中包裹单个 node，返回spec.1234567891011// return a single subnode from layoutSpecThatFits:override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; return ASWrapperLayoutSpec(layoutElement: _subnode)&#125;// set a size (but not position)override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; _subnode.style.preferredSize = CGSize(width: constrainedSize.max.width, height: constrainedSize.max.height / 2.0) return ASWrapperLayoutSpec(layoutElement: _subnode)&#125; ASInsetLayoutSpec给 element 添加 inset margin。element 必须有 instrinsic size or 显示设置的size123456override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; ... let insets = UIEdgeInsets(top: 10.0, left: 10.0, bottom: 10.0, right: 10.0) let headerWithInset = ASInsetLayoutSpec(insets: insets, child: textNode) return headerWithInset&#125; ASOverlayLayoutSpec重叠布局规范尺寸是根据 element 的尺寸计算得出的。在下图中，element 是蓝色层重叠布局规范尺寸是根据包裹 element 的尺寸计算出来的。在下图中，子元素是蓝色图层。蓝色 element 会把他的 size 作为 constrainedSize 传给重叠布局元素（红色图层）。所以 element （蓝色layer）必须要有自己的 intrinsic size 或者 已经设置 size了。12345override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec&#123; let backgroundNode = ASDisplayNodeWithBackgroundColor(UIColor.blue) let foregroundNode = ASDisplayNodeWithBackgroundColor(UIColor.red) return ASOverlayLayoutSpec(child: backgroundNode, overlay: foregroundNode)&#125; ASBackgroundLayoutSpecASBackgroundLayoutSpec 布局一个组件（蓝色），并拉伸其后的另一个组件作为背景（红色）。background 规范 size根据 child 的尺寸计算。下图中，蓝色是child。将 blue child 的size 当做 constrainedSize 传给 background layout element (red layer). so child(blue layer) 一定要有自己的intrinsic size 或者 已经设置 size了。123456override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; let backgroundNode = ASDisplayNodeWithBackgroundColor(UIColor.red) let foregroundNode = ASDisplayNodeWithBackgroundColor(UIColor.blue) return ASBackgroundLayoutSpec(child: foregroundNode, background: backgroundNode)&#125; ASCenterLayoutSpecASCenterLayoutSpec 在最大 constrainedSize 将放在 child 中心位置。如果center spec’s width 和 height 没有限制，那么 ASCenterLayoutSpec 缩到 child 的size大小。ASCenterLayoutSpec 两个属性:centeringOptions. 确定 child 如何在中心规格内居中。选项包括：None, X, Y, XY.sizingOptions. 确定中心规格将占用多少空间。选项包括：Default, minimum X, minimum Y, minimum XY.12345override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; let subnode = ASDisplayNodeWithBackgroundColor(UIColor.green, CGSize(width: 60.0, height: 100.0)) let centerSpec = ASCenterLayoutSpec(centeringOptions: .XY, sizingOptions: [], child: subnode) return centerSpec&#125; ASRatioLayoutSpecASRatioLayoutSpec 使用固定宽高比来布局组件。ASRatioLayoutSpec 他的 constrainedSize 必须要配置 width or height。这样才能够使用 scaleASRatioLayoutSpec 经常用于那些没有 intrinsic size 的node（ASNetworkImageNode or ASVideoNode）。123456override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; // Half Ratio let subnode = ASDisplayNodeWithBackgroundColor(UIColor.green, CGSize(width: 100, height: 100.0)) let ratioSpec = ASRatioLayoutSpec(ratio: 0.5, child: subnode) return ratioSpec&#125; ASRelativeLayoutSpec并根据垂直和水平位置说明符对组件进行布局.与“ 9部分”图像区域相似，可以将孩子放置在4个角的任意一个或4个边缘中的任意一个的中间以及中心。12345678910111213override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; ... let backgroundNode = ASDisplayNodeWithBackgroundColor(UIColor.blue) let foregroundNode = ASDisplayNodeWithBackgroundColor(UIColor.red, CGSize(width: 70.0, height: 100.0)) let relativeSpec = ASRelativeLayoutSpec(horizontalPosition: .start, verticalPosition: .start, sizingOption: [], child: foregroundNode) let backgroundSpec = ASBackgroundLayoutSpec(child: relativeSpec, background: backgroundNode) ...&#125; ASAbsoluteLayoutSpec通过设置其子节点的layoutPosition属性来指定其子节点的确切位置（x / y坐标）。绝对布局比其他类型的布局更不灵活且难以维护。唯一属性sizing: 确定 ASAbsoluteLayoutSpec 占用多少空间。选项包括：Default 和 Size to Fit。请注意，Size to Fit 选项将复制旧的ASStaticLayoutSpec的行为123456789101112131415161718override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; let maxConstrainedSize = constrainedSize.max // Layout all nodes absolute in a static layout spec guitarVideoNode.style.layoutPosition = CGPoint.zero guitarVideoNode.style.preferredSize = CGSize(width: maxConstrainedSize.width, height: maxConstrainedSize.height / 3.0) nicCageVideoNode.style.layoutPosition = CGPoint(x: maxConstrainedSize.width / 2.0, y: maxConstrainedSize.height / 3.0) nicCageVideoNode.style.preferredSize = CGSize(width: maxConstrainedSize.width / 2.0, height: maxConstrainedSize.height / 3.0) simonVideoNode.style.layoutPosition = CGPoint(x: 0.0, y: maxConstrainedSize.height - (maxConstrainedSize.height / 3.0)) simonVideoNode.style.preferredSize = CGSize(width: maxConstrainedSize.width / 2.0, height: maxConstrainedSize.height / 3.0) hlsVideoNode.style.layoutPosition = CGPoint(x: 0.0, y: maxConstrainedSize.height / 3.0) hlsVideoNode.style.preferredSize = CGSize(width: maxConstrainedSize.width / 2.0, height: maxConstrainedSize.height / 3.0) return ASAbsoluteLayoutSpec(children: [guitarVideoNode, nicCageVideoNode, simonVideoNode, hlsVideoNode])&#125; ASCornerLayoutSpecASCornerLayoutSpec 提供一个简单方法，把 element 放在角落。12345678override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec&#123; ... // Layout the center of badge to the top right corner of avatar. let cornerSpec = ASCornerLayoutSpec(child: avatarNode, corner: badgeNode, location: .topRight) // Slightly shift center of badge inside of avatar. cornerSpec.offset = CGPoint(x: -3, y: 3) ...&#125; ASLayoutSpec所有 layout spec 都继承自它主要任务：处理 children 布局管理，用户可以 子类化它实现自己自定义 layout spec。作为间隔区：充当 ASStackLayoutSpec 的spacer，当使用 .flexGrow and/or .flexShrink 时候12345678override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; ... let spacer = ASLayoutSpec() spacer.style.flexGrow = 1.0 stack.children = [imageNode, spacer, textNode] ...&#125; ASStackLayoutSpec(Flexbox Container)相关属性对照flexbox-model有 7 个属性：direction. 确定 stack 方向。如果已经设置了 horizontalAlignment and verticalAlignment, 他们会被重新解析一遍。导致 justifyContent and alignItems也会相应的变化。spacing. 每个 child element 之间的距离.horizontalAlignment. 指定 children 是如何水平对齐的。根据stack direction方向。设置对齐方式 会导致 justifyContent or alignItems 更新。verticalAlignment. 指定 children 是如何垂直对齐的。根据stack direction方向。设置对齐方式 会导致 justifyContent or alignItems 更新。justifyContent. 沿主轴的对齐方式.alignItems. 沿交叉轴的方向布局.flexWrap. element 堆叠成单行还是多行。默认为单行。alignContent. 元素组成有多行，cross-axis方向空间充足，内容行的对齐方式。12345678910111213override func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec &#123; let mainStack = ASStackLayoutSpec(direction: .horizontal, spacing: 6.0, justifyContent: .start, alignItems: .center, children: [titleNode, subtitleNode]) // Set some constrained size to the stack mainStack.style.minWidth = ASDimensionMakeWithPoints(60.0) mainStack.style.maxHeight = ASDimensionMakeWithPoints(40.0) return mainStack&#125; Layout Element 属性ASStackLayoutElement Properties：只会在 StackLayoutSpec 中的元素(node or layout spec)生效ASAbsoluteLayoutElement Properties：只会在AbsoluateLayoutSpec中的元素（ subnode 或 layoutSpec）生效；ASLayoutElement Properties：适用于所有 Node 和 layoutSpec； ASStackLayoutElement(flex-item)属性相关属性对照flexbox-model属性类型描述.style.spacingBeforeCGFloatdirection 上与前一个 node 的间隔.style.spacingAfterCGFloatdirection 上与后一个 node 的间隔.style.flexGrowBool子节点尺寸总和小于 minimum即存在剩余空间时，是否放大.style.flexShrinkBool子节点总和大于 maximum，即空间不足时，是否缩小.style.flexBasisASDimension在使用flexGrow 或 flexShrink 属性之前，并且剩余空间被均分之前，指定item的初始size.style.alignSelfASStackLayoutAlignSelfitem 在cross-axis方向布局方式，此属性会覆盖 layoutSpec(flex-container) 属性alignItems，可选值有：Auto、Start、End、Center、Stretch.style.ascenderCGFloat用于基线对齐，描述对象从顶部到其基线的距离.style.descenderCGFloat用于基线对齐，描述对象从基线到其底部的距离 ASAbsoluteLayoutElement 属性属性类型描述.style.layoutPositionCGPoint该对象在 ASAbsoluteLayoutSpec 中的位置 ASLayoutElement 属性属性类型描述.style.widthASDimension指定 ASLayoutElement 内容区域的宽度。minWidth 和 maxWidth 属性会覆盖 width，默认值为 ASDimensionAuto.style.heightASDimension指定ASLayoutElement 内容区域的高度。minHeight 和 maxHeight 属性会覆盖 height，默认值为 ASDimensionAuto.style.minWidthASDimensionminWidth 属性用于设置一个特定布局元素的最小宽度.它可以防止 width 属性值小于 minWidth 指定的值，minWidth 的值会覆盖 maxWidth 和 width. 默认值为 ASDimensionAuto.style.maxWidthASDimensionmaxWidth 属性用于设置一个特定布局元素的最大宽度.它可以防止 width 属性值大于 maxWidth 指定的值. maxWidth 的值会覆盖 width，minWidth 会覆盖 maxWidth. 默认值为 ASDimensionAuto.style.minHeightASDimensionminHeight 属性用于设置一个特定布局元素的最小高度.它可以防止 height 属性值小于 minHeight 指定的值.minHeight 的值会覆盖 maxHeight 和 height. 默认值为 ASDimensionAuto.style.maxHeightASDimensionmaxHeight 属性用于设置一个特定布局元素的最大高度，它可以防止 height 属性值大于 maxHeight 指定的值.maxHeight 的值会覆盖 height，minHeight 会覆盖 maxHeight.默认值为 ASDimensionAuto.style.preferredSizeCGSize提供布局元素的建议 size.如果提供了 minSize 或 maxSize，并且 preferredSize 超过了这些值，则强制使用 minSize 或 maxSize.如果未提供 preferredSize，则布局元素的 size 默认为 calculateSizeThatFits: 方法提供的固有大小.此方法是可选的，但是对于没有固有大小或需要用与固有大小不同的的 size 进行布局的节点，则必须指定 preferredSize 或 preferredLayoutSize 中的一个，比如没这个属性可以在 ASImageNode 上设置，使这个节点的 size 和图片 size 不同, 警告：当 size 的宽度或高度是相对值时调用 getter 将进行断言.style.minSizeCGSize可选属性，为布局元素提供最小尺寸，如果提供，minSize 将会强制使用.如果父级布局元素的 minSize 小于其子级的 minSize，则强制使用子级的 minSize，并且其大小将扩展到布局规则之外,例如，如果给全屏容器中的某个元素设置 50％ 的 preferredSize 相对宽度，和 200pt 的 minSize 宽度，preferredSize 会在 iPhone 屏幕上产生 160pt 的宽度，但由于 160pt 低于 200pt 的 minSize 宽度，因此最终该元素的宽度会是 200pt.style.maxSizeCGSize可选属性，为布局元素提供最大尺寸，如果提供，maxSize 将会强制使用.style.preferredLayoutSizeASLayoutSize为布局元素提供建议的相对 size.ASLayoutSize 使用百分比而不是点来指定布局.例如，子布局元素的宽度应该是父宽度的 50％.如果提供了可选的 minLayoutSize 或 maxLayoutSize，并且 preferredLayoutSize 超过了这些值，则将使用 minLayoutSize 或 maxLayoutSize.style.minLayoutSizeASLayoutSize可选属性，为布局元素提供最小的相对尺寸， 如果提供，minLayoutSize 将会强制使用.如果父级布局元素的 minLayoutSize 小于其子级的 minLayoutSize，则会强制使用子级的 minLayoutSize，并且其大小将扩展到布局规则之外.style.maxLayoutSizeASLayoutSize可选属性，为布局元素提供最大的相对尺寸.如果提供，maxLayoutSize 将会强制使用.如果父级布局元素的 maxLayoutSize 小于其子级的 maxLayoutSize，那么将强制使用子级的 maxLayoutSize，并且其大小将扩展到布局规则之外 Layout API Sizing在Layout API中，理解复合尺寸类型的最简单方法是查看所有的 unit 之间的关系。 Values (CGFloat, ASDimension)ASDimension本质上是一个普通的CGFloat，支持表示点值，相对百分比值或自动值。unit 允许相同的API接受固定值和相对值。12345678// dimension returned is relative (%)ASDimensionMake(\"50%\")ASDimensionMakeWithFraction(0.5)// dimension returned in pointsASDimensionMake(\"70pt\")ASDimensionMake(70)ASDimensionMakeWithPoints(70) 使用 ASDimension 的例子ASDimension 用于设置 ASStackLayoutSpec 中element 的 flexBasis. flexBasis 属性在 stack layout 中指定对象的初始大小，在下面的视图中，我们希望左侧堆栈占据水平宽度的40％，右侧堆栈占据宽度的60％。为此，我们在水平堆栈的两个子级上设置.flexBasis属性：1234self.leftStack.style.flexBasis = ASDimensionMake(\"40%\")self.rightStack.style.flexBasis = ASDimensionMake(\"60%\")horizontalStack.children = [self.leftStack, self.rightStack] Sizes (CGSize, ASLayoutSize)ASLayoutSize与CGSize相似，但是其宽度和高度值可以表示点或百分比值。宽度和高度的类型是独立的；一个可以是点或百分比值。1ASLayoutSizeMake(ASDimension width, ASDimension height);ASLayoutSize用于设置布局元素的 .preferredLayoutSize , .minLayoutSize 和 .maxLayoutSize 属性。它允许相同的API接受固定大小以及相对大小。12345// Dimension type \"Auto\" indicates that the layout element may // be resolved in whatever way makes most sense given the circumstanceslet width = ASDimensionMake(.auto, 0)let height = ASDimensionMake(\"50%\")layoutElement.style.preferredLayoutSize = ASLayoutSizeMake(width, height)如果不需要相对值，则可以设置布局元素的.preferredSize，.minSize和.maxSize属性。这些属性采用常规CGSize值。1layoutElement.style.preferredSize = CGSize(width: 30, height: 60)大多数时候，都不想同时限制宽度和高度。在这种情况下，可以使用ASDimension值分别设置布局元素的尺寸属性。1234567layoutElement.style.width = ASDimensionMake(\"50%\")layoutElement.style.minWidth = ASDimensionMake(\"50%\")layoutElement.style.maxWidth = ASDimensionMake(\"50%\")layoutElement.style.height = ASDimensionMake(\"50%\")layoutElement.style.minHeight = ASDimensionMake(\"50%\")layoutElement.style.maxHeight = ASDimensionMake(\"50%\") Size Range (ASSizeRange)UIKit没有提供组合最小和最大CGSize的 struct。因此，创建了ASSizeRange以支持最小和最大CGSize对。ASSizeRange通常用于布局API的内部。但是，作为输入传递给layoutSpecThatFits：的constrainedSize值是ASSizeRange。1func layoutSpecThatFits(_ constrainedSize: ASSizeRange) -&gt; ASLayoutSpec传递给ASDisplayNode子类的layoutSpecThatFits：方法的constrainedSize是节点应适合的最小和最大大小。constrainedSize中包含的最小CGSize和最大CGSize可用于调整节点的布局元素的大小。","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"},{"name":"Texture","slug":"Texture","permalink":"https://changzw.github.io/tags/Texture/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"UI 布局","slug":"第三方框架/UI-布局","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"}]},{"title":"dealloc的调用时机","date":"2018-04-02T07:06:19.000Z","path":"2018/04/02/dealloc的调用时机/","text":"一般想法 delloc 会在对象释放的时候调用。用户重载该方法释放自己分配的堆控件，移除订阅……在 MRC 中12345678- (void)dealloc &#123; self.array = nil; self.string = nil; // ... // // 非Objc对象内存的释放，如CFRelease(...) // ... // [super dealloc];&#125;ARC 中12345- (void)dealloc &#123; // ... // // 非Objc对象内存的释放，如CFRelease(...) // ... //&#125;对比两端代码：这个对象实例变量（Ivars）的释放去哪儿了？没有显示的调用[super dealloc]，上层的析构去哪儿了？ ARC文档中对dealloc过程的解释A class may provide a method definition for an instance method named dealloc. This method will be called after the final release of the object but before it is deallocated or any of its instance variables are destroyed. The superclass’s implementation of dealloc will be called automatically when the method returns.大概意思是：dealloc方法在最后一次release后被调用，但此时实例变量（Ivars）并未释放，父类的dealloc的方法将在子类dealloc方法返回后自动调用The instance variables for an ARC-compiled class will be destroyed at some point after control enters the dealloc method for the root class of the class. The ordering of the destruction of instance variables is unspecified, both within a single class and between subclasses and superclasses.理解：ARC下对象的Ivars在根类[NSObject dealloc]中释放（通常root class都是NSObject），变量释放顺序各种不确定（一个类内的不确定，子类和父类间也不确定，也就是说不用care释放顺序）问题：[super delloc] 为什么可以在子类的 delloc 返回后自动调用对象的 Ivars 为什么会在根类的 delloc 中释放 delloc 调用栈分析调用过程dealloc -&gt; _objc_rootDealloc -&gt; object_dispose -&gt; objc_destructInstance123456789101112131415161718192021222324252627282930313233343536373839404142434445- (void)dealloc &#123; _objc_rootDealloc(self); &#125; void _objc_rootDealloc(id obj) &#123; obj-&gt;rootDealloc(); &#125;inline void objc_object::rootDealloc() &#123; if (isTaggedPointer()) return; // fixme necessary? if (fastpath(isa.nonpointer &amp;&amp; !isa.weakly_referenced &amp;&amp; // 弱引用 !isa.has_assoc &amp;&amp; // 关联对象 !isa.has_cxx_dtor &amp;&amp; // 析构器 !isa.has_sidetable_rc)) &#123; // 散列表 assert(!sidetable_present()); free(this); &#125; else &#123; object_dispose((id)this); &#125;&#125;id object_dispose(id obj) &#123; objc_destructInstance(obj); free(obj); return nil;&#125;/************************************************************************ objc_destructInstance* Destroys an instance without freeing memory.* Calls C++ destructors.* Calls ARC ivar cleanup.* Removes associative references.* Returns `obj`. Does nothing if `obj` is nil.**********************************************************************/void *objc_destructInstance(id obj) &#123; if (obj) &#123; // Read all of the flags at once for performance. bool cxx = obj-&gt;hasCxxDtor(); bool assoc = obj-&gt;hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj);// 清理 ivars if (assoc) _object_remove_assocations(obj);// 清理关联对象 obj-&gt;clearDeallocating();// 清理 weak 表 &#125; return obj;&#125;主要是这个方法objc_destructInstance，根据他的注释销毁实例对象，但没有释放内存调用 C++ 的 destructor掉用 ARC 将 ivar 清理清理关联对象object_cxxDestruct 做了什么？clearDeallocating 做了什么？ clearDeallocating 清空弱引用12345678910inline void objc_object::clearDeallocating() &#123; if (slowpath(!isa.nonpointer)) &#123; // Slow path for raw pointer isa. sidetable_clearDeallocating(); &#125; else if (slowpath(isa.weakly_referenced || isa.has_sidetable_rc)) &#123; // Slow path for non-pointer isa with weak refs and/or side table data. clearDeallocating_slow(); &#125; assert(!sidetable_present());&#125;ok clearDeallocating 用于清空引用计数表并清除弱引用表，将所有weak引用指nil object_cxxDestruct从这篇文章中：ARC actually creates a -.cxx_destruct method to handle freeing instance variables. This method was originally created for calling C++ destructors automatically when an object was destroyed.object_cxxDestruct 方法用于释放实例的 ivars和《Effective Objective-C 2.0》中提到的：When the compiler saw that an object contained C++ objects, it would generate a method called .cxx_destruct. ARC piggybacks on this method and emits the required cleanup code within it.可以了解到，.cxx_destruct方法原本是为了C++对象析构的，ARC借用了这个方法插入代码实现了自动内存释放的工作1234567891011121314151617181920212223242526272829void object_cxxDestruct(id obj)&#123; if (!obj) return; if (obj-&gt;isTaggedPointer()) return; object_cxxDestructFromClass(obj, obj-&gt;ISA());&#125;/************************************************************************ object_cxxDestructFromClass.* Call C++ destructors on obj, starting with cls's * dtor method (if any) followed by superclasses' dtors (if any), * stopping at cls's dtor (if any).* Uses methodListLock and cacheUpdateLock. The caller must hold neither.**********************************************************************/static void object_cxxDestructFromClass(id obj, Class cls) &#123; void (*dtor)(id); // Call cls's dtor first, then superclasses's dtors. for ( ; cls; cls = cls-&gt;superclass) &#123; if (!cls-&gt;hasCxxDtor()) return; dtor = (void(*)(id)) lookupMethodInClassAndLoadCache(cls, SEL_cxx_destruct); if (dtor != (void(*)(id))_objc_msgForward_impcache) &#123; if (PrintCxxCtors) &#123; _objc_inform(\"CXX: calling C++ destructors for class %s\", cls-&gt;nameForLogging()); &#125; (*dtor)(obj); &#125; &#125;&#125;在实例对象的最后一个 release 方法调用，引用计数 = 0 调用dealloc实例对象是否是 isTaggedPointer通过 C++ 的析构器释放 ivars 成员变量内存移除关联对象移除 weak 引用相关数据，weak 变量置为 nilARC下dealloc过程及.cxx_destruct的探究","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"功能细节记录","date":"2018-03-24T00:08:47.000Z","path":"2018/03/24/功能细节记录/","text":"使得系统setting页面中有自己app 的设置iOS开发之Settings Bundle的使用 app 和 app Extension 共享数据UserDefault 使用 groupName 初始化就可以了FileManager 数据获取一定使用 URL 格式拼接 group，如果使用 String 会读不到数据","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"22-比较级倒装","date":"2018-03-15T15:04:54.000Z","path":"2018/03/15/English/22-倒装句/","text":"介绍倒装句是⼀种把动词（或助动词）移到主语前⾯的句型。以这个定义来看，⼀般 的疑问句都可以算是倒装句。撇开疑问句这种只具有语法功能的倒装句不谈，⽐较值得研究的是具有修辞功能的倒装句。恰当地运⽤倒装句，可以强调语⽓、增强清楚性与简洁性，以及 更流畅地衔接前后的句⼦。以下分别就⼏种重要的倒装句来看看它倒装的条件， 以及可达到的修辞效果。 比较级的倒装Girls like cats more than boys.(不清楚） 这个句⼦可能有两种意思：Girls like cats more than boys do. (⼥孩比男孩更喜欢猫。）Girls like cats more than they like boys. (⼥孩比较喜欢猫，比较不喜欢男孩。）⽐较级的句型通常会牵涉到两个从句互相⽐较。这两个从句间应有重复的部 分才能⽐较。⼀旦有重复，就有省略的空间。但是如果省略不当，就会伤害句⼦ 的清楚性。 关系从句的倒装 假设语气的倒装 引用句的倒装 类似 there is/are 的倒装 否定副词开头的倒装","tags":[{"name":"语法","slug":"语法","permalink":"https://changzw.github.io/tags/%E8%AF%AD%E6%B3%95/"}],"categories":[{"name":"英语学习","slug":"英语学习","permalink":"https://changzw.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"语法","slug":"英语学习/语法","permalink":"https://changzw.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E6%B3%95/"}]},{"title":"英语语法学习","date":"2018-03-15T14:35:33.000Z","path":"2018/03/15/English/英语语法学习/","text":"使用数据：英语魔法师之语法俱乐部记录自己学习英语的过程","tags":[{"name":"English","slug":"English","permalink":"https://changzw.github.io/tags/English/"}],"categories":[{"name":"英语学习","slug":"英语学习","permalink":"https://changzw.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"},{"name":"语法","slug":"英语学习/语法","permalink":"https://changzw.github.io/categories/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E6%B3%95/"}]},{"title":"如何给自己的库添加前缀","date":"2018-03-12T15:12:42.000Z","path":"2018/03/12/如何给自己的库添加前缀/","text":"在 Rxswift中rx_tap : 原始语法The original syntaxrxTap : 同上，但是语义有歧义，如果不是 Rxswift库中却是用 rxABC 这样的reactiveTap : 语义很清楚，但是太长了rx.tap : ✨😲✨ 这样就很好了，一个漂亮的命名空间. 想法来源LazySequence12myArray.map &#123; ... &#125;myArray.lazy.map &#123; ... &#125;我们也可以在 RxCocoa 中有同样的语法:12if myButton.enabled &#123; ... &#125;myButton.rx.enabled.subscribeNext &#123; ... &#125; 实现细节 共享的代码我想我们可以把 Reactive protocol 转换成一个泛型 struct :123456public struct Reactive&lt;Base: AnyObject&gt; &#123; public let base: Base public init(_ base: Base) &#123; self.base = base &#125;&#125;接着我们扩展 NSObjectProtocol 协议来创建 rx 代理 :12345public extension NSObjectProtocol &#123; public var rx: Reactive&lt;Self&gt; &#123; return Reactive(self) &#125;&#125;RxSwift 中的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public struct Reactive&lt;Base&gt; &#123; /// Base object to extend. public let base: Base public init(_ base: Base) &#123; self.base = base &#125;&#125;/// A type that has reactive extensions.public protocol ReactiveCompatible &#123; /// Extended type associatedtype ReactiveBase @available(*, deprecated, message: \"Use `ReactiveBase` instead.\") typealias CompatibleType = ReactiveBase /// Reactive extensions. static var rx: Reactive&lt;ReactiveBase&gt;.Type &#123; get set &#125; /// Reactive extensions. var rx: Reactive&lt;ReactiveBase&gt; &#123; get set &#125;&#125;extension ReactiveCompatible &#123; /// Reactive extensions. public static var rx: Reactive&lt;Self&gt;.Type &#123; get &#123; return Reactive&lt;Self&gt;.self &#125; set &#123; // this enables using Reactive to \"mutate\" base type &#125; &#125; /// Reactive extensions. public var rx: Reactive&lt;Self&gt; &#123; get &#123; return Reactive(self) &#125; set &#123; // this enables using Reactive to \"mutate\" base object &#125; &#125;&#125;import class Foundation.NSObject/// Extend NSObject with `rx` proxy.extension NSObject: ReactiveCompatible &#123; &#125; 因为我们使用Self，所以我们需要扩展协议而不是具体类型。为了方便起见，我建议使用NSObjectProtocol，但我们也可以使用更有意义的协议，例如ReactiveCompatible或类似的协议。自己实现一个小的扩展使用 泛型（模板）创建自己的类型 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public struct Czw&lt;Base&gt; &#123; public let base: Base public init(_ base: Base) &#123; self.base = base &#125;&#125;public protocol CzwCompatible &#123; associatedtype CzwBase static var czw: Czw&lt;CzwBase&gt;.Type &#123; get set &#125; var czw: Czw&lt;CzwBase&gt; &#123; get set &#125;&#125;extension CzwCompatible &#123; public static var czw: Czw&lt;Self&gt;.Type &#123; get &#123; return Czw&lt;Self&gt;.self &#125; set &#123; // this enables using Czw to \"mutate\" base type &#125; &#125; /// Czw extensions. public var czw: Czw&lt;Self&gt; &#123; get &#123; return Czw(self) &#125; set &#123; // this enables using Czw to \"mutate\" base object &#125; &#125;&#125;import class Foundation.NSObjectextension NSObject: CzwCompatible &#123; &#125;extension String: CzwCompatible &#123;&#125;extension Czw where Base == String &#123; var x: String &#123; get &#123; \"233\" &#125; &#125;&#125;let a = \"1\"let b = a.czw.x 具体扩展现在要将 reactive extensions 添加到类型，我们需要使用通用约束来扩展Reactive，而不是扩展目标类型本身。因此对于下面这段代码：12345extension UIButton &#123; public var rx_tap: ControlEvent&lt;Void&gt; &#123; return rx_controlEvent(.touchUpInside) &#125;&#125;我们可以这么做12345extension Reactive where Base: UIButton &#123; public var tap: ControlEvent&lt;Void&gt; &#123; return controlEvent(.touchUpInside) &#125;&#125; 内存管理注意事项我看到的这种新语法的主要缺点是，它可能导致闭包内部不太直观的内存管理。实际上，现在，响应式扩展属于Reactive类型（代理）。因此，无论在方法实现中使用 self 的什么地方，它都引用代理而不是 base。但是由于这个 proxy 是一种值类型，无法弱化(weakify)它，并且每次在闭包内使用 self 时，它实际上都会 strongify（retain）其所有引用类型成员（即 base ）。因此，在实现扩展时需要格外小心。 让我们以UISearchBar为例。Sample 1 : 当前的实现1234567891011121314151617181920212223extension UISearchBar &#123; public var rx_delegate: DelegateProxy &#123; return RxSearchBarDelegateProxy.proxyForObject(self) &#125; public var rx_text: ControlProperty&lt;String&gt; &#123; let source: Observable&lt;String&gt; = Observable.deferred &#123; [weak self] () -&gt; Observable&lt;String&gt; in let text = self?.text ?? \"\" return (self?.rx_delegate.observe(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty()) .map &#123; a in return a[1] as? String ?? \"\" &#125; .startWith(text) &#125; let bindingObserver = UIBindingObserver(UIElement: self) &#123; (searchBar, text: String) in searchBar.text = text &#125; return ControlProperty(values: source, valueSink: bindingObserver) &#125;&#125;Sample 2 : 错误内存管理的新实现1234567891011121314151617181920212223extension Reactive where Base: UISearchBar &#123; public var delegate: DelegateProxy &#123; return RxSearchBarDelegateProxy.proxyForObject(self.base) &#125; public var text: ControlProperty&lt;String&gt; &#123; let source: Observable&lt;String&gt; = Observable.deferred &#123; [weak searchBar = self.base] () -&gt; Observable&lt;String&gt; in let text = searchBar?.text ?? \"\" return self.delegate.observe(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) .map &#123; a in return a[1] as? String ?? \"\" &#125; .startWith(text) &#125; let bindingObserver = UIBindingObserver(UIElement: self.base) &#123; (searchBar, text: String) in searchBar.text = text &#125; return ControlProperty(values: source, valueSink: bindingObserver) &#125;&#125;Sample 3 : 具有良好内存管理的新实现1234567891011121314151617181920212223extension Reactive where Base: UISearchBar &#123; public var delegate: DelegateProxy &#123; return RxSearchBarDelegateProxy.proxyForObject(self.base) &#125; public var text: ControlProperty&lt;String&gt; &#123; let source: Observable&lt;String&gt; = Observable.deferred &#123; [weak searchBar = self.base] () -&gt; Observable&lt;String&gt; in let text = searchBar?.text ?? \"\" return (searchBar?.rx.delegate.observe(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty()) .map &#123; a in return a[1] as? String ?? \"\" &#125; .startWith(text) &#125; let bindingObserver = UIBindingObserver(UIElement: self.base) &#123; (searchBar, text: String) in searchBar.text = text &#125; return ControlProperty(values: source, valueSink: bindingObserver) &#125;&#125;关键部分是在每个 sample 代码的第 10行sample2 很容易通过 self 访问 delegate 观察者，因为 delegate 是在同一 proxy 扩展上定义的。但是这样做，闭包捕获了 self 并保留了其所有引用成员。因此，它取消了 [weak searchBar = self.base] 捕获列表避免这种情况的正确方法是，总是在旧的实现中用 base 替换 self ，并且每当有rx_前缀时，都应该用 rx. 代理替换它。Move from rx_ prefix to a rx. proxy (for swift3 update ?)","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"},{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"Rx+MVVM 实际应用","date":"2018-03-04T11:13:20.000Z","path":"2018/03/04/RxSwfit+RAC/Rx-MVVM-实际应用/","text":"在看文 RxSwift 相关官方文档以后，知道 RxSwift 提供的多种功能以后，在实际场景中我们该怎么使用呢？ 前言本篇文章只谈 rx 在 MVVM 中如何使用。RxSwift 的功能强大，加上 Apple 提供的framework也提供了很多方式，来处理 MVVM 中事件监听回调……使用 RxSwift 的优缺点不谈，单单说 RxSwift 代码零散在 View层，ViewModel层就让人困扰，到底什么样的事件流才是最合适的，这个因人而异，不过在团队开发中框架使用的方式要统一！这样可以大大提高开发效率……MVVM 复合模式的样子1234567891011ViewController * 管理视图布局渲染 * 控制器生命周期 * 接受视图 actions，并作出相应 * 控制器跳转 * ....ViewModel * 各种 Server 的中介器 * netServer，DBServer，OtherManager…… * .... 为什么要在 MVVM 中使用 Rx抛去上段补充信息，只关注event/data的流动方向，得出下图那么可不可以把 input/output 当做槽口槽口！，如果看 RxSwift 源码可以看到大量的 sink(水槽) 类，sink 是连接各种 Observable 和 Observer 的管道:Observable 流进水槽的槽口，流出（event(data?)）Observer 流出水槽的槽口，接受（event(data?)）所以，使用 RxSwift 来制作 View层和ViewModel 层的槽口，RxSwift vs 事件/数据的流程 vs App 流程123456protocol ViewModelType &#123; associatedtype Input associatedtype Output var input: Input &#123; get &#125; var output: Output &#123; get &#125;&#125;一个详细的 demo12345678910111213141516171819202122232425262728final class SayHelloViewModel: ViewModelType &#123; let input: Input let output: Output struct Input &#123; let name: AnyObserver&lt;String&gt; let validate: AnyObserver&lt;Void&gt; &#125; struct Output &#123; let greeting: Driver&lt;String&gt; &#125; private let nameSubject = ReplaySubject&lt;String&gt;.create(bufferSize: 1) private let validateSubject = PublishSubject&lt;Void&gt;() init() &#123; let greeting = validateSubject .withLatestFrom(nameSubject) .map &#123; name in return \"Hello \\(name)!\" &#125; .asDriver(onErrorJustReturn: \":-(\") self.output = Output(greeting: greeting) self.input = Input(name: nameSubject.asObserver(), validate: validateSubject.asObserver()) &#125;&#125;Subject是私有的。没有非法侵入ViewModel的方式，只能通过公共的Input和output属性。ViewModel 可以插入到任何view，容易单元测试和Rx绑定。view 使用这种方式绑定的 demo cell 监听复用问题cell 引用的 Observable tableView:cellForRowAtIndexPath: 中被订阅，该方法反复调用的过程 cell 不会被释放，只是被复用，所以每次 cell 在该方法中订阅的时候都应该先解除上一次的订阅。如果不解除，这个 Observable 会有多个订阅者那么如何有效的解除上次 cell 复用产生的订阅呢？思路一：有三种实现方式123456789101112131415override func prepareForReuse() &#123; super.prepareForReuse()// Clean Rx subscriptions disposeBag = nil&#125;func bind(to viewModel: ViewModel) &#123; let bag = DisposeBag() nameTextField.rx .text .orEmpty .bind(to: viewModel.input.name) .disposed(by: bag) disposeBag = bag&#125;or12345override func prepareForReuse() &#123; super.prepareForReuse()// Clean Rx subscriptions disposeBag = DisposeBag()&#125;第三那种 使用 swizzle cell-rx1234567891011121314extension UITableViewCell: SelfAware &#123; @objc func rx_prepareForReuse() &#123; self.rx_prepareForReuse() rx_reusableDisposeBag = DisposeBag() &#125; public class func swizzle() &#123; // make sure this isn't a subclass guard self === UITableViewCell.self else &#123; return &#125; self.swizzleMethodForSelector(#selector(self.prepareForReuse), withMethodForSelector: #selector(self.rx_prepareForReuse)) &#125; public static func awake() &#123; UITableViewCell.swizzle() &#125;&#125;or 自定义 Rx extension，使用 takeUntil(rx.prepareReuse)引用：RxSwift + MVVM: how to feed ViewModels","tags":[{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"swift 语法小记","date":"2018-02-09T13:44:00.000Z","path":"2018/02/09/swift 语法/swift-语法小记/","text":"Swift 语法 Swift 中位移枚举如何表示OC 中位移枚举1234567// 位移枚举typedef NS_OPTIONS(NSUInteger, Direction) &#123; Top = 1 &lt;&lt; 0, // 0000 0001, Bottom = 1 &lt;&lt; 1, // 0000 0010, Left = 1 &lt;&lt; 2, // 0000 0100, Right = 1 &lt;&lt; 3, // 0000 1000,&#125;Swift中位移枚举,替换方案是选项集合(OptionSet)1234567891011121314struct Direction: OptionSet &#123; let rawValue: UInt static let top = Direction(rawValue: 1 &lt;&lt; 0) static let bottom = Direction(rawValue: 1 &lt;&lt; 1) static let left = Direction(rawValue: 1 &lt;&lt; 2) static let right = Direction(rawValue: 1 &lt;&lt; 3)&#125;在Swift就不再使用 &amp;, | 运算了， 如果想使用多选，需要用数组代替，例如```swiftlet options: Direction = [.top, .bottom] // 与OC中 Top | Bottom 相同的作用options.contains(.top)options.contains(.left) Counter loop1234567891011121314151617181920212223for i in 1...10 &#123;&#125;var g = (0..&lt;10).generate()while let i = g.next() &#123;&#125;// iterate over every other integerfor i in 0.stride(to: 10, by: 2) &#123; print(i) &#125;// skip a specific numberfor i in (0..&lt;10).filter(&#123; $0 != 5 &#125;) &#123; print(i) &#125;let a = [\"one\",\"two\",\"three\",\"four\"]// ok so this one’s a bit convoluted...let everyOther = a.enumerate().filter &#123; $0.0 % 2 == 0 &#125;.map &#123; $0.1 &#125;.lazyfor s in everyOther &#123; print(s)&#125; 编译符@discardableResult1234567891011func sum(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;sum(a: 1, b: 2) // Result of call to 'sum(a:b:)' is unused//表示取消不使用返回值的警告@discardableResult func sum(a: Int, b: Int) -&gt; Int &#123; return a + b&#125;sum(a: 1, b: 2) // No longer produce the warning在 Objective-c中1- (NSString *)greeting __attribute__((warn_unused_result)); String使用 String(describing: Class.self) 方法 代替 NSStringFromClass 得到 类的字符串 GCD once","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"}],"categories":[{"name":"开发语言","slug":"开发语言","permalink":"https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"},{"name":"swift","slug":"开发语言/swift","permalink":"https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/swift/"}]},{"title":"Texture 浅析","date":"2018-02-09T08:10:24.000Z","path":"2018/02/09/Texture-浅析/","text":"NodesASDisplayNode 是 UIView 的抽象层, 就像 UIView 是 CALayer 的抽象层一样. 不同的是 UIKit 只能运行在主线程，nodes 是线程安全的，可以在后台线程上并行实例化和配置它们的整个层次结构。 子类化 自定义 ASDisplayNode 子类如果想使用 Texture，需要自定义类继承自 ASDisplayNode 需要注意方法：注意：UIKit 相关属性方法只能在 main thread 中使用，注意 ASDisplayNode 方法在 main/background thread 中实现很重要ASDisplayNode方法线程功能描述initbackground这个方法很少用（因为background），使用 nodeBlocks 的时调用，初始化方法调用才可以调用其他方法didLoadmain类似 viewDidLoad，添加 UIKit objects初始化，配置objects 属性，事件……layoutSpecThatFitsbackground布局代码(返回 layout spec object布局nodes)，layout spec object 对象不会cache，而是在合适(啥时候？)的时候调用重新创建layoutmain调用 super.layout 方法会调用layoutSpecThatFits，这样所有的 nodes 都会布局完成，类似 viewWillLayoutSubviews 方法，很少使用，如果想这样subnode.frame = self.bounds 那就用吧 自定义 ASViewController 子类ASViewController 是 UIViewController 的子类，所以 ASViewController 需要在 main thread 中使用。ASViewController 管理 node 就像 UIViewController 管理 view 一样但是 ASViewController 的指派构造函数与 UIViewController 不同1234567init() &#123; let pagerNode = ASPagerNode() super.init(node: pagerNode) pagerNode.setDataSource(self) pagerNode.setDelegate(self)&#125;-loadView在 loadView 如果你不改变 self.view 的值，就可以，不过建议你使用 viewDidLoad 方法. 调用 [super loadView] 会设置 node.view .-viewDidLoad在 ASViewController 的生命周期中，这个方法只会，在 loadView 调用以后立即调用一次。那些只会调用一次的配置放在这里最好。布局代码不应该放在这里，因为几何元素改变这个方法不会调用（当然可以在viewDidLoad中配置监听者模式监听）-viewWillLayoutSubviews该方法与 node 的 -layout 方法在同一时间被调用，并且在ASViewController的生命周期中可能被多次调用。只要 ASViewController 的 node 的 bounds 改变（包括旋转，分屏，键盘显示），以及层次结构发生了更改（添加，删除或更改了 children），它就会被调用为了保持一致性，最佳做法是将所有布局代码放入此方法中。因为它的调用频率不高，所以不直接依赖于大小的代码也属于此处。-viewWillAppear: / -viewDidDisappear:这些方法在ASViewController的node出现在屏幕上之前（最早可见）和刚从视图层次结构中删除之后（不再可见的最早时间）被调用。这些方法提供了一个很好的机会来启动或停止与控制器的演示或解雇有关的动画。这也是记录用户操作的好地方。尽管可以多次调用这些方法并且可以获取几何图形信息，但是并不能为所有几何图形更改调用它们，因此，不应将它们用于核心布局代码（超出特定动画所需的设置）。 布局 Node 是如何绘制的下面是 一个 swift 版本的 YYAyncLayer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146public class AsyncLayer: CALayer &#123;// 1. 多串行队列控制thread并发数 private static let queues: [DispatchQueue] = &#123; (0 ... $0).map &#123; _ in DispatchQueue(label: \"com.lee.async.render\") &#125; &#125; (max(min(ProcessInfo().activeProcessorCount, 16), 1)) private static var current = 0 // 拿到指定的 queue 分配任务 private static var display: DispatchQueue &#123; objc_sync_enter(self) current += current == Int.max ? -current : 1 objc_sync_exit(self) return queues[current % queues.count] &#125; private var sentinel = 0 /// 是否异步处理 public var isAsynchronously: Bool = true public override class func defaultValue(forKey key: String) -&gt; Any? &#123; guard key == \"isAsynchronously\" else &#123; return super.defaultValue(forKey: key) &#125; return true &#125; // 如果通知重新渲染了就取消，就取消当前渲染 public override func setNeedsDisplay() &#123; cancel() super.setNeedsDisplay() &#125; public override func display() &#123; super.contents = super.contents display(isAsynchronously) &#125; public func cancel() &#123; objc_sync_enter(self) sentinel += 1 objc_sync_exit(self) &#125; deinit &#123; cancel() &#125;&#125;extension AsyncLayer &#123; private func display(_ async: Bool) &#123; guard let delegate = delegate as? AsyncLayerDelegate else &#123; return &#125; delegate.display(will: self) if async &#123; let size = bounds.size let opaque = isOpaque let scale = UIScreen.main.scale let background = (opaque &amp;&amp; (backgroundColor != nil)) ? backgroundColor : nil // 使用闭包捕获当前值，跟 self.sentinel 比较，如果self.sentinel 的值变了，说明渲染取消 let current = sentinel let isCancelled = &#123; return current != self.sentinel &#125; AsyncLayer.display.async &#123; [weak self] in guard let self = self else &#123; return &#125; guard !isCancelled() else &#123; return &#125; UIGraphicsBeginImageContextWithOptions(size, opaque, scale) guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125; if opaque &#123;// 不透明 context.saveGState() let rect = CGRect(x: 0, y: 0, width: size.width * scale, height: size.height * scale) if background == nil || background?.alpha != 1 &#123; context.setFillColor(#colorLiteral(red: 1, green: 1, blue: 1, alpha: 1)) context.addRect(rect) context.fillPath() &#125; if let color = background &#123; context.setFillColor(color) context.addRect(rect) context.fillPath() &#125; context.restoreGState() &#125; delegate.display(draw: self, at: context, with: size, isCancelled: isCancelled) if isCancelled() &#123; UIGraphicsEndImageContext()// 主线程会回调渲染 DispatchQueue.main.async &#123; delegate.display(did: self, with: false) &#125; return &#125; let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() if isCancelled() &#123; UIGraphicsEndImageContext() DispatchQueue.main.async &#123; delegate.display(did: self, with: false) &#125; return &#125; DispatchQueue.main.async &#123; if isCancelled() &#123; delegate.display(did: self, with: false) &#125; else &#123; self.contents = image?.cgImage delegate.display(did: self, with: true) &#125; &#125; &#125; &#125; else &#123; UIGraphicsBeginImageContextWithOptions(bounds.size, isOpaque, UIScreen.main.scale) guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125; if isOpaque &#123; var size = bounds.size size.width *= contentsScale size.height *= contentsScale context.saveGState() if backgroundColor == nil || backgroundColor!.alpha &lt; 1 &#123; context.setFillColor(UIColor.white.cgColor) context.addRect(CGRect(origin: .zero, size: size)) context.fillPath() &#125; if let color = backgroundColor &#123; context.setFillColor(color) context.addRect(CGRect(origin: .zero, size: size)) context.fillPath() &#125; context.restoreGState() &#125; delegate.display(draw: self, at: context, with: bounds.size) &#123; false &#125; let image = UIGraphicsGetImageFromCurrentImageContext() UIGraphicsEndImageContext() contents = image?.cgImage delegate.display(did: self, with: true) &#125; &#125;&#125;触发绘画的事务struct Transaction {} extension Transaction { static func commit(_ target: AnyObject, with selector: Selector) { let item = Item(target, with: selector) Transaction.configObserver waits.insert(item) } } extension Transaction { // transaction item 集合，确保插入事务唯一 private static var waits: Set&lt;Item&gt; = [] private static let configObserver: Void = { let runloop = CFRunLoopGetCurrent() // observer 通知什么时候渲染 let observer = CFRunLoopObserverCreate( kCFAllocatorDefault, CFRunLoopActivity.beforeWaiting.rawValue | CFRunLoopActivity.exit.rawValue, true, // repeat 0xFFFFFF, // after CATransaction(2000000) callback, nil ) CFRunLoopAddObserver(runloop, observer, .commonModes) } () private static let callback: CFRunLoopObserverCallBack = { _,_,_ in waits.forEach { _ = $0.target.perform($0.selector) } waits = [] } } extension Transaction { private struct Item: Hashable { let target: AnyObject let selector: Selector init(_ target: AnyObject, with selector: Selector) { self.target = target self.selector = selector } func hash(into hasher: inout Hasher) { hasher.combine(target.hash) hasher.combine(selector) } static func == (lhs: Transaction.Item, rhs: Transaction.Item) -&gt; Bool { return lhs.target === rhs.target &amp;&amp; lhs.selector == rhs.selector } } } 引用：Texture","tags":[{"name":"swift","slug":"swift","permalink":"https://changzw.github.io/tags/swift/"},{"name":"Texture","slug":"Texture","permalink":"https://changzw.github.io/tags/Texture/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"UI 布局","slug":"第三方框架/UI-布局","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"}]},{"title":"RxSwift 学习笔记","date":"2018-02-06T02:08:45.000Z","path":"2018/02/06/RxSwfit+RAC/RxSwift-学习笔记/","text":"学习目的知道 rxswift 都有什么知道他们都怎么用知道为什么有这些东西根类归纳整理如何自己扩展适当分析源码 主要概念可监听序列(信号)operator(信号变换&amp;组合)observer(观察者)订阅（绑定）Disposable取消订阅 如何创建信号 可监听序列event12345public enum Event&lt;Element&gt; &#123; case next(Element) case error(Swift.Error) case completed &#125;1234567891011121314let numbers: Observable&lt;Int&gt; = Observable.create &#123; observer -&gt; Disposable in observer.onNext(0) observer.onNext(1) observer.onCompleted() return Disposables.create()&#125;Observable&lt;Int&gt;.just(one)Observable.of(one, two, three)Observable.from([one, two, three])Observable&lt;Void&gt;.empty()Observable&lt;Any&gt;.never()Observable&lt;Int&gt;.range(start: 1, count: 10)Observable&lt;String&gt;.create 特征序列 Single1234public enum SingleEvent&lt;Element&gt; &#123; case success(Element) case error(Swift.Error) &#125;发出⼀个元素，或⼀个error 事件不会共享附加作⽤⼀个⽐较常⻅的例⼦就是执⾏ HTTP 请求，然后返回⼀个应答或错误。不过你也可以⽤ Single 来描述任何只有⼀个元素的序列。123456789101112131415161718192021func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; &#123; return Single&lt;[String: Any]&gt;.create &#123; single in let url = URL(string: \"https://api.github.com/repos/\\(repo)\")! let task = URLSession.shared.dataTask(with: url) &#123; data, _, error in if let error = error &#123; single(.error(error)) return &#125; guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves), let result = json as? [String: Any] else &#123; single(.error(DataError.cantParseJSON)) return &#125; single(.success(result)) &#125; task.resume() return Disposables.create &#123; task.cancel() &#125; &#125; &#125;可以对 Observable 调⽤ .asSingle() ⽅法，将它转换为 Single。 Completable没有 next 时间发出 completed 或error 事件不会共享附加作Completable 适⽤于那种你只关⼼任务是否完成，⽽不需要在意任务返回值的情况。它和 Observable有点相似。1234567891011121314func cacheLocally() -&gt; Completable &#123; return Completable.create &#123; completable in // Store some data locally ... ... guard success else &#123; completable(.error(CacheError.failedCaching)) return Disposables.create &#123;&#125; &#125; completable(.completed) return Disposables.create &#123;&#125; &#125;&#125; Maybe发出⼀个next，completed或error 事件不会共享附加作⽤如果你遇到那种可能需要发出⼀个元素，⼜可能不需要发出时，就可以使⽤ Maybe。12345678910func generateString() -&gt; Maybe&lt;String&gt; &#123; return Maybe&lt;String&gt;.create &#123; maybe in maybe(.success(\"RxSwift\")) // OR maybe(.completed) // OR maybe(.error(error)) return Disposables.create &#123;&#125; &#125; &#125;以对 Observable 调⽤ .asMaybe() ⽅法，将它转换为 Maybe。 Driver主要是为了简化 UI 层的代码不会产⽣ error 事件⼀定在 MainScheduler 监听（主线程监听）共享附加作⽤使用 driver 的原因1234567891011121314151617181920let results = query.rx.text .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .observeOn(MainScheduler.instance) // 结果在主线程返回 .catchErrorJustReturn([]) // 错误被处理了，这样⾄少不会终⽌整个序列 &#125; .share(replay: 1)// HTTP 请求是被共享的results .map &#123; \"\\($0.count)\" &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag)使用 drive1234567891011121314151617let results = query.rx.text.asDriver() // 将ControlProperty 转换为 Driver .throttle(0.3, scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .asDriver(onErrorJustReturn: []) // 仅仅提供发⽣错误时的备选返回值 &#125;results .map &#123; \"\\($0.count)\" &#125; .drive(resultCount.rx.text) // 这⾥改⽤ `drive` ⽽不是 `bindTo` .disposed(by: disposeBag) // 这样可以确保必备条件都已经满⾜了results .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag) SignalSignal 和 Driver 相似，唯⼀的区别是，Driver 会对新观察者回放（重新发送）上⼀个元素，⽽ Signal 不会对新观察者回放上⼀个元素。不会产⽣ error 事件⼀定在 MainScheduler 监听（主线程监听）共享附加作⽤⼀般情况下状态序列我们会选⽤ Driver 这个类型，事件序列我们会选⽤ Signal 这个类型。 ControlEventControlEvent 专⻔⽤于描述 UI 控件所产⽣的事件，它具有以下特征：不会产⽣ error 事件⼀定在 MainScheduler⼀定在 MainScheduler 订阅（主线程订阅） 监听（主线程监听）共享附加作⽤ 观察者 AnyObserver 特征观察者 Binder不会处理错误事件确保绑定都是在给定 Scheduler 上执⾏（默认 MainScheduler）只处理 next 事件在介绍 AnyObserver 时，我们举了这样⼀个例⼦：123456789101112let observer: AnyObserver&lt;Bool&gt; = AnyObserver &#123; [weak self] (event) in switch event &#123; case .next(let isHidden): self?.usernameValidOutlet.isHidden = isHidden default: break &#125; &#125;usernameValid .bind(to: observer) .disposed(by: disposeBag)由于这个观察者是⼀个 UI 观察者，所以它在响应事件时，只会处理 next 事件，并且更新 UI 的操作需要在主线程上执⾏。因此⼀个更好的⽅案就是使⽤ Binder：123456let observer: Binder&lt;Bool&gt; = Binder(usernameValidOutlet) &#123; (view, isHidden) in view.isHidden = isHidden &#125; usernameValid .bind(to: observer) .disposed(by: disposeBag)Binder 可以只处理 next 事件，并且保证响应 next 事件的代码一定会在给定 Scheduler 上执⾏，这⾥采⽤默认的 MainScheduler。复用由于⻚⾯是否隐藏是⼀个常⽤的观察者，所以应该让所有的 UIView 都提供这种观察者：123456789101112extension Reactive where Base: UIView &#123; public var isHidden: Binder&lt;Bool&gt; &#123; return Binder(self.base) &#123; view, hidden in view.isHidden = hidden &#125; &#125; &#125;//-----usernameValid .bind(to: usernameValidOutlet.rx.isHidden) .disposed(by: disposeBag) 即使观察序列又是观察者 AsyncSubject PublishSubject ReplaySubject BehaviorSubject ControlProperty RxRelay PublishRelayPublishRelay 就是 PublishSubject 去掉终⽌事件 onError 或 onCompleted 。 BehaviorRelayBehaviorRelay 就是 BehaviorSubject 去掉终⽌事件 演示 onError 或 onCompleted 。 如何选择operatorObservable 创建产⽣特定的⼀个元素：just经过⼀段延时：timer从⼀个序列拉取元素：from重复的产⽣某⼀个元素：repeatElement存在⾃定义逻辑：create每次订阅时产⽣：deferred每隔⼀段时间，发出⼀个元素：interval在⼀段延时后：timer⼀个空序列，只有⼀个完成事件：empty⼀个任何事件都没有产⽣的序列：neverObservable组合任意⼀个 Observable 产⽣了元素，就发出这个元素：merge当上⼀个 Observable 才能开始发出元素：concat组合多个 Observables 的元素当每⼀个 Observable 都发出⼀个新的元素：zip当任意⼀个 Observable 发出⼀个新的元素：combineLatestObservable转换对每个元素直接转换：map转换到另⼀个 Observable ：flatMap只接收最新的元素转换的 Observable 所产⽣的元素：flatMapLatest每⼀个元素转换的 Observable 按顺序产⽣元素：concatMap基于所有遍历过的元素：scan基于时间序拖延⼀段时间后再发出：delay想要将产⽣的事件封装成元素发送出来将他们封装成 Event：materialize然后解封出来：dematerialize基于数量的操作忽略掉所有的 next 事件，只接收 completed 和 error 事件：ignoreElements创建⼀个新的 Observable 在原有的序列前⾯加⼊⼀些元素：startWith我想从 Observable 中收集元素，缓存这些元素之后在发出：buffer我想将 Observable 拆分成多个 Observables ：window基于元素的共同特征：groupBy我想只接收 Observable 中特定的元素发出唯⼀的元素：single我想重新从 Observable 中发出某些元素通过判定条件过滤出⼀些元素：filter仅发出头⼏个元素：take仅发出尾部的⼏个元素：takeLast仅仅发出第 n 个元素：elementAt跳过头⼏个元素跳过头 n 个元素：skip跳过头⼏个满⾜判定的元素：skipWhile，skipWhileWithIndex跳过某段时间内产⽣的头⼏个元素：skip跳过头⼏个元素直到另⼀个 Observable 发出⼀个元素：skipUntil只取头⼏个元素只取头⼏个满⾜判定的元素：takeWhile，takeWhileWithIndex只取某段时间内产⽣的头⼏个元素：take只取头⼏个元素直到另⼀个 Observable 发出⼀个元素：takeUntil周期性的对 Observable 抽样：sample发出那些元素，这些元素产⽣后的特定的时间内，没有新的元素产⽣：debounce直到元素的值发⽣变化，才发出新的元素：distinctUntilChanged并提供元素是否相等的判定函数：distinctUntilChanged在开始发出元素时，延时后进⾏订阅：delaySubscription我想要从⼀些 Observables 中，只取第⼀个产⽣元素的 Observable ：amb我想评估 Observable 的全部元素并且对每个元素应⽤聚合⽅法，待所有元素都应⽤聚合⽅法后，发出结果：reduce并且对每个元素应⽤聚合⽅法，每次应⽤聚合⽅法后，发出结果：scan我想在某个 Scheduler 应⽤操作符：subscribeOn在某个 Scheduler 监听：observeOn我想要 Observable 发⽣某个事件时, 采取某个⾏动：do我想要 Observable 发出⼀个 error 事件：error如果规定时间内没有产⽣元素：timeout我想要 Observable 发⽣错误时，优雅的恢复如果规定时间内没有产⽣元素，就切换到备选 Observable ：timeout如果产⽣错误，将错误替换成某个元素 ：catchErrorJustReturn如果产⽣错误，就切换到备选 Observable ：catchError如果产⽣错误，就重试 ：retry我创建⼀个 Disposable 资源，使它与 Observable 具有相同的寿命：using我创建⼀个 Observable ，直到我通知它可以产⽣元素后，才能产⽣元素：publish并且，就算是在产⽣元素后订阅，也要发出全部元素：replay并且，⼀旦所有观察者取消观察，他就被释放掉：refCount通知它可以产⽣元素了：connect 动态信号1234567RACSignal *s = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@0]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; &#125;];&#125;]; Cocoa 桥接12345678910111213141516171819202122232425262728293031323334- (void) bridge &#123; RACSignal *sO = RACObserver(self, button); self.sigSetFrame = [self.button rac_signalForSelector:@selector(setFrame:)]; [_sigSetFrame subscribeNext:^(id x) &#123; NSLog(@\"setFrame:%@\", x); &#125;]; self.sigClick = [self.button rac_signalForControlEvents:UIControlEventTouchUpInside]; [_sigClick subscribeNext:^(id x) &#123; NSLog(@\"event: %@\", x); &#125;]; [[self rac_liftSelector:@selector(lift:) withSignals:_sigClick, nil] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [[self rac_liftSelector:@selector(lift:) withSignalsFromArray:@[[_sigClick map:^id(id value) &#123; return @[@3]; &#125;]]] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [self rac_liftSelector:@selector(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@1)]];&#125;- (int) lift:(id)value&#123; printf(\"lift: %s\", __func__); return 1;&#125; 信号变化(内部是产生一个新信号的)123[_sigClick map:^id(id value) &#123; return @[@3];&#125;]; 序列转换1self.sigSequence = [[RACSequence return:@3] concat:[RACSequence return:@4]].signal; 订阅（绑定）信号的方式 直接订阅方法1234[self.sigSample subscribeNext:^(id x) &#123; NSLog(@\"sample: %@\", x);&#125;]; 绑定1RAC(self, a) = Signal; Cocoa 桥接1234567891011121314151617181920- (void)signal &#123; [[self rac_liftSelector:@selector(lift:) withSignals:_sigClick, nil] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [[self rac_liftSelector:@selector(lift:) withSignalsFromArray:@[[_sigClick map:^id(id value) &#123; return @[@3]; &#125;]]] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [self rac_liftSelector:@selector(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@1)]];&#125;- (int) lift:(id)value&#123; printf(\"lift: %s\", __func__); return 1;&#125; 信号变化&amp;组合单个信号的变化多个信号的组合高阶操作 值操作问题：为什么会有这样的值操作方法？自己如何扩展新的值方法transform 这些用的比较多mapMapReplaceReduceEach tuple(a, b) -&gt; c值判断逻辑变换notandor用的比较少reduceApply 这个不太清楚为什么要这么设计，用combineLatest: reduceEach: 就可以做了，而且代码看起来更好。materializedematerialize 数量操作repeat 一直会有值条件过滤1ignoreignoreValuesdistinctUntilChanged条件过滤2takeUntilBlock:(BOOL (^)(id x))predicatetakeWhileBlock:(BOOL (^)(id x))predicate;skipUntilBlock:(BOOL (^)(id x))predicate;skipWhileBlock:(BOOL (^)(id x))predicate;数量判断，如果有值就发送any;any:(BOOL (^)(id object))predicateBlock;all:(BOOL (^)(id object))predicateBlock;重试retryretry: Countcollect 汇聚 信号必须有返回值副作用：– 对于信号值变化以外的一些操作doNextdoCompleteddoError折叠函数不听对一个value 操作，使用折叠函数解决这个问题123[sig10 aggregateWithStart:@0 reduce:^id(id running, id next) &#123; return @([running intValue] + [next intValue]);&#125;];(RACSignal *)aggregateWithStart:(id)start reduce:(id (^)(id running, id next))reduceBlock;(RACSignal *)aggregateWithStart:(id)start reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock;(RACSignal *)aggregateWithStartFactory:(id (^)(void))startFactory reduce:(id (^)(id running, id next))reduceBlock;(instancetype)scanWithStart:(id)startingValue reduce:(id (^)(id running, id next))reduceBlock;(instancetype)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock; 时间操作+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler;+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler withLeeway:(NSTimeInterval)leeway;delaythrottle 阀门，在固定时间内没有新值发送的时候，会发送最后的值 多个信号组合问题：受哪个信号终止而终止？错误传递？各个信号何时开始开始订阅？在哪个线程发出？concat第一个结束后，订阅第二个第一个error 后，就直接 errormergezipcombineLatestsampletakeUntiltakeUntilReplacement, 当 B 来了直接替换 A，开始订阅 B 信号的高阶操作（升阶降阶）升阶 S(v) -&gt; S(s(v))降阶 S(s(v)) -&gt; S(v)1234RACSignal *signal = @[@1, @2, @3, @4].rac_sequence.signal;RACSignal *signalB = [[signal map:^id(id value) &#123; return [[RACSignal return:value] delay:1];&#125;] concat];降阶操作switchToLatestsif/then/elseswitch/cases/defaultflattenflatten 类似 merge 只不过一个是接收的 value是 signal，另一个接收的就是 valueflatten:count 按个数展开信号，当信号个数 &gt; count 以后等待，如果有 sig completed，那么把等待中的sig 放入展开数组里面flatten:1 == concatflattenMap满足 monad 的部分定义，绝大部分函数都可以使用 flattenMap 实现bind大部分函数都可以使用 bind 实现 冷信号&amp;热信号 一些习题如何获得无限递增的信号12345678RACSignal *increment(int inc) &#123; RACSignal *repeat = [[RACSignal return:@(inc)] repeat]; return [[repeat scanWithStart:0 reduce:^id(id running, id next) &#123; return @([running intValue] + [next intValue]); &#125;] delay:1];&#125;fibonacci1234567RACSignal *fibonacci() &#123; RACSignal *repeat = [[RACSignal return:nil] repeat]; return [repeat scanWithStart:RACTuplePack(@1, @1) reduce:^id(RACTuple *running, id _) &#123; int next = [running.first intValue] + [running.second intValue]; return RACTuplePack(running.second, @(next)); &#125;];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"RxSwift 4.Action","date":"2018-02-03T12:27:31.000Z","path":"2018/02/03/RxSwfit+RAC/RxSwift-Action/","text":"原文：Action该库与RxSwift一起使用，以在可观察对象之上提供抽象：Action。Action 是说“嘿，稍后我需要你订阅此内容”的一种方式。实际上，它涉及的更多。Action 初始化时需要 workFactory: 一个需要一些输入并产生可观察值的闭包。调用 execute() 时，它将参数传递给此闭包并订阅工作。只有在“enabled”时才可以执行（如果未指定，则为true）一次只执行一件事。汇总各个执行中的 next/error 事件Action 和 UIButton 配合使用。它管理按钮的 enable 状态，确保在工作完成时禁用按钮 如何使用必须传递一个 workFactory ，该工厂接受输入并返回一个 Observable每当你调用 execute(input)，你传入的 input 传入到 workFactory 执行该 Action 订阅 Observable 对象，然后在 Action 的 elements 属性上发 Observable 的 Next事件如果 Observable 发出 event 事件，这个 error 会以 next 事件在 Action 的 errors 属性中以 next 事件发出Actions 每次只能执行一次，如果你尝试执行一个正在 executing 的 action，会得到一个 error。Action 的 executing 属性会发送 next 事件，关联值是 ture or false12345action: Action&lt;String, Bool&gt; = Action(workFactory: &#123; input in return networkLibrary.checkEmailExists(input)&#125;)...action.execute(\"ash@ashfurrow.com\")注意：第一个泛型参数是 input 的类型。第二个泛型是 workFactory 闭包创建的 Observable 发送 next 事件的数据类型（你可以把它看做 Action 的Output）还可以为 Action 初始化程序指定 enabledIf 参数。1234let validEmailAddress = emailTextField.rx.text.map(isValidEmail)action: Action&lt;String, Bool&gt; = Action(enabledIf: validEmailAddress, workFactory: &#123; input in return networkLibrary.checkEmailExists(input)&#125;)此时 execute() 只有当 email address 合法才会执行.注意， enabledIf 与 enabled 属性不同。UIButton 扩展：它接受CocoaAction，它的类型是 Action &lt;Void，Void&gt;。1button.rx.action = action当按下按钮时，action 执行操作。button 的 enable 属性和 action 的 enabled 属性绑定。这意味着你可以将表单验证逻辑作为信号输入到 action 中，并为你处理按钮的启用状态。同样，用户不能在动作完成执行之前再次按下按钮，因为它一次只能处理一件事。看看这个实际的CocoaAction代码示例。如果你想使用 Action 进行复杂的操作，例如使用下载进度报告下载文件（例如，更新UI中的进度条），那么可以使用 Action&lt;Void，Int&gt; 代替CocoaAction。开箱即用的CocoaAction无法发出进度值，你自己的 Action&lt;Void，Int&gt; 将做到这一点。有关详细信息，请参阅本文。如果你的方案涉及许多需要触发同一操作以提供不同输入的按钮，则可以在每个UIButton上使用bindTo，并使用闭包返回正确的输入。12345678let button1 = UIButton()let button2 = UIButton()let action = Action&lt;String, String&gt; &#123; input in print(input) return .just(input)&#125;button1.rx.bindTo(action) &#123; _ in return \"Hello\"&#125;button2.rx.bindTo(action) &#123; _ in return \"Goodbye\"&#125;button1和button2共享相同的Action，但是它们使用不同的输入（相应的输出Hello和Goodbye）更复杂的用例可以是与UIViewController相关的单个操作，该操作管理你的导航，错误处理和加载状态。通过这种方法，可以根据需要拥有任意数量的 UIButton（或UIBarButtonItems），在一个公共位置一次性订阅 executing ，errors 和 elements。UIAlertController 还使用了一个非常酷的 UIAlertAction 扩展。一招：由于该类的限制，你无法使用常规的初始化程序实例化它。相反，请调用此类方法：1let action = UIAlertAction.Action(\"Hi\", style: .default)","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"RxSwift 3.Subject(Observable & Observer)","date":"2018-02-02T10:33:57.000Z","path":"2018/02/02/RxSwfit+RAC/RxSwift-3-Subject(Observable&Observer)/","text":"首先在开发的时候思考，他是一个 Observable AsyncSubject特点：当 Observable Sequence 发送 complete 事件，AsyncSubject 才会发送最后一个 next 事件和 complete当 Observable Sequence 发送 error 事件，AsyncSubject 只发送 error 事件，不会发送最后一个 next2. 演示 123456789let disposeBag = DisposeBag() let subject = AsyncSubject&lt;String&gt;()subject .subscribe &#123; print(\"Subscription: 1 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\" \")subject.onNext(\" \")subject.onNext(\" \")subject.onCompleted() 输出结果： 12Subscription: 1 Event: next(ί )Subscription: 1 Event: completed PublishSubject特点：PublishSubject 发送订阅后产⽣的元素.PublishSubject 不发送订阅前产⽣的元素.2. 演示 123456789101112let disposeBag = DisposeBag()let subject = PublishSubject&lt;String&gt;()subject .subscribe &#123; print(\"Subscription: 1 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\" \")subject.onNext(\" \")subject .subscribe &#123; print(\"Subscription: 2 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\"A \")subject.onNext(\"B \") 123456Subscription: 1 Event: next( )Subscription: 1 Event: next( )Subscription: 1 Event: next(A )Subscription: 2 Event: next(A )Subscription: 1 Event: next(B )Subscription: 2 Event: next(B ) ReplaySubject特点：ReplaySubject 将对观察者发送全部的元素，⽆论观察者是何时进⾏订阅的。2. 演示 123456789101112let disposeBag = DisposeBag()let subject = ReplaySubject&lt;String&gt;.create(bufferSize: 1)subject .subscribe &#123; print(\"Subscription: 1 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\" \")subject.onNext(\" \")subject .subscribe &#123; print(\"Subscription: 2 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\"A \")subject.onNext(\"B \") 1234567Subscription: 1 Event: next( ) Subscription: 1 Event: next( ) Subscription: 2 Event: next( )Subscription: 1 Event: next(A )Subscription: 2 Event: next(A )Subscription: 1 Event: next(B )Subscription: 2 Event: next(B ) BehaviorSubject特点：具有默认值当订阅 BehaviorSubject 时，它会将源 Observable 中最新的元素发送出来（如果不存在最新的元素，就发出默认元素）。然后将随后产⽣的元素发送出来。如果 Observable 发 error 事件，那么BehaviorSubject不会再发送 next 事件，而只是传递来自源 Observable 的 error 事件。normalerror2. 演示 12345678910111213141516171819let disposeBag = DisposeBag()let subject = BehaviorSubject(value: \" \")subject .subscribe &#123; print(\"Subscription: 1 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\" \") subject.onNext(\" \") subject .subscribe &#123; print(\"Subscription: 2 Event:\", $0) &#125; .disposed(by: disposeBag)subject.onNext(\"A \") subject.onNext(\"B \") subject .subscribe &#123; print(\"Subscription: 3 Event:\", $0) &#125; .disposed(by: disposeBag) subject.onNext(\" \") subject.onNext(\" \") 123456789101112131415Subscription: 1 Event: next( )Subscription: 1 Event: next( )Subscription: 1 Event: next( )Subscription: 2 Event: next( )Subscription: 1 Event: next(A )Subscription: 2 Event: next(A )Subscription: 1 Event: next(B )Subscription: 2 Event: next(B )Subscription: 3 Event: next(B )Subscription: 1 Event: next( )Subscription: 2 Event: next( )Subscription: 3 Event: next( )Subscription: 1 Event: next( )Subscription: 2 Event: next( )Subscription: 3 Event: next( ) Variable（弃用）在 RxSwift 5.x 中，他被官⽅的正式的弃⽤了，并且在需要时，推荐使⽤ BehaviorRelay 或者 BehaviorSubject。 RelayRxRelay提供两种中继：PublishRelay 和 BehaviorRelay。它们的行为与对应的 Subjects 完全相同，但有两个变化：Relays never complete.Relays never emit errors.本质上，中继仅发出.next事件，并且永不终止，有了他，我们将 API 转化为 Rx 样式时，就不必担⼼⼀个意外的终⽌事件，导致后续事件转发失效。 PublishRelayPublishRelay 就是 PublishSubject 去掉终⽌事件 onError 和 onCompleted。示例：1234567891011let disposeBag = DisposeBag() let relay = PublishRelay&lt;String&gt;() relay .subscribe &#123; print(\"Event:\", $0) &#125; .disposed(by: disposeBag)relay.accept(\" \")relay.accept(\" \")// outputEvent: next( )Event: next( ) BehaviorRelayBehaviorRelay 就是 BehaviorSubject 去掉终⽌事件 onError 和 onCompleted。示例：123456789101112let disposeBag = DisposeBag() let relay = BehaviorRelay(value: \" \")relay .subscribe &#123; print(\"Event:\", $0) &#125; .disposed(by: disposeBag)relay.accept(\" \")relay.accept(\" \")// outputEvent: next( )Event: next( )Event: next( )","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"RxSwift 2.Observer","date":"2018-02-02T06:47:35.000Z","path":"2018/02/02/RxSwfit+RAC/RxSwift-Observer/","text":"Observer: 监听 Observable Sequence，接受它传来的 events 如何创建 Observer Observable 的 subscribe 方法创建观察者最直接的⽅法就是在 Observable 的 subscribe ⽅法后⾯描述，事件发⽣时，需要如 何做出响应。1234567tap.subscribe(onNext: &#123; [weak self] in self?.showAlert() &#125;, onError: &#123; error in print(\"发⽣错误： \\(error.localizedDescription)\") &#125;, onCompleted: &#123; print(\"任务完成\")&#125;)subscribe 方法内部会产生 AnonymousObserver 对象（RxSwift 库私有的）1234567public func subscribe(_ on: @escaping (Event&lt;Element&gt;) -&gt; Void) -&gt; Disposable &#123; let observer = AnonymousObserver &#123; e in on(e) &#125; return self.asObservable().subscribe(observer)&#125; AnyObserver-- 任意观察者类注释：A type-erased ObserverType.将操作转发到具有相同 Element 类型的任意基础观察者，隐藏基础观察者类型的细节。AnyObserver 可以⽤来描叙任意⼀种观察者。eg: 打印⽹络请求结果：1234567URLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(onNext: &#123; data in print(\"Data Task Success with count: \\(data.count)\") &#125;, onError: &#123; error in print(\"Data Task Error: \\(error)\") &#125;) .disposed(by: disposeBag)可以看作是：1234567891011121314let observer: AnyObserver&lt;Data&gt; = AnyObserver &#123; (event) in switch event &#123; case .next(let data): print(\"Data Task Success with count: \\(data.count)\") case .error(let error): print(\"Data Task Error: \\(error)\") default: break &#125; &#125;URLSession.shared.rx.data(request: URLRequest(url: url)) .subscribe(observer) .disposed(by: disposeBag)⽤户名提示语是否隐藏：123usernameValid .bind(to: usernameValidOutlet.rx.isHidden) .disposed(by: disposeBag)可以看作是：123456789101112let observer: AnyObserver&lt;Bool&gt; = AnyObserver &#123; [weak self] (event) in switch event &#123; case .next(let isHidden): self?.usernameValidOutlet.isHidden = isHidden default: break &#125; &#125;usernameValid .bind(to: observer) .disposed(by: disposeBag) Binder–UI 观察者类注释：强制执行接口绑定规则的观察者:无法绑定错误（在调试版本中，错误的绑定会导致致命错误，在发布版本中的错误会被记录）确保在特定的调度程序上执行绑定Binder 不会保留目标，并且在释放目标的情况下，元素也不会绑定。默认情况下，它绑定主调度程序上的元素Binder 主要有以下特征：处理 next 事件不处理错误事件确保绑定都是在给定 Scheduler 上执⾏（默认 MainScheduler）⼀旦产⽣错误事件，在调试环境下将执⾏ fatalError，在发布环境下将打印错误信息。示例，对比上面的 AnyObserver示例由于这个观察者是⼀个 UI 观察者，所以它在响应事件时，只会处理 next 事件 并且更新 UI 的操作需要在主线程上执⾏。 因此⼀个更好的⽅案就是使⽤ Binder：1234567let observer: Binder&lt;Bool&gt; = Binder(usernameValidOutlet) &#123; (view, isHidden) in view.isHidden = isHidden &#125;usernameValid .bind(to: observer) .disposed(by: disposeBag)RxCocoa 中的 rx 扩展对于 Binder 的使用：你也可以⽤这种⽅式来创建⾃定义的 UI 观察者。1234567extension Reactive where Base: UIView &#123; public var isHidden: Binder&lt;Bool&gt; &#123; return Binder(self.base) &#123; view, hidden in view.isHidden = hidden &#125; &#125; &#125;1234567extension Reactive where Base: UILabel &#123; public var text: Binder&lt;String?&gt; &#123; return Binder(self.base) &#123; label, text in label.text = text &#125; &#125; &#125;引用：Observer - 观察者","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"Hot 和 Cold Observables","date":"2018-02-02T03:05:12.000Z","path":"2018/02/02/RxSwfit+RAC/Hot-和-Cold-Observables/","text":"原文: Hot and Cold Observables恕我直言，我建议更多地将其视为序列的属性，而不是单独的类型，因为它们由完全适合它们的相同抽象表示，即可观察序列。这是ReactiveX.io的定义:Observable何时开始发出其项目序列？这取决于 Observable.“hot” Observable 对象可能会在创建后立即开始发射项目，因此以后订阅该 Observable 对象的任何观察者都可以开始观察中间位置的序列。“cold”Observable对象要等到观察者订阅它，然后才能开始发射项目，因此可以保证这样的观察者从一开始就可以看到整个序列。Hot ObservablesCold observables… are sequences… are sequencesUse resources (“produce heat”) no matter if there is any observer subscribed.Don’t use resources (don’t produce heat) until observer subscribes.Variables / properties / constants, tap coordinates, mouse coordinates, UI control values, current timeAsync operations, HTTP Connections, TCP connections, streamsUsually contains ~ N elementsUsually contains ~ 1 elementSequence elements are produced no matter if there is any observer subscribed.Sequence elements are produced only if there is a subscribed observer.Observable Sequence 被多个订阅它的 observers 共享每个订阅的 observer 都会有一个 Observable SequenceUsually statefulUsually stateless","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RAC","slug":"RAC","permalink":"https://changzw.github.io/tags/RAC/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"RxSwift 1.特征","date":"2018-01-31T12:32:57.000Z","path":"2018/01/31/RxSwfit+RAC/RxSwift-特征/","text":"特性完全是可选的。你可以自由地在程序中的任何地方使用原始的Observable序列，因为所有核心RxSwift / RxCocoa API都支持它们。 特征是如何工作的特性只是 Observable sequence 的包装器结构。你可以将它们视为可观察序列的一种构建器模式实现。构建特质后，调用.asObservable() 会将其转换回原始的可观察序列。1234567struct Single&lt;Element&gt; &#123; let source: Observable&lt;Element&gt;&#125;struct Driver&lt;Element&gt; &#123; let source: Observable&lt;Element&gt;&#125; 可观察序列Observable Sequence: 它是信号源，产生事件，RxSwift 重视 Observable&lt;T&gt; 类。下面介绍的几个类型都是在 Observable&lt;T&gt; 类的基础上定制化出来的特征序列。Observable&lt;T&gt; 可发送出来的事件类型12345public enum Event&lt;Element&gt; &#123; case next(Element) case error(Swift.Error) case completed &#125; RxSwift 特征 Single/Completable/Maybe SingleSingle 只能发送两个事件123456public enum SingleEvent&lt;Element&gt; &#123; /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`) case success(Element) /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`) case error(Swift.Error)&#125;在 Single 的初始化中可以看到做了 SingleEvent -&gt; Event 的处理1234567891011121314public static func create(subscribe: @escaping (@escaping SingleObserver) -&gt; Disposable) -&gt; Single&lt;Element&gt; &#123; let source = Observable&lt;Element&gt;.create &#123; observer in return subscribe &#123; event in switch event &#123; case .success(let element): observer.on(.next(element)) observer.on(.completed) case .error(let error): observer.on(.error(error)) &#125; &#125; &#125; return PrimitiveSequence(raw: source)&#125;在 .success 事件中，Single 发送了一个 .next 后紧跟着又发送了 .completed 事件，所以:success - 产⽣⼀个单独的元素error - 产⽣⼀个错误不会共享附加作用Single 实际场景：Single 的例⼦就是执⾏ HTTP 请求，然后返回⼀个应答或错误。不过你也可以⽤ Single 来描述 任何只有⼀个元素的序列。12345678910111213141516171819func getRepo(_ repo: String) -&gt; Single&lt;[String: Any]&gt; &#123; return Single&lt;[String: Any]&gt;.create &#123; single in let task = URLSession.shared.dataTask(with: URL(string: \"https://api.github.com/repos/\\(repo)\")!) &#123; data, _, error in if let error = error &#123; single(.error(error)) return &#125; guard let data = data, let json = try? JSONSerialization.jsonObject(with: data, options: .mutableLeaves), let result = json as? [String: Any] else &#123; single(.error(DataError.cantParseJSON)) return &#125; single(.success(result)) &#125; task.resume() return Disposables.create &#123; task.cancel() &#125; &#125;&#125;订阅：12345678910getRepo(\"ReactiveX/RxSwift\") .subscribe &#123; event in switch event &#123; case .success(let json): print(\"JSON: \", json) case .error(let error): print(\"Error: \", error) &#125; &#125; .disposed(by: disposeBag)or12345678getRepo(\"ReactiveX/RxSwift\") .subscribe(onSuccess: &#123; json in print(\"JSON: \", json) &#125;, onError: &#123; error in print(\"Error: \", error) &#125;) .disposed(by: disposeBag)可以对 Observable 调⽤ .asSingle() ⽅法，将它转换为 Single。 CompletableCompletable 也只能发送两个事件，他没有 .next 事件，所以他们有接受数据值相关的事件！123456public enum CompletableEvent &#123; /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`) case error(Swift.Error) /// Sequence completed successfully. case completed&#125;Completable 创建方法同 Single，也是做了 CompletableEvent -&gt; Event 的处理没有 next 事件，不会发出元素只发送 completed 或者 error不会共享附加作⽤Completable 实际场景：Completable 适⽤于那种你只关⼼任务是否完成，⽽不需要在意任务返回值的情况。它和 Observable有点相似。123456789101112func cacheLocally() -&gt; Completable &#123; return Completable.create &#123; completable in // Store some data locally ... guard success else &#123; completable(.error(CacheError.failedCaching)) return Disposables.create &#123;&#125; &#125; completable(.completed) return Disposables.create &#123;&#125; &#125;&#125;订阅12345678910cacheLocally() .subscribe &#123; completable in switch completable &#123; case .completed: print(\"Completed with no error\") case .error(let error): print(\"Completed with an error: \\(error.localizedDescription)\") &#125; &#125; .disposed(by: disposeBag)or12345678cacheLocally() .subscribe(onCompleted: &#123; print(\"Completed with no error\") &#125;, onError: &#123; error in print(\"Completed with an error: \\(error.localizedDescription)\") &#125;) .disposed(by: disposeBag) Maybe它介于 Single 和 Completable 之间，它要么只能发出⼀个元素，要么产⽣⼀个 completed 事件，要么产⽣⼀个 error 事件。12345678public enum MaybeEvent&lt;Element&gt; &#123; /// One and only sequence element is produced. (underlying observable sequence emits: `.next(Element)`, `.completed`) case success(Element) /// Sequence terminated with an error. (underlying observable sequence emits: `.error(Error)`) case error(Swift.Error) /// Sequence completed successfully. case completed&#125;Maybe 初始化方法，做了 MaybeEvent -&gt; Event 的处理12345678910111213141516public static func create(subscribe: @escaping (@escaping MaybeObserver) -&gt; Disposable) -&gt; PrimitiveSequence&lt;Trait, Element&gt; &#123; let source = Observable&lt;Element&gt;.create &#123; observer in return subscribe &#123; event in switch event &#123; case .success(let element): observer.on(.next(element)) observer.on(.completed) case .error(let error): observer.on(.error(error)) case .completed: observer.on(.completed) &#125; &#125; &#125; return PrimitiveSequence(raw: source)&#125;使用场景Observable 调⽤ .asMaybe() ⽅法，将它转换为 Maybe。 RxCocoa 特征 Driver/Signal/ControlEvent Driver主要是为了简化 UI 层的代码。不过如果你遇到的序 列具有以下特征，你也可以使⽤它：不会产⽣ error 事件⼀定在 MainScheduler 监听（主线程监听）共享附加作⽤为什么要叫 Driver 呢？它的目的是让 model 数据层驱动 UI 变化。E.g.Drive UI from CoreData model.Drive UI using values from other UI elements (bindings). …初学者会使用这样的：12345678910111213141516let results = query.rx.text .throttle(.milliseconds(300), scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) &#125;results .map &#123; \"\\($0.count)\" &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag)上面的代码会有什么问题？如果 fetchAutoCompleteItems observable sequence 发出 error (eg连接失败，解析错误), 这样的错误不会解绑订阅，UI再也不会响应新的查询如果 fetchAutoCompleteItems 返回的结果在某个后台线程，后台线程返回的结果会绑定到 UI元素，导致确定性的 crashs结果绑定到两个 UI 元素上，意味着每次用户查询都会发送 2次 HTTP 请求，这不是开发者的本意该代码的更合适版本如下所示：1234567891011121314151617181920212223let results = query.rx.text .throttle(.milliseconds(300), scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .observeOn(MainScheduler.instance) // results are returned on MainScheduler .catchErrorJustReturn([]) // in the worst case, errors are handled &#125; .share(replay: 1) // HTTP requests are shared and results replayed // to all UI elementsresults .map &#123; \"\\($0.count)\" &#125; .bind(to: resultCount.rx.text) .disposed(by: disposeBag)results .bind(to: resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag)确保在大型系统中正确处理所有需求很具有挑战性，但是有一种更简单的方法，使用编译器和特征来证明满足这些要求。以下代码：12345678910111213141516171819202122let results = query.rx.text.asDriver()// This converts a normal sequence into a `Driver` sequence. .throttle(.milliseconds(300), scheduler: MainScheduler.instance) .flatMapLatest &#123; query in fetchAutoCompleteItems(query) .asDriver(onErrorJustReturn: []) // Builder just needs info about what to return in case of error. &#125;results .map &#123; \"\\($0.count)\" &#125; //Driver 的订阅要使用 drive来做 .drive(resultCount.rx.text) // If there is a `drive` method available instead of `bind(to:)`, .disposed(by: disposeBag) // that means that the compiler has proven that all properties // are satisfied.results .drive(resultsTableView.rx.items(cellIdentifier: \"Cell\")) &#123; (_, result, cell) in cell.textLabel?.text = \"\\(result)\" &#125; .disposed(by: disposeBag)所以上面代码发生了什么？asDriver方法将ControlProperty特性转换为Driver特性。1query.rx.text.asDriver()注意，没有什么特别的事情要做。Driver 具有 ControlProperty 特性的所有属性，以及其他一些属性。底层的 observable sequence 只是包装为Driver trait，仅此而已。observable sequence 转化为 Driver1.asDriver(onErrorJustReturn: [])P.S. 任何 observable sequence 转化为 Driver 都必须满足下面三点Can’t error out.Observe on main scheduler.Sharing side effects (share(replay: 1, scope: .whileConnected)).那么，如何确保满足这些呢？只需使用普通的Rx运算符即可。asDriver(onErrorJustReturn:[])等效于以下代码。123456let safeSequence = xs .observeOn(MainScheduler.instance) // observe events on main scheduler .catchErrorJustReturn(onErrorJustReturn) // can't error out .share(replay: 1, scope: .whileConnected) // side effects sharingreturn Driver(raw: safeSequence) // wrap it up最后一步是使用 drive ，而不是使用 bind(to:)。 SignalSignal 和 Driver 相似，唯⼀的区别是，Driver 会对新观察者回放（重新发送）上⼀个元素，⽽ Signal 不会对新观察者回放上⼀个元素。不会产⽣ error 事件在 MainScheduler 监听（主线程监听）共享附加作⽤Signal 和 Driver 的区别示例123456789let textField: UITextField = ... let nameLabel: UILabel = ... let nameSizeLabel: UILabel = ... let state: Driver&lt;String?&gt; = textField.rx.text.asDriver() let observer = nameLabel.rx.text state.drive(observer) // ... 假设以下代码是在⽤户输⼊姓名后运⾏ let newObserver = nameSizeLabel.rx.text state.map &#123; $0?.count.description &#125;.drive(newObserver)这个例⼦是将⽤户输⼊的姓名绑定到对应的标签上。当⽤户输⼊姓名后，我们创建了⼀个新的观察者，⽤于订阅姓名的字数。那么问题来了，订阅时，展示字数的标签会⽴即更新吗？ 因为 Driver 会对新观察者回放上⼀个元素（当前姓名），所以这⾥是会更新的。在对他进⾏订阅时，标签的默认⽂本会被刷新。这是合理的。那如果我们⽤ Driver 来描述点击事件呢，这样合理吗？12345678let button: UIButton = ... let showAlert: (String) -&gt; Void = ... let event: Driver&lt;Void&gt; = button.rx.tap.asDriver() let observer: () -&gt; Void = &#123; showAlert(\"弹出提示框1\") &#125; event.drive(onNext: observer) // ... 假设以下代码是在⽤户点击 button 后运⾏ let newObserver: () -&gt; Void = &#123; showAlert(\"弹出提示框2\") &#125; event.drive(onNext: newObserver)当⽤户点击⼀个按钮后，创建⼀个新的观察者，来响应点击事件。此时会发⽣什么？Driver 会把上⼀次的点击事件回放给新观察者。所以，这⾥的 newObserver 在订阅时，就会接受到上次的点击事件，然后弹出提示框。这似乎不太合理。于是我们就引⼊了 Signal:1234567...let event: Signal&lt;Void&gt; = button.rx.tap.asSignal()let observer: () -&gt; Void = &#123; showAlert(\"弹出提示框1\") &#125; event.emit(onNext: observer) // ... 假设以下代码是在⽤户点击 button 后运⾏ let newObserver: () -&gt; Void = &#123; showAlert(\"弹出提示框2\") &#125; event.emit(onNext: newObserver)在同样的场景中，Signal 不会把上⼀次的点击事件回放给新观察者，⽽只会将订阅后产⽣的点击事件，发布给新观察者。这正是我们所需要的。结论: ⼀般情况下状态序列我们会选⽤ Driver 这个类型，事件序列我们会选⽤ Signal 这个类型。 ControlProperty它是 Observable / ObservableType 特性，表示UI元素的属性。值序列仅表示初始控制值和用户启动的值更改。程序化价值的变化将不会报告。它的特点：永远不会失败share(replay: 1)共享最新值它是有状态的，一旦订阅如果有产生过值，那么最新的值会立即重播当控件销毁的时候发送 complete 事件不发送 error 事件在主线程上传播 events实际使用案例1234567891011121314151617extension Reactive where Base: UISearchBar &#123; /// Reactive wrapper for `text` property. public var value: ControlProperty&lt;String?&gt; &#123; let source: Observable&lt;String?&gt; = Observable.deferred &#123; [weak searchBar = self.base as UISearchBar] () -&gt; Observable&lt;String?&gt; in let text = searchBar?.text return (searchBar?.rx.delegate.methodInvoked(#selector(UISearchBarDelegate.searchBar(_:textDidChange:))) ?? Observable.empty()) .map &#123; a in return a[1] as? String &#125; .startWith(text) &#125; let bindingObserver = Binder(self.base) &#123; (searchBar, text: String?) in searchBar.text = text &#125; return ControlProperty(values: source, valueSink: bindingObserver) &#125;&#125;123456789101112131415161718extension Reactive where Base: UISegmentedControl &#123; /// Reactive wrapper for `selectedSegmentIndex` property. public var selectedSegmentIndex: ControlProperty&lt;Int&gt; &#123; return value &#125; /// Reactive wrapper for `selectedSegmentIndex` property. public var value: ControlProperty&lt;Int&gt; &#123; return UIControl.rx.value( self.base, getter: &#123; segmentedControl in segmentedControl.selectedSegmentIndex &#125;, setter: &#123; segmentedControl, value in segmentedControl.selectedSegmentIndex = value &#125; ) &#125;&#125; ControlEvent它是 Observable / ObservableType 特性，表示UI元素的事件。特点：永不失败订阅的时候不会发送初试值当控件销毁时，发送 complete不发送 errors 事件在主线程发送 events实际使用案例这是一个典型的示例，你可以在开发中使用它：1234567public extension Reactive where Base: UIViewController &#123; /// Reactive wrapper for `viewDidLoad` message `UIViewController:viewDidLoad:`. public var viewDidLoad: ControlEvent&lt;Void&gt; &#123; let source = self.methodInvoked(#selector(Base.viewDidLoad)).map &#123; _ in &#125; return ControlEvent(events: source) &#125;&#125;在UICollectionView + Rx中，我们可以通过以下方式找到它：12345678910extension Reactive where Base: UICollectionView &#123; /// Reactive wrapper for `delegate` message `collectionView:didSelectItemAtIndexPath:`. public var itemSelected: ControlEvent&lt;IndexPath&gt; &#123; let source = delegate.methodInvoked(#selector(UICollectionViewDelegate.collectionView(_:didSelectItemAt:))) .map &#123; a in return a[1] as! IndexPath &#125; return ControlEvent(events: source) &#125;&#125;引用：Traits","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"协调器 Redux","date":"2018-01-24T11:22:03.000Z","path":"2018/01/24/architecture/协调器-Redux/","text":"原文：Coordinators Redux今年年初我写过关于 协调器的文章, 但是自从那以后对于协调器的思考已经成熟了很多，我想通过这几个月所学的东西来来重新介绍这个话题。这是根据我今年在NSSpain的一次演讲改编而成。此处找到幻灯片。在这里找到视频。 三个问题 1. App Delegates 中放的东西太多了苹果公司在指导我们将代码放在合适的地方方面做得非常糟糕。弄清如何构建 App 完全由我们自己决定。最开始写代码的地方显而易见是 app’s delegate.app delegate 是每个 App 的入口。它的主要职责是从操作系统到应用程序的子系统来回传递消息。不幸的是，由于它位于所有事物的中心，因此很容易在东西放在这。这样设计方式中的一个受害者就是 rootViewController 的配置。如果你的使用 tabbarController 作为 root，那么你必须要在某个配置所有的 tabbarController 的 children，并且 App delegate 就是个很好的场所。我写的第一个 App（对于大多数读者我猜测，这是真的），我在我的AppDelegate中，为 rootviewcontroller 配置了所有配置。那些代码真的不属于这里，写在这里只是为了方便。在我写完我第一个 app 以后我意识到了这个，然后我变得聪明了，我是用了这样的技巧：1@interface SKTabBarController : UITabBarController我会创建一个我想要使用的 rootViewController 子类，然后我会把代码挪到这里。这只是关于这个问题的临时补丁，最后发现这也不是此代码该放的地方。我建议我们研究这个对象——rootViewController，从责任的角度。管理子视图控制器属于这些职责，但分配和配置它们的职责不多。我们正在对一个从未打算进行子类化的东西进行子类化，只是为了我们可以隐藏一些无家可归的代码。对于此应用程序配置逻辑，我们需要一个更好的家。 2.太多责任这里有另外一个问题。单个ViewController也遇到这样的问题，把大量的责任放倾倒App delegate里面。ViewController 中负责的一些事情：模型视图绑定子视图分配内存获取数据布局数据转换导航流程用户输入模型变化还有更多我提过一些方法将这些责任藏到 ViewController 的 children中，方法在8 Patterns to Help You Destroy Massive View Controller中. 所有责任不能在一个地方，这样 ViewController 中的代码就会少于 3000行了。哪些东西应该在这个类？哪些应该在别的地方？ViewController的工作是什么？这些问题还没有理清楚。引用 Graham Lee 说的一句话，我很喜欢。When you get overly attached to MVC, then you look at every class you create and ask the question “is this a model, a view, or a controller?”. Because this question makes no sense, the answer doesn’t either: anything that isn’t evidently data or evidently graphics gets put into the amorphous “controller” collection, which eventually sucks your entire codebase into its innards like a black hole collapsing under its own weight.什么是ViewController？Smalltalkian意义上的控制器最初严格是为用户输入而设计的。甚至“控制”一词也给我们带来了麻烦。如我之前所写：When you call something a Controller, it absolves you of the need to separate your concerns. Nothing is out of scope, since its purpose is to control things. Your code quickly devolves into a procedure, reaching deep into other objects to query their state and manipulate them from afar. Boundless, it begins absorbing responsibilities. 平缓的 Flow最后一个我想要讨论的问题是：navigation flow12345- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath &#123; id object = [self.dataSource objectAtIndexPath:indexPath]; SKDetailViewController *detailViewController = [[SKDetailViewController alloc] initWithDetailObject:object]; [self.navigationController pushViewController:detailViewController animated:YES]; &#125;这事一段很常见的代码，不幸的是，他是垃圾代码。让我们一行行看：1id object = [self.dataSource objectAtIndexPath:indexPath];第一行的 dataSource 是 ViewController 逻辑上的 child，然后我们正在跟他要我们需要引用的的对象。1SKDetailViewController *detailViewController = [[SKDetailViewController alloc] initWithDetailObject:object];这里事情开始变得麻烦。ViewController 正在实例化一个新的 ViewController，然后配置它。这个 ViewController ”知道“ 在 flow 中接下来会流出什么。他知道新的 ViewController 是怎么配置的。正在执行 Presenting 的 ViewController 知道他所在 App 位置中的大量细节（新 ViewController的配置细节）。1[self.navigationController pushViewController:detailViewController animated:YES];第三行是它完全偏离轨道的地方。这个 ViewController 知道了他的父级 ViewController，因为请记住，这些视图控制器在同一层次结构中，子 ViewController 会向父 ViewController 发送消息，告诉他要做什么。子 ViewController 正在指挥他的父亲。在现实世界里，孩子不应该到处指挥自己的父亲。在编程中，我会说孩子甚至不应该知道他们的父亲是谁！在8种模式帮助你干掉大量的ViewController, 我建议使用一个 Navigator 类型，它可以注入到那些包含导航逻辑的 ViewControllers 中。如果你想要把导航逻辑放到同一个地方， Navigators 是一个不错的解决方案，但是我们很快遇到一个导航器没办法帮我们解决的问题。在这三行代码中有很多逻辑，但是 ViewController 不是这些逻辑发生的地方。想象你有个编辑图像的 app你的 PhotoSelectionViewController presents StraighteningViewController presents FilteringViewController presents CaptioningViewController。你的导航 flow 现在分布在三个不同的对象之间。进一步说，某个 ViewController presenting PhotoSelectionViewController ，但是 dismissal 逻辑必须要在 CaptioningViewController 中处理。传递 Navigator 使这些 ViewControllers 保持链状连接在一起，并不能真正解决每个 ViewController 知道链中下一个的问题。我们也需要解决这个问题。 Libraries vs Frameworks我认为Apple 希望我们以所有这些方式编写代码。他们希望我们使用 ViewController 成为世界中心，因为所有以相同样式编写的 app 都可以通过更改SDK发挥最大的影响力。不幸的是，对于开发者，这并不总是最好的举动。我们是负责将来维护 app 的人，可靠的设计和代码可扩展性是我们最看重的。他们说libraries 和 frameworks 的区别是，你调用 libraries，frameworks 调用你。我想尽可能像依赖 libraries 的方式，对待 3rd-party 依赖。当使用 UIKit ，你不需要负责什么。调用 -pushViewController:animated: 然后它做一些工作。并且在将来的某个不确定的时间，下一个ViewController出现他会调用 viewDidLoad: 在这里面你可做更多事。你不应该让 UIKit 决定何时运行代码，而是应尽快退出 UIKit -land, 以便你可以完全控制代码的流向。我曾经将ViewController为 app 中最高等级的东西，这些东西知道如何运行整个app。但是我开始想颠覆这个想法后他会是什么样子。view 对其 ViewController是透明的。view 由 ViewController 控制。如果我们以相同的方式使视图控制器只是另一透明的东西怎么办？ Coordinators什么是 Coordinators ？Coordinator 是用于管理一个or 多个ViewController的对象。将所有驱动逻辑从 ViewController中移除，并将这些内容向上移动一层，这会使你的生活变得更加美好。这一切都从 app Coordinator 开始。Coordinator解决 app delegate 中内容过多的问题。app delegate 可以保留app Coordinator并启动它。app Coordinator 将为app 设置主视图控制器。可以在文献中找到这种模式，例如企业应用程序体系结构模式之类的书。他们把 Coordinator 叫做 Application Controller. app coordinator 是 Application Controller 的特别版，尤其对于 iOS。app coordinator 可以创建并配置 ViewController，或者它可以长生新的子 Coordinator来执行子任务。coordinators 可以接管 ViewController的哪些任务？主要是 navigation 和 model 变化.(我的意思是通过模型变化将用户的更改保存在数据库中，或者对 API 进行 PUT or POST 请求，这些都会破坏性地修改用户的数据。)当你把这些任务从ViewController中拿走，我们最终得到了一个惰性的 ViewController。它可以呈现，可以获取数据，对其进行转换以进行呈现、显示，但至关重要的是无法对其进行更改。现在我们知道，每当展示 ViewController 时，都不会让他自己控制。每当需要让我们知道事件或用户输入时，它都会使用委托方法。让我们看一个代码示例。 代码示例让我们从 App delegate开始1234567- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.rootViewController = [[UINavigationController alloc] init]; self.appCoordinator = [[SKAppCoordinator alloc] initWithNavigationController:self.rootViewController]; [self.appCoordinator start]; [self.window makeKeyAndVisible]; &#125;app delegate 构建 app 的window 和 root ViewController，然后开启 app Coordinator。Coordinator的初始化与开始工作是分开的。这样我们就可以按自己的意愿（懒惰，贪婪等）创建它，并且只有在准备好后才能启动它。Coordinator 就是一个 NSObject:1@interface SKAppCoordinator : NSObject这很棒，这里没有秘密，UIViewController 有上千行代码，我们不知道当我们调用他的方法时会发生什么，因为他是闭源的。简单的 NSObject 类型对象运行app，可使一切变得更加简单。app coordinator 使用他需要的数据初始化，这些数据包括 root ViewController123456- (instancetype)initWithNavigationController:(UINavigationController *)navigationController &#123; self = [super init]; if (!self) return nil; _navigationController = navigationController; return self; &#125;一旦我们调用 -start 方法，coordinator就会开始工作1234567- (void)start &#123; if ([self isLoggedIn]) &#123; [self showContent]; &#125; else &#123; [self showAuthentication]; &#125; &#125;从一开始 Coordinator 就做决定！以前像这样的逻辑没有固定位置，你可以把他放在 appdelegate中或者 ViewController中，但是放这两个地方都有各自的缺陷。在 ViewController中，你有一个 ViewController做超出它本身责任的事情。在 appdelegate中，你会放入一些与他不相关的代码污染他。让我们研究一下 -showAuthentication 方法。在这里，base Coordinator 生成 子 Coordinator，并让其执行子任务123456- (void)showAuthentication &#123; SKAuthenticationCoordinator *authCoordinator = [[SKKAuthenticationCoordinator alloc] initWithNavigationViewController:self.navigationController]; authCoordinator.delegate = self; [authCoordinator start]; [self.childCoordinators addObject:authCoordinator]; &#125;我们使用 childCoordinators 数组引用 Coordinators，防止其被销毁。ViewController存在一棵树中，并且每个 ViewController都包含一个 view。 view存在于 subViews 树中，而且每个 subview 有一个 layer。layers也存在于一棵树中。因为 childCoordinators ，你也会得到一棵 Coordinators 树。子 Coordinator 会创建一些 ViewControllers，等待他们工作，viewcontroller 工作完后 Coordinator会通知我们。当 Coordinator 发送信号告知ViewController工作完时，它会清理自己，弹出他添加的所有 ViewController，然后使用委托将消息发送到父级。一旦我们已认证，我们会得到一个 delegate 消息，然后我们允许子 Coordinator 销毁，然后我们返回平常的程序中。1234- (void)coordinatorDidAuthenticate:(SKAuthenticationCoordinator *)coordinator &#123; [self.childCoordinators removeObject:coordinator]; [self showContent]; &#125;在身份验证 Coordinator 内部，它创建所需的任何Viewcontroller，并将其推入导航控制器。让我们看一下。12345678910@implementation AuthCoordinator- (instancetype)initWithNavigationController:(UINavigationController *)navigationController &#123; self = [super init]; if (!self) return nil; _navigationController = navigationController; return self; &#125;初始化类似于app coordinator.12345- (void)start &#123; SKFirstRunViewController *firstRunViewcontroller = [SKFirstRunViewController new]; firstRunViewcontroller.delegate = self; [self.navigationController pushViewController:firstRunViewcontroller animated:NO]; &#125;身份验证需要从“首次运行 viewcontroller”开始。该viewcontroller具有用于注册和登录的按钮，还可能包含一些幻灯片，解释了app。让我们继续使用该Viewcontroller 并成为其代表。该ViewController 有一个 delegate，因此当用户点击“注册”按钮时，我们可以得到通知。Coordinator 将处理该操作，而不是ViewController需要知道要创建和呈现的注册ViewController。12345- (void)firstRunViewControllerDidTapSignup:(SKFirstRunViewController *)firstRunViewController &#123; SKSignUpViewController *signUpViewController = [[SKSignUpViewController alloc] init]; signupViewController.delegate = self; [self.navigationController pushViewController:signupViewController animated:YES]; &#125;Coordinator 成为这个注册过的 ViewController的代理，为了它可以在按下按钮时通知我们。123- (void)signUpViewController:(SKSignUpViewController *)signupViewController didTapSignupWithEmail:(NSString *)email password:(NSString *)password &#123; //... &#125;诸如此类。在这里，我们实际上执行了注册API请求并保存了身份验证 token，然后通知了父coordinator。每当ViewController发生任何事情（例如用户输入）时，ViewController都会告诉其delegate（在这种情况下为Coordinator），并且Coordinator将执行用户想要的实际任务。让Coordinator来完成这项工作很重要，以便 ViewController 保持惰性。 为什么 Coordinators 很好用 1.每个 ViewController 现在是孤立的除了知道如何呈现数据，ViewController 啥都不知道。每当有什么事发生时，它都会通知 delegate，但是当然它不知道其 delegate 是谁。以前，当分支时，ViewController 需要问“好吧，我在iPad还是iPhone上？”。“用户是否正在接受A / B测试？” 他们不再需要提这样的问题。我们是否只是将这个有条件的问题推给了 Coordinator ？从某种意义上讲，但是我们可以以更好的方式解决它。当确实需要一次具有两个 flow 时，对于A / B测试或多个 size classes，你可以交换整个 Coordinator 对象，而不必在整个 ViewController 上粘贴一堆条件。如果你想了解 flow 的工作方式，那么这非常容易，因为所有代码都在一个地方。 2.ViewControllers 现在可以复用ViewControllers 对要显示的上下文或按钮的用途不承担任何责任。它们可以被使用和重新使用，以保持其美观，而不会拖累任何逻辑。如果你要编写iPad版本的app，则只需替换 Coordinator 即可，并且可以重复使用所有ViewControllers。 3.app中每个任务和子任务都有一种专用的封装方式即使任务可以在多个 ViewControllers 上运行，它也会被封装。如果你的iPad版本重复使用了其中的一些子任务，但没有重复使用，则仅使用这些子任务就非常容易。 4.Coordinator 将显示绑定与副作用分开你再也不必担心在呈现 ViewController时，ViewController破坏数据了。它只能读取和显示，不能写入或破坏数据。这与命令查询分离相似。 5. Coordinator是完全由你控制的对象你不必等待 -viewDidLoad 调用了，才可以进行工作。现在完全可以自己控制工作。在UIViewController超类中没有看不见的代码在做你不知道的事。取代被调用，你开始这个调用。翻转此模型可以更轻松地了解发生了什么。app的行为对你完全透明，UIKit 现在只是你要使用它时调用的库。Backchannel SDK 使用此模式来管理其所有 ViewControllers。app coordinator 和身份验证 coordinator 示例来自该项目。最后，Coordinator 只是一种组织模式。没有你能使用的 Coordinator 库，因为它很简单。没有可以 pod 的 Coordinator库，也米有可以继承的子类。甚至没有一个可遵循的协议。这不是缺点，而是使用像Coordinator这样的模式的优点：它只是你的代码，没有依赖项。他们将使你的app和代码更易于管理。ViewController将具有更高的可重用性，并且比以往任何时候都更容易开发你的 app。","tags":[{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"}]},{"title":"RxFlow 3: 提示和技巧","date":"2018-01-22T02:28:43.000Z","path":"2018/01/22/RxSwfit+RAC/RxFlow-3-提示和技巧/","text":"这篇是 RxFlow 系列文章的最后一章。在前两篇文章中，我已经介绍了所有关键功能/原理让我们深入探讨我在响应式编程中发现的技巧和窍门。 UIViewController 支持 Reactive正如我们在第2篇中所看到的，我们有时需要以响应方式知道何时显示一个Presentable。一个 Presentable 暴露三个 Observables：code 12345678910/// Observable that triggers a bool indicating if/// the current Presentable is being displayedvar rxVisible: Observable&lt;Bool&gt; &#123; get &#125;/// Single triggered when this presentable is displayed/// for the first timevar rxFirstTimeVisible: Single&lt;Void&gt; &#123; get &#125;/// Single triggered when this presentable is dismissedvar rxDismissed: Single&lt;Void&gt; &#123; get &#125; 在 RxFlow 中，UIViewController 遵从 Presentable 协议，因此我们必须找到方法让他们支持 Reactive。幸运的是在此过程中发现的一个项目在此方面起到了很大作用：RxViewController.通过应用我在这篇文章中(Swift中的静态名称空间)描述的模式，它为UIViewControllers提供了Reactive扩展。它使用RxCocoa内置函数允许观察选择器调用。一旦理解了这一概念，便对UIViewController进行了自己的扩展。code 123456789101112131415161718192021222324extension Reactive where Base: UIViewController &#123; /// Observable, triggered when the view has appeared for the first time public var firstTimeViewDidAppear: Single&lt;Void&gt; &#123; return sentMessage(#selector(Base.viewDidAppear)).map &#123; _ in return Void() &#125;.take(1).asSingle() &#125; /// Observable, triggered when the view is being dismissed public var dismissed: ControlEvent&lt;Bool&gt; &#123; let source = sentMessage(#selector(Base.dismiss)) .map &#123; $0.first as? Bool ?? false &#125; return ControlEvent(events: source) &#125; /// Observable, triggered when the view appearance state changes public var displayed: Observable&lt;Bool&gt; &#123; let viewDidAppearObs = sentMessage(#selector(Base.viewDidAppear)) .map &#123; _ in true &#125; let viewWillDisappearObs = sentMessage(#selector(Base.viewWillDisappear)) .map &#123; _ in false &#125; return Observable&lt;Bool&gt;.merge(viewDidAppearObs, viewWillDisappearObs) &#125;&#125; 作为记录，这就是 Coordinator 的用法，其中 “nextPresentable” 是由 Flow 上的 “navigate（to : )” 函数生成的 Presentable 。在已经关联的Presentable首次显示之后，我们仅监听下一个Stepper。code 1234567891011121314151617nextPresentable.rxFirstTimeVisible.subscribe(onSuccess: &#123; [unowned self, unowned nextPresentable, unowned nextStepper] (_) in // we listen to the presentable's Stepper. // For each new Step value, we trigger a new navigation process // this is the core principle of the whole RxFlow mechanism // The process is paused each time the presentable is not currently displayed // for instance when another presentable is above it in the VCs hierarchy. nextStepper.steps .pausable(nextPresentable.rxVisible.startWith(true)) .asDriver(onErrorJustReturn: NoStep()) .drive(onNext: &#123; [unowned self] (step) in // the nextPresentable's Stepper fires a new Step self.steps.onNext(step) &#125;).disposed(by: nextPresentable.disposeBag)&#125;).disposed(by: self.disposeBag) 暂停在 RxFlow 中另一个关键原则：Flow 中发生什么就要停留在 Flow 中。因此我必须找到一个方式","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"RxFlow 2: 实践","date":"2018-01-21T08:24:56.000Z","path":"2018/01/21/RxSwfit+RAC/RxFlow-2-实践/","text":"注意！！！1public typealias NextFlowItems = FlowContributors原文RxFlow Part 2: In Practice上篇：RxFlow-1-原理几周前我介绍了 RxFlow 框架，我已经在这个框架上工作了几个月，现在可以使用了。如果您尚未阅读，建议您看一下这篇文章。总结，RxFlow 旨在：轻松的将你的导航切成逻辑部分把导航代码从 ViewController 中删除鼓励 ViewController 复用性促进 响应式编程促进 依赖注入快速回忆下以下术语：Flow: 每个 Flow 都在应用程序中定义了一个导航区域。Step: 在应用中，每个 Step 就是一个导航状态，Flows 和 Steps 的结合描述了有所导航操作的可能。Stepper: 任何可以发出 Steps 的东西。Steppers 负责触发每个在 Flows 中的导航操作Presentable: 可以被呈现出来的事物的抽象（基本上是 UIViewController 和 可以呈现的 Flow）NextFlowItem(FlowContributors): 他会告诉 Coordinator，在他的响应机制中，接下来将会是什么产生新的 StepsCoordinator: Coordinator 的工作是以一种一直的方式混合Flows and Steps组合同样重要的是要记住，RxFlow使用面向协议的程序设计，这样它才不会将代码冻结在继承层次结构中。在 RxFlow repo 中，你将找到一个演示应用程序。它几乎显示了每种可能的导航类型Navigation stackTab barMaster / detailModal popup 都是关于 StatesRxFlow 主要是使用响应式的方式处理导航状态。为了在多个上下文中复用，这些状态一定要不知道当前使用的导航 Flow。因此，状态不是表示“我要跳转到此屏幕”，而是表示“某人或某物执行此操作”，然后RxFlow会根据当前导航 Flow 选择正确的screen。对于 RxFlow，这个导航状态称为“Steps”。枚举是描述 Steps 的好方法:枚举方便使用一个 value 只可以被定义一次(因此一个状态是惟一的)枚举可以安全使用，因为Swift在 switch 语法中要求你实现所有可能值枚举可以关联 value，这些value 可以从一个 screen 传到另一个 screen枚举是值类型，因此不存在传递不受控制的共享参考eg: 在 demo App 中，这些都是我们涵盖导航可能性所需的所有 Steps。 1234567891011121314import RxFlowenum DemoStep: Step &#123; case apiKey case apiKeyIsComplete case movieList case moviePicked (withMovieId: Int) case castPicked (withCastId: Int) case settings case settingsDone case about&#125; 使用 Flow对于 RxFlow，所有导航代码都在 Flow 中声明，eg：presenting 或者 pushing ViewController。在你的 App 中一个 Flow 代表了导航逻辑段，当 Flow 和一个明确的 Step 结合后，Flow触发导航动作。为此，Flow 要实现：一个 “navigate(to:)” 方法根据 Flow 和 Step，执行导航操作一个 “root” UIViewController，他将基于在此 Flow 中的导航有个 Flow 控制 UINavigationController 和 stack的例子。在这个 Flow 中，可以执行3个导航操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import RxFlowimport UIKitclass WatchedFlow: Flow &#123; var root: UIViewController &#123; return self.rootViewController &#125; private let rootViewController = UINavigationController() private let service: MoviesService init(withService service: MoviesService) &#123; self.service = service &#125; func navigate(to step: Step) -&gt; [NextFlowItem] /*FlowContributors*/ &#123; guard let step = step as? DemoStep else &#123; return NextFlowItem.noNavigation &#125; switch step &#123; case .movieList: return navigateToMovieListScreen() case .moviePicked(let movieId): return navigateToMovieDetailScreen(with: movieId) case .castPicked(let castId): return navigateToCastDetailScreen(with: castId) default: return NextFlowItem.noNavigation &#125; &#125; private func navigateToMovieListScreen () -&gt; [NextFlowItem]/*FlowContributors*/ &#123; let viewModel = WatchedViewModel(with: self.service) let viewController = WatchedViewController.instantiate(with: viewModel) viewController.title = \"Watched\" self.rootViewController.pushViewController(viewController, animated: true) return [NextFlowItem(nextPresentable: viewController, nextStepper: viewModel)] &#125; private func navigateToMovieDetailScreen (with movieId: Int) -&gt; [NextFlowItem]/*FlowContributors*/ &#123; let viewModel = MovieDetailViewModel(withService: self.service, andMovieId: movieId) let viewController = MovieDetailViewController.instantiate(with: viewModel) viewController.title = viewModel.title self.rootViewController.pushViewController(viewController, animated: true) return [NextFlowItem(nextPresentable: viewController, nextStepper: viewModel)] &#125; private func navigateToCastDetailScreen (with castId: Int) -&gt; [NextFlowItem]/*FlowContributors*/ &#123; let viewModel = CastDetailViewModel(withService: self.service, andCastId: castId) let viewController = CastDetailViewController.instantiate(with: viewModel) viewController.title = viewModel.name self.rootViewController.pushViewController(viewController, animated: true) return NextFlowItem.noNavigation &#125;&#125; 导航是一个副作用在学习函数响应式编程的时候，我们经常读到 副作用。FRP 的目的是传递事件，然后再整过程中使用 FRP 的函数处理事件。这些functions 可以转换事件，最终(但是不是必须)将执行你想要的任何功能的代码(网络请求，保存文件，显示一个 alert……)：这些是 副作用因为 RxFlow 依赖响应式编程，我们可以轻松地识别出固有的概念：events：发出 Stepsfunction：就是 “navigate(to:)” functiontransformation：“navigate(to:)” 将 Step 转换成另一个 NextFlowItem (FlowContributors)side effects：执行在“navigate(to:)”中的导航操作（eg: “navigateToMovieListScreen()” 方法在navigation stack 上 push 一个新的UIViewController） Navigating 是为了生成 NextFlowItems(FlowContributors)接着来说，一个 NextFlowItem(FlowContributors) 是一个持有一个 Presentable 和一个 Stepper 简单的数据结构。Presentable 告诉 Coordinator 接下来你要 present 出来的是什么Stepper 告诉 Coordinator 接下来是什么东西发出 Steps默认情况，所有的 UIViewController 都是 Presentable. Flows 也是 Presentable，因为有事，你想启动一个新的导航区域，该区域在他自己的 Flow 中描述，所以 RxFlow 也会把他当做可以被 present 的东西为什么 Coordinator 要知道 Presentables？Presentable 是一个描述可以被呈现的事物的抽象类。因为 Step 不会被发出，除非他关联的 Presentable 被显示，Presentable 提供 Observables，Coordinator 会订阅这个 Observables（所以 Coordinator 会知道 Presentable 的显示状态）。因此 Presentable 没有完全显示的时候发送一个 Step 不存在任何危险。Stepper 可以是任何东西：自定义的 UIViewController，ViewModel，Presenter…… 一旦他在 Coordinator 中注册，Stepper 就可以通过他的 ”step&quot; 属性发送 Steps(step 是 RxSwift 中的 subject)。 Coordinator 会监听 Stepper 发送出来的 Steps，调用 Flow’s “navigate(to:)”在 demo App 中有一个 Stepper 例子： 123456789101112131415161718192021import RxFlowimport RxSwiftclass WatchedViewModel: Stepper &#123; let movies: [MovieViewModel] init(with service: MoviesService) &#123; // we can do some data refactoring in order to display // things exactly the way we want (this is the aim of a ViewModel) self.movies = service.watchedMovies().map(&#123; (movie) -&gt; MovieViewModel in return MovieViewModel(id: movie.id, title: movie.title, image: movie.image) &#125;) &#125; public func pick (movieId: Int) &#123; self.step.onNext(DemoStep.moviePicked(withMovieId: movieId)) &#125;&#125; 在这个例子中，当用户选择一个 movie的时候会调用 pick 函数。这个函数在 “self.step” Rx Stream 中发出一个new value。总结导航过程：navigate(to:) 函数调用时，传入一个 Step 作为参数根据这个 Step，一些导航代码被调用（side effects）也根据这个 Step，产生 NextFlowItems (FlowContributors)。因此，Presentables 和 Steppers 被注册进 Coordinator 中Steppers 发出新的 Steps，然后再来一次以上过程 为什么对与一个 Flow &amp; Step 组合产生多个 NextFlowItems (FlowContributors)是可以的？因为在某一个时间没有什么禁止一个app有多个导航。eg: tab bar上面的每一个item 多会导向一个 navigation stack。Step 触发UITabbarController 显示，将在每个navigation stack 中生成一个 NextFlowItem (FlowContributors)。你可以看一下 demo app 理解一下概念。这里有我们把一个 UITabbarController 和 2个Flows连接的一段代码。 1234567891011121314151617181920212223242526272829private func navigationToDashboardScreen () -&gt; [NextFlowItem] /*(FlowContributors)*/ &#123; let tabbarController = UITabBarController() let wishlistStepper = WishlistStepper() let wishListFlow = WishlistWarp(withService: self.service, andStepper: wishlistStepper) let watchedFlow = WatchedFlow(withService: self.service) Flows.whenReady(flow1: wishListFlow, flow2: watchedFlow, block: &#123; [unowned self] (root1: UINavigationController, root2: UINavigationController) in let tabBarItem1 = UITabBarItem(title: \"Wishlist\", image: UIImage(named: \"wishlist\"), selectedImage: nil) let tabBarItem2 = UITabBarItem(title: \"Watched\", image: UIImage(named: \"watched\"), selectedImage: nil) root1.tabBarItem = tabBarItem1 root1.title = \"Wishlist\" root2.tabBarItem = tabBarItem2 root2.title = \"Watched\" tabbarController.setViewControllers([root1, root2], animated: false) self.rootViewController.pushViewController(tabbarController, animated: true) &#125;) return ([NextFlowItem(nextPresentable: wishListFlow, nextStepper: wishlistStepper), NextFlowItem(nextPresentable: watchedFlow, nextStepper: OneStepper(withSingleStep: DemoStep.movieList))])&#125; 静态方法 “Flows.whenReady()” 带着参数 Flows 启动还带有一个闭包，当 Flows 准备显示的时候回调（即当Flow的第一个屏幕被选中的时候） 为什么对于Flow和Step的组合完全不产生NextFlowItem(FlowContributors)，为什么可以？因为导航 Flow 必须要有一个终点！eg 导航stack的最后一个屏幕不会再向下导航，他只可以 pop back。在这种情况，“navigate(to:)” 返回 NextFlowItem.noNavigation。 在 Flow 中会发生什么……停留在 Flow 中！正如我们已经看到的，在同一时间有多个 Flows 被导航是可以的。eg：在 navigation stack 中的一个 screen 可以启动弹出窗口，该弹出窗口也可以包含另一个navigation stack。从 UIKit 的角度上看，UIViewController的层级结构非常重要，我们不能弄混 Coordinator 内部的层次结构。这就是为什么当一个 Flow 没有显示（在我们的例子中，就是当第一个 navigation stack 在弹出窗口之下），Coordinator将忽视 Flow 中可能发出来的 Steps。从更一般的角度来看，在 Flow 上下文中发出的 Steps 只能在该 Flow 上下文中解释（它们不能被其他 Flow 捕获）。 依赖注入变得容易DI 是RxFlow的一个主要目标。基本上，依赖注入可以通过将某种实现（服务，管理器等）作为参数传递给初始化程序或方法来完成（也可以通过属性来完成）。在 RxFlow 中, 开发人员负责实例化UIViewControllers，ViewModels，Presenter等,这是一个注入你所需代码的绝佳机会。下面是ViewModel中依赖项注入的示例。 123456789101112131415161718192021222324import RxFlowimport UIKitclass WatchedFlow: Flow &#123; ... private let service: MoviesService init(withService service: MoviesService) &#123; self.service = service &#125; ... private func navigateToMovieListScreen () -&gt; [NextFlowItem] /*(FlowContributors)*/ &#123; // inject Service into ViewModel let viewModel = WatchedViewModel(with: self.service) // injecy ViewMNodel into UIViewController let viewController = WatchedViewController.instantiate(with: viewModel) viewController.title = \"Watched\" self.rootViewController.pushViewController(viewController, animated: true) return [NextFlowItem(nextPresentable: viewController, nextStepper: viewModel)] &#125; ...&#125; 如何引导导航过程既然已经知道如何将事物组合在一起，将 Flows 和 Steps 混合在一起以触发导航动作并产生NextFlowItems (FlowContributors)，剩下要做的一件事：在应用程序启动时引导导航过程。一切都在AppDelegate中发生，并且会发现这非常简单：实例化 Coordinator实例化要导航的第一个 Flow让 Coordinator 使用第一个 Step 来调度 Flow当第一个 Flow 准本好了，把他的 root 配置成 Window的 rootViewController在 demo App 中： 1234567891011121314151617181920212223242526272829303132import UIKitimport RxFlowimport RxSwiftimport RxCocoa@UIApplicationMainclass AppDelegate: UIResponder, UIApplicationDelegate &#123; let disposeBag = DisposeBag() var window: UIWindow? var coordinator = Coordinator() let movieService = MoviesService() lazy var mainFlow = &#123; return MainFlow(with: self.movieService) &#125;() func application(_ application: UIApplication, didFinishWithOptions options: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; guard let window = self.window else &#123; return false &#125; Flows.whenReady(flow: mainFlow, block: &#123; [unowned window] (root) in window.rootViewController = root &#125;) coordinator.coordinate(flow: mainFlow, withStepper: OneStepper(withSingleStep: DemoStep.apiKey)) return true &#125;&#125; 奖励协调器有两个响应式扩展：willNavigate和didNavigate。例如，你可以在AppDelegate中订阅它们。123coordinator.rx.didNavigate.subscribe(onNext: &#123; (flow, step) in print (\"did navigate to flow=\\(flow) and step=\\(step)\")&#125;).disposed将会生成如下 log： 12345678910111213did navigate flow=RxFlowDemo.MainFlow step=apiKeyIsCompletedid navigate flow=RxFlowDemo.WishlistFlow step=movieListdid navigate flow=RxFlowDemo.WatchedFlow step=movieListdid navigate flow=RxFlowDemo.WishlistFlow step=moviePicked(23452)did navigate flow=RxFlowDemo.WishlistFlow step=castPicked(2)did navigate flow=RxFlowDemo.WatchedFlow step=moviePicked(55423)did navigate flow=RxFlowDemo.WatchedFlow step=castPicked(5)did navigate flow=RxFlowDemo.WishlistFlow step=settingsdid navigate flow=RxFlowDemo.SettingsFlow step=settingsdid navigate flow=RxFlowDemo.SettingsFlow step=apiKeydid navigate flow=RxFlowDemo.SettingsFlow step=aboutdid navigate flow=RxFlowDemo.SettingsFlow step=apiKeydid navigate flow=RxFlowDemo.SettingsFlow step=settingsDone 日志对于分析和debug 程序很有帮助","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"RxFlow 1: 原理","date":"2018-01-21T06:26:59.000Z","path":"2018/01/21/RxSwfit+RAC/RxFlow-1-原理/","text":"原文RxFlow Part 1: In Theory这篇是该系列文章的第一篇，该篇也是该系列文章的核心。我会介绍 RxFlow ：它是一个我基于 iOS App上设计实现的响应式流\b中介器(Reactive Flow Coordinator) 事实关于iOS应用程序中的导航，有两种选择：使用 Apple Xcode 提供的内建机制：storyboards 和 segues用代码实现一个自定义机制这两种解决方案的缺点：内建机制：navigation 相对来说静止，storyboards 相对来说过于庞大。导航代码污染了 UIViewControllers自定义机制：代码可能难以设置，也可能很复杂，具体取决于所选的设计模式（Router，Coordinator） RxFlow 旨在促进将 storyboards 切割成原子单元，以实现UIViewControllers的协作和可重用性允许 UIViewController 根据导航上下文以不同方式呈现简化依赖注入的实现从UIViewControllers删除导航机制促进响应式编程在处理大多数导航案例的同时，以声明的方式表示导航（以声明式的方式处理导航过程）促进将应用程序切成逻辑导航块 从 Storyboard 到 Coordinator 模式作为 iOS 开发人员，随着开发能力提高（Android或者web），我经常遇到关于导航的同样疑问。对于其他所有概念问题，有很多模式可以解决常见的体系结构问题和关注点分离需求（MVC,MVP,MVVM,VIPER)但是，一旦设计导航，我就犯愁了：如何在Storyboard / Segues中使用依赖项注入？如何控制应用程序的流程？如何摆脱UIViewControllers中的导航样板代码？随着时间的流逝，我对iOS应用程序从 MVC模式带一个Storyboard 到 MVC模式待多个 Storyboards，最后到 MVVM模式 + Flow Coordinator —— 目前来说他是我们可以叫上名字的最佳实践了。MVVM模式 + Flow Coordinator 好是因为我们可以进行依赖注入，UIViewController 可复用行，可测试性。我有机会将此模式应用于生产中的大型复杂应用程序。但是最后，仍然有一些问题困扰着我：我总是不得不一次次地写 Coordinator 模式使用大量 delegate 模式，让 ViewModels 得到 Coordinator 回调信息一开始我看 Redux 模式，尤其是导航状态机。我们可以有个全局导航状态，使用 RxSwift Observables暴露出来，然后监听状态驱动导航。唯一困扰我的是导航状态的唯一性，以及它可能具有不受控制的责任（以及它可以存储的海量数据）出现了这样的一个想法：导航只是一种状态的反射，这种状态可以一步步修改。一个状态，在整个应用程序结构中传播，不是存储在单个位置中，而是由观察者统一起来，可以对它作出反应并因此驱动导航。文章之后，这些分散在应用程序中的小状态称为“Steps”，观察者称为“Coordinator”。RxFlow 来自经验总结，他解决了传统中仍然存在的两个主要问题;Coordinator pattern:开发人员不必再编写Coordinator，他只需要声明导航及其所针对的状态不需要 delegate，因为 state 是由 Loom 监听 RxSwift Observable 关键原则要了解有关 Coordinator 模式的更多信息，我建议你开一下这篇文章 Coordinator Redux尽管这是一个非常好的架构，但是Coordinator模式也有一些缺点：每次引导应用程序时都必须编写协调机制因为要使用 delegate 模式来处理与 Coordinator 之间通信，所以会有很多样板代码RxFlow 是一个以响应式方式实现的 Coordinator 模式，它有 Coordinator 模式架构中的所有重要功能，但进行了一些改进：使导航更具声明性提供一个内置的协调器，用于处理你声明的导航流使用响应式编程处理和 Coordinator 通讯的问题 必须熟悉6个术语才能理解RxFlowFlow：每个 Flow 都在应用程序中定义了一个导航区域。这是你声明导航动作的地方Step：每个 Step 在 App 中是一个导航状态。Flows 和 Steps 的组合描述了所有可能的导航操作。Step 甚至可以内嵌值（eg：Ids，URLs…）将会传播到 Flows 中声明的屏幕Stepper：它可以是任何发出 Steps 的东西，Steppers 负责触发 Flows中的每个导航过程。Presentable：它是可以呈现的事物的抽象类（基本上是UIViewController和Flow是可呈现的）。Presentables 提供响应式 Observables， Coordinator 将以兼容 UIKit 的方式，订阅这个 Observables 来控制Flow的 StepsFlowable：它是一个结合了Presentable和Stepper的简单数据结构。它告诉 Coordinator 下一步将发生什么，这将在您的响应式机制中产生新的 StepsCoordinator：一旦开发人员定义完 代表导航可能性的流程和步骤的组合，Coordinator 的工作就是以一致的方式混合这些组合。第一篇文章只是说明框架的 概念理论，接下的文章将会从源码的角度讨论更多 有关 RxFlow 的技术点。","tags":[{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"},{"name":"RxSwift","slug":"RxSwift","permalink":"https://changzw.github.io/tags/RxSwift/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"RxSwift","slug":"第三方框架/RxSwift","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/RxSwift/"}]},{"title":"OC 对象分析","date":"2018-01-09T09:08:06.000Z","path":"2018/01/09/deep analyse/OC-对象分析/","text":"引用源码：objc4思考：问自己的问题实例对象，类对象，元类对象之间的关系对象的属性&amp;方法是怎么传的对象方法是如何查询的oc 的消息机制是什么样的这些理论可以应用到什么地方？ Objective-C中的对象有哪些Objective-C中万物接对象，对象主要分为3种instance对象class对象meta-class对象 objc_object 源码结构 objc_class 源码结构class 和 meta-class 的结构相同 isa 和 superclass 指针isa 指向生产他这个对象的对象：instance 对象的isa 是class 对象class 对象的 isa 是 meta-class 对象meta-class 的 isa 是 root-metaclass 对象（所有元类的 isa 都指向他） class_rw_t 和 class_ro_t见上图 👆","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"}]},{"title":"Meta Class","date":"2018-01-03T14:32:46.000Z","path":"2018/01/03/deep analyse/Meta-Class/","text":"smallTalk 中 Metaclass 的 7个要素object 是 class 的实例class 最终继承自 objectclass 是 metaclass 的实例metaclass 和 class 的继承是平行的metaclass 继承自 class 和 behaviormetaclass 是 Metaclass 的实例Metaclass 的 metaclass 是 Metaclass 的实例 object 是 class 的实例 每个 class 都继承自 Object实例对象的 class 都继承自 Object is-a 的含义当 Object 接收 msg 的时候，在他的 class 对象方法列表中找，一直沿着 superclasses ，知道 Object 对象查找这个消息 Object 的责任描述 Object 的公共行为error-handling, halting …所有类最终都继承自 Object class 是 metaclass 的实例Class 也是对象：每个 class A 是他的 metaclass 的唯一实例，叫做 A class metaclasses 是隐式的当创建 class 的是时候，会隐式创建 Metaclass没有共享的 metaclass(class 和 metaclass 是一一对应的) metaclass 和 class 的继承是平行的class 和 object 的一致性object 有的东西，class 也有同样的方法查询策略object 在class 的 method 字典中查找class 在 metaclass 的method 字典中查找 metaclass 继承自 class 和 behavior metaclass 是 Metaclass 的实例 Metaclass 的 metaclass 是 Metaclass 的实例 为什么要有 MetaClassobjc_class: objc_object, 所以object 有的东西 class 也有object 是 class 的实例，class 是 metaclass 的实例object 方法，属性，协议方法都保存在 class 对象中；class方法，属性，协议方法都保存在 metaclass 对象中class 是 object 的工厂，metaclass 是class 的工厂因为class 继承自 object 所以消息查找方式相同如果没有 metaclass 呢？smalltalk-76，类的类都是 Class ，该类实现了任何类都需要的方法-eg. new方法。如果想添加一个类方法，必须添加到 Classobjc_msgSend(void /* id self, SEL op, … */) 复用消息通道，类方法也可以放在Class里，但发送消息时，需要增加一个参数","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"flexbox model","date":"2017-12-09T15:04:50.000Z","path":"2017/12/09/flexbox-model/","text":"flex-container 属性demoflex-item 属性demo 基础&amp;术语main axis - flex container 主轴，flex-items 沿着这个轴布局。具体哪个方向取决于 flex-direction 属性 (see below).main-start | main-end - flex-items 在 flex-container 中从 main-start 到 main-end 布局.main size - flex-item main-axis 方向的长度cross axis - 垂直于 main-axis 的轴。即垂直于 flex-items 排列布局方向的轴。cross-start | cross-end - Flex-item 布局垂直方向布局从 cross-start 到 cross-end.cross size - flex-item cross-axis 方向长度 属性属性描述可取值display指定 HTML 元素盒子类型flex,inline-flexflex-direction指定了弹性容器中子元素的排列方式row,columnflex-wrap设置弹性盒子的子元素超出父容器时是否换行wrap,nowrap,wrap-reversejustify-content设置弹性盒子元素在主轴（横轴）方向上的对齐方式flex-start,flex-end,center,space-around,space-betweenalign-self在弹性子元素上使用覆盖容器的 align-items 属性flex-start,flex-end,centeralign-items设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式flex-start ,flex-end,center,stretch,baselinealign-content修改 flex-wrap 属性的行为，类似align-items, 但不是设置子元素对齐，而是设置行对齐flex-start,flex-end,center,space-around,space-between,stretchorder设置弹性盒子的子元素排列顺序integerflex设置弹性盒子的子元素如何分配空间integerflex-basis指定 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。integerflex-grow元素的扩大比率integerflex-shrink元素的收缩比率integer 父级的属性–flex-container flex-direction123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; flex-wrap123.container&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125;nowrap (default): 所有 items 都在一行显示wrap: flex items 将从上到下多行显示。wrap-reverse: 将从下到上多行显示。flex-wrap 可视化demo使用 demo的时候调整浏览器大小 justify-contentmain-axis 方向 flex-items 布局方式。123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe;&#125;justify-content: demo align-itemscross-axis 方向 flex-items 布局方式123.container &#123; align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;&#125; align-content类似align-items, 但不是设置子元素对齐，而是设置行对齐123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;&#125; 次级属性(flex items) order元素排列顺序123.item &#123; order: &lt;integer&gt;; /* default is 0 */&#125; flex-grow元素的扩展比率123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink元素的收缩比率 flex-basisflex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。 align-self在弹性子元素上使用。覆盖容器的 align-items 属性。123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;引用：CSS3 弹性盒子(Flex Box)A Complete Guide to FlexboxComplete Guide to Flexbox","tags":[{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"}],"categories":[{"name":"设计思想","slug":"设计思想","permalink":"https://changzw.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"}]},{"title":"TCP/IP","date":"2017-11-18T15:01:11.000Z","path":"2017/11/18/TCP-IP/","text":"TCP/IP TCP/IP 三次握手http 是基于 TCP/IP 协议，双全工为什么要3次握手？最简单的回答，后一个次握手都是确定前一次握手的接受成功！除了第一次是有 seq=x，其他每次握手都要带上 ack=x+1，确定上一次的 seq接受成功这也说明最后一次握手永远是否能够接受都是无法保障的，但是 &gt;= 三次握手基本满足需求，无需再浪费资源为什么要4次挥手？三次就可以满足双方都知道结果了呀？分手要双方都提出，我要分手，每一方提出都要对方确认一下！所以有了一对 (fin=x – ack=x+1), (fin=y – ack=y+1)fin=x 是提出分手，编号x，ack=x+1 是确定受到 fin=x报文数据，然后我也要发一次我要分手为什么要双方都要主动发送 fin 呢？因为一方发送 fin 以后，另一发有可能还有没有发完的数据，确认双方都是没有事要做了 WireShark 使用验证 TCP/IP 连接12nc -l 12345 //监听nc 127.0.0.1 12345 //建立连接WireShark, Loopback:lo0","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://changzw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://changzw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"Category分析","date":"2017-11-17T14:00:06.000Z","path":"2017/11/17/deep analyse/Category分析/","text":"当给类添加方法的时候，一般会想到使用 category，给类添加方法oc 的在runtime 的时候 分类是如何加载的查看 objc 源码调用过程objc-os.mm_objc_initmap_imagesmap_images_nolockobjc-runtime-new.mm_read_imagesremethodizeClassattachCategoriesattachListsrealloc、memmove、 memcpy1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties; // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"}]},{"title":"CAShapeLayer 画图","date":"2017-10-27T02:14:56.000Z","path":"2017/10/27/UI 相关/CAShapeLayer-画图/","text":"为什么要有 ShapeLayer？因为平常开发中 主要是 矩形的绘制，很少用到其他多边形的（一般都用图片代替）使用 ShapeLayer，通过 path 来定义自己的图形嗯 shapelayer 就是一个 绘制 path 的工具也可以用 Core Graphics 直接向原始的CALyer的内容中绘制路径CAShapeLayer是一个通过 矢量 图形而不是 bitmap 来绘制的图层CALayer的子类。相比直下，使用CAShapeLayer有以下一些优点：渲染快速: CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多高效使用内存: 一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存不会被图层边界剪裁掉: 一个CAShapeLayer可以在边界之外绘制:你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉不会出现像素化: 当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"性能","slug":"性能","permalink":"https://changzw.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"UI","slug":"UI","permalink":"https://changzw.github.io/tags/UI/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"UI","slug":"iOS-Programming/UI","permalink":"https://changzw.github.io/categories/iOS-Programming/UI/"}]},{"title":"自动布局包裹视图","date":"2017-09-21T08:24:56.000Z","path":"2017/09/21/自动布局包裹视图/","text":"原文 Auto Layout and Views that Wrap理解包裹文本和其他流动布局。在视屏中，盒子里的面，当container resized 的时候，UILabel (或者 Mac 系统里面的 NSTextField) 包裹的文字的行为像这样：video1这篇文章将会讲解，当 container resized 的时候 UILabel 的行为会是这样的：video2 为什么没有这样的效果在自动布局中，view 有一个“固有尺寸”（intrinsic content size）的概念：宽和高（都有，或有其一，或都没有）刚好满足view 的大小。布局系统根据view的 “compression resistance”的 优先级，至少会给view 一个足够大的空间。布局系统分别对待 width 和 height。举例：如果一个 segmented control’s的文本很长以至于超出包裹view的宽度，它的固有高度仍然尝试满足 在view的高度。这种效果对于已经定义size的 view 非常好，such as buttons, sliders, and small labels.但是包裹的view 会有十分复杂的行为：他们的 width 和 height 相互关联，系统有的时候会让固有 width 照顾固有 height，反过来也是。这种情况不能单纯的用 布局限制来解释证明: 思考一个简化模型，忽略word 截断和复杂的文本内容。我们想要一个有固定面积的 view,i.e. width × height = constant. 布局限制一定要这也样的格式：attribute1 = multiplier × attribute2+ constant (为了让系统可以提供确定的执行效果). 没有啥方式使用第二个等式来表示第一个等式。因此也没有啥方式描述布局限制包裹的 view。我们必须使用布局引擎计算出来的 width 和 height 作为自由变量。最简单的方式–也是apple 使用的一种–是固定 width，然后让 height 自适应（取决label 的内容大小） 推断最大 布局 宽度UILabel 和 NSTextField 有 preferredMaxLayoutWidth 这个属性。如果它 非 0，他就会作为label 的固有尺寸的最大宽度，当 label有超过 container View 容量的文字是，label可以适配到 这个 width 上。这个 label 将会返回一个更大的固有 height。(如果 label 只有少量文字，那么label 的固有width 就回小于__preferredMaxLayoutWidth__)iOS 上，UILabel 的 preferredMaxLayoutWidth__被设置为label 的width在 它显示在nib 上的时候（即使在 runtime 它的size 改变）OS X 上, NSTextField 可选__preferredMaxLayoutWidth，在布局之后。如果 label 的有效空间可以改变，像最上面 video1里面的demo，或者如果container 可以resized （或者rotated），你就需要动态的改变 preferredMaxLayoutWidth。 调整 preferredMaxLayoutWidth为了动态的设置preferredMaxLayoutWidth, 需要重载 label 的父类方法：12 -[UIView layoutSubviews] -[NSView layout]为了得到最上面video2的效果，要将__preferredMaxLayoutWidth__设置为有效的label例子的布局，label 要有这几个限制:固定左右限制，使label占据整个水平空间，代码里不要使用 数字 硬编码你的 constrain. 这会是你的布局十分脆弱。取而代替的, 可以利用布局系统来达到效果，需要做两步。上面 video2里面，在label 中 使用下面的代码：123456- (void)layoutSubviews &#123; [super layoutSubviews]; CGFloat availableLabelWidth = self.label.frame.size.width; self.label.preferredMaxLayoutWidth = availableLabelWidth; [super layoutSubviews];&#125;实现调用 [super layoutSubviews]，将会计算label上的 constraints（因为他是一个间接的子view）相应的改变它的frame。此时 width 是有用的，但是height不是；height 用的是label 的固有height，它依赖 以前 preferredMaxLayoutWidth 的值。现在我们知道了 label 的实际width，我们设置它的最大布局width. 在内部,在下一次查询label 的固有尺寸时， label的固有尺寸是无效的，而对于当前的 width会有 精确的 height。所有布局信息就绪, 再次调用 [super layoutSubviews]again. 创建属于你自己的 包裹viewWrapDemo. 这个例子有一个 preferredMaxLayoutWidth 属性 that the superview sets, 和 一个共享布局方法 (-[MyWrappingView enumerateItemRectsForLayoutWidth:usingBlock:]). 这个方法在 -intrinsicContentSize 中调用–通过preferredMaxLayoutWidth 计算基本尺寸。在 -layoutSubviews 中调用，算出那些 找色的item 的实际 size 和 位置video3 压缩 包裹最后，有很多次我们想把包裹view 和内容抱紧 contenthugging 的方式组合。可以添加约束，以使它以中心为中心，并至少有一些距离，而不是固定 label 的leading和trailing空间位置。将其与上面的- layoutsubviews结合起来实现提供以下行为:video4边缘的空间是充足的，如果它大于或等于常数-它只会把标签推进去，它就不会把它拉出来。我们想要做的是找到标签可以占用的宽度，而不需要占用所有的宽度。自动布局API只提供一种计算距离的方法:布局，然后测量。因此，为了找出标签的宽度，我们告诉它要变得非常宽(仔细选择优先级)，把它放在外面，测量它，然后使用结果作为首选的最大布局宽度。该标签的内在尺寸将完成其余部分。123456789101112131415161718192021- (void)layoutSubviews &#123; NSLayoutConstraint *labelAsWideAsPossibleConstraint = [NSLayoutConstraint constraintWithItem:self.label attribute:NSLayoutAttributeWidth relatedBy:NSLayoutRelationGreaterThanOrEqual toItem:nil attribute:0 multiplier:1.0 constant:1e8]; // a big number labelAsWideAsPossibleConstraint.priority = [self.label contentCompressionResistancePriorityForAxis:UILayoutConstraintAxisHorizontal]; [self.label addConstraint:labelAsWideAsPossibleConstraint]; [super layoutSubviews]; CGFloat availableLabelWidth = self.label.frame.size.width; self.label.preferredMaxLayoutWidth = availableLabelWidth; [self.label removeConstraint:labelAsWideAsPossibleConstraint]; [super layoutSubviews];&#125;所有例子代码 WrapDemo project on GitHub.感谢Kevin Cathey在布局方面的帮助和见解。总结：UILabel 的 preferredMaxLayoutWidth当应用布局约束时，这个属性会影响标签的大小。在布局中，如果文本超出了该属性指定的宽度，则额外的文本将流向一个或多个新行，从而增加标签的高度。 其他参考文章Apple: iOS UILabeliOS: Multi-line UILabel in Auto LayoutAdvanced Auto Layout Toolbox","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"iOS 离屏渲染","date":"2017-09-20T02:23:06.000Z","path":"2017/09/20/UI 相关/iOS-离屏渲染/","text":"什么是离屏渲染？他对性能有什么影响？如何避免离屏渲染？ iOS 渲染如果想要了解离屏渲染，应该先知道iOS渲染框架是什么样的。让屏幕页面流畅应该保证页面刷新率为 60 帧/秒，1 帧的时间大概就是 16.67 ms了。iOS 的渲染框架： Core Animation组合屏幕上的内容，追踪视图结构和内容的变化。流程图中 Commit Transaction 前面的红框代表触发视图内容变化的事件，比如点击按钮之后Core Animation 框架会捕获到屏幕内容的变化并提交给 Render Server（渲染服务器）Render Server 里另外一个版本的 Core Animation 框架负责解码并绘制内容。CPU 解码完成后将数据交给 GPUGPU 渲染完成后显示离屏渲染是为了 缓存的离屏渲染空间只有屏幕的 2.5倍100ms 以后如果缓存没有使用就会被释放掉圆角图片由于GPU的浮点运算能力比CPU强，CPU渲染的效率可能不如离屏渲染。但如果仅仅是实现一个简单的效果，直接使用 CPU 渲染的效率又可能比离屏渲染好，毕竟普通的离屏渲染要涉及到缓冲区创建和上下文切换等耗时操作。对一些简单的绘制过程来说，这个过程有可能用CoreGraphics，全部用CPU来完成反而会比GPU做得更好。一个常见的 CPU 渲染的例子是：重写 drawRect 方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了 CPU 渲染。整个渲染过程由 CPU 在 App 内同步地完成，渲染得到的bitmap最后再交由GPU用于显示。总之，具体使用 CPU 渲染还是使用 GPU 离屏渲染更多的时候需要进行性能上的具体比较才可以。一个常见的性能优化的例子就是如何给 UIView/UIImageView 加圆角。如下是三种加圆角的方式：设置 cornerRadiusUIBezierPathCore Graphics(为 UIView 加圆角)与直接截取图片(为 UIImageView 加圆角)如下是这三种方法的比较：—Advanced Graphics and Animations for iOS Apps（WWDC14 419)","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"性能","slug":"性能","permalink":"https://changzw.github.io/tags/%E6%80%A7%E8%83%BD/"},{"name":"UI","slug":"UI","permalink":"https://changzw.github.io/tags/UI/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"UI","slug":"iOS-Programming/UI","permalink":"https://changzw.github.io/categories/iOS-Programming/UI/"}]},{"title":"如何使用 RunLoop","date":"2017-08-30T11:00:54.000Z","path":"2017/08/30/runloop/如何使用-RunLoop/","text":"本文主要以翻译为主，有翻译or理解错的地方请提出，3Q 使用 RunLoop 对象Apple 框架中是如何描述 RunLoop 的:框架RunLoop线程安全CocoaNSRunLoop 实例对象不安全Core FoundationCFRunLoopRef指针安全带着问题？runloop 使用需要注意什么？什么时候使用 runloop系统框架哪些地方使用了 runloop？runloop 运行时的内部实体结构分析？ 获得一个 runloop 对象swift12var a = RunLoop.currentvar b = CFRunLoopGetCurrent()oc12id a = [NSRunLoop currentRunLoop];id b = CFRunLoopGetCurrent();__CFRunLoop 结构体 123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; //* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData;// reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; // 当前 runloop 要监听的 mode CFMutableSetRef _commonModeItems; // 所有模式下 要监听的 source0,source1,observer, timer CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; app 运行时 CFRunLoop 内部样子简版 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 app 运行时 CFRunLoop 内部样子，打印 runloop 对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372&lt;CFRunLoop 0x6000008b0000 [0x7fff80615350]&gt;&#123; wakeup port = 0x2703, stopped = false, ignoreWakeUps = true, current mode = (none), common modes = &lt;CFBasicHash 0x600003afbb70 [0x7fff80615350]&gt;&#123; type = mutable set, count = 2, entries =&gt; 0 : &lt;CFString 0x7fff86743f40 [0x7fff80615350]&gt;&#123; contents = \"UITrackingRunLoopMode\"&#125; 2 : &lt;CFString 0x7fff80628740 [0x7fff80615350]&gt;&#123; contents = \"kCFRunLoopDefaultMode\"&#125; &#125;, common mode items = &lt;CFBasicHash 0x600003aa7690 [0x7fff80615350]&gt;&#123; type = mutable set, count = 13, entries =&gt; 0 : &lt;CFRunLoopSource 0x6000001bc180 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x7fff384399f5) &#125; &#125; 1 : &lt;CFRunLoopSource 0x6000001b0240 [0x7fff80615350]&gt;&#123; signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x6000010b8e40, callout = FBSSerialQueueRunLoopSourceHandler (0x7fff365a092a) &#125; &#125; 2 : &lt;CFRunLoopSource 0x6000001b40c0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 1, info = 0x510b, callout = PurpleEventCallback (0x7fff38439a01) &#125; &#125; 5 : &lt;CFRunLoopSource 0x6000001b80c0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x600003ae95f0&gt; &#123; port = 430b, callback = 0x0 &#125; &#125; 7 : &lt;CFRunLoopObserver 0x6000005b0820 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123; type = mutable-small, count = 0, values = () &#125; &#125; 8 : &lt;CFRunLoopObserver 0x6000005b0780 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123; type = mutable-small, count = 0, values = () &#125; &#125; 9 : &lt;CFRunLoopObserver 0x6000005b06e0 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x7fff47879310), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt; &#125; 10 : &lt;CFRunLoopObserver 0x6000005b0640 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x7fff478792a7), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt; &#125; 12 : &lt;CFRunLoopSource 0x6000001b8b40 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x6000001b0180, callout = __handleEventQueue (0x7fff478e3efb) &#125; &#125; 16 : &lt;CFRunLoopSource 0x6000001b89c0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x600003ae9650&gt; &#123; port = 3f0b, callback = 0x0 &#125; &#125; 18 : &lt;CFRunLoopObserver 0x6000005b0140 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x7fff473eda72), context = &lt;CFRunLoopObserver context 0x600001fb5180&gt; &#125; 21 : &lt;CFRunLoopSource 0x6000001b8a80 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x6000034a8160&gt; &#123; port = 4207, callback = 0x7fff2e3fdd33 &#125; &#125; 22 : &lt;CFRunLoopSource 0x6000001b8cc0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x600003a9fe70, callout = __handleHIDEventFetcherDrain (0x7fff478e3f07) &#125; &#125; &#125;, modes = &lt;CFBasicHash 0x600003afbba0 [0x7fff80615350]&gt;&#123; type = mutable set, count = 3, entries =&gt; 0 : &lt;CFRunLoopMode 0x600000fb8270 [0x7fff80615350]&gt;&#123; name = UITrackingRunLoopMode, port set = 0x2c03, queue = 0x600001ab9180, source = 0x600001ab9200 (not fired), timer port = 0x5303, sources0 = &lt;CFBasicHash 0x600003aa76f0 [0x7fff80615350]&gt;&#123; type = mutable set, count = 4, entries =&gt; 0 : &lt;CFRunLoopSource 0x6000001bc180 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x7fff384399f5) &#125; &#125; 1 : &lt;CFRunLoopSource 0x6000001b8b40 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x6000001b0180, callout = __handleEventQueue (0x7fff478e3efb) &#125; &#125; 2 : &lt;CFRunLoopSource 0x6000001b0240 [0x7fff80615350]&gt;&#123; signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x6000010b8e40, callout = FBSSerialQueueRunLoopSourceHandler (0x7fff365a092a) &#125; &#125; 3 : &lt;CFRunLoopSource 0x6000001b8cc0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x600003a9fe70, callout = __handleHIDEventFetcherDrain (0x7fff478e3f07) &#125; &#125; &#125;, sources1 = &lt;CFBasicHash 0x600003aa7720 [0x7fff80615350]&gt;&#123; type = mutable set, count = 4, entries =&gt; 0 : &lt;CFRunLoopSource 0x6000001b40c0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 1, info = 0x510b, callout = PurpleEventCallback (0x7fff38439a01) &#125; &#125; 4 : &lt;CFRunLoopSource 0x6000001b89c0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x600003ae9650&gt; &#123; port = 3f0b, callback = 0x0 &#125; &#125; 5 : &lt;CFRunLoopSource 0x6000001b8a80 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x6000034a8160&gt; &#123; port = 4207, callback = 0x7fff2e3fdd33 &#125; &#125; 6 : &lt;CFRunLoopSource 0x6000001b80c0 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x600003ae95f0&gt; &#123; port = 430b, callback = 0x0 &#125; &#125; &#125; , observers = ( \"&lt;CFRunLoopObserver 0x6000005b0780 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;type = mutable-small, count = 0, values = () &#125; &#125;\", \"&lt;CFRunLoopObserver 0x6000005b0140 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x7fff473eda72), context = &lt;CFRunLoopObserver context 0x600001fb5180&gt; &#125;\", \"&lt;CFRunLoopObserver 0x6000005b0640 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x7fff478792a7), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt; &#125;\", \"&lt;CFRunLoopObserver 0x6000005b06e0 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x7fff47879310), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt; &#125;\", \"&lt;CFRunLoopObserver 0x6000005b0820 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123; type = mutable-small, count = 0, values = () &#125; &#125;\" ), timers = (null), currently 600930818 (56642367633481) / soft deadline in: 1.84466874e+10 sec (@ -1) / hard deadline in: 1.84466874e+10 sec (@ -1) &#125;, 1 : &lt;CFRunLoopMode 0x600000fb8340 [0x7fff80615350]&gt;&#123; name = GSEventReceiveRunLoopMode, port set = 0x5203, queue = 0x600001ab9280, source = 0x600001ab9380 (not fired), timer port = 0x2e03, sources0 = &lt;CFBasicHash 0x600003aa77b0 [0x7fff80615350]&gt;&#123; type = mutable set, count = 1, entries =&gt; 0 : &lt;CFRunLoopSource 0x6000001bc180 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x7fff384399f5) &#125; &#125; &#125;, sources1 = &lt;CFBasicHash 0x600003aa77e0 [0x7fff80615350]&gt;&#123; type = mutable set, count = 1, entries =&gt; 2 : &lt;CFRunLoopSource 0x6000001b4180 [0x7fff80615350]&gt;&#123; signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123; version = 1, info = 0x510b, callout = PurpleEventCallback (0x7fff38439a01) &#125; &#125; &#125;, observers = (null), timers = (null), currently 600930818 (56642369572615) / soft deadline in: 1.84466874e+10 sec (@ -1) / hard deadline in: 1.84466874e+10 sec (@ -1) &#125;, 2 : &lt;CFRunLoopMode 0x600000fb01a0 [0x7fff80615350]&gt;&#123; name = kCFRunLoopDefaultMode, port set = 0x2603, queue = 0x600001ab0880, source = 0x600001ab0980 (not fired), timer port = 0x1f03, sources0 = &lt;CFBasicHash 0x600003aa7750 [0x7fff80615350]&gt;&#123; type = mutable set, count = 4, entries =&gt; 0 : &lt;CFRunLoopSource 0x6000001bc180 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x0, callout = PurpleEventSignalCallback (0x7fff384399f5)&#125;&#125; 1 : &lt;CFRunLoopSource 0x6000001b8b40 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000001b0180, callout = __handleEventQueue (0x7fff478e3efb)&#125;&#125; 2 : &lt;CFRunLoopSource 0x6000001b0240 [0x7fff80615350]&gt;&#123;signalled = Yes, valid = Yes, order = 0, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x6000010b8e40, callout = FBSSerialQueueRunLoopSourceHandler (0x7fff365a092a)&#125;&#125; 3 : &lt;CFRunLoopSource 0x6000001b8cc0 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = -2, context = &lt;CFRunLoopSource context&gt;&#123;version = 0, info = 0x600003a9fe70, callout = __handleHIDEventFetcherDrain (0x7fff478e3f07)&#125;&#125; &#125;, sources1 = &lt;CFBasicHash 0x600003aa7780 [0x7fff80615350]&gt;&#123; type = mutable set, count = 4, entries =&gt; 0 : &lt;CFRunLoopSource 0x6000001b40c0 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = -1, context = &lt;CFRunLoopSource context&gt;&#123;version = 1, info = 0x510b, callout = PurpleEventCallback (0x7fff38439a01)&#125;&#125; 4 : &lt;CFRunLoopSource 0x6000001b89c0 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x600003ae9650&gt; &#123;port = 3f0b, callback = 0x0&#125;&#125; 5 : &lt;CFRunLoopSource 0x6000001b8a80 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x6000034a8160&gt; &#123;port = 4207, callback = 0x7fff2e3fdd33&#125;&#125; 6 : &lt;CFRunLoopSource 0x6000001b80c0 [0x7fff80615350]&gt;&#123;signalled = No, valid = Yes, order = 0, context = &lt;MSHRunLoopSource 0x600003ae95f0&gt; &#123;port = 430b, callback = 0x0&#125;&#125; &#125;, observers = ( \"&lt;CFRunLoopObserver 0x6000005b0780 [0x7fff80615350]&gt;&#123; valid = Yes, activities = 0x1, repeats = Yes, order = -2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;\", \"&lt;CFRunLoopObserver 0x6000005b0140 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0x20, repeats = Yes, order = 0, callout = _UIGestureRecognizerUpdateObserver (0x7fff473eda72), context = &lt;CFRunLoopObserver context 0x600001fb5180&gt;&#125;\", \"&lt;CFRunLoopObserver 0x6000005b0640 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 1999000, callout = _beforeCACommitHandler (0x7fff478792a7), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt;&#125;\", \"&lt;CFRunLoopObserver 0x6000005b06e0 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2001000, callout = _afterCACommitHandler (0x7fff47879310), context = &lt;CFRunLoopObserver context 0x7fc5adc01e40&gt;&#125;\", \"&lt;CFRunLoopObserver 0x6000005b0820 [0x7fff80615350]&gt;&#123;valid = Yes, activities = 0xa0, repeats = Yes, order = 2147483647, callout = _wrapRunLoopWithAutoreleasePoolHandler (0x7fff47848c8c), context = &lt;CFArray 0x600003ae9bf0 [0x7fff80615350]&gt;&#123;type = mutable-small, count = 0, values = ()&#125;&#125;\" ), timers = &lt;CFArray 0x6000010b6400 [0x7fff80615350]&gt;&#123; type = mutable-small, count = 1, values = ( 0 : &lt;CFRunLoopTimer 0x6000001b86c0 [0x7fff80615350]&gt;&#123;valid = Yes, firing = No, interval = 0, tolerance = 0, next fire date = 600930808 (-10.16959 @ 56632202715119), callout = (Delayed Perform) UIApplication _accessibilitySetUpQuickSpeak (0x7fff2574c7d2 / 0x7fff46da0bb6) (/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Library/Developer/CoreSimulator/Profiles/Runtimes/iOS.simruntime/Contents/Resources/RuntimeRoot/System/Library/PrivateFrameworks/UIKitCore.framework/UIKitCore), context = &lt;CFRunLoopTimer context 0x6000021ef300&gt;&#125; ) &#125;, currently 600930818 (56642369637217) / soft deadline in: 1.84467441e+10 sec (@ 56632202715119) / hard deadline in: 1.84467441e+10 sec (@ 56632202715119) &#125;, &#125;&#125; NSRunLoop 是对CFRunLoopRef指针的封装，虽然两者之间类型转换不消耗性能，但是NSRunLoop class 定义一个得到 CFRunLoopRef 的方法 getCFRunLoop 配置 RunLoop在子线程上运行 RunLoop，你一定要向 runloop 中至少添加一个 input source 或者 timer，如果 runloop 中没有可监听的 sources，那么在 runloop 运行的时候他就会立刻退出。详情看下文 配置 RunLoop 事件源(sources)除了添加事件源 sources，你可能还要给 runloop 添加 observers（使用它来监听当前 runloop 的执行阶段）。创建 run loop observer 123456789101112131415161718192021222324252627282930- (void)threadMain&#123; // The application uses garbage collection, so no autorelease pool is needed. NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop]; // Create a run loop observer and attach it to the run loop. CFRunLoopObserverContext context = &#123;0, self, NULL, NULL, NULL&#125;; CFRunLoopObserverRef observer = CFRunLoopObserverCreate( kCFAllocatorDefault, kCFRunLoopAllActivities, YES, 0, &amp;myRunLoopObserver, &amp;context); if (observer)&#123; CFRunLoopRef cfLoop = [myRunLoop getCFRunLoop]; CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode); &#125; // Create and schedule the timer. [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(doFireTimer:) userInfo:nil repeats:YES]; NSInteger loopCount = 10; do&#123; // Run the run loop 10 times to let the timer fire. [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]]; loopCount--; &#125; while (loopCount);&#125; 给 thread 配置 runloop 让处于保活状态，给runloop 添加一个 input sources来接受消息会比较好。虽然只有一个 timer sources 也可以进入 runloop，但是一旦 timer fires，timer 就会失效，导致 runloop 退出。添加一个 repeating timer 可以让 runloop 保活，可是反复调用 timer fire，会反复唤醒thread(这实际上是轮询的另一种形式)，相对来说，使用 input source 来等待 event 发生，没发生前thread 都处于睡眠状态。 开启 RunLoop只有子线程才需要开启 RunLoop一个 RunLoop 实例至少有一个 input source or timer 来监听事件，如果没有可监听的sources，RunLoop开启后会立即退出。启动 RunLoop 的方法：方式方法名(NSRunLoop)解释无条件run最简单但也最不可取的方案。会让线程进入无限循环，对 run loop 很难控制。可以添加和移除 input source 和 timer，但只能通过 kill 的方式停止 run loop。无法在自定义模式下运行 runloop。设定时间限制runUntilDate:run loop 在收到事件或超时前会一直运行。run loop 结束后可以重启，并处理接下来的事情。比上一种方式更好，提供了时间限制。处于特定模式runMode:beforeDate:相比上一种方式，增加了在特定模式下运行 run loopRunning a run loop 123456789101112131415161718192021- (void)skeletonThreadMain &#123; // Set up an autorelease pool here if not using garbage collection. BOOL done = NO; // Add your sources or timers to the run loop and do any other setup. do&#123; // Start the run loop but return after each source is handled. SInt32 result = CFRunLoopRunInMode(kCFRunLoopDefaultMode, 10, YES); // If a source explicitly stopped the run loop, or if there are no // sources or timers, go ahead and exit. if ((result == kCFRunLoopRunStopped) || (result == kCFRunLoopRunFinished)) done = YES; // Check for any other exit conditions here and set the // done variable as needed. &#125; while (!done); // Clean up code here. Be sure to release any allocated autorelease pools.&#125; 可以递归启动 run loop。也就是说可以在 input source 或 timer 的回调处理函数中调用 CFRunLoopRun, CFRunLoopRunInMode 或上面提到的 NSRunLoop 的三个方法，而且嵌套的 run loop 可以在任意 Mode 下运行。 退出 RunLoop在处理事件之前，有两种方法可以让 RunLoop退出：给 run loop 配置 timeout 值告诉 run loop 停止使用timeout的方式：RunLoop 退出之前会执行完所有正常情况下的处理，包括向 observers 发送通知。使用 CFRunLoopStop()：和 timeout方式相似。RunLoop 会把剩下的所有状态发送给 observers，然后退出。不同的是：你只能使用 CFRunLoopStop 停止以 Unconditionally 方式开启的 RunLoop。要注意的是 CFRunLoopStop 只会停止对 CFRunLoopRun 和 CFRunLoopRunInMode 的调用。对于 Cocoa 框架相当于只停止一次 runMode:beforeDate: 的调用，而不是退出 run loop。stop 一次运行和 exit 整个 run loop 是不一样的。虽然移除 RunLoop 的 input source 和 timer 也会导致其退出，但这种方法不可靠。因为有些系统程序会向 RunLoop 中添加 input source，开发者根本不知道有这回事，移除的时候就会漏掉，自然就不会导致 RunLoop 退出。 配置 RunLoop 事件源(sources) 定义 Custom Input Source创建自定义输入源涉及定义以下内容：你想让 input source 处理的信息A scheduler routine：用于让外部 client 获知如何联系 input sourceA handler routine：执行任何 client 发出请求的A cancellation routine：使 input source 失效因为你使用 custom input source 来处理 custom information，配置的过程会相当灵活。The scheduler, handler, and cancellation routines，是你创建 custome input source 的关键。但是，input source 剩下的大部分行为都没有在这几个历程中，eg：向 input source 传递数据的方式需要你自己实现让其他线程知道这个 input source 的存在下图给出了一个 custom input source 配置 demo。在这个例子中，app 的主线程维护 ：引用 input source引用 input source 自定义的 command buffer引用 runloop[已经把input source 加到里面了]当 main thread 有一个task想要 worker thread 处理，main thread 会post 一个 command 到 command buffer 中，顺带把 worker thread 需要的信息发给它，然后 main thread 开启 task（因为main thread 和 worker thread 都有可以访问 command buffer，所以访问 command buffer 的过程要 sync）。一旦命令发布，main thread 向 input source 发送消息，唤起 worker thread 的runloop。worker thread 的 runloop 一旦接受到唤起命令，他就会调用 input source 的 handler 程序，handler 会处理 command buffer 中的命令。操作 custom input source 定义 Input Source定义 custome input source 需要 Core Foundation，接口都是基于 C 的！下面代码封装成 OC：RunLoopSource 封装了 CFRunLoopSourceRef，并管理一个 command buffer，并使用 buffer 接收其他线程的消息。RunLoopContext 封装了 CFRunLoopRef 和 RunLoopSource 指针，用于向应用主线程传递 source 对象和 run loop 引用。Custom Input Source 对象定义 123456789101112131415161718192021222324252627282930313233// These are the CFRunLoopSourceRef callback functions.void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);void RunLoopSourcePerformRoutine (void *info);void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode);@interface RunLoopSource : NSObject&#123; CFRunLoopSourceRef runLoopSource; NSMutableArray* commands;&#125; - (id)init;- (void)addToCurrentRunLoop;- (void)invalidate; // Handler method- (void)sourceFired; // Client interface for registering commands to process- (void)addCommand:(NSInteger)command withData:(id)data;- (void)fireAllCommandsOnRunLoop:(CFRunLoopRef)runloop; @end // RunLoopContext is a container object used during registration of the input source.@interface RunLoopContext : NSObject&#123; CFRunLoopRef runLoop; RunLoopSource* source;&#125;@property (readonly) CFRunLoopRef runLoop;@property (readonly) RunLoopSource* source; - (id)initWithSource:(RunLoopSource*)src andLoop:(CFRunLoopRef)loop;@end 虽然 Objective-C 代码管理 input source 的自定义数据，但是把 input source 添加到 runloop 中需要基于 c 的方法。 第一个被调用的例程是 scheduler，当你把 source 添加到 runloop 时就会调用。 input source 只有一个 client，也就是主线程。这里 scheduler 做的事情就是用 application delegate 的 registerSource: 方法将 RunLoopContext 对象中的信息传递过去，以便之后 application delegate 与 input source 通信时使用。Scheduling a run loop source12345678void RunLoopSourceScheduleRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)&#123; RunLoopSource* obj = (RunLoopSource*)info; AppDelegate* del = [AppDelegate sharedAppDelegate]; RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl]; [del performSelectorOnMainThread:@selector(registerSource:) withObject:theContext waitUntilDone:NO];&#125;当向 input source 发送消息的时候，用于处理数据的 perform 函数会被调用，它是最重要的回调之一。下面的这个方法只是把请求转发给了 RunLoopSource 的 sourceFired 方法。后面会列出 sourceFired 处理 command buffer 的逻辑。12345//Performing work in the input sourcevoid RunLoopSourcePerformRoutine (void *info)&#123; RunLoopSource* obj = (__bridge RunLoopSource*)info; [obj sourceFired];&#125;如果你以前使用 CFRunLoopSourceInvalidate() 方法把 input source 从runloop中移除，系统会调用 input source 的 cancellation routine. 你可以使用这个 routine 通知 clients，你的input source 失效，需要移除他们对 input source 的引用。下面的 cancellation routine 体用系统传入的 RunLoopSource，runloop，runloopMode 创建一个新的 RunLoopContext，并传给 application delegate。Invalidating a run loop source:12345678void RunLoopSourceCancelRoutine (void *info, CFRunLoopRef rl, CFStringRef mode)&#123; RunLoopSource* obj = (__bridge RunLoopSource*)info; AppDelegate* del = [AppDelegate sharedAppDelegate]; RunLoopContext* theContext = [[RunLoopContext alloc] initWithSource:obj andLoop:rl]; [del performSelectorOnMainThread:@selector(removeSource:) withObject:theContext waitUntilDone:YES];&#125;注意 application delegate’s 的 registerSource: and removeSource: 方法在下面有 把 Input Source 添加到 Run Loop12345678910111213141516- (id)init&#123; CFRunLoopSourceContext context = &#123;0, self, NULL, NULL, NULL, NULL, NULL, &amp;RunLoopSourceScheduleRoutine, RunLoopSourceCancelRoutine, RunLoopSourcePerformRoutine&#125;; _runLoopSource = CFRunLoopSourceCreate(NULL, 0, &amp;context); commands = [[NSMutableArray alloc] init]; return self;&#125;- (void)addToCurrentRunLoop&#123; CFRunLoopRef runLoop = CFRunLoopGetCurrent(); CFRunLoopAddSource(runLoop, _runLoopSource, kCFRunLoopDefaultMode);&#125;当 worker 线程调用 addToCurrentRunLoop 方法时，才会将 input source 放到 runloop 中，并在此时调用 RunLoopSourceScheduleRoutine 。input source 加到 runloop 之后，thread 就可以跑起他的 runloop ，等待他派发 task 。CFRunLoopSourceContext 结构体描述了 custom input source（source0）的上下文CFRunLoopSourceContext1 结构体描述了 port-based input source（source1）的上下文12345678910111213141516171819202122232425262728293031typedef struct &#123; CFIndex version; void * info; const void *(*retain)(const void *info); void (*release)(const void *info); CFStringRef (*copyDescription)(const void *info); Boolean (*equal)(const void *info1, const void *info2); CFHashCode (*hash)(const void *info); void (*schedule)(void *info, CFRunLoopRef rl, CFRunLoopMode mode); void (*cancel)(void *info, CFRunLoopRef rl, CFRunLoopMode mode); void (*perform)(void *info);&#125; CFRunLoopSourceContext;typedef struct &#123; CFIndex version; void * info; const void *(*retain)(const void *info); void (*release)(const void *info); CFStringRef (*copyDescription)(const void *info); Boolean (*equal)(const void *info1, const void *info2); CFHashCode (*hash)(const void *info);#if (TARGET_OS_MAC &amp;&amp; !(TARGET_OS_EMBEDDED || TARGET_OS_IPHONE)) || (TARGET_OS_EMBEDDED || TARGET_OS_IPHONE) mach_port_t (*getPort)(void *info); void * (*perform)(void *msg, CFIndex size, CFAllocatorRef allocator, void *info);#else void * (*getPort)(void *info); void (*perform)(void *info);#endif&#125; CFRunLoopSourceContext1; Input Source 与 Client 的协作想使用 input source，你需要从其他 thread 发送消息。input source 的全部目的是使其关联 thread 处于休眠状态，直到有事要做。这需要让你的应用程序中的其他线程知道输入源并有一种与之通信的方法。当 input source 第一次装载到 run loop 的时候，可以向 client 发送注册 input source 的请求。可以将一个 input source 直接或间接注册到多个 client 中。下面的代码展示了 application delegate 提供的注册方法 registerSource:，之前提到过回调函数 RunLoopSourceScheduleRoutine 的实现会调用 registerSource:。也就是说执行流程是 install(addToCurrentRunLoop) -&gt; schedule(RunLoopSourceScheduleRoutine) -&gt; register(registerSource:)。对应地，当 input source 从 run loop 中被移除，回调函数 RunLoopSourceCancelRoutine 中会调用 removeSource: 方法。scheduler an input source 和 Invalidating an input source1234567891011121314151617- (void)registerSource:(RunLoopContext*)sourceInfo;&#123; [sourcesToPing addObject:sourceInfo];&#125; - (void)removeSource:(RunLoopContext*)sourceInfo&#123; id objToRemove = nil; for (RunLoopContext* context in sourcesToPing) &#123; if ([context isEqual:sourceInfo]) &#123; objToRemove = context; break; &#125; &#125; if (objToRemove) [sourcesToPing removeObject:objToRemove];&#125; 向 Input Source 发送信号在将数据交给 Input Source 后，客户端必须发信号通知源并唤醒其 runloop。消息传达 input source 以后，thread 可以处于休眠状态，你应该显示的唤起 runloop，如果处理完了可能会导致错误结果！Waking up the run loop:1234- (void)fireCommandsOnRunLoop:(CFRunLoopRef)runloop &#123; CFRunLoopSourceSignal(runLoopSource); CFRunLoopWakeUp(runloop);&#125; 配置 Timer Sources创建 Timer Sources：创建一个 timer 对象，然后在 runloop中调度它。Cocoa 中使用 NSTimer，Core Foundation 中使用 CFRunLoopTimerRef 类型。虽然二者是 toll-free bridged 的，但是 NSTimer 提供的 API 更便捷：12scheduledTimerWithTimeInterval:target:selector:userInfo:repeats:scheduledTimerWithTimeInterval:invocation:repeats:上面这2个方法会创建 timer 并添加到当前线程 runloop 的 DefaultMode 中。也可以手动创建一个 NSTimer 对象并用 NSRunLoop 的 addTimer:forMode: 方法将其添加到 runloop 的指定 Mode 中。下面的代码展示了两种添加 timer 的方式：第一个 timer 延迟 1 秒触发并每隔 0.1 秒重复触发，第二个 timer 延迟 0.2 秒触发然后每隔 0.2 秒重复触发。Creating and scheduling timers using NSTimer:123456789101112131415161718NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop]; // Create and schedule the first timer.NSDate* futureDate = [NSDate dateWithTimeIntervalSinceNow:1.0];NSTimer* myTimer = [[NSTimer alloc] initWithFireDate:futureDate interval:0.1 target:self selector:@selector(myDoFireTimer1:) userInfo:nil repeats:YES];[myRunLoop addTimer:myTimer forMode:NSDefaultRunLoopMode]; // Create and schedule the second timer.[NSTimer scheduledTimerWithTimeInterval:0.2 target:self selector:@selector(myDoFireTimer2:) userInfo:nil repeats:YES];Creating and scheduling a timer using Core Foundation:123456CFRunLoopRef runLoop = CFRunLoopGetCurrent();CFRunLoopTimerContext context = &#123;0, NULL, NULL, NULL, NULL&#125;;CFRunLoopTimerRef timer = CFRunLoopTimerCreate(kCFAllocatorDefault, 0.1, 0.3, 0, 0, &amp;myCFTimerCallback, &amp;context); CFRunLoopAddTimer(runLoop, timer, kCFRunLoopCommonModes); 配置 a Port-Based Input SourceCocoa and Core Foundation 都提供了 port-based 对象用于线程 or 进程间通讯，下面会使用不同类型的 ports 实现建立 port 通讯 配置 NSMachPort Object使用 NSMachPort 对象建立本地连接：创建 NSMachPort 对象并添加到 primary 线程的 runloop 中。当启动 secondary 线程时将这个 NSMachPort 对象传递给 secondary 线程的入口函数。secondary 线程会用这个 NSMachPort 对象往 primary 线程发消息。 main thread 代码实现下面的代码是启动 secondary worker 线程的主要代码。使用 Cocoa 框架的代码要比 Core Foundation 的少，效果几乎一样。有个不同点是 Cocoa 直接传递 NSPort 对象，而 Core Foundation 传递端口名字符串。1234567891011121314- (void)launchThread&#123; NSPort* myPort = [NSMachPort port]; if (myPort) &#123; // This class handles incoming port messages. [myPort setDelegate:self]; // Install the port as an input source on the current run loop. [[NSRunLoop currentRunLoop] addPort:myPort forMode:NSDefaultRunLoopMode]; // Detach the thread. Let the worker release the port. [NSThread detachNewThreadSelector:@selector(LaunchThreadWithPort:) toTarget:[MyWorkerClass class] withObject:myPort]; &#125;&#125;为了建立好 threads 间的通讯，你可能想要得到 worker thread 将他的本地端口号发送给 main thread，把这个当做校验消息。main thread 得到 worker thread 的端口号，校验完毕，就知道启动 secondary thread 的过程一切进展顺利。主线程会将 worker thread 的 portID 保存起来。下面的 handlePortMessage: 方法会在线程自己的本地端口收到数据后被调用。NSPortMessage 持有两个端口对象：发送端口和接收端口。handlePortMessage: 方法中使用 [portMessage sendPort] 获取到了发送端口对象，也就是 secondary thread 拥有的本地端口。也就是 secondary thread 启动后会给 primary thread 发消息，告知自己的端口对象，主线程会将其存下来以备日后使用。msgid 标记了消息的唯一 ID。Handling Mach port messages:1234567891011121314151617#define kCheckinMessage 100// Handle responses from the worker thread.- (void)handlePortMessage:(NSPortMessage *)portMessage&#123; unsigned int message = [portMessage msgid]; NSPort* distantPort = nil; if (message == kCheckinMessage) &#123; // Get the worker thread’s communications port. distantPort = [portMessage sendPort]; // Retain and save the worker port for later use. [self storeDistantPort:distantPort]; &#125; else&#123; // Handle other messages. &#125;&#125; secondary thread 代码实现对于 secondary worker thread, 你一定要明确他的端口号！用它与 primary thread 通讯。下面代码：如何配置 worker thread，worker thread 的入口函数会被传入 primary thread 的端口对象。下面代码中的 MyWorkerClass 是个辅助类，它的 sendCheckinMessage: 方法负责创建worker thread的本地端口，并发消息给 primary thread 。12345678910111213141516171819+(void)LaunchThreadWithPort:(id)inData&#123; NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init]; // Set up the connection between this thread and the main thread. NSPort* distantPort = (NSPort*)inData; MyWorkerClass* workerObj = [[self alloc] init]; [workerObj sendCheckinMessage:distantPort]; [distantPort release]; // Let the run loop process things. do &#123; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]; &#125; while (![workerObj shouldExit]); [workerObj release]; [pool release];&#125; 配置 NSMessagePort Object 使用 Core Foundation 配置 Port-Based Input SourceThreading Programming Guide-RunLoopThreading Programming Guide(2)","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"runloop","slug":"iOS-Programming/runloop","permalink":"https://changzw.github.io/categories/iOS-Programming/runloop/"}]},{"title":"RunLoop 原理分析","date":"2017-08-27T11:49:54.000Z","path":"2017/08/27/runloop/RunLoop分析/","text":"带着问题思考 QuestionsRunLoop 他是什么？RunLoop 结构是什么样的？为什么要是这样的结构，其他的样子不可以吗？RunLoop 内部分析？系统中有哪些功能使用了 runloop？开发中如何使用 RunLoop引用 CFRunLoopRef 源码：CF-1153.18.tar.gz RunLoop 来源一般来说，thread 只运行一次，然后终止. 像命令行驱动程序。但是这样的程序没有用户交互性为了使程序增加用户交互性，就需要一个机制让程序不退出等待用户操作。使用Event Loop设计模式，让 thread 关联一个 event loop，监听 event，然后调用事件的 reactor 处理事件通常是交由 event loop 关联的 thread 处理。这样使 thread 保活1234567function main initialize() while message != quit message := get_next_message() process_message(message) end whileend function而对于没有 runloop 的thread123456789101112@objcfunc task2() &#123; print(#function)&#125;override func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; let thread = Thread &#123; print(\"task1\") &#125; thread.start() perform(#selector(LongLiveViewController.task2), on: thread, with: nil, waitUntilDone: false)&#125;结果只会打印 task1，因为 thread 没有 runloop，所以执行完当前任务 task1 以后会自动退出123456789func withoutRunloop() &#123; let thread = Thread &#123; print(\"task 1\") RunLoop.current.add(Port(), forMode: .default) RunLoop.current.run(mode: .default, before: Date.distantFuture) &#125; thread.start() perform(#selector(LongLiveViewController.task2), on: thread, with: nil, waitUntilDone: true)&#125;打印 task1，task2()，只有当 Port 从 runloop 中移除这个线程就会退出，否则他的生命周期由 runloop 维护着，具体看下文 Event loop 机制Event Loop 在很多平台上都有，无论是 GUI，开始系统事件都需要 Event Loop 模式来处理交互程序环境Event_Loop对应名称OSX/iOSRunLoopWindows消息队列Linuxepoll，select消息队列使得调用方跟被调用方之间解耦 OSX/iOS 中的 Event Loop RunLoop 特点：他是与线程相关的基础架构的一部分，充当着循环处理、调度事件/转发消息的角色，管理thread运行状态。它使得线程不会执行完单个任务后就立刻结束让线程在没有任务时保持休眠状态在需要处理消息时被立刻唤醒RunLoop 是个对象，每个线程都可以有对应的 runloop。runloop的管理机制并不完全是自动的，有时需要设计好 runloop 的运行时间和事件处理回调。除了主线程外，子线程需要开发者手动去配置并运行它的 runloop主线程的 runloop 已经由系统自动配置并运行了。runloop 在 Cocoa 和 Core Foundation 有两个对应的类：NSRunLoop 和 CFRunLoop Run Loop 内部执行流程线程的 run loop 每次运行都会处理待决的事件，并为绑定的所有 observer 生成通知。次序如下：如果mode里没有source/timer/observer, 直接返回。通知 observer 已经进入 run loop (kCFRunLoopEntry)通知 observer 有 timer 将要触发 (kCFRunLoopBeforeTimers)通知 observer 有非基于端口的 input source(source0) 将要触发 (kCFRunLoopBeforeSources)触发所有已就绪的非基于端口的 input source(source0)如果一个基于端口的 input source(source1, 系统触发) 已就绪并等待触发，立即处理事件，并转至第 9 步通知 observer 线程即将休眠 (kCFRunLoopBeforeWaiting)让线程休眠，直到被以下条件唤醒：有基于端口的 input source 事件到达timer 触发run loop 设定的超时时间到了run loop 被手动唤醒通知 observer 线程刚刚被唤醒 (kCFRunLoopAfterWaiting)处理待决事件如果用户定义的 timer 触发了，处理 timer 事件并重启 run loop，跳回到第 2 步如果 input source 触发了，分发事件如果 run loop 被唤醒且没有超时，重启 run loop，跳回到第 2 步通知 observer 已经退出 run loop (kCFRunLoopExit)对应简化源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); // 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; // 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); // 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; // 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); // 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); // 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); // 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); // 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); // 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; // 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; // 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 // • 一个基于 port 的Source 的事件。 // • 一个 Timer 到时间了 // • RunLoop 自身的超时时间到了 // • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; // 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); // 收到消息，处理消息。 handle_msg: // 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; // 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; // 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; // 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; // 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; // 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; // 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; // source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; // 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; // 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 RunLoop底层实现核心是源码中的第 7 步：7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒一个基于 port 的Source 的事件。一个 Timer 到时间了RunLoop 自身的超时时间到了被其他什么调用者手动唤醒mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：使用 xcode，当程序不执行操作的时候，click debug 的暂停在没有事件处理时：Thread 1 Queue : com.apple.main-thread (serial)com.apple.uikit.eventfetch-thread (6)这两个线程的runloop都停留在mach_msg_trap状态，等待事件发生。其他线程都是 _workq_kernreturn：等待 spinlock 技术，从而执行队列中的下一个 task（或者退出） RunLoop结构 Mode首先要知道 Mode 的作用：为了减少runloop监听的source/timer/observer 的个数RunLoop 和 Mode 简化源码123456789101112131415161718typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @\"kCFRunLoopDefaultMode\" CFMutableSetRef _sources0; // Set 自定义的 input source，由其他 thread 发送消息 CFMutableSetRef _sources1; // Set 基于 port 包含了一个 mach_port 和一个回调（函数指针），用于通过内核和其他线程相互发送消息 CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; typedef struct __CFRunLoop *CFRunLoopRef;struct __CFRunLoop &#123; pthread thread; CFMutableSetRef _commonModes; // Set 通用 modes集合，任何Source/Observer/Timer 加入其中以后，_commonModes 中的每个 mode 都会引用这些(Source/Observer/Timer ),并对其做相应处理 CFMutableSetRef _commonModeItems; // Set 所有_commonModes中引用 &lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFRunLoopCopyAllModes方法会得到它 ...&#125;;Input Sources:Port-Based Sources：监听App的 Mach Port，由内核发出信号，输入源收到信号后，执行相关的例程。(sources1)Custom Input Sources：监听自定义的输入源，需要在其它线程手动发送信号，输入源收到信号后，执行相关的例程。(sources0)Cocoa Perform Selector Sources：Cocoa中自定义的输入源，目的是在不同线程中执行任务，同一线程中的任务是顺序执行的,当任务执行完成后系统会自动移除这个源。（注意：在目标线程中执行任务时，这个目标线程必须有活跃的RunLoop）(sources0)时间源 time sources需要监听runloop的当前状态的：监听者 observersRunLoop 的每次运行都会在某个特定模式下，而且只有这个模式所包含的 item 集合才会参与发送事件(被监听)和接收通知。如果改 item 没有加入到指定模式下的runloop，那么该模式下就不会执通知or监听该 item，如果没有 item 那么会进入休眠状态。mode 中需要注意的 default 和 tracing 这两种，在实际开发中会经常使用Mode名称描述DefaultNSDefaultRunLoopMode (Cocoa), kCFRunLoopDefaultMode (Core Foundation)App的默认运行模式，通常主线程是在这个运行模式下运行ConnectionNSConnectionReplyMode (Cocoa)Cocoa 中结合 NSConnection 使用，用于监听回复(Reply)，极少用到。(已弃用)ModalNSModalPanelRunLoopMode (Cocoa)Cocoa 中 modal panel 使用它接收与之相关 Source 的事件Event trackingNSEventTrackingRunLoopMode (Cocoa), UITrackingRunLoopMode (Cocoa Touch)跟踪用户交互事件（用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他Mode影响）Common modesNSRunLoopCommonModes (Cocoa), kCFRunLoopCommonModes (Core Foundation)这是一组可配置的通用集合，如果将某个 input source 注册到该模式下，那么 input source 在通用模式集合中的每个 mode 中都会注册。Cocoa 框架中的 Common modes 默认包含 Default, Modal, Event tracking 三种 Mode；Core Foundation 只包含 Default，可以使用 CFRunLoopAddCommonMode 函数向集合中添加自定义 Mode。Common modes 不是一个mode，而是一个 modes 集合！eg: 在 Cocoa 框架中，如果 Sources, timers, observers 添加到 CommonModes中，那么 Sources, timers, observers 会被 CommonModes 结合中(Default, Modal, Event tracking)所有模式共享！1void CFRunLoopAddCommonMode(CFRunLoopRef rl, CFRunLoopMode mode);一旦 mode 添加到 runloop 的_commonModes以后就不可以被删除了！此时需要创建新的 runloop 对象，把旧 runloop 中需要的 mode copy 出来，放在新的 runloop 中CFRunLoopCopyCurrentMode/CFRunLoopCopyAllModes RunLoop 中的sources 和 observers在 RunLoop 对象结构中有个 Mode，是为了在某种模式下 RunLoop 才会处理，可以减少每次需要监听的事件源 Sources 事件源 Input Sourcessource分为两类，source0和source1。source0只含有回调指针，处理如UIEvent，CFSocket这类事件。它只能手动唤醒。source1则是有一个mach port和回调指针，能被Mach内核传递的信息唤醒。触摸事件其实是source1接收系统事件后在回调 __IOHIDEventSystemClientQueueCallback__IOHIDEventSystemClientQueueCallback() 内触发的 Source0Source0 再触发的 _UIApplicationHandleEventQueue()输入源：将事件以 asynchronous 的方式向 thread 发送 event输入源Port-Based SourcesCustom Input Sources对应 mode 结构体source1source0消息从何来(发送方)kernel 线程其他用户thread监听事件Mach ports（内核 ports）event用户自定义Input sources 的event添加方法NSPort 对象CFRunLoopSourceRef Timer Sources时间源：在预设时间后以同步的方式把 event 传递给 threadTimer：是线程通知自己做某事的一种方式 Run Loop Observers 观察者不同于 source 在同步或异步事件发生时触发，observer 会在 runloop 运行期间的某些特殊地方触发。CFRunLoopObserverRef是 runloop 状态的观察者，能够监听RunLoop所有的状态改变。进入 run loop当 run loop 即将处理一个 timer当 run loop 即将处理一个 input source当 run loop 即将休眠当 run loop 已经被唤醒，但在它处理唤醒它的事件之前退出 run loop对应 CFRunLoopActivity 枚举12345678910111213141516typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; // 即将进入Loop kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将处理Timer kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Source kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将进入休眠 kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 刚从休眠中唤醒 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 即将退出Loop kCFRunLoopExit = (1UL &lt;&lt; 7), // 所有状态 kCFRunLoopAllActivities = 0x0FFFFFFFU&#125;; RunLoop 核心对象的源码结构RunLoop 123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; // CFSetAddValue(rl-&gt;_commonModeItems, rls); CFRunLoopSourceRef rlo // CFSetAddValue(rl-&gt;_commonModeItems, rlo); CFRunLoopObserverRef rlo CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; RunLoopMode 123456789101112131415161718192021struct __CFRunLoopMode &#123; CFStringRef _name; Boolean _stopped; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif&#125;; RunLoopSource 12345678910struct __CFRunLoopSource &#123; CFRuntimeBase _base; uint32_t _bits; CFIndex _order; /* immutable */ CFMutableBagRef _runLoops; union &#123; CFRunLoopSourceContext version0; /* immutable, except invalidation */ CFRunLoopSourceContext1 version1; /* immutable, except invalidation */ &#125; _context;&#125;; RunLoop Observers 123456789struct __CFRunLoopObserver &#123; CFRuntimeBase _base; CFRunLoopRef _runLoop; CFIndex _rlCount; CFOptionFlags _activities; /* immutable */ CFIndex _order; /* immutable */ CFRunLoopObserverCallBack _callout; /* immutable */ CFRunLoopObserverContext _context; /* immutable, except invalidation */&#125;; RunLoop Timer 12345678910111213struct __CFRunLoopTimer &#123; CFRuntimeBase _base; CFRunLoopRef _runLoop; CFMutableSetRef _rlModes; CFAbsoluteTime _nextFireDate; CFTimeInterval _interval; /* immutable */ CFTimeInterval _tolerance; /* mutable */ uint64_t _fireTSR; /* TSR units */ CFIndex _order; /* immutable */ CFRunLoopTimerCallBack _callout; /* immutable */ CFRunLoopTimerContext _context; /* immutable, except invalidation */&#125;; 使用到 RunLoop 的相关实践先分析下系统中都使用 runLoop 做了什么 系统如何使用 RunLoopapp 运行时，打印CFRunLoop 内部样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode, kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123;callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123;callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123;callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Obvserver // Entry CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // BeforeWaiting CFRunLoopObserver &#123;order = 0, activities = 0x20, callout = _UIGestureRecognizerUpdateObserver&#125; // BeforeWaiting | Exit CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, callout = _afterCACommitHandler&#125; // BeforeWaiting | Exit CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; // BeforeWaiting | Exit CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123; firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;// end commons, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;)&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 打开上面代码可以看到，系统默认注册了5个Mode:Observer：123//内存管理相关：_wrapRunLoopWithAutoreleasePoolHandler： //AutoReleasePool最高优先级处理 (observer)_wrapRunLoopWithAutoreleasePoolHandler： //AutoReleasePool最低优先级处理 (observer)123//界面刷新相关：afterCACommitHandler： //监听CATransaction，刷新UI（observer）, 优先级很低_beforeCACommitHandler： //监听CATransaction12//手势检测回调：手势变化时都会被这个观察者捕获。mach_msg_trap状态时也需要被RunLoop唤醒以后处理。_UIGestureRecognizerUpdateObserver： //监听CATransaction，刷新UI（observer）Source：12_handleHIDEventFetcherDrain： //释放IOHIDEvent对象的callback（source0)，所以有IOHIDEvent事件的位置（通常是唤醒RunLoop的位置）都会有这个回调方法。_handleEventQueue： //用户事件回调(source0)，一般的addTarget: action: forControlEvents:方法都会加在source0，并由_handleEventQueue执行。 AutoreleasePool根据上述分析，通过 RunLoop Observer，监听 RunLoop 状态来管理 AutoreleasePool的。苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。1234567891011_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 关于GCD实际上 RunLoop 底层也会用到 GCD 的东西，比如 RunLoop 是用 dispatch_source_t 实现的 Timer（评论中有人提醒，NSTimer 是用了 XNU 内核的 mk_timer，我也仔细调试了一下，发现 NSTimer 确实是由 mk_timer 驱动，而非 GCD 驱动的）。但同时 GCD 提供的某些接口也用到了 RunLoop， 例如 dispatch_async()。当调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 会向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE() 里执行这个 block。但这个逻辑仅限于 dispatch 到主线程，dispatch 到其他线程仍然是由 libDispatch 处理的。 关于网络请求iOS 中，关于网络请求的接口自下至上有如下几层:1234CFSocketCFNetwork -&gt;ASIHttpRequestNSURLConnection -&gt;AFNetworkingNSURLSession -&gt;AFNetworking2, Alamofire• CFSocket 是最底层的接口，只负责 socket 通信。• CFNetwork 是基于 CFSocket 等接口的上层封装，ASIHttpRequest 工作于这一层。• NSURLConnection 是基于 CFNetwork 的更高层的封装，提供面向对象的接口，AFNetworking 工作于这一层。• NSURLSession 是 iOS7 中新增的接口，表面上是和 NSURLConnection 并列的，但底层仍然用到了 NSURLConnection 的部分功能 (比如 com.apple.NSURLConnectionLoader 线程)，AFNetworking2 和 Alamofire 工作于这一层。下面主要介绍下 NSURLConnection 的工作过程。通常使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。 引用Threading Programming Guide – Run LoopsCFRunLoopAddCommonMode深入理解RunLoop 本文实例使用到 RunLoop 的相关实践 大量参考该文章，敬佩~Event loop后端eventloopEvent-driven programmingThreading Programming Guide(2)","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"runloop","slug":"iOS-Programming/runloop","permalink":"https://changzw.github.io/categories/iOS-Programming/runloop/"}]},{"title":"Method Swizzling","date":"2017-08-01T04:23:17.000Z","path":"2017/08/01/deep analyse/Method-Swizzling/","text":"Method swizzling 的作用他是一种 交换指针指向 的技术Method swizzling 用于改变一个已经存在的 selector 的实现。在运行时通过改变 selector 在类的消息分发列表中的映射从而改变原有方法。例如：在 app 中追踪每一个视图控制器被用户呈现了几次：通过在 viewDidAppear: 方法中添加追踪代码来实现，但会有大量重复代码。继承是另一种可行的方式，但是这要求所有被继承的视图控制器如 UIViewController, UITableViewController, UINavigationController 都在 viewDidAppear：实现追踪代码，这同样会造成很多重复代码。这里有另外一种可行的方式：从 category 实现 method swizzling 。下面是实现方式：123456789101112131415161718192021222324252627282930313233343536373839404142#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class];// 1. 得到方法名称 selector SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:);// 2. 得到方法类型（方法签名） Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // When swizzling a class method, use the following: // Class class = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(class, originalSelector); // Method swizzledMethod = class_getClassMethod(class, swizzledSelector);// 3. 给 originalSelector 添加新method的实现和参数类，如果originSel在 cls 中没有实现体，那么会添加各一个实现体，并return YES，如果已经有实现体 return NO BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; // 4. 替换 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; // viewWillAppear NSLog(@\"viewWillAppear: %@\", self);&#125;@endclass_addMethod 。要先尝试添加 originSel 是为了做一层保护，因为如果这个类没有实现 originSel ，但其父类实现了，那 class_getInstanceMethod 会返回父类的方法。这样 method_exchangeImplementations 替换的是父类的那个方法。所以先尝试添加 originSel，如果已经存在，再用 method_exchangeImplementations 把原方法的实现跟新的方法实现给交换掉。过程变化图 应该在哪些地方使用 method swizzling swizzling 应该只在 +load 中在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，[只会调用一次]+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。[可能会被调用多次]两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 dispatch_onceswizzling 应该只在 dispatch_once 中完成。swizzling 改变了全局的状态确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 提供原子性 Selectors, Methods, &amp; Implementations在 Objective-C 的运行时中，selectors, methods, implementations 指代了不同概念，然而我们通常会说在消息发送过程中，这三个概念是可以相互转换的。 下面是苹果 Objective-C Runtime Reference中的描述：Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。123456// Method 结构struct method_t &#123; SEL name; const char *types; MethodListIMP imp;&#125;;Implementation（typedef id (*IMP)(id, SEL,...)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象 metaclass ）。第二个参数是这个方法的名字 selector，该方法的真正参数紧随其后。理解 selector, method, implementation 这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。 调用 _cmd下面代码在正常情况下会出现循环：1234- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@\"viewWillAppear: %@\", NSStringFromClass([self class]));&#125;然而在交换了方法实现后就不会出现循环了。好的程序员应该对这里出现的方法的递归调用有所警觉，这里我们应该理清在 method swizzling 后方法的实现究竟变成了什么。在交换了方法的实现后，xxx_viewWillAppear:方法的实现已经被替换为了 UIViewController -viewWillAppear：的原生实现，所以这里并不是在递归调用。由于 xxx_viewWillAppear: 这个方法的实现已经被替换为了 viewWillAppear: 的实现，所以，当我们在这个方法中再调用 viewWillAppear: 时便会造成递归循环。记住给需要转换的所有方法加个前缀以区别原生方法。 涉及 runtime 方法通过 SEL 获取一个方法 MethodMethod class_getInstanceMethod(Class cls, SEL name);通过 Method 获取该方法的实现 IMPIMP method_getImplementation(Method m);返回一个字符串，描述了方法的参数和返回类型const char * method_getTypeEncoding(Method m);通过 SEL 以及 IMP 给一个类添加新的方法 Method，其中 types 就是 method_getTypeEncoding 的返回值。BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types);当 cls 中有 name 方法实现，添加method return NO当 cls 中没有 name 方法，则添加方法实现 return YES通过给定的 SEL 替换同一个类中的方法的实现 IMP，其中 SEL 是想要替换的 selector 名，IMP 是替换后的实现。IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types);交换两个方法的实现 IMPvoid method_exchangeImplementations(Method m1, Method m2); 思考很多人认为交换方法实现会带来无法预料的结果。然而采取了以下预防措施后, method swizzling 会变得很可靠：在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。理解实现原理：只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 &lt;obje/runtime.h&gt; 能够让你更好理解实现原理。持续的预防：不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。 swift 中如何 swizzle目前 swift 的版本已经不允许使用 load 和 initialize 方法也没有了 dispatch_once 方法，那么如何确保 swizzle 只执行一次呢？引用 Method Swizzling","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"底层","slug":"底层","permalink":"https://changzw.github.io/tags/%E5%BA%95%E5%B1%82/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"objc","slug":"iOS-Programming/objc","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/"},{"name":"runtime","slug":"iOS-Programming/objc/runtime","permalink":"https://changzw.github.io/categories/iOS-Programming/objc/runtime/"}]},{"title":"CollectionView 使用","date":"2017-06-15T02:41:33.000Z","path":"2017/06/15/UI 相关/CollectionView-使用/","text":"基本实现注意点CollectionView 在呈现的数据和用于呈现该数据的视觉元素之间保持严格的区分（view + layout）。基本使用的过程：自己的布局对象：子类化 layout自定义 collectionView 中的 item（cell，supplementary views 和 decoration views）在layout 的 prepare 方法中计算出所有 attribute（用来修饰 cell，supplementary views 和 decoration views）并缓存在 layout 对象中每个 attribute 的indexPath，frame，zIndex ……根据 attribute 计算出 collectionViewContentSize计算 attribute 的数据可以给 layout 自定义一个 delegate 协议，让他去向 collectionView 拿layoutAttributesForElementsInRect 获取视图的可见矩形区域中的所有 UICollectionViewLayoutAttributes，类似实现 layoutAttributesForItem:atIndexPath， layoutAttributesForSupplementaryViewOfKind:atIndexPath ，layoutAttributesForDecorationViewOfKind:atIndexPath1234567891011121314// 可以使用 binaryTree 算法，将复杂度降到 O(log(n))override func layoutAttributesForElements(in rect: CGRect) -&gt; [UICollectionViewLayoutAttributes]? &#123; var visibleLayoutAttributes: [UICollectionViewLayoutAttributes] = [] for attributes in cache &#123; if attributes.frame.intersects(rect) &#123; visibleLayoutAttributes.append(attributes) &#125; &#125; return visibleLayoutAttributes&#125;override func layoutAttributesForItem(at indexPath: IndexPath) -&gt; UICollectionViewLayoutAttributes? &#123; return cache[indexPath.item]&#125;是否刷新页面当 collection view 的 bounds 改变时，布局需要告诉 collection view 是否需要重新计算布局。我的猜想是：当 collection view 改变大小时，大多数布局会被作废，比如设备旋转的时候。因此，一个幼稚的实现可能只会简单的返回 YES。虽然实现功能很重要，但是 scroll view 的 bounds 在滚动时也会改变，这意味着你的布局每秒会被丢弃多次。根据计算的复杂性判断，这将会对性能产生很大的影响。当 collection view 的宽度改变时，我们自定义的布局必须被丢弃，但这滚动并不会影响到布局。幸运的是，collection view 将它的新 bounds 传给 shouldInvalidateLayoutForBoundsChange: 方法。这样我们便能比较视图当前的bounds 和新的 bounds 来确定返回值：12345678override func shouldInvalidateLayout(forBoundsChange newBounds: CGRect) -&gt; Bool &#123; let oldBounds = collectionView?.bounds if newBounds.width != oldBounds?.width &#123; return true &#125;else &#123; return false &#125;&#125; 分析 UICollectionView.h 中的类结构12345678@class UICollectionView, UICollectionReusableView, UICollectionViewCell, UICollectionViewLayout, UICollectionViewTransitionLayout, UICollectionViewLayoutAttributes, UITouch, UINib;@class UIDragItem, UIDragPreviewParameters, UIDragPreviewTarget;@class UICollectionViewDropProposal, UICollectionViewPlaceholder, UICollectionViewDropPlaceholder;@class UIContextMenuConfiguration, UITargetedPreview;@protocol UIContextMenuInteractionCommitAnimating;@protocol UIDataSourceTranslating, UISpringLoadedInteractionContext;@protocol UIDragSession, UIDropSession;@protocol UICollectionViewDragDelegate, UICollectionViewDropDelegate, UICollectionViewDropCoordinator, UICollectionViewDropItem, UICollectionViewDropPlaceholderContext;引用：自定义 Collection View 布局","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"c 可变参数宏整理","date":"2017-06-01T10:47:00.000Z","path":"2017/06/01/c-宏整理/","text":"#、##、__VA_ARGS__和##__VA_ARGS__的作用 #用来把参数转换成字符串实例1123456789#define P(A) printf(\"%s:%d\\n\",#A,A);int main(int argc, char **argv)&#123; int a = 1, b = 2; P(a); P(b); P(a+b); system(\"pause\"); &#125;输出为：123a:1b:2a+b:3实例212#define SQUARE(x) printf(\"The square of \"#x\" is %d.\\n\", ((x)*(x)));SQUARE(8)输出的是：The square of 8 is 64 ##运算符可以用于宏函数的替换部分这个运算符把两个语言符号组合成单个语言符号，为宏扩展提供了一种连接实际变元的手段实例11#define XNAME(n) x ## n如果这样使用宏：XNAME(8)则会被展开成这样：x8##就是个粘合剂，将前后两部分粘合起来，也就是有“字符化”的意思。但是“##”不能随意粘合任意字符，必须是合法的C语言标示符。在单一的宏定义中，最多可以出现一次“#”或“##”预处理操作符。如果没有指定与“#”或“##”预处理操作符相关的计算次序，则会产生问题。为避免该问题，在单一的宏定义中只能使用其中一种操作符(即，一份“#”或一个“##”，或都不用)。除非非常有必要，否则尽量不要使用“#”和“##”。 __VA_ARGS__ 是一个可变参数的宏这个可变参数的宏是新的C99规范中新增的，目前似乎只有gcc支持（VC6.0的编译器不支持）。实现思想就是宏定义中参数列表的最后一个参数为省略号（也就是三个点）。 ##__VA_ARGS__宏前面加上##的作用在于，当可变参数的个数为0时，这里的##起到把前面多余的&quot;,&quot;去掉的作用,否则会编译出错一般这个用在调试信息上多一点例如：1234567891011121314151617#define my_print1(...) printf(\\_\\_VA_ARGS__)my_print1(\"i=%d,j=%d\\n\",i,j) 正确打印#define my_print2(fmt,...) printf(fmt, \\_\\_VA_ARGS__) my_print1(\"i=%d,j=%d\\n\",i,j) 正确打印my_print1(\"iiiiiii\\n\") 编译失败打印，因为扩展出来只有一个参数，至少要两个及以上参数``` 如果是#define my_print2(fmt,...) printf(fmt,##\\_\\_VA_ARGS__) 那么 my_print1 里面不管是几个参数都能正确打印```c#define MODULE_NAME \"MY_LIB\"#define error_print(fmt, ...) printf(\"[ERROR][\"MODULE_NAME\"](%s|%d)\" fmt, __func__, __LINE__, ##__VA_ARGS__) C 库宏 - va_start()","tags":[{"name":"C/C++","slug":"C-C","permalink":"https://changzw.github.io/tags/C-C/"}],"categories":[{"name":"开发语言","slug":"开发语言","permalink":"https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/"},{"name":"C/C++","slug":"开发语言/C-C","permalink":"https://changzw.github.io/categories/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/C-C/"}]},{"title":"Masonry 分析","date":"2017-06-01T05:47:00.000Z","path":"2017/06/01/source-code/Masonry-分析/","text":"分析源码：这个第三方库，他设计的目标是什么？需要哪些基础知识整体结构是什么样的由外而内逐层分析层次结构每个层次结构的意图是什么，为了实现这个意图他使用了什么方式，这么做有什么优点为了让用户使用方便，实现了什么样的接口，为了实现这样的接口底层又是如何实践的呢？ Masonry 是什么Masonry源码Masonry是一个轻量级的布局框架，它以更好的语法包装了AutoLayoutMasonry拥有自己的布局DSL，它提供了可链式语法来描述NSLayoutConstraints，从而使布局代码更简洁易读。（DSL 其实是 Domain Specific Language 的缩写，中文翻译为领域特定语言） 为什么要设计 Masonry对比一下 AutoLayout 中使用 NSLayoutConstraint 是多么糟糕12345678910111213141516171819202122232425UIView *superview = self.view;UIView *view1 = [[UIView alloc] init];view1.translatesAutoresizingMaskIntoConstraints = NO;view1.backgroundColor = [UIColor greenColor];[superview addSubview:view1];UIEdgeInsets padding = UIEdgeInsetsMake(10, 10, 10, 10);[superview addConstraints:@[ //view1 constraints [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeTop multiplier:1.0 constant:padding.top], ... bottom, left [NSLayoutConstraint constraintWithItem:view1 attribute:NSLayoutAttributeRight relatedBy:NSLayoutRelationEqual toItem:superview attribute:NSLayoutAttributeRight multiplier:1 constant:-padding.right], ]];如果使用 Masonry123[view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(superview).insets(padding);&#125;];P.S. Masonry 内部会帮你调用 view.translatesAutoresizingMaskIntoConstraints = NO;Masonry 设计的目的，就是以链式编程手段封装 NSLayoutConstraint 冗余代码！如何处理原来繁杂接口如何实现链式如何封装 NSLayoutConstraint 的使用了何种编程手段[整体架构设计，设计模式，语法技巧]带着这些问题，根据源码结构分析出来 Masonry 代码结构分析 从调用层次分析这里我要像洋葱一样一层一层的拨开最外层接口根据这段代码分析UIView category 中实现 View+MASAdditions.h (View+MASShorthandAdditions.h)1234567891011121314151617181920#define MAS_VIEW UIView@interface MAS_VIEW (MASAdditions)- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block;//NSLayoutAttribute properties@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;...还有很多布局属性这里省略@property (nonatomic, strong, readonly) MASViewAttribute *(^mas_attribute)(NSLayoutAttribute attr);@property (nonatomic, strong, readonly) MASViewAttribute *mas_firstBaseline;@property (nonatomic, strong, readonly) MASViewAttribute *mas_lastBaseline;//a key to associate with this view@property (nonatomic, strong) id mas_key;从👆源码可以看到三个见名知意的方法方法参数 MASConstraintMaker 这个就是 make属性 MASViewAttribute 这个就是 make 后面的 make.edgesid mas_key 这个是啥，目前不知道我想知道，他的链式是怎么实现的，如何封装 autolayout 相关的数据的，目前看到的只是平常使用的接口我还要找到 下图的这些信息接着往里面看MASViewAttribute: 一个不可变元组，存着 receiver view, related view 和关联的 NSLayoutAttribute [根据文档注释]123@property (nonatomic, weak, readonly) MAS_VIEW *view;@property (nonatomic, weak, readonly) id item;@property (nonatomic, assign, readonly) NSLayoutAttribute layoutAttribute;目前理解为下图等式的相关信息MASConstraintMaker：提供一个工厂方法来创建 MASConstraints, 这些 constraints 只有在被 installed 的时候才会被收集[根据文档注释]MASConstraintMaker.h123456789@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;...@property (nonatomic, strong, readonly) MASConstraint *firstBaseline;@property (nonatomic, strong, readonly) MASConstraint *lastBaseline;// 这个是干啥的？@property (nonatomic, strong, readonly) MASConstraint *(^attributes)(MASAttribute attrs);MASConstraint？跟 NSLayoutConstraint 好像允许使用可链接的语法创建约束约束可以表示单个 NSLayoutConstraint（MASViewConstraint）或一组 NSLayoutConstraints（MASComposisteConstraint）bingo，到这里下面这两个问题有眉目了, 最开始的几个问题122. 如何实现链式3. 如何封装 `NSLayoutConstraint` 的 分析 Masonry 链式封装 主要组件结构MASConstraintMakerMASConstraintMASViewConstraintMASComposisteConstraintMASConstraintDelegate 使用函数调用栈分析12345678[redView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(superview.mas_top).with.offset(padding); //with with make.left.equalTo(greenView.mas_right).offset(padding); //without with make.bottom.equalTo(blueView.mas_top).offset(-padding); make.right.equalTo(superview.mas_right).offset(-padding); make.width.equalTo(greenView.mas_width); make.height.equalTo(@[greenView, blueView]); //can pass array of views&#125;];masonry call stack step1: 主流程 masonry call stack step2：调用block 收集布局信息 masonry call stack step3：install constraints 整体流程&amp;核心调用栈分析结束后，接下来再看细节技巧就容易多了 代码组件分析MASConstraintMakerMASConstraintMASViewConstraintMASComposisteConstraintMASConstraintDelegateMASViewAttributeNSLayoutConstraint 的问题布局数据分散，使用命令式方法调用，接口参数就是布局属性，导致用户使用闹心Masonry 是如何解决这个问题的呢？需要创建对象保存 model 数据创建链节点(把大量参数以链节点的方式逐一放在节点中（MASViewConstraint节点）)调用系统 NSLayoutConstraint 方法整体步骤：node1: 创建 MASConstraint 节点，绑定第一个 item1 和 attr1node2: 创建 MASViewAttribute(item2, attr2)，并添加等式的 relation (block 闭包调用)node3: 添加 valueOffset，priority，divideBy …… 常量数据 （block 闭包低啊用）block 结束，所有 constraint 配置完，进行 install 内部调用 NSLayoutConstraint 方法，把复杂的方法封装在内部 model 层数据根据这个等式 等式信息：创建一个 constraint 需要：两对（view, attr)relationmulityconstantpriorityMASViewAttribute 元组封装 (item, constraintAttr)MASViewConstraint 在 MASViewAttribute 基础上封装 (mas_attr = 1.0 * mas_attr + constant) 生成 MASViewAttribute 的方式UIView+MASAdditions123456789// 计算属性@property (nonatomic, strong, readonly) MASViewAttribute *mas_left;@property (nonatomic, strong, readonly) MASViewAttribute *mas_top;@property (nonatomic, strong, readonly) MASViewAttribute *mas_right;@property (nonatomic, strong, readonly) MASViewAttribute *mas_bottom;- (MASViewAttribute *)mas_left &#123; return [[MASViewAttribute alloc] initWithView:self layoutAttribute:NSLayoutAttributeLeft];&#125;MASConstraintMaker 生成链条节点 MASConstraint 时，使用工厂方法内部配置 MASViewAttribute MASConstraint 配置过程make.bottom.equalTo(blueView.mas_top).offset(-padding);attr1: 由 MASConstraintMaker 中的计算属性方法创建 make.top.leftrelation: 由 MASConstraint 中的方法 equalTo 添加attr2: 由 UIView+MASAdditions 扩展方法得到offset: 由 MASConstraint 中的方法 equalTo 添加priority: 由 MASConstraint 中的方法 priority 添加 布局工厂 MASConstraintMaker他的 product 是 MASConstraint他的工厂方法123456789101112131415161718192021222324252627282930313233343536373839// 1. 计算属性，我理解为工厂方法@property (nonatomic, strong, readonly) MASConstraint *left;@property (nonatomic, strong, readonly) MASConstraint *top;@property (nonatomic, strong, readonly) MASConstraint *right;@property (nonatomic, strong, readonly) MASConstraint *bottom;...// 计算属性的 get 方法- (MASConstraint *)top &#123; return [self addConstraintWithLayoutAttribute:NSLayoutAttributeTop];&#125;- (MASConstraint *)addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; return [self constraint:nil addConstraintWithLayoutAttribute:layoutAttribute];&#125;// 2. 真正的工厂方法，同时 他也是 给 constraint 添加 NSLayoutAttribute 的地方- (MASConstraint *)constraint:(MASConstraint *)constraint addConstraintWithLayoutAttribute:(NSLayoutAttribute)layoutAttribute &#123; MASViewAttribute *viewAttribute = [[MASViewAttribute alloc] initWithView:self.view layoutAttribute:layoutAttribute]; MASViewConstraint *newConstraint = [[MASViewConstraint alloc] initWithFirstViewAttribute:viewAttribute];// 2.2 make.top.left.equalTo(superview).insets(padding); [left 节点的时候调用，产生第二个 节点以后所有节点的方法] if ([constraint isKindOfClass:MASViewConstraint.class]) &#123; //replace with composite constraint NSArray *children = @[constraint, newConstraint]; MASCompositeConstraint *compositeConstraint = [[MASCompositeConstraint alloc] initWithChildren:children]; compositeConstraint.delegate = self; [self constraint:constraint shouldBeReplacedWithConstraint:compositeConstraint]; return compositeConstraint; &#125;// 2.1 make.top.left.equalTo(superview).insets(padding); [top 节点的时候调用，产生第一个 节点的方法] if (!constraint) &#123; newConstraint.delegate = self; [self.constraints addObject:newConstraint]; &#125; return newConstraint;&#125;得出结论：根据上面代码中的 2.1，2.2 知道 make.left.right.top…… 会生产 3 个 MASViewConstraint，并组合到 MASCompositeConstraint 里面2333 这就知道了 为什么要有 MASCompositeConstraint，他的一个作用就是 实现链式兼容啊！（因为赤裸裸的 3个 MASViewConstraint，怎么变成一个 节点啊）那么问题又来了，make.left.right.top(view)，是怎么实现 left = view.left, right = view.right …… 的呢？等式关系，使用函数表示，内部直接把对应 relation 配置给 constraint123- (MASConstraint * (^)(id attr))mas_equalTo;- (MASConstraint * (^)(id attr))mas_greaterThanOrEqualTo;- (MASConstraint * (^)(id attr))mas_lessThanOrEqualTo;接下来的链式都是用函数闭包的方式，把参数传给 constraint 的 [闭包格式 MASConstraint * (^)(parameter 参数)]MASConstraintDelegate 是工厂方法协议, 从 这段代码的 2 看，他是让 constraint 生成 constraint 的方法过渡点。他是为了满足 make.top.left 中 top.left 通过 topConstraint 生成一个 leftConstraint的方法所以对于链式编程技巧：链条的开始，创建成链的起始节点对象一条链上应该只有一个对象，后面的所有节点都是对于这个对象的属性配置添加如果同一条链上有多个对象，那么使用组合模式，把多个节点对象封装成一个节点对象12为什么要使用闭包传？使用方法消息传不好吗？好像就是为了不要 `[]` 这个符号吧……，使用 `.` 链式调用看着好看 其他开发细节分析下面这些是啥？都是一些 c 语言的宏，在其他文章里分析过了1234567891011121314151617181920212223242526272829303132333435363738394041//MASUtilities.h#define MASAttachKeys(...) \\ &#123; \\ NSDictionary *keyPairs = NSDictionaryOfVariableBindings(__VA_ARGS__); \\ for (id key in keyPairs.allKeys) &#123; \\ id obj = keyPairs[key]; \\ NSAssert([obj respondsToSelector:@selector(setMas_key:)], \\ @\"Cannot attach mas_key to %@\", obj); \\ [obj setMas_key:key]; \\ &#125; \\ &#125;static inline id _MASBoxValue(const char *type, ...)#define MASBoxValue(value) _MASBoxValue(@encode(__typeof__((value))), (value))//View+MASShorthandAdditions.h#define MAS_ATTR_FORWARD(attr) \\- (MASViewAttribute *)attr &#123; \\ return [self mas_##attr]; \\&#125;#define MAS_ATTR_FORWARD_AVAILABLE(attr, available) \\- (MASViewAttribute *)attr available &#123; \\ return [self mas_##attr]; \\&#125;//MASConstraint.h#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__)))#define mas_greaterThanOrEqualTo(...) greaterThanOrEqualTo(MASBoxValue((__VA_ARGS__)))#define mas_lessThanOrEqualTo(...) lessThanOrEqualTo(MASBoxValue((__VA_ARGS__)))#define mas_offset(...) valueOffset(MASBoxValue((__VA_ARGS__)))#ifdef MAS_SHORTHAND_GLOBALS#define equalTo(...) mas_equalTo(__VA_ARGS__)#define greaterThanOrEqualTo(...) mas_greaterThanOrEqualTo(__VA_ARGS__)#define lessThanOrEqualTo(...) mas_lessThanOrEqualTo(__VA_ARGS__)#define offset(...) mas_offset(__VA_ARGS__) runtime 的运用主要是给 view 添加关联对象123456789101112131415161718192021222324252627//MASViewConstraint.m@interface MAS_VIEW (MASConstraints)// 见名知意@property (nonatomic, readonly) NSMutableSet *mas_installedConstraints; @end@implementation MAS_VIEW (MASConstraints)static char kInstalledConstraintsKey; - (NSMutableSet *)mas_installedConstraints &#123; NSMutableSet *constraints = objc_getAssociatedObject(self, &amp;kInstalledConstraintsKey); if (!constraints) &#123; constraints = [NSMutableSet set]; objc_setAssociatedObject(self, &amp;kInstalledConstraintsKey, constraints, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; return constraints;&#125;@end//View+MASAdditions.m- (id)mas_key &#123; return objc_getAssociatedObject(self, @selector(mas_key));&#125;- (void)setMas_key:(id)key &#123; objc_setAssociatedObject(self, @selector(mas_key), key, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;mas_key 是为了调试布局用的Masonry 布局冲突快速定位如何快速定位哪个 View 出现了约束警告？Auto Layout Guide","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"源码","slug":"源码","permalink":"https://changzw.github.io/tags/%E6%BA%90%E7%A0%81/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"UI 布局","slug":"第三方框架/UI-布局","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/UI-%E5%B8%83%E5%B1%80/"}]},{"title":"iOS View 编程指南","date":"2017-05-15T01:31:54.000Z","path":"2017/05/15/UI 相关/iOS-View-编程指南/","text":"View 和 Window 架构 View 结构基础layer 管理 view 辅助存储器，处理view 相关的动画。 View 层级和子view 管理 View 绘制循环UIView类使用按需绘制模型来呈现内容。当视图首次出现在屏幕上时，系统要求它绘制其内容。系统捕获该内容的快照并将该快照用作 view 的视觉表示。如果不更改视图的内容，则可能永远不会再次调用视图的绘图代码。快照图像可用于涉及视图的大多数操作。如果更改了内容，则会通知系统视图已更改。然后，视图重复绘制视图和捕获新结果快照的过程。当视图的内容更改时，您不会直接重绘这些更改。而是使用setNeedsDisplay或setNeedsDisplayInRect：方法使视图无效。这些方法告诉系统视图的内容已更改，并且需要在下一个机会重新绘制。在启动任何绘图操作之前，系统将一直等到当前运行循环结束。这种延迟使你有机会一次使多个视图无效，从层次结构中添加或删除视图，隐藏视图，调整视图大小以及重新放置视图。所做的所有更改都将同时反映出来。问题：都有什么方式可以出发视图重新绘制？ 内容 Modes 可拉伸 Views 内建动画支持 View 几何和坐标系 The Relationship of the Frame, Bounds, and Center Properties 坐标系转换CGContextGetCTMReturns the current transformation matrix. Points Versus Pixels The Runtime Interaction Model for Views Tips for Using Views Effectively Views Do Not Always Have a Corresponding View Controller Minimize Custom Drawing Take Advantage of Content Modes Declare Views as Opaque Whenever Possible Adjust Your View’s Drawing Behavior When Scrolling Do Not Customize Controls by Embedding Subviews","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"翻译","slug":"翻译","permalink":"https://changzw.github.io/tags/%E7%BF%BB%E8%AF%91/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"Guide","slug":"iOS-Programming/Guide","permalink":"https://changzw.github.io/categories/iOS-Programming/Guide/"}]},{"title":"Swift 面向协议编程","date":"2017-05-13T16:30:52.000Z","path":"2017/05/14/swift 语法/Swift-面向协议编程/","text":"WWDC 2015Developer ToolsProtocol-Oriented Programming in SwiftSession 408 Class面向对象的设计思想封装：把相关数据和操作进行分组访问控制：构建一面墙把里面代码和外面代码分开抽象接口：抽象接口表达类的作用和通讯功能命名空间：避免代码名称冲突Expressive syntax：表达式语法（下标扩展）extension 扩展性：忘了给类加东西，可以使用 extension 给他加上但是，在 swift 里上面的这些都可以用 struct or enum 做Building Better Apps with Value Types in Swift","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"WWDC","slug":"WWDC","permalink":"https://changzw.github.io/tags/WWDC/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"},{"name":"WWDC","slug":"iOS-Programming/WWDC","permalink":"https://changzw.github.io/categories/iOS-Programming/WWDC/"}]},{"title":"RAC-学习笔记01","date":"2017-04-06T02:08:45.000Z","path":"2017/04/06/RxSwfit+RAC/RAC-学习笔记01/","text":"学习目的知道 rac 都有什么知道他们都怎么用知道为什么有这些东西根类归纳整理如何自己扩展适当分析源码 主要概念信号信号变换&amp;组合订阅（绑定）取消订阅RACSignal : 基于时间的异步事件流RACSequence : 惰性集合，同步（很少用），collection类型的封装，可以使用 Stream（monad）封装的函数式方式 如何创建信号 单元信号1234RACSignal *sig0 = [RACSignal error:NSError.new];RACSignal *sig1 = [RACSignal return:@0];RACSignal *sig2 = [RACSignal empty];RACSignal *sig3 = [RACSignal never]; 动态信号1234567RACSignal *s = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@0]; [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; &#125;];&#125;]; Cocoa 桥接12345678910111213141516171819202122232425262728293031323334- (void) bridge &#123; RACSignal *sO = RACObserver(self, button); self.sigSetFrame = [self.button rac_signalForSelector:@selector(setFrame:)]; [_sigSetFrame subscribeNext:^(id x) &#123; NSLog(@\"setFrame:%@\", x); &#125;]; self.sigClick = [self.button rac_signalForControlEvents:UIControlEventTouchUpInside]; [_sigClick subscribeNext:^(id x) &#123; NSLog(@\"event: %@\", x); &#125;]; [[self rac_liftSelector:@selector(lift:) withSignals:_sigClick, nil] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [[self rac_liftSelector:@selector(lift:) withSignalsFromArray:@[[_sigClick map:^id(id value) &#123; return @[@3]; &#125;]]] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [self rac_liftSelector:@selector(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@1)]];&#125;- (int) lift:(id)value&#123; printf(\"lift: %s\", __func__); return 1;&#125; 信号变化(内部是产生一个新信号的)123[_sigClick map:^id(id value) &#123; return @[@3];&#125;]; 序列转换1self.sigSequence = [[RACSequence return:@3] concat:[RACSequence return:@4]].signal; 订阅（绑定）信号的方式 直接订阅方法1234[self.sigSample subscribeNext:^(id x) &#123; NSLog(@\"sample: %@\", x);&#125;]; 绑定1RAC(self, a) = Signal; Cocoa 桥接1234567891011121314151617181920- (void)signal &#123; [[self rac_liftSelector:@selector(lift:) withSignals:_sigClick, nil] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [[self rac_liftSelector:@selector(lift:) withSignalsFromArray:@[[_sigClick map:^id(id value) &#123; return @[@3]; &#125;]]] subscribeNext:^(id x) &#123; NSLog(@\"%@\", x); &#125;]; [self rac_liftSelector:@selector(lift:) withSignalOfArguments:[_sigClick mapReplace:RACTuplePack(@1)]];&#125;- (int) lift:(id)value&#123; printf(\"lift: %s\", __func__); return 1;&#125; 信号变化&amp;组合单个信号的变化多个信号的组合高阶操作 值操作问题：为什么会有这样的值操作方法？自己如何扩展新的值方法transform 这些用的比较多mapMapReplaceReduceEach tuple(a, b) -&gt; c值判断逻辑变换notandor用的比较少reduceApply 这个不太清楚为什么要这么设计，用combineLatest: reduceEach: 就可以做了，而且代码看起来更好。materializedematerialize 数量操作repeat 一直会有值条件过滤1ignoreignoreValuesdistinctUntilChanged条件过滤2takeUntilBlock:(BOOL (^)(id x))predicatetakeWhileBlock:(BOOL (^)(id x))predicate;skipUntilBlock:(BOOL (^)(id x))predicate;skipWhileBlock:(BOOL (^)(id x))predicate;数量判断，如果有值就发送any;any:(BOOL (^)(id object))predicateBlock;all:(BOOL (^)(id object))predicateBlock;重试retryretry: Countcollect 汇聚 信号必须有返回值副作用：– 对于信号值变化以外的一些操作doNextdoCompleteddoError折叠函数不听对一个value 操作，使用折叠函数解决这个问题123[sig10 aggregateWithStart:@0 reduce:^id(id running, id next) &#123; return @([running intValue] + [next intValue]);&#125;];(RACSignal *)aggregateWithStart:(id)start reduce:(id (^)(id running, id next))reduceBlock;(RACSignal *)aggregateWithStart:(id)start reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock;(RACSignal *)aggregateWithStartFactory:(id (^)(void))startFactory reduce:(id (^)(id running, id next))reduceBlock;(instancetype)scanWithStart:(id)startingValue reduce:(id (^)(id running, id next))reduceBlock;(instancetype)scanWithStart:(id)startingValue reduceWithIndex:(id (^)(id running, id next, NSUInteger index))reduceBlock; 时间操作+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler;+ (RACSignal *)interval:(NSTimeInterval)interval onScheduler:(RACScheduler *)scheduler withLeeway:(NSTimeInterval)leeway;delaythrottle 阀门，在固定时间内没有新值发送的时候，会发送最后的值 多个信号组合问题：受哪个信号终止而终止？错误传递？各个信号何时开始开始订阅？在哪个线程发出？concat第一个结束后，订阅第二个第一个error 后，就直接 errormergezipcombineLatestsampletakeUntiltakeUntilReplacement, 当 B 来了直接替换 A，开始订阅 B 信号的高阶操作（升阶降阶）升阶 S(v) -&gt; S(s(v))降阶 S(s(v)) -&gt; S(v)1234RACSignal *signal = @[@1, @2, @3, @4].rac_sequence.signal;RACSignal *signalB = [[signal map:^id(id value) &#123; return [[RACSignal return:value] delay:1];&#125;] concat];降阶操作switchToLatestsif/then/elseswitch/cases/defaultflattenflatten 类似 merge 只不过一个是接收的 value是 signal，另一个接收的就是 valueflatten:count 按个数展开信号，当信号个数 &gt; count 以后等待，如果有 sig completed，那么把等待中的sig 放入展开数组里面flatten:1 == concatflattenMap满足 monad 的部分定义，绝大部分函数都可以使用 flattenMap 实现bind大部分函数都可以使用 bind 实现 冷信号&amp;热信号 一些习题如何获得无限递增的信号12345678RACSignal *increment(int inc) &#123; RACSignal *repeat = [[RACSignal return:@(inc)] repeat]; return [[repeat scanWithStart:0 reduce:^id(id running, id next) &#123; return @([running intValue] + [next intValue]); &#125;] delay:1];&#125;fibonacci1234567RACSignal *fibonacci() &#123; RACSignal *repeat = [[RACSignal return:nil] repeat]; return [repeat scanWithStart:RACTuplePack(@1, @1) reduce:^id(RACTuple *running, id _) &#123; int next = [running.first intValue] + [running.second intValue]; return RACTuplePack(running.second, @(next)); &#125;];&#125;","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"},{"name":"objc","slug":"objc","permalink":"https://changzw.github.io/tags/objc/"},{"name":"RAC","slug":"RAC","permalink":"https://changzw.github.io/tags/RAC/"}],"categories":[{"name":"第三方框架","slug":"第三方框架","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/"},{"name":"ReactiveCocoa","slug":"第三方框架/ReactiveCocoa","permalink":"https://changzw.github.io/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6/ReactiveCocoa/"}]},{"title":"进程&线程间通信","date":"2017-03-09T02:09:25.000Z","path":"2017/03/09/进程-线程间通信/","text":"一、进程间的通信方式 管道( pipe )管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 有名管道 (namedpipe)有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。 信号量(semophore )信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。 消息队列( messagequeue )消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 信号 (sinal )信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 共享内存(shared memory )共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。 套接字(socket )套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。 二、线程间的通信方式锁机制：包括互斥锁、条件变量、读写锁互斥锁提供了以排他方式防止数据结构被并发修改的方法。读写锁允许多个线程同时读共享数据，而对写操作是互斥的。条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。信号量机制(Semaphore)：包括无名线程信号量和命名线程信号量信号机制(Signal)：类似进程间的信号处理线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。","tags":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://changzw.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://changzw.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]},{"title":"自定义控件[转载objccn]","date":"2017-01-13T05:34:47.000Z","path":"2017/01/13/自定义控件/","text":"可以直接看 objccn.io 的这篇自定义控件控件渲染方式控件交互方式optional 数据源 视图层次概览12345UIResponder ↑ UIView ↑ UIControl UIResponder(响应链)UIResponder 是 UIView 的父类。responder 能够处理触摸、手势、远程控制等事件。之所以它是一个单独的类而没有合并到 UIView 中，是因为 UIResponder 有更多的子类，最明显的就是 UIApplication 和 UIViewController。通过重写 UIResponder 的方法，可以决定一个类是否可以成为第一响应者 (first responder)，例如当前输入焦点元素。当 touches (触摸) 或 motion (指一系列运动传感器) 等交互行为发生时，它们被发送给第一响应者 (通常是一个视图)。如果第一响应者没有处理，则该行为沿着响应链到达视图控制器，如果行为仍然没有被处理，则继续传递给应用。如果想监测晃动手势，可以根据需要在这3层中的任意位置处理。UIResponder 还允许自定义输入方法，从 inputAccessoryView 向键盘添加辅助视图到使用 inputView 提供一个完全自定义的键盘。 UIView(渲染layer宿主)UIView 子类处理所有跟内容绘制有关的事情以及触摸时间。但我们重申一些技巧点:一个普遍错误的概念：视图的区域是由它的 frame 定义的。实际上 frame 是一个派生属性，是由 center 和 bounds 合成而来。不使用 Auto Layout 时，大多数人使用 frame 来改变视图的位置和大小。小心些，官方文档特别详细说明了一个注意事项:如果 transform 属性不是 identity transform 的话，那么这个属性的值是未定义的，因此应该将其忽略另一个允许向视图添加交互的方法是使用手势识别。注意它们对 responders 并不起作用，而只对视图及其子类奏效。 UIControl(交互控件)UIControl 建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。看一下具体的子类，我们可以看一下按钮，日期选择器 (Date pickers)，文本框等等。创建交互控件时，你通常想要子类化一个 UIControl。一些常见的像 bar buttons (虽然也支持 target / action) 和 text view (这里需要你使用代理来获得通知) 的类其实并不是 UIControl。 渲染现在，我们转向可见部分：自定义渲染。正如 Daniel 在他的文章中提到的，你可能想避免在 CPU 上做渲染而将其丢给 GPU。这里有一条经验：尽量避免 drawRect:，使用现有的视图构建自定义视图。通常最快速的渲染方法是使用图片视图。例如，假设你想画一个带有边框的圆形头像，像下面图片中这样:为了实现这个，我们用以下的代码创建了一个图片视图的子类:1234567// called from initializer- (void)setupView &#123; self.clipsToBounds = YES; self.layer.cornerRadius = self.bounds.size.width / 2; self.layer.borderWidth = 3; self.layer.borderColor = [UIColor darkGrayColor].CGColor;&#125;我鼓励各位读者深入了解 CALayer 及其属性，因为你用它能实现的大多数事情会比用 Core Graphics 自己画要快。然而一如既往，监测自己的代码的性能是十分重要的。把可拉伸的图片和图片视图一起使用也可以极大的提高效率。在 Taming UIButton 这个帖子中，Reda Lemeden 探索了几种不同的绘图方法。在文章结尾处有一个很有价值的来自 UIKit 团队的工程师 Andy Matuschak 的回复，解释了可拉伸图片是这些技术中最快的。原因是可拉伸图片在 CPU 和 GPU 之间的数据转移量最小，并且这些图片的绘制是经过高度优化的。处理图片时，你也可以让 GPU 为你工作来代替使用 Core Graphics。使用 Core Image，你不必用 CPU 做任何的工作就可以在图片上建立复杂的效果。你可以直接在 OpenGL 上下文上直接渲染，所有的工作都在 GPU 上完成。 自定义绘制如果决定了采用自定义绘制，有几种不同的选项可供选择。如果可能的话，看看是否可以生成一张图片并在内存和磁盘上缓存起来。如果内容是动态的，也许你可以使用 Core Animation，如果还是行不通，使用 Core Graphics。如果你真的想要接近底层，使用 GLKit 和原生 OpenGL 也不是那么难，但是需要做很多工作。如果你真的选择了重写 drawRect:，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，这在当视图的 frame 改变时并不会重新绘制。 自定义交互自定义控件的时候，你几乎一定会扩展一个 UIControl 的子类。在你的子类里，可以使用 target action 机制触发事件，如下面的例子:1[self sendActionsForControlEvents:UIControlEventValueChanged];为了响应触摸，你可能更倾向于使用手势识别。然而如果想要更接近底层，仍然可以重写 touchesBegan， touchesMoved 和 touchesEnded 方法来访问原始的触摸行为。但虽说如此，创建一个手势识别的子类来把手势处理相关的逻辑从你的视图或者视图控制器中分离出来，在很多情况下都是一种更合适的方式。创建自定义控件时所面对的一个普遍的设计问题是向拥有它们的类中回传返回值。比如，假设你创建了一个绘制交互饼状图的自定义控件，想知道用户何时选择了其中一个部分。你可以用很多种不同的方法来解决这个问题，比如通过 target action 模式，代理，block 或者 KVO，甚至通知。 使用 Target-Action通常也是最方便的做法是使用 target-action。在用户选择后你可以在自定义的视图中做类似这样的事情:1[self sendActionsForControlEvents:UIControlEventValueChanged];如果有一个视图控制器在管理这个视图，需要这样做:123456789- (void)setupPieChart &#123; [self.pieChart addTarget:self action:@selector(updateSelection:) forControlEvents:UIControlEventValueChanged];&#125;- (void)updateSelection:(id)sender&#123; NSLog(@\"%@\", self.pieChart.selectedSector);&#125;这么做的好处是在自定义视图子类中需要做的事情很少，并且自动获得多目标支持 使用代理如果你需要更多的控制从视图发送到视图控制器的消息，通常使用代理模式。在我们的饼状图中，代码看起来大概是这样:1[self.delegate pieChart:self didSelectSector:self.selectedSector];在视图控制器中，你要写如下代码:123456789@interface MyViewController &lt;PieChartDelegate&gt; ...- (void)setupPieChart&#123; self.pieChart.delegate = self;&#125;- (void)pieChart:(PieChart*)pieChart didSelectSector:(PieChartSector*)sector&#123; // 处理区块&#125;当你想要做更多复杂的工作而不仅仅是通知所有者值发生了变化时，这么做显然更合适。不过虽然大多数开发人员可以非常快速的实现自定义代理，但这种方式仍然有一些缺点：你必须检查代理是否实现了你想要调用的方法 (使用 respondsToSelector:)，最重要的，通常你只有一个代理 (或者需要创建一个代理数组)。也就是说，一旦视图所有者和视图之间的通信变得稍微复杂，我们几乎总是会采取这种模式。 使用 Block另一个选择是使用 block。再一次用饼状图举例，代码看起来大概是这样:123@interface PieChart : UIControl @property (nonatomic,copy) void(^selectionHandler)(PieChartSection* selectedSection); @end在选取行为的代码中，你只需要执行它。在此之前检查一下block是否被赋值非常重要，因为执行一个未被赋值的 block 会使程序崩溃。123if (self.selectionHandler != NULL) &#123; self.selectionHandler(self.selectedSection);&#125;这种方法的好处是可以把相关的代码整合在视图控制器中:12345- (void)setupPieChart &#123; self.pieChart.selectionHandler = ^(PieChartSection* section) &#123; // 处理区块 &#125;&#125;就像代理，每个动作通常只有一个 block。另一个重要的限制是不要形成引用循环。如果你的视图控制器持有饼状图的强引用，饼状图持有 block，block 又持有视图控制器，就形成了一个引用循环。只要在 block 中引用 self 就会造成这个错误。所以通常代码会写成这个样子：12345__weak id weakSelf = self;self.pieChart.selectionHandler = ^(PieChartSection* section) &#123; MyViewController* strongSelf = weakSelf; [strongSelf handleSectionChange:section];&#125;一旦 block 中的代码要失去控制 (比如 block 中要处理的事情太多，导致 block 中的代码过多)，你还应该将它们抽离成独立的方法，这种情况的话可能用代理会更好一些。 使用 KVO如果喜欢 KVO，你也可以用它来观察。这有一点神奇而且没那么直接，但当应用中已经使用，它是很好的解耦设计模式。在饼状图类中，编写代码:1self.selectedSegment = theNewSelectedSegment;当使用合成属性，KVO 会拦截到该变化并发出通知。在视图控制器中，编写类似的代码:12345678- (void)setupPieChart&#123; [self.pieChart addObserver:self forKeyPath:@\"selectedSegment\" options:0 context:NULL];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if(object == self.pieChart &amp;&amp; [keyPath isEqualToString:@\"selectedSegment\"]) &#123; // 处理改变 &#125;&#125;根据你的需要，在 viewWillDisappear: 或 dealloc 中，还需要移除观察者。对同一个对象设置多个观察者很容易造成混乱。有一些技术可以解决这个问题，比如 ReactiveCocoa 或者更轻量级的 THObserversAndBinders。 使用通知作为最后一个选择，如果你想要一个非常松散的耦合，可以使用通知来使其他对象得知变化。对于饼状图来说你几乎肯定不想这样，不过为了讲解的完整，这里介绍如何去做。在饼状图的的头文件中：1extern NSString* const SelectedSegmentChangedNotification;在实现文件中：12345NSString* const SelectedSegmentChangedNotification = @\"selectedSegmentChangedNotification\";...- (void)notifyAboutChanges&#123; [[NSNotificationCenter defaultCenter] postNotificationName:SelectedSegmentChangedNotification object:self];&#125;现在订阅通知，在视图控制器中：123456789- (void)setupPieChart&#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(segmentChanged:) name:SelectedSegmentChangedNotification object:self.pieChart];&#125;- (void)segmentChanged:(NSNotification*)note&#123;&#125;当添加了观察者，你可以不将饼状图作为参数 object，而是传递 nil，以接收所有饼状图对象发出的通知。就像 KVO 通知，你也需要在恰当的地方退订这些通知。这项技术的好处是完全的解耦。另一方面，你失去了类型安全，因为在回调中你得到的是一个通知对象，而不像代理，编译器无法检查通知发送者和接受者之间的类型是否匹配。 辅助功能 (Accessibility)苹果官方提供的标准 iOS 控件均有辅助功能。这也是推荐用标准控件创建自定义控件的另一个原因。这或许可以作为一整期的主题，但是如果你想编写自定义视图，Accessibility Programming Guide 说明了如何创建辅助控制器。最为值得注意的是，如果有一个视图中有多个需要辅助功能的元素，但它们并不是该视图的子视图，你可以让视图实现 UIAccessibilityContainer 协议。对于每一个元素，返回一个描述它的 UIAccessibilityElement 对象。 本地化创建自定义视图时，本地化也同样重要。像辅助功能一样，这个可以作为一整期的话题。本地化自定义视图的最直接工作就是字符串内容。如果使用 NSString，你不必担心编码问题。如果在自定义视图中展示日期或数字，使用日期和数字格式化类来展示它们。使用 NSLocalizedString 本地化字符串。另一个本地化过程中很有用的工具是 Auto Layout。例如，有在英文中很短的词在德语中可能会很长。如果根据英文单词的长度对视图的尺寸做硬编码，那么当翻译成德文的时候几乎一定会遇上麻烦。通过使用 Auto Layout，让标签控件自动调整为内容的尺寸，并向依赖元素添加一些其他的限制以确保重新设置尺寸，使这项工作变得非常简单。苹果为此提供了一个很好的介绍。另外，对于类似希伯来语这种顺序从右到左的语言，如果你使用了 leading 和 trailing 属性，整个视图会自动按照从右到左的顺序展示，而不是硬编码的从左至右。 测试最后，让我们考虑测试视图的问题。对于单元测试，你可以使用 Xcode 自带的工具或者其它第三方框架。另外，可以使用 UIAutomation 或者其它基于它的工具。为此，你的视图完全支持辅助功能是必要的。UIAutomation 并未充分得到利用的一个功能是截图；你可以用它自动对比视图和设计以确保两者每一个像素都分毫不差。(插一个无关的小提示：你还可以使用它来为应用上架 App Store 自动生成截图，这在你有多个多国语言的应用时会特别有用)。引用自定义控件","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]},{"title":"iOS 设备尺寸表","date":"2016-11-30T23:25:43.000Z","path":"2016/12/01/设备尺寸/","text":"尺寸要求Apple Doc屏幕尺寸横屏快照尺寸竖屏快照尺寸3.5寸960 * 640640*9604寸1136*640640*11364.7寸1334*750750*13345.5寸2208*12421242*22085.8寸2436*11251125*24369.7寸(iPad)1024*768768*102412.9寸(iPad)2732*20482048*2732iTunesConnect 上架可使用 高尺寸代替低尺寸","tags":[{"name":"iOS","slug":"iOS","permalink":"https://changzw.github.io/tags/iOS/"}],"categories":[{"name":"iOS Programming","slug":"iOS-Programming","permalink":"https://changzw.github.io/categories/iOS-Programming/"}]}]}